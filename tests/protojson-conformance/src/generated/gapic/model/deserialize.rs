// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TestStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __failure_message,
            __matched_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TestStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "failureMessage" => Ok(__FieldTag::__failure_message),
                            "failure_message" => Ok(__FieldTag::__failure_message),
                            "matchedName" => Ok(__FieldTag::__matched_name),
                            "matched_name" => Ok(__FieldTag::__matched_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TestStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TestStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__failure_message => {
                            if !fields.insert(__FieldTag::__failure_message) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for failure_message"));
                            }
                            result.failure_message = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__matched_name => {
                            if !fields.insert(__FieldTag::__matched_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for matched_name"));
                            }
                            result.matched_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FailureSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __test,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FailureSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "test" => Ok(__FieldTag::__test),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FailureSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FailureSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__test => {
                            if !fields.insert(__FieldTag::__test) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for test"));
                            }
                            result.test = map.next_value::<std::option::Option<std::vec::Vec<crate::generated::gapic::model::TestStatus>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConformanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __protobuf_payload,
            __json_payload,
            __jspb_payload,
            __text_payload,
            __requested_output_format,
            __message_type,
            __test_category,
            __jspb_encoding_options,
            __print_unknown_fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConformanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "protobufPayload" => Ok(__FieldTag::__protobuf_payload),
                            "protobuf_payload" => Ok(__FieldTag::__protobuf_payload),
                            "jsonPayload" => Ok(__FieldTag::__json_payload),
                            "json_payload" => Ok(__FieldTag::__json_payload),
                            "jspbPayload" => Ok(__FieldTag::__jspb_payload),
                            "jspb_payload" => Ok(__FieldTag::__jspb_payload),
                            "textPayload" => Ok(__FieldTag::__text_payload),
                            "text_payload" => Ok(__FieldTag::__text_payload),
                            "requestedOutputFormat" => Ok(__FieldTag::__requested_output_format),
                            "requested_output_format" => Ok(__FieldTag::__requested_output_format),
                            "messageType" => Ok(__FieldTag::__message_type),
                            "message_type" => Ok(__FieldTag::__message_type),
                            "testCategory" => Ok(__FieldTag::__test_category),
                            "test_category" => Ok(__FieldTag::__test_category),
                            "jspbEncodingOptions" => Ok(__FieldTag::__jspb_encoding_options),
                            "jspb_encoding_options" => Ok(__FieldTag::__jspb_encoding_options),
                            "printUnknownFields" => Ok(__FieldTag::__print_unknown_fields),
                            "print_unknown_fields" => Ok(__FieldTag::__print_unknown_fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConformanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConformanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__protobuf_payload => {
                            if !fields.insert(__FieldTag::__protobuf_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for protobuf_payload"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .conformance.ConformanceRequest.protobuf_payload, latest field was protobufPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_request::Payload::ProtobufPayload(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__json_payload => {
                            if !fields.insert(__FieldTag::__json_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for json_payload"));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .conformance.ConformanceRequest.json_payload, latest field was jsonPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_request::Payload::JsonPayload(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__jspb_payload => {
                            if !fields.insert(__FieldTag::__jspb_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for jspb_payload"));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .conformance.ConformanceRequest.jspb_payload, latest field was jspbPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_request::Payload::JspbPayload(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__text_payload => {
                            if !fields.insert(__FieldTag::__text_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text_payload"));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .conformance.ConformanceRequest.text_payload, latest field was textPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_request::Payload::TextPayload(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__requested_output_format => {
                            if !fields.insert(__FieldTag::__requested_output_format) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for requested_output_format"));
                            }
                            result.requested_output_format = map.next_value::<std::option::Option<crate::generated::gapic::model::WireFormat>>()?.unwrap_or_default();
                        },
                        __FieldTag::__message_type => {
                            if !fields.insert(__FieldTag::__message_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for message_type"));
                            }
                            result.message_type = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__test_category => {
                            if !fields.insert(__FieldTag::__test_category) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for test_category"));
                            }
                            result.test_category = map.next_value::<std::option::Option<crate::generated::gapic::model::TestCategory>>()?.unwrap_or_default();
                        },
                        __FieldTag::__jspb_encoding_options => {
                            if !fields.insert(__FieldTag::__jspb_encoding_options) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for jspb_encoding_options"));
                            }
                            result.jspb_encoding_options = map.next_value::<std::option::Option<crate::generated::gapic::model::JspbEncodingConfig>>()?
                                ;
                        },
                        __FieldTag::__print_unknown_fields => {
                            if !fields.insert(__FieldTag::__print_unknown_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for print_unknown_fields"));
                            }
                            result.print_unknown_fields = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConformanceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parse_error,
            __serialize_error,
            __timeout_error,
            __runtime_error,
            __protobuf_payload,
            __json_payload,
            __skipped,
            __jspb_payload,
            __text_payload,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConformanceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parseError" => Ok(__FieldTag::__parse_error),
                            "parse_error" => Ok(__FieldTag::__parse_error),
                            "serializeError" => Ok(__FieldTag::__serialize_error),
                            "serialize_error" => Ok(__FieldTag::__serialize_error),
                            "timeoutError" => Ok(__FieldTag::__timeout_error),
                            "timeout_error" => Ok(__FieldTag::__timeout_error),
                            "runtimeError" => Ok(__FieldTag::__runtime_error),
                            "runtime_error" => Ok(__FieldTag::__runtime_error),
                            "protobufPayload" => Ok(__FieldTag::__protobuf_payload),
                            "protobuf_payload" => Ok(__FieldTag::__protobuf_payload),
                            "jsonPayload" => Ok(__FieldTag::__json_payload),
                            "json_payload" => Ok(__FieldTag::__json_payload),
                            "skipped" => Ok(__FieldTag::__skipped),
                            "jspbPayload" => Ok(__FieldTag::__jspb_payload),
                            "jspb_payload" => Ok(__FieldTag::__jspb_payload),
                            "textPayload" => Ok(__FieldTag::__text_payload),
                            "text_payload" => Ok(__FieldTag::__text_payload),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConformanceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConformanceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parse_error => {
                            if !fields.insert(__FieldTag::__parse_error) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parse_error"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.parse_error, latest field was parseError",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::ParseError(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__serialize_error => {
                            if !fields.insert(__FieldTag::__serialize_error) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for serialize_error"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.serialize_error, latest field was serializeError",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::SerializeError(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__timeout_error => {
                            if !fields.insert(__FieldTag::__timeout_error) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for timeout_error"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.timeout_error, latest field was timeoutError",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::TimeoutError(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__runtime_error => {
                            if !fields.insert(__FieldTag::__runtime_error) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for runtime_error"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.runtime_error, latest field was runtimeError",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::RuntimeError(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__protobuf_payload => {
                            if !fields.insert(__FieldTag::__protobuf_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for protobuf_payload"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.protobuf_payload, latest field was protobufPayload",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::ProtobufPayload(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__json_payload => {
                            if !fields.insert(__FieldTag::__json_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for json_payload"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.json_payload, latest field was jsonPayload",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::JsonPayload(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__skipped => {
                            if !fields.insert(__FieldTag::__skipped) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for skipped"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.skipped, latest field was skipped",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::Skipped(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__jspb_payload => {
                            if !fields.insert(__FieldTag::__jspb_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for jspb_payload"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.jspb_payload, latest field was jspbPayload",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::JspbPayload(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::__text_payload => {
                            if !fields.insert(__FieldTag::__text_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for text_payload"));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.text_payload, latest field was textPayload",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::TextPayload(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::JspbEncodingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __use_jspb_array_any_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JspbEncodingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "useJspbArrayAnyFormat" => Ok(__FieldTag::__use_jspb_array_any_format),
                            "use_jspb_array_any_format" => Ok(__FieldTag::__use_jspb_array_any_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::JspbEncodingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JspbEncodingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__use_jspb_array_any_format => {
                            if !fields.insert(__FieldTag::__use_jspb_array_any_format) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for use_jspb_array_any_format"));
                            }
                            result.use_jspb_array_any_format = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
