// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the IAM Meta API.
///
/// Manages access control for Google Cloud Platform resources.
library;

import 'dart:typed_data';

import 'package:google_cloud_gax/common.dart';
import 'package:google_cloud_gax/src/encoding.dart';
import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_type/type.dart';
import 'package:http/http.dart' as http;

/// API Overview
///
/// Manages Identity and Access Management (IAM) policies.
///
/// Any implementation of an API that offers access control features
/// implements the google.iam.v1.IAMPolicy interface.
///
/// ## Data model
///
/// Access control is applied when a principal (user or service account), takes
/// some action on a resource exposed by a service. Resources, identified by
/// URI-like names, are the unit of access control specification. Service
/// implementations can choose the granularity of access control and the
/// supported permissions for their resources.
/// For example one database service may allow access control to be
/// specified only at the Table level, whereas another might allow access control
/// to also be specified at the Column level.
///
/// ## Policy Structure
///
/// See google.iam.v1.Policy
///
/// This is intentionally not a CRUD style API because access control policies
/// are created and deleted implicitly with the resources to which they are
/// attached.
class IAMPolicy {
  static const String _host = 'iam-meta-api.googleapis.com';

  final ServiceClient _client;

  IAMPolicy({required http.Client client})
      : _client = ServiceClient(client: client);

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource.
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource.
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building permission-aware
  /// UIs and command-line tools, not for authorization checking. This operation
  /// may "fail open" without warning.
  Future<TestIamPermissionsResponse> testIamPermissions(
      TestIamPermissionsRequest request) async {
    final url = Uri.https(_host, '/v1/${request.resource}:testIamPermissions');
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Request message for `SetIamPolicy` method.
class SetIamPolicyRequest extends Message {
  static const String fullyQualifiedName = 'google.iam.v1.SetIamPolicyRequest';

  /// REQUIRED: The resource for which the policy is being specified.
  /// See the operation documentation for the appropriate value for this field.
  final String resource;

  /// REQUIRED: The complete policy to be applied to the `resource`. The size of
  /// the policy is limited to a few 10s of KB. An empty policy is a
  /// valid policy but certain Cloud Platform services (such as Projects)
  /// might reject them.
  final Policy? policy;

  /// OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
  /// the fields in the mask will be modified. If no mask is provided, the
  /// following default mask is used:
  ///
  /// `paths: "bindings, etag"`
  final FieldMask? updateMask;

  SetIamPolicyRequest({
    required this.resource,
    this.policy,
    this.updateMask,
  }) : super(fullyQualifiedName);

  factory SetIamPolicyRequest.fromJson(Map<String, dynamic> json) {
    return SetIamPolicyRequest(
      resource: json['resource'],
      policy: decode(json['policy'], Policy.fromJson),
      updateMask: decodeCustom(json['updateMask'], FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'resource': resource,
      if (policy != null) 'policy': policy!.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'resource=$resource',
    ].join(',');
    return 'SetIamPolicyRequest($contents)';
  }
}

/// Request message for `GetIamPolicy` method.
class GetIamPolicyRequest extends Message {
  static const String fullyQualifiedName = 'google.iam.v1.GetIamPolicyRequest';

  /// REQUIRED: The resource for which the policy is being requested.
  /// See the operation documentation for the appropriate value for this field.
  final String resource;

  /// OPTIONAL: A `GetPolicyOptions` object for specifying options to
  /// `GetIamPolicy`.
  final GetPolicyOptions? options;

  GetIamPolicyRequest({
    required this.resource,
    this.options,
  }) : super(fullyQualifiedName);

  factory GetIamPolicyRequest.fromJson(Map<String, dynamic> json) {
    return GetIamPolicyRequest(
      resource: json['resource'],
      options: decode(json['options'], GetPolicyOptions.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'resource': resource,
      if (options != null) 'options': options!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'resource=$resource',
    ].join(',');
    return 'GetIamPolicyRequest($contents)';
  }
}

/// Request message for `TestIamPermissions` method.
class TestIamPermissionsRequest extends Message {
  static const String fullyQualifiedName =
      'google.iam.v1.TestIamPermissionsRequest';

  /// REQUIRED: The resource for which the policy detail is being requested.
  /// See the operation documentation for the appropriate value for this field.
  final String resource;

  /// The set of permissions to check for the `resource`. Permissions with
  /// wildcards (such as '*' or 'storage.*') are not allowed. For more
  /// information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  final List<String>? permissions;

  TestIamPermissionsRequest({
    required this.resource,
    this.permissions,
  }) : super(fullyQualifiedName);

  factory TestIamPermissionsRequest.fromJson(Map<String, dynamic> json) {
    return TestIamPermissionsRequest(
      resource: json['resource'],
      permissions: decodeList(json['permissions']),
    );
  }

  @override
  Object toJson() {
    return {
      'resource': resource,
      if (permissions != null) 'permissions': permissions,
    };
  }

  @override
  String toString() {
    final contents = [
      'resource=$resource',
    ].join(',');
    return 'TestIamPermissionsRequest($contents)';
  }
}

/// Response message for `TestIamPermissions` method.
class TestIamPermissionsResponse extends Message {
  static const String fullyQualifiedName =
      'google.iam.v1.TestIamPermissionsResponse';

  /// A subset of `TestPermissionsRequest.permissions` that the caller is
  /// allowed.
  final List<String>? permissions;

  TestIamPermissionsResponse({
    this.permissions,
  }) : super(fullyQualifiedName);

  factory TestIamPermissionsResponse.fromJson(Map<String, dynamic> json) {
    return TestIamPermissionsResponse(
      permissions: decodeList(json['permissions']),
    );
  }

  @override
  Object toJson() {
    return {
      if (permissions != null) 'permissions': permissions,
    };
  }

  @override
  String toString() => 'TestIamPermissionsResponse()';
}

/// Encapsulates settings provided to GetIamPolicy.
class GetPolicyOptions extends Message {
  static const String fullyQualifiedName = 'google.iam.v1.GetPolicyOptions';

  /// Optional. The maximum policy version that will be used to format the
  /// policy.
  ///
  /// Valid values are 0, 1, and 3. Requests specifying an invalid value will be
  /// rejected.
  ///
  /// Requests for policies with any conditional role bindings must specify
  /// version 3. Policies with no conditional role bindings may specify any valid
  /// value or leave the field unset.
  ///
  /// The policy in the response might use the policy version that you specified,
  /// or it might use a lower policy version. For example, if you specify version
  /// 3, but the policy has no conditional role bindings, the response uses
  /// version 1.
  ///
  /// To learn which resources support conditions in their IAM policies, see the
  /// [IAM
  /// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  final int? requestedPolicyVersion;

  GetPolicyOptions({
    this.requestedPolicyVersion,
  }) : super(fullyQualifiedName);

  factory GetPolicyOptions.fromJson(Map<String, dynamic> json) {
    return GetPolicyOptions(
      requestedPolicyVersion: json['requestedPolicyVersion'],
    );
  }

  @override
  Object toJson() {
    return {
      if (requestedPolicyVersion != null)
        'requestedPolicyVersion': requestedPolicyVersion,
    };
  }

  @override
  String toString() {
    final contents = [
      if (requestedPolicyVersion != null)
        'requestedPolicyVersion=$requestedPolicyVersion',
    ].join(',');
    return 'GetPolicyOptions($contents)';
  }
}

/// An Identity and Access Management (IAM) policy, which specifies access
/// controls for Google Cloud resources.
///
///
/// A `Policy` is a collection of `bindings`. A `binding` binds one or more
/// `members`, or principals, to a single `role`. Principals can be user
/// accounts, service accounts, Google groups, and domains (such as G Suite). A
/// `role` is a named list of permissions; each `role` can be an IAM predefined
/// role or a user-created custom role.
///
/// For some types of Google Cloud resources, a `binding` can also specify a
/// `condition`, which is a logical expression that allows access to a resource
/// only if the expression evaluates to `true`. A condition can add constraints
/// based on attributes of the request, the resource, or both. To learn which
/// resources support conditions in their IAM policies, see the
/// [IAM
/// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
///
/// **JSON example:**
///
/// ```
///     {
///       "bindings": [
///         {
///           "role": "roles/resourcemanager.organizationAdmin",
///           "members": [
///             "user:mike@example.com",
///             "group:admins@example.com",
///             "domain:google.com",
///             "serviceAccount:my-project-id@appspot.gserviceaccount.com"
///           ]
///         },
///         {
///           "role": "roles/resourcemanager.organizationViewer",
///           "members": [
///             "user:eve@example.com"
///           ],
///           "condition": {
///             "title": "expirable access",
///             "description": "Does not grant access after Sep 2020",
///             "expression": "request.time <
///             timestamp('2020-10-01T00:00:00.000Z')",
///           }
///         }
///       ],
///       "etag": "BwWWja0YfJA=",
///       "version": 3
///     }
/// ```
///
/// **YAML example:**
///
/// ```
///     bindings:
///     - members:
///       - user:mike@example.com
///       - group:admins@example.com
///       - domain:google.com
///       - serviceAccount:my-project-id@appspot.gserviceaccount.com
///       role: roles/resourcemanager.organizationAdmin
///     - members:
///       - user:eve@example.com
///       role: roles/resourcemanager.organizationViewer
///       condition:
///         title: expirable access
///         description: Does not grant access after Sep 2020
///         expression: request.time < timestamp('2020-10-01T00:00:00.000Z')
///     etag: BwWWja0YfJA=
///     version: 3
/// ```
///
/// For a description of IAM and its features, see the
/// [IAM documentation](https://cloud.google.com/iam/docs/).
class Policy extends Message {
  static const String fullyQualifiedName = 'google.iam.v1.Policy';

  /// Specifies the format of the policy.
  ///
  /// Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
  /// are rejected.
  ///
  /// Any operation that affects conditional role bindings must specify version
  /// `3`. This requirement applies to the following operations:
  ///
  /// * Getting a policy that includes a conditional role binding
  /// * Adding a conditional role binding to a policy
  /// * Changing a conditional role binding in a policy
  /// * Removing any role binding, with or without a condition, from a policy
  ///   that includes conditions
  ///
  /// **Important:** If you use IAM Conditions, you must include the `etag` field
  /// whenever you call `setIamPolicy`. If you omit this field, then IAM allows
  /// you to overwrite a version `3` policy with a version `1` policy, and all of
  /// the conditions in the version `3` policy are lost.
  ///
  /// If a policy does not include any conditions, operations on that policy may
  /// specify any valid version or leave the field unset.
  ///
  /// To learn which resources support conditions in their IAM policies, see the
  /// [IAM
  /// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  final int? version;

  /// Associates a list of `members`, or principals, with a `role`. Optionally,
  /// may specify a `condition` that determines how and when the `bindings` are
  /// applied. Each of the `bindings` must contain at least one principal.
  ///
  /// The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
  /// of these principals can be Google groups. Each occurrence of a principal
  /// counts towards these limits. For example, if the `bindings` grant 50
  /// different roles to `user:alice@example.com`, and not to any other
  /// principal, then you can add another 1,450 principals to the `bindings` in
  /// the `Policy`.
  final List<Binding>? bindings;

  /// Specifies cloud audit logging configuration for this policy.
  final List<AuditConfig>? auditConfigs;

  /// `etag` is used for optimistic concurrency control as a way to help
  /// prevent simultaneous updates of a policy from overwriting each other.
  /// It is strongly suggested that systems make use of the `etag` in the
  /// read-modify-write cycle to perform policy updates in order to avoid race
  /// conditions: An `etag` is returned in the response to `getIamPolicy`, and
  /// systems are expected to put that etag in the request to `setIamPolicy` to
  /// ensure that their change will be applied to the same version of the policy.
  ///
  /// **Important:** If you use IAM Conditions, you must include the `etag` field
  /// whenever you call `setIamPolicy`. If you omit this field, then IAM allows
  /// you to overwrite a version `3` policy with a version `1` policy, and all of
  /// the conditions in the version `3` policy are lost.
  final Uint8List? etag;

  Policy({
    this.version,
    this.bindings,
    this.auditConfigs,
    this.etag,
  }) : super(fullyQualifiedName);

  factory Policy.fromJson(Map<String, dynamic> json) {
    return Policy(
      version: json['version'],
      bindings: decodeListMessage(json['bindings'], Binding.fromJson),
      auditConfigs:
          decodeListMessage(json['auditConfigs'], AuditConfig.fromJson),
      etag: decodeBytes(json['etag']),
    );
  }

  @override
  Object toJson() {
    return {
      if (version != null) 'version': version,
      if (bindings != null) 'bindings': encodeList(bindings),
      if (auditConfigs != null) 'auditConfigs': encodeList(auditConfigs),
      if (etag != null) 'etag': encodeBytes(etag),
    };
  }

  @override
  String toString() {
    final contents = [
      if (version != null) 'version=$version',
      if (etag != null) 'etag=$etag',
    ].join(',');
    return 'Policy($contents)';
  }
}

/// Associates `members`, or principals, with a `role`.
class Binding extends Message {
  static const String fullyQualifiedName = 'google.iam.v1.Binding';

  /// Role that is assigned to the list of `members`, or principals.
  /// For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
  final String? role;

  /// Specifies the principals requesting access for a Google Cloud resource.
  /// `members` can have the following values:
  ///
  /// * `allUsers`: A special identifier that represents anyone who is
  ///    on the internet; with or without a Google account.
  ///
  /// * `allAuthenticatedUsers`: A special identifier that represents anyone
  ///    who is authenticated with a Google account or a service account.
  ///
  /// * `user:{emailid}`: An email address that represents a specific Google
  ///    account. For example, `alice@example.com` .
  ///
  ///
  /// * `serviceAccount:{emailid}`: An email address that represents a service
  ///    account. For example, `my-other-app@appspot.gserviceaccount.com`.
  ///
  /// * `group:{emailid}`: An email address that represents a Google group.
  ///    For example, `admins@example.com`.
  ///
  /// * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
  ///    identifier) representing a user that has been recently deleted. For
  ///    example, `alice@example.com?uid=123456789012345678901`. If the user is
  ///    recovered, this value reverts to `user:{emailid}` and the recovered user
  ///    retains the role in the binding.
  ///
  /// * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus
  ///    unique identifier) representing a service account that has been recently
  ///    deleted. For example,
  ///    `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`.
  ///    If the service account is undeleted, this value reverts to
  ///    `serviceAccount:{emailid}` and the undeleted service account retains the
  ///    role in the binding.
  ///
  /// * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique
  ///    identifier) representing a Google group that has been recently
  ///    deleted. For example, `admins@example.com?uid=123456789012345678901`. If
  ///    the group is recovered, this value reverts to `group:{emailid}` and the
  ///    recovered group retains the role in the binding.
  ///
  ///
  /// * `domain:{domain}`: The G Suite domain (primary) that represents all the
  ///    users of that domain. For example, `google.com` or `example.com`.
  final List<String>? members;

  /// The condition that is associated with this binding.
  ///
  /// If the condition evaluates to `true`, then this binding applies to the
  /// current request.
  ///
  /// If the condition evaluates to `false`, then this binding does not apply to
  /// the current request. However, a different role binding might grant the same
  /// role to one or more of the principals in this binding.
  ///
  /// To learn which resources support conditions in their IAM policies, see the
  /// [IAM
  /// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  final Expr? condition;

  Binding({
    this.role,
    this.members,
    this.condition,
  }) : super(fullyQualifiedName);

  factory Binding.fromJson(Map<String, dynamic> json) {
    return Binding(
      role: json['role'],
      members: decodeList(json['members']),
      condition: decode(json['condition'], Expr.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (role != null) 'role': role,
      if (members != null) 'members': members,
      if (condition != null) 'condition': condition!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (role != null) 'role=$role',
    ].join(',');
    return 'Binding($contents)';
  }
}

/// Specifies the audit configuration for a service.
/// The configuration determines which permission types are logged, and what
/// identities, if any, are exempted from logging.
/// An AuditConfig must have one or more AuditLogConfigs.
///
/// If there are AuditConfigs for both `allServices` and a specific service,
/// the union of the two AuditConfigs is used for that service: the log_types
/// specified in each AuditConfig are enabled, and the exempted_members in each
/// AuditLogConfig are exempted.
///
/// Example Policy with multiple AuditConfigs:
///
///     {
///       "audit_configs": [
///         {
///           "service": "allServices",
///           "audit_log_configs": [
///             {
///               "log_type": "DATA_READ",
///               "exempted_members": [
///                 "user:jose@example.com"
///               ]
///             },
///             {
///               "log_type": "DATA_WRITE"
///             },
///             {
///               "log_type": "ADMIN_READ"
///             }
///           ]
///         },
///         {
///           "service": "sampleservice.googleapis.com",
///           "audit_log_configs": [
///             {
///               "log_type": "DATA_READ"
///             },
///             {
///               "log_type": "DATA_WRITE",
///               "exempted_members": [
///                 "user:aliya@example.com"
///               ]
///             }
///           ]
///         }
///       ]
///     }
///
/// For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
/// logging. It also exempts `jose@example.com` from DATA_READ logging, and
/// `aliya@example.com` from DATA_WRITE logging.
class AuditConfig extends Message {
  static const String fullyQualifiedName = 'google.iam.v1.AuditConfig';

  /// Specifies a service that will be enabled for audit logging.
  /// For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.
  /// `allServices` is a special value that covers all services.
  final String? service;

  /// The configuration for logging of each type of permission.
  final List<AuditLogConfig>? auditLogConfigs;

  AuditConfig({
    this.service,
    this.auditLogConfigs,
  }) : super(fullyQualifiedName);

  factory AuditConfig.fromJson(Map<String, dynamic> json) {
    return AuditConfig(
      service: json['service'],
      auditLogConfigs:
          decodeListMessage(json['auditLogConfigs'], AuditLogConfig.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (service != null) 'service': service,
      if (auditLogConfigs != null)
        'auditLogConfigs': encodeList(auditLogConfigs),
    };
  }

  @override
  String toString() {
    final contents = [
      if (service != null) 'service=$service',
    ].join(',');
    return 'AuditConfig($contents)';
  }
}

/// Provides the configuration for logging a type of permissions.
/// Example:
///
///     {
///       "audit_log_configs": [
///         {
///           "log_type": "DATA_READ",
///           "exempted_members": [
///             "user:jose@example.com"
///           ]
///         },
///         {
///           "log_type": "DATA_WRITE"
///         }
///       ]
///     }
///
/// This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting
/// jose@example.com from DATA_READ logging.
class AuditLogConfig extends Message {
  static const String fullyQualifiedName = 'google.iam.v1.AuditLogConfig';

  /// The log type that this config enables.
  final AuditLogConfig_LogType? logType;

  /// Specifies the identities that do not cause logging for this type of
  /// permission.
  /// Follows the same format of
  /// `Binding.members`.
  final List<String>? exemptedMembers;

  AuditLogConfig({
    this.logType,
    this.exemptedMembers,
  }) : super(fullyQualifiedName);

  factory AuditLogConfig.fromJson(Map<String, dynamic> json) {
    return AuditLogConfig(
      logType: decodeEnum(json['logType'], AuditLogConfig_LogType.fromJson),
      exemptedMembers: decodeList(json['exemptedMembers']),
    );
  }

  @override
  Object toJson() {
    return {
      if (logType != null) 'logType': logType!.toJson(),
      if (exemptedMembers != null) 'exemptedMembers': exemptedMembers,
    };
  }

  @override
  String toString() {
    final contents = [
      if (logType != null) 'logType=$logType',
    ].join(',');
    return 'AuditLogConfig($contents)';
  }
}

/// The list of valid permission types for which logging can be configured.
/// Admin writes are always logged, and are not configurable.
class AuditLogConfig_LogType extends Enum {
  /// Default case. Should never be this.
  static const logTypeUnspecified =
      AuditLogConfig_LogType('LOG_TYPE_UNSPECIFIED');

  /// Admin reads. Example: CloudIAM getIamPolicy
  static const adminRead = AuditLogConfig_LogType('ADMIN_READ');

  /// Data writes. Example: CloudSQL Users create
  static const dataWrite = AuditLogConfig_LogType('DATA_WRITE');

  /// Data reads. Example: CloudSQL Users list
  static const dataRead = AuditLogConfig_LogType('DATA_READ');

  const AuditLogConfig_LogType(super.value);

  factory AuditLogConfig_LogType.fromJson(String json) =>
      AuditLogConfig_LogType(json);

  @override
  String toString() => 'LogType.$value';
}

/// The difference delta between two policies.
class PolicyDelta extends Message {
  static const String fullyQualifiedName = 'google.iam.v1.PolicyDelta';

  /// The delta for Bindings between two policies.
  final List<BindingDelta>? bindingDeltas;

  /// The delta for AuditConfigs between two policies.
  final List<AuditConfigDelta>? auditConfigDeltas;

  PolicyDelta({
    this.bindingDeltas,
    this.auditConfigDeltas,
  }) : super(fullyQualifiedName);

  factory PolicyDelta.fromJson(Map<String, dynamic> json) {
    return PolicyDelta(
      bindingDeltas:
          decodeListMessage(json['bindingDeltas'], BindingDelta.fromJson),
      auditConfigDeltas: decodeListMessage(
          json['auditConfigDeltas'], AuditConfigDelta.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (bindingDeltas != null) 'bindingDeltas': encodeList(bindingDeltas),
      if (auditConfigDeltas != null)
        'auditConfigDeltas': encodeList(auditConfigDeltas),
    };
  }

  @override
  String toString() => 'PolicyDelta()';
}

/// One delta entry for Binding. Each individual change (only one member in each
/// entry) to a binding will be a separate entry.
class BindingDelta extends Message {
  static const String fullyQualifiedName = 'google.iam.v1.BindingDelta';

  /// The action that was performed on a Binding.
  /// Required
  final BindingDelta_Action? action;

  /// Role that is assigned to `members`.
  /// For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
  /// Required
  final String? role;

  /// A single identity requesting access for a Google Cloud resource.
  /// Follows the same format of Binding.members.
  /// Required
  final String? member;

  /// The condition that is associated with this binding.
  final Expr? condition;

  BindingDelta({
    this.action,
    this.role,
    this.member,
    this.condition,
  }) : super(fullyQualifiedName);

  factory BindingDelta.fromJson(Map<String, dynamic> json) {
    return BindingDelta(
      action: decodeEnum(json['action'], BindingDelta_Action.fromJson),
      role: json['role'],
      member: json['member'],
      condition: decode(json['condition'], Expr.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (action != null) 'action': action!.toJson(),
      if (role != null) 'role': role,
      if (member != null) 'member': member,
      if (condition != null) 'condition': condition!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (action != null) 'action=$action',
      if (role != null) 'role=$role',
      if (member != null) 'member=$member',
    ].join(',');
    return 'BindingDelta($contents)';
  }
}

/// The type of action performed on a Binding in a policy.
class BindingDelta_Action extends Enum {
  /// Unspecified.
  static const actionUnspecified = BindingDelta_Action('ACTION_UNSPECIFIED');

  /// Addition of a Binding.
  static const add = BindingDelta_Action('ADD');

  /// Removal of a Binding.
  static const remove = BindingDelta_Action('REMOVE');

  const BindingDelta_Action(super.value);

  factory BindingDelta_Action.fromJson(String json) =>
      BindingDelta_Action(json);

  @override
  String toString() => 'Action.$value';
}

/// One delta entry for AuditConfig. Each individual change (only one
/// exempted_member in each entry) to a AuditConfig will be a separate entry.
class AuditConfigDelta extends Message {
  static const String fullyQualifiedName = 'google.iam.v1.AuditConfigDelta';

  /// The action that was performed on an audit configuration in a policy.
  /// Required
  final AuditConfigDelta_Action? action;

  /// Specifies a service that was configured for Cloud Audit Logging.
  /// For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.
  /// `allServices` is a special value that covers all services.
  /// Required
  final String? service;

  /// A single identity that is exempted from "data access" audit
  /// logging for the `service` specified above.
  /// Follows the same format of Binding.members.
  final String? exemptedMember;

  /// Specifies the log_type that was be enabled. ADMIN_ACTIVITY is always
  /// enabled, and cannot be configured.
  /// Required
  final String? logType;

  AuditConfigDelta({
    this.action,
    this.service,
    this.exemptedMember,
    this.logType,
  }) : super(fullyQualifiedName);

  factory AuditConfigDelta.fromJson(Map<String, dynamic> json) {
    return AuditConfigDelta(
      action: decodeEnum(json['action'], AuditConfigDelta_Action.fromJson),
      service: json['service'],
      exemptedMember: json['exemptedMember'],
      logType: json['logType'],
    );
  }

  @override
  Object toJson() {
    return {
      if (action != null) 'action': action!.toJson(),
      if (service != null) 'service': service,
      if (exemptedMember != null) 'exemptedMember': exemptedMember,
      if (logType != null) 'logType': logType,
    };
  }

  @override
  String toString() {
    final contents = [
      if (action != null) 'action=$action',
      if (service != null) 'service=$service',
      if (exemptedMember != null) 'exemptedMember=$exemptedMember',
      if (logType != null) 'logType=$logType',
    ].join(',');
    return 'AuditConfigDelta($contents)';
  }
}

/// The type of action performed on an audit configuration in a policy.
class AuditConfigDelta_Action extends Enum {
  /// Unspecified.
  static const actionUnspecified =
      AuditConfigDelta_Action('ACTION_UNSPECIFIED');

  /// Addition of an audit configuration.
  static const add = AuditConfigDelta_Action('ADD');

  /// Removal of an audit configuration.
  static const remove = AuditConfigDelta_Action('REMOVE');

  const AuditConfigDelta_Action(super.value);

  factory AuditConfigDelta_Action.fromJson(String json) =>
      AuditConfigDelta_Action(json);

  @override
  String toString() => 'Action.$value';
}

/// Output-only policy member strings of a Google Cloud resource's built-in
/// identity.
class ResourcePolicyMember extends Message {
  static const String fullyQualifiedName = 'google.iam.v1.ResourcePolicyMember';

  /// IAM policy binding member referring to a Google Cloud resource by
  /// user-assigned name (https://google.aip.dev/122). If a resource is deleted
  /// and recreated with the same name, the binding will be applicable to the new
  /// resource.
  ///
  /// Example:
  /// `principal://parametermanager.googleapis.com/projects/12345/name/locations/us-central1-a/parameters/my-parameter`
  final String? iamPolicyNamePrincipal;

  /// IAM policy binding member referring to a Google Cloud resource by
  /// system-assigned unique identifier (https://google.aip.dev/148#uid). If a
  /// resource is deleted and recreated with the same name, the binding will not
  /// be applicable to the new resource
  ///
  /// Example:
  /// `principal://parametermanager.googleapis.com/projects/12345/uid/locations/us-central1-a/parameters/a918fed5`
  final String? iamPolicyUidPrincipal;

  ResourcePolicyMember({
    this.iamPolicyNamePrincipal,
    this.iamPolicyUidPrincipal,
  }) : super(fullyQualifiedName);

  factory ResourcePolicyMember.fromJson(Map<String, dynamic> json) {
    return ResourcePolicyMember(
      iamPolicyNamePrincipal: json['iamPolicyNamePrincipal'],
      iamPolicyUidPrincipal: json['iamPolicyUidPrincipal'],
    );
  }

  @override
  Object toJson() {
    return {
      if (iamPolicyNamePrincipal != null)
        'iamPolicyNamePrincipal': iamPolicyNamePrincipal,
      if (iamPolicyUidPrincipal != null)
        'iamPolicyUidPrincipal': iamPolicyUidPrincipal,
    };
  }

  @override
  String toString() {
    final contents = [
      if (iamPolicyNamePrincipal != null)
        'iamPolicyNamePrincipal=$iamPolicyNamePrincipal',
      if (iamPolicyUidPrincipal != null)
        'iamPolicyUidPrincipal=$iamPolicyUidPrincipal',
    ].join(',');
    return 'ResourcePolicyMember($contents)';
  }
}
