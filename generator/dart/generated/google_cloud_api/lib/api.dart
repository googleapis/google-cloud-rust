// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Service Config API.
///
/// Lets you define and config your API service.
library;

import 'package:google_cloud_gax/gax.dart';
import 'package:google_cloud_gax/src/encoding.dart';
import 'package:google_cloud_protobuf/protobuf.dart';

/// `Authentication` defines the authentication configuration for API methods
/// provided by an API service.
///
/// Example:
///
///     name: calendar.googleapis.com
///     authentication:
///       providers:
///       - id: google_calendar_auth
///         jwks_uri: https://www.googleapis.com/oauth2/v1/certs
///         issuer: https://securetoken.google.com
///       rules:
///       - selector: "*"
///         requirements:
///           provider_id: google_calendar_auth
///       - selector: google.calendar.Delegate
///         oauth:
///           canonical_scopes: https://www.googleapis.com/auth/calendar.read
class Authentication extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Authentication';

  /// A list of authentication rules that apply to individual API methods.
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<AuthenticationRule>? rules;

  /// Defines a set of authentication providers that a service supports.
  final List<AuthProvider>? providers;

  Authentication({
    this.rules,
    this.providers,
  }) : super(fullyQualifiedName);

  factory Authentication.fromJson(Map<String, dynamic> json) {
    return Authentication(
      rules: decodeListMessage(json['rules'], AuthenticationRule.fromJson),
      providers: decodeListMessage(json['providers'], AuthProvider.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (rules != null) 'rules': encodeList(rules),
      if (providers != null) 'providers': encodeList(providers),
    };
  }

  @override
  String toString() => 'Authentication()';
}

/// Authentication rules for the service.
///
/// By default, if a method has any authentication requirements, every request
/// must include a valid credential matching one of the requirements.
/// It's an error to include more than one kind of credential in a single
/// request.
///
/// If a method doesn't have any auth requirements, request credentials will be
/// ignored.
class AuthenticationRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.AuthenticationRule';

  /// Selects the methods to which this rule applies.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String? selector;

  /// The requirements for OAuth credentials.
  final OauthRequirements? oauth;

  /// If true, the service accepts API keys without any other credential.
  /// This flag only applies to HTTP and gRPC requests.
  final bool? allowWithoutCredential;

  /// Requirements for additional authentication providers.
  final List<AuthRequirement>? requirements;

  AuthenticationRule({
    this.selector,
    this.oauth,
    this.allowWithoutCredential,
    this.requirements,
  }) : super(fullyQualifiedName);

  factory AuthenticationRule.fromJson(Map<String, dynamic> json) {
    return AuthenticationRule(
      selector: json['selector'],
      oauth: decode(json['oauth'], OauthRequirements.fromJson),
      allowWithoutCredential: json['allowWithoutCredential'],
      requirements:
          decodeListMessage(json['requirements'], AuthRequirement.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (selector != null) 'selector': selector,
      if (oauth != null) 'oauth': oauth!.toJson(),
      if (allowWithoutCredential != null)
        'allowWithoutCredential': allowWithoutCredential,
      if (requirements != null) 'requirements': encodeList(requirements),
    };
  }

  @override
  String toString() {
    final contents = [
      if (selector != null) 'selector=$selector',
      if (allowWithoutCredential != null)
        'allowWithoutCredential=$allowWithoutCredential',
    ].join(',');
    return 'AuthenticationRule($contents)';
  }
}

/// Specifies a location to extract JWT from an API request.
class JwtLocation extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.JwtLocation';

  /// Specifies HTTP header name to extract JWT token.
  final String? header;

  /// Specifies URL query parameter name to extract JWT token.
  final String? query;

  /// Specifies cookie name to extract JWT token.
  final String? cookie;

  /// The value prefix. The value format is "value_prefix{token}"
  /// Only applies to "in" header type. Must be empty for "in" query type.
  /// If not empty, the header value has to match (case sensitive) this prefix.
  /// If not matched, JWT will not be extracted. If matched, JWT will be
  /// extracted after the prefix is removed.
  ///
  /// For example, for "Authorization: Bearer {JWT}",
  /// value_prefix="Bearer " with a space at the end.
  final String? valuePrefix;

  JwtLocation({
    this.header,
    this.query,
    this.cookie,
    this.valuePrefix,
  }) : super(fullyQualifiedName);

  factory JwtLocation.fromJson(Map<String, dynamic> json) {
    return JwtLocation(
      header: json['header'],
      query: json['query'],
      cookie: json['cookie'],
      valuePrefix: json['valuePrefix'],
    );
  }

  @override
  Object toJson() {
    return {
      if (header != null) 'header': header,
      if (query != null) 'query': query,
      if (cookie != null) 'cookie': cookie,
      if (valuePrefix != null) 'valuePrefix': valuePrefix,
    };
  }

  @override
  String toString() {
    final contents = [
      if (header != null) 'header=$header',
      if (query != null) 'query=$query',
      if (cookie != null) 'cookie=$cookie',
      if (valuePrefix != null) 'valuePrefix=$valuePrefix',
    ].join(',');
    return 'JwtLocation($contents)';
  }
}

/// Configuration for an authentication provider, including support for
/// [JSON Web Token
/// (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).
class AuthProvider extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.AuthProvider';

  /// The unique identifier of the auth provider. It will be referred to by
  /// `AuthRequirement.provider_id`.
  ///
  /// Example: "bookstore_auth".
  final String? id;

  /// Identifies the principal that issued the JWT. See
  /// https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.1
  /// Usually a URL or an email address.
  ///
  /// Example: https://securetoken.google.com
  /// Example: 1234567-compute@developer.gserviceaccount.com
  final String? issuer;

  /// URL of the provider's public key set to validate signature of the JWT. See
  /// [OpenID
  /// Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  /// Optional if the key set document:
  ///  - can be retrieved from
  ///    [OpenID
  ///    Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html)
  ///    of the issuer.
  ///  - can be inferred from the email domain of the issuer (e.g. a Google
  ///  service account).
  ///
  /// Example: https://www.googleapis.com/oauth2/v1/certs
  final String? jwksUri;

  /// The list of JWT
  /// [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).
  /// that are allowed to access. A JWT containing any of these audiences will
  /// be accepted. When this setting is absent, JWTs with audiences:
  ///   - "https://[service.name]/[google.protobuf.Api.name]"
  ///   - "https://[service.name]/"
  /// will be accepted.
  /// For example, if no audiences are in the setting, LibraryService API will
  /// accept JWTs with the following audiences:
  ///   -
  ///   https://library-example.googleapis.com/google.example.library.v1.LibraryService
  ///   - https://library-example.googleapis.com/
  ///
  /// Example:
  ///
  ///     audiences: bookstore_android.apps.googleusercontent.com,
  ///                bookstore_web.apps.googleusercontent.com
  final String? audiences;

  /// Redirect URL if JWT token is required but not present or is expired.
  /// Implement authorizationUrl of securityDefinitions in OpenAPI spec.
  final String? authorizationUrl;

  /// Defines the locations to extract the JWT.  For now it is only used by the
  /// Cloud Endpoints to store the OpenAPI extension [x-google-jwt-locations]
  /// (https://cloud.google.com/endpoints/docs/openapi/openapi-extensions#x-google-jwt-locations)
  ///
  /// JWT locations can be one of HTTP headers, URL query parameters or
  /// cookies. The rule is that the first match wins.
  ///
  /// If not specified,  default to use following 3 locations:
  ///    1) Authorization: Bearer
  ///    2) x-goog-iap-jwt-assertion
  ///    3) access_token query parameter
  ///
  /// Default locations can be specified as followings:
  ///    jwt_locations:
  ///    - header: Authorization
  ///      value_prefix: "Bearer "
  ///    - header: x-goog-iap-jwt-assertion
  ///    - query: access_token
  final List<JwtLocation>? jwtLocations;

  AuthProvider({
    this.id,
    this.issuer,
    this.jwksUri,
    this.audiences,
    this.authorizationUrl,
    this.jwtLocations,
  }) : super(fullyQualifiedName);

  factory AuthProvider.fromJson(Map<String, dynamic> json) {
    return AuthProvider(
      id: json['id'],
      issuer: json['issuer'],
      jwksUri: json['jwksUri'],
      audiences: json['audiences'],
      authorizationUrl: json['authorizationUrl'],
      jwtLocations:
          decodeListMessage(json['jwtLocations'], JwtLocation.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (id != null) 'id': id,
      if (issuer != null) 'issuer': issuer,
      if (jwksUri != null) 'jwksUri': jwksUri,
      if (audiences != null) 'audiences': audiences,
      if (authorizationUrl != null) 'authorizationUrl': authorizationUrl,
      if (jwtLocations != null) 'jwtLocations': encodeList(jwtLocations),
    };
  }

  @override
  String toString() {
    final contents = [
      if (id != null) 'id=$id',
      if (issuer != null) 'issuer=$issuer',
      if (jwksUri != null) 'jwksUri=$jwksUri',
      if (audiences != null) 'audiences=$audiences',
      if (authorizationUrl != null) 'authorizationUrl=$authorizationUrl',
    ].join(',');
    return 'AuthProvider($contents)';
  }
}

/// OAuth scopes are a way to define data and permissions on data. For example,
/// there are scopes defined for "Read-only access to Google Calendar" and
/// "Access to Cloud Platform". Users can consent to a scope for an application,
/// giving it permission to access that data on their behalf.
///
/// OAuth scope specifications should be fairly coarse grained; a user will need
/// to see and understand the text description of what your scope means.
///
/// In most cases: use one or at most two OAuth scopes for an entire family of
/// products. If your product has multiple APIs, you should probably be sharing
/// the OAuth scope across all of those APIs.
///
/// When you need finer grained OAuth consent screens: talk with your product
/// management about how developers will use them in practice.
///
/// Please note that even though each of the canonical scopes is enough for a
/// request to be accepted and passed to the backend, a request can still fail
/// due to the backend requiring additional scopes or permissions.
class OauthRequirements extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.OAuthRequirements';

  /// The list of publicly documented OAuth scopes that are allowed access. An
  /// OAuth token containing any of these scopes will be accepted.
  ///
  /// Example:
  ///
  ///      canonical_scopes: https://www.googleapis.com/auth/calendar,
  ///                        https://www.googleapis.com/auth/calendar.read
  final String? canonicalScopes;

  OauthRequirements({
    this.canonicalScopes,
  }) : super(fullyQualifiedName);

  factory OauthRequirements.fromJson(Map<String, dynamic> json) {
    return OauthRequirements(
      canonicalScopes: json['canonicalScopes'],
    );
  }

  @override
  Object toJson() {
    return {
      if (canonicalScopes != null) 'canonicalScopes': canonicalScopes,
    };
  }

  @override
  String toString() {
    final contents = [
      if (canonicalScopes != null) 'canonicalScopes=$canonicalScopes',
    ].join(',');
    return 'OAuthRequirements($contents)';
  }
}

/// User-defined authentication requirements, including support for
/// [JSON Web Token
/// (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).
class AuthRequirement extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.AuthRequirement';

  /// `id` from authentication provider.
  ///
  /// Example:
  ///
  ///     provider_id: bookstore_auth
  final String? providerId;

  /// NOTE: This will be deprecated soon, once AuthProvider.audiences is
  /// implemented and accepted in all the runtime components.
  ///
  /// The list of JWT
  /// [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).
  /// that are allowed to access. A JWT containing any of these audiences will
  /// be accepted. When this setting is absent, only JWTs with audience
  /// "https://`Service_name`/`API_name`"
  /// will be accepted. For example, if no audiences are in the setting,
  /// LibraryService API will only accept JWTs with the following audience
  /// "https://library-example.googleapis.com/google.example.library.v1.LibraryService".
  ///
  /// Example:
  ///
  ///     audiences: bookstore_android.apps.googleusercontent.com,
  ///                bookstore_web.apps.googleusercontent.com
  final String? audiences;

  AuthRequirement({
    this.providerId,
    this.audiences,
  }) : super(fullyQualifiedName);

  factory AuthRequirement.fromJson(Map<String, dynamic> json) {
    return AuthRequirement(
      providerId: json['providerId'],
      audiences: json['audiences'],
    );
  }

  @override
  Object toJson() {
    return {
      if (providerId != null) 'providerId': providerId,
      if (audiences != null) 'audiences': audiences,
    };
  }

  @override
  String toString() {
    final contents = [
      if (providerId != null) 'providerId=$providerId',
      if (audiences != null) 'audiences=$audiences',
    ].join(',');
    return 'AuthRequirement($contents)';
  }
}

/// `Backend` defines the backend configuration for a service.
class Backend extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Backend';

  /// A list of API backend rules that apply to individual API methods.
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<BackendRule>? rules;

  Backend({
    this.rules,
  }) : super(fullyQualifiedName);

  factory Backend.fromJson(Map<String, dynamic> json) {
    return Backend(
      rules: decodeListMessage(json['rules'], BackendRule.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (rules != null) 'rules': encodeList(rules),
    };
  }

  @override
  String toString() => 'Backend()';
}

/// A backend rule provides configuration for an individual API element.
class BackendRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.BackendRule';

  /// Selects the methods to which this rule applies.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String? selector;

  /// The address of the API backend.
  ///
  /// The scheme is used to determine the backend protocol and security.
  /// The following schemes are accepted:
  ///
  ///    SCHEME        PROTOCOL    SECURITY
  ///    http://       HTTP        None
  ///    https://      HTTP        TLS
  ///    grpc://       gRPC        None
  ///    grpcs://      gRPC        TLS
  ///
  /// It is recommended to explicitly include a scheme. Leaving out the scheme
  /// may cause constrasting behaviors across platforms.
  ///
  /// If the port is unspecified, the default is:
  /// - 80 for schemes without TLS
  /// - 443 for schemes with TLS
  ///
  /// For HTTP backends, use `protocol`
  /// to specify the protocol version.
  final String? address;

  /// The number of seconds to wait for a response from a request. The default
  /// varies based on the request protocol and deployment environment.
  final double? deadline;

  /// Deprecated, do not use.
  final double? minDeadline;

  /// The number of seconds to wait for the completion of a long running
  /// operation. The default is no deadline.
  final double? operationDeadline;

  final BackendRule_PathTranslation? pathTranslation;

  /// The JWT audience is used when generating a JWT ID token for the backend.
  /// This ID token will be added in the HTTP "authorization" header, and sent
  /// to the backend.
  final String? jwtAudience;

  /// When disable_auth is true, a JWT ID token won't be generated and the
  /// original "Authorization" HTTP header will be preserved. If the header is
  /// used to carry the original token and is expected by the backend, this
  /// field must be set to true to preserve the header.
  final bool? disableAuth;

  /// The protocol used for sending a request to the backend.
  /// The supported values are "http/1.1" and "h2".
  ///
  /// The default value is inferred from the scheme in the
  /// `address` field:
  ///
  ///    SCHEME        PROTOCOL
  ///    http://       http/1.1
  ///    https://      http/1.1
  ///    grpc://       h2
  ///    grpcs://      h2
  ///
  /// For secure HTTP backends (https://) that support HTTP/2, set this field
  /// to "h2" for improved performance.
  ///
  /// Configuring this field to non-default values is only supported for secure
  /// HTTP backends. This field will be ignored for all other backends.
  ///
  /// See
  /// https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids
  /// for more details on the supported values.
  final String? protocol;

  /// The map between request protocol and the backend address.
  final Map<String, BackendRule>? overridesByRequestProtocol;

  BackendRule({
    this.selector,
    this.address,
    this.deadline,
    this.minDeadline,
    this.operationDeadline,
    this.pathTranslation,
    this.jwtAudience,
    this.disableAuth,
    this.protocol,
    this.overridesByRequestProtocol,
  }) : super(fullyQualifiedName);

  factory BackendRule.fromJson(Map<String, dynamic> json) {
    return BackendRule(
      selector: json['selector'],
      address: json['address'],
      deadline: decodeDouble(json['deadline']),
      minDeadline: decodeDouble(json['minDeadline']),
      operationDeadline: decodeDouble(json['operationDeadline']),
      pathTranslation: decodeEnum(
          json['pathTranslation'], BackendRule_PathTranslation.fromJson),
      jwtAudience: json['jwtAudience'],
      disableAuth: json['disableAuth'],
      protocol: json['protocol'],
      overridesByRequestProtocol: decodeMapMessage(
          json['overridesByRequestProtocol'], BackendRule.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (selector != null) 'selector': selector,
      if (address != null) 'address': address,
      if (deadline != null) 'deadline': encodeDouble(deadline),
      if (minDeadline != null) 'minDeadline': encodeDouble(minDeadline),
      if (operationDeadline != null)
        'operationDeadline': encodeDouble(operationDeadline),
      if (pathTranslation != null) 'pathTranslation': pathTranslation!.toJson(),
      if (jwtAudience != null) 'jwtAudience': jwtAudience,
      if (disableAuth != null) 'disableAuth': disableAuth,
      if (protocol != null) 'protocol': protocol,
      if (overridesByRequestProtocol != null)
        'overridesByRequestProtocol': encodeMap(overridesByRequestProtocol),
    };
  }

  @override
  String toString() {
    final contents = [
      if (selector != null) 'selector=$selector',
      if (address != null) 'address=$address',
      if (deadline != null) 'deadline=$deadline',
      if (minDeadline != null) 'minDeadline=$minDeadline',
      if (operationDeadline != null) 'operationDeadline=$operationDeadline',
      if (pathTranslation != null) 'pathTranslation=$pathTranslation',
      if (jwtAudience != null) 'jwtAudience=$jwtAudience',
      if (disableAuth != null) 'disableAuth=$disableAuth',
      if (protocol != null) 'protocol=$protocol',
    ].join(',');
    return 'BackendRule($contents)';
  }
}

/// Path Translation specifies how to combine the backend address with the
/// request path in order to produce the appropriate forwarding URL for the
/// request.
///
/// Path Translation is applicable only to HTTP-based backends. Backends which
/// do not accept requests over HTTP/HTTPS should leave `path_translation`
/// unspecified.
class BackendRule_PathTranslation extends ProtoEnum {
  static const pathTranslationUnspecified =
      BackendRule_PathTranslation('PATH_TRANSLATION_UNSPECIFIED');

  /// Use the backend address as-is, with no modification to the path. If the
  /// URL pattern contains variables, the variable names and values will be
  /// appended to the query string. If a query string parameter and a URL
  /// pattern variable have the same name, this may result in duplicate keys in
  /// the query string.
  ///
  /// # Examples
  ///
  /// Given the following operation config:
  ///
  ///     Method path:        /api/company/{cid}/user/{uid}
  ///     Backend address:    https://example.cloudfunctions.net/getUser
  ///
  /// Requests to the following request paths will call the backend at the
  /// translated path:
  ///
  ///     Request path: /api/company/widgetworks/user/johndoe
  ///     Translated:
  ///     https://example.cloudfunctions.net/getUser?cid=widgetworks&uid=johndoe
  ///
  ///     Request path: /api/company/widgetworks/user/johndoe?timezone=EST
  ///     Translated:
  ///     https://example.cloudfunctions.net/getUser?timezone=EST&cid=widgetworks&uid=johndoe
  static const constantAddress =
      BackendRule_PathTranslation('CONSTANT_ADDRESS');

  /// The request path will be appended to the backend address.
  ///
  /// # Examples
  ///
  /// Given the following operation config:
  ///
  ///     Method path:        /api/company/{cid}/user/{uid}
  ///     Backend address:    https://example.appspot.com
  ///
  /// Requests to the following request paths will call the backend at the
  /// translated path:
  ///
  ///     Request path: /api/company/widgetworks/user/johndoe
  ///     Translated:
  ///     https://example.appspot.com/api/company/widgetworks/user/johndoe
  ///
  ///     Request path: /api/company/widgetworks/user/johndoe?timezone=EST
  ///     Translated:
  ///     https://example.appspot.com/api/company/widgetworks/user/johndoe?timezone=EST
  static const appendPathToAddress =
      BackendRule_PathTranslation('APPEND_PATH_TO_ADDRESS');

  const BackendRule_PathTranslation(super.value);

  factory BackendRule_PathTranslation.fromJson(String json) =>
      BackendRule_PathTranslation(json);

  @override
  String toString() => 'PathTranslation.$value';
}

/// Billing related configuration of the service.
///
/// The following example shows how to configure monitored resources and metrics
/// for billing, `consumer_destinations` is the only supported destination and
/// the monitored resources need at least one label key
/// `cloud.googleapis.com/location` to indicate the location of the billing
/// usage, using different monitored resources between monitoring and billing is
/// recommended so they can be evolved independently:
///
///
///     monitored_resources:
///     - type: library.googleapis.com/billing_branch
///       labels:
///       - key: cloud.googleapis.com/location
///         description: |
///           Predefined label to support billing location restriction.
///       - key: city
///         description: |
///           Custom label to define the city where the library branch is located
///           in.
///       - key: name
///         description: Custom label to define the name of the library branch.
///     metrics:
///     - name: library.googleapis.com/book/borrowed_count
///       metric_kind: DELTA
///       value_type: INT64
///       unit: "1"
///     billing:
///       consumer_destinations:
///       - monitored_resource: library.googleapis.com/billing_branch
///         metrics:
///         - library.googleapis.com/book/borrowed_count
class Billing extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Billing';

  /// Billing configurations for sending metrics to the consumer project.
  /// There can be multiple consumer destinations per service, each one must have
  /// a different monitored resource type. A metric can be used in at most
  /// one consumer destination.
  final List<Billing_BillingDestination>? consumerDestinations;

  Billing({
    this.consumerDestinations,
  }) : super(fullyQualifiedName);

  factory Billing.fromJson(Map<String, dynamic> json) {
    return Billing(
      consumerDestinations: decodeListMessage(
          json['consumerDestinations'], Billing_BillingDestination.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (consumerDestinations != null)
        'consumerDestinations': encodeList(consumerDestinations),
    };
  }

  @override
  String toString() => 'Billing()';
}

/// Configuration of a specific billing destination (Currently only support
/// bill against consumer project).
class Billing_BillingDestination extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.Billing.BillingDestination';

  /// The monitored resource type. The type must be defined in
  /// `Service.monitored_resources`
  /// section.
  final String? monitoredResource;

  /// Names of the metrics to report to this billing destination.
  /// Each name must be defined in
  /// `Service.metrics` section.
  final List<String>? metrics;

  Billing_BillingDestination({
    this.monitoredResource,
    this.metrics,
  }) : super(fullyQualifiedName);

  factory Billing_BillingDestination.fromJson(Map<String, dynamic> json) {
    return Billing_BillingDestination(
      monitoredResource: json['monitoredResource'],
      metrics: decodeList(json['metrics']),
    );
  }

  @override
  Object toJson() {
    return {
      if (monitoredResource != null) 'monitoredResource': monitoredResource,
      if (metrics != null) 'metrics': metrics,
    };
  }

  @override
  String toString() {
    final contents = [
      if (monitoredResource != null) 'monitoredResource=$monitoredResource',
    ].join(',');
    return 'BillingDestination($contents)';
  }
}

/// Required information for every language.
class CommonLanguageSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.CommonLanguageSettings';

  /// Link to automatically generated reference documentation.  Example:
  /// https://cloud.google.com/nodejs/docs/reference/asset/latest
  final String? referenceDocsUri;

  /// The destination where API teams want this client library to be published.
  final List<ClientLibraryDestination>? destinations;

  /// Configuration for which RPCs should be generated in the GAPIC client.
  final SelectiveGapicGeneration? selectiveGapicGeneration;

  CommonLanguageSettings({
    this.referenceDocsUri,
    this.destinations,
    this.selectiveGapicGeneration,
  }) : super(fullyQualifiedName);

  factory CommonLanguageSettings.fromJson(Map<String, dynamic> json) {
    return CommonLanguageSettings(
      referenceDocsUri: json['referenceDocsUri'],
      destinations: decodeListEnum(
          json['destinations'], ClientLibraryDestination.fromJson),
      selectiveGapicGeneration: decode(
          json['selectiveGapicGeneration'], SelectiveGapicGeneration.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (referenceDocsUri != null) 'referenceDocsUri': referenceDocsUri,
      if (destinations != null) 'destinations': encodeList(destinations),
      if (selectiveGapicGeneration != null)
        'selectiveGapicGeneration': selectiveGapicGeneration!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (referenceDocsUri != null) 'referenceDocsUri=$referenceDocsUri',
    ].join(',');
    return 'CommonLanguageSettings($contents)';
  }
}

/// Details about how and where to publish client libraries.
class ClientLibrarySettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.ClientLibrarySettings';

  /// Version of the API to apply these settings to. This is the full protobuf
  /// package for the API, ending in the version element.
  /// Examples: "google.cloud.speech.v1" and "google.spanner.admin.database.v1".
  final String? version;

  /// Launch stage of this version of the API.
  final LaunchStage? launchStage;

  /// When using transport=rest, the client request will encode enums as
  /// numbers rather than strings.
  final bool? restNumericEnums;

  /// Settings for legacy Java features, supported in the Service YAML.
  final JavaSettings? javaSettings;

  /// Settings for C++ client libraries.
  final CppSettings? cppSettings;

  /// Settings for PHP client libraries.
  final PhpSettings? phpSettings;

  /// Settings for Python client libraries.
  final PythonSettings? pythonSettings;

  /// Settings for Node client libraries.
  final NodeSettings? nodeSettings;

  /// Settings for .NET client libraries.
  final DotnetSettings? dotnetSettings;

  /// Settings for Ruby client libraries.
  final RubySettings? rubySettings;

  /// Settings for Go client libraries.
  final GoSettings? goSettings;

  ClientLibrarySettings({
    this.version,
    this.launchStage,
    this.restNumericEnums,
    this.javaSettings,
    this.cppSettings,
    this.phpSettings,
    this.pythonSettings,
    this.nodeSettings,
    this.dotnetSettings,
    this.rubySettings,
    this.goSettings,
  }) : super(fullyQualifiedName);

  factory ClientLibrarySettings.fromJson(Map<String, dynamic> json) {
    return ClientLibrarySettings(
      version: json['version'],
      launchStage: decodeEnum(json['launchStage'], LaunchStage.fromJson),
      restNumericEnums: json['restNumericEnums'],
      javaSettings: decode(json['javaSettings'], JavaSettings.fromJson),
      cppSettings: decode(json['cppSettings'], CppSettings.fromJson),
      phpSettings: decode(json['phpSettings'], PhpSettings.fromJson),
      pythonSettings: decode(json['pythonSettings'], PythonSettings.fromJson),
      nodeSettings: decode(json['nodeSettings'], NodeSettings.fromJson),
      dotnetSettings: decode(json['dotnetSettings'], DotnetSettings.fromJson),
      rubySettings: decode(json['rubySettings'], RubySettings.fromJson),
      goSettings: decode(json['goSettings'], GoSettings.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (version != null) 'version': version,
      if (launchStage != null) 'launchStage': launchStage!.toJson(),
      if (restNumericEnums != null) 'restNumericEnums': restNumericEnums,
      if (javaSettings != null) 'javaSettings': javaSettings!.toJson(),
      if (cppSettings != null) 'cppSettings': cppSettings!.toJson(),
      if (phpSettings != null) 'phpSettings': phpSettings!.toJson(),
      if (pythonSettings != null) 'pythonSettings': pythonSettings!.toJson(),
      if (nodeSettings != null) 'nodeSettings': nodeSettings!.toJson(),
      if (dotnetSettings != null) 'dotnetSettings': dotnetSettings!.toJson(),
      if (rubySettings != null) 'rubySettings': rubySettings!.toJson(),
      if (goSettings != null) 'goSettings': goSettings!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (version != null) 'version=$version',
      if (launchStage != null) 'launchStage=$launchStage',
      if (restNumericEnums != null) 'restNumericEnums=$restNumericEnums',
    ].join(',');
    return 'ClientLibrarySettings($contents)';
  }
}

/// This message configures the settings for publishing [Google Cloud Client
/// libraries](https://cloud.google.com/apis/docs/cloud-client-libraries)
/// generated from the service config.
class Publishing extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Publishing';

  /// A list of API method settings, e.g. the behavior for methods that use the
  /// long-running operation pattern.
  final List<MethodSettings>? methodSettings;

  /// Link to a *public* URI where users can report issues.  Example:
  /// https://issuetracker.google.com/issues/new?component=190865&template=1161103
  final String? newIssueUri;

  /// Link to product home page.  Example:
  /// https://cloud.google.com/asset-inventory/docs/overview
  final String? documentationUri;

  /// Used as a tracking tag when collecting data about the APIs developer
  /// relations artifacts like docs, packages delivered to package managers,
  /// etc.  Example: "speech".
  final String? apiShortName;

  /// GitHub label to apply to issues and pull requests opened for this API.
  final String? githubLabel;

  /// GitHub teams to be added to CODEOWNERS in the directory in GitHub
  /// containing source code for the client libraries for this API.
  final List<String>? codeownerGithubTeams;

  /// A prefix used in sample code when demarking regions to be included in
  /// documentation.
  final String? docTagPrefix;

  /// For whom the client library is being published.
  final ClientLibraryOrganization? organization;

  /// Client library settings.  If the same version string appears multiple
  /// times in this list, then the last one wins.  Settings from earlier
  /// settings with the same version string are discarded.
  final List<ClientLibrarySettings>? librarySettings;

  /// Optional link to proto reference documentation.  Example:
  /// https://cloud.google.com/pubsub/lite/docs/reference/rpc
  final String? protoReferenceDocumentationUri;

  /// Optional link to REST reference documentation.  Example:
  /// https://cloud.google.com/pubsub/lite/docs/reference/rest
  final String? restReferenceDocumentationUri;

  Publishing({
    this.methodSettings,
    this.newIssueUri,
    this.documentationUri,
    this.apiShortName,
    this.githubLabel,
    this.codeownerGithubTeams,
    this.docTagPrefix,
    this.organization,
    this.librarySettings,
    this.protoReferenceDocumentationUri,
    this.restReferenceDocumentationUri,
  }) : super(fullyQualifiedName);

  factory Publishing.fromJson(Map<String, dynamic> json) {
    return Publishing(
      methodSettings:
          decodeListMessage(json['methodSettings'], MethodSettings.fromJson),
      newIssueUri: json['newIssueUri'],
      documentationUri: json['documentationUri'],
      apiShortName: json['apiShortName'],
      githubLabel: json['githubLabel'],
      codeownerGithubTeams: decodeList(json['codeownerGithubTeams']),
      docTagPrefix: json['docTagPrefix'],
      organization:
          decodeEnum(json['organization'], ClientLibraryOrganization.fromJson),
      librarySettings: decodeListMessage(
          json['librarySettings'], ClientLibrarySettings.fromJson),
      protoReferenceDocumentationUri: json['protoReferenceDocumentationUri'],
      restReferenceDocumentationUri: json['restReferenceDocumentationUri'],
    );
  }

  @override
  Object toJson() {
    return {
      if (methodSettings != null) 'methodSettings': encodeList(methodSettings),
      if (newIssueUri != null) 'newIssueUri': newIssueUri,
      if (documentationUri != null) 'documentationUri': documentationUri,
      if (apiShortName != null) 'apiShortName': apiShortName,
      if (githubLabel != null) 'githubLabel': githubLabel,
      if (codeownerGithubTeams != null)
        'codeownerGithubTeams': codeownerGithubTeams,
      if (docTagPrefix != null) 'docTagPrefix': docTagPrefix,
      if (organization != null) 'organization': organization!.toJson(),
      if (librarySettings != null)
        'librarySettings': encodeList(librarySettings),
      if (protoReferenceDocumentationUri != null)
        'protoReferenceDocumentationUri': protoReferenceDocumentationUri,
      if (restReferenceDocumentationUri != null)
        'restReferenceDocumentationUri': restReferenceDocumentationUri,
    };
  }

  @override
  String toString() {
    final contents = [
      if (newIssueUri != null) 'newIssueUri=$newIssueUri',
      if (documentationUri != null) 'documentationUri=$documentationUri',
      if (apiShortName != null) 'apiShortName=$apiShortName',
      if (githubLabel != null) 'githubLabel=$githubLabel',
      if (docTagPrefix != null) 'docTagPrefix=$docTagPrefix',
      if (organization != null) 'organization=$organization',
      if (protoReferenceDocumentationUri != null)
        'protoReferenceDocumentationUri=$protoReferenceDocumentationUri',
      if (restReferenceDocumentationUri != null)
        'restReferenceDocumentationUri=$restReferenceDocumentationUri',
    ].join(',');
    return 'Publishing($contents)';
  }
}

/// Settings for Java client libraries.
class JavaSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.JavaSettings';

  /// The package name to use in Java. Clobbers the java_package option
  /// set in the protobuf. This should be used **only** by APIs
  /// who have already set the language_settings.java.package_name" field
  /// in gapic.yaml. API teams should use the protobuf java_package option
  /// where possible.
  ///
  /// Example of a YAML configuration::
  ///
  ///  publishing:
  ///    java_settings:
  ///      library_package: com.google.cloud.pubsub.v1
  final String? libraryPackage;

  /// Configure the Java class name to use instead of the service's for its
  /// corresponding generated GAPIC client. Keys are fully-qualified
  /// service names as they appear in the protobuf (including the full
  /// the language_settings.java.interface_names" field in gapic.yaml. API
  /// teams should otherwise use the service name as it appears in the
  /// protobuf.
  ///
  /// Example of a YAML configuration::
  ///
  ///  publishing:
  ///    java_settings:
  ///      service_class_names:
  ///        - google.pubsub.v1.Publisher: TopicAdmin
  ///        - google.pubsub.v1.Subscriber: SubscriptionAdmin
  final Map<String, String>? serviceClassNames;

  /// Some settings.
  final CommonLanguageSettings? common;

  JavaSettings({
    this.libraryPackage,
    this.serviceClassNames,
    this.common,
  }) : super(fullyQualifiedName);

  factory JavaSettings.fromJson(Map<String, dynamic> json) {
    return JavaSettings(
      libraryPackage: json['libraryPackage'],
      serviceClassNames: decodeMap(json['serviceClassNames']),
      common: decode(json['common'], CommonLanguageSettings.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (libraryPackage != null) 'libraryPackage': libraryPackage,
      if (serviceClassNames != null) 'serviceClassNames': serviceClassNames,
      if (common != null) 'common': common!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (libraryPackage != null) 'libraryPackage=$libraryPackage',
    ].join(',');
    return 'JavaSettings($contents)';
  }
}

/// Settings for C++ client libraries.
class CppSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.CppSettings';

  /// Some settings.
  final CommonLanguageSettings? common;

  CppSettings({
    this.common,
  }) : super(fullyQualifiedName);

  factory CppSettings.fromJson(Map<String, dynamic> json) {
    return CppSettings(
      common: decode(json['common'], CommonLanguageSettings.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (common != null) 'common': common!.toJson(),
    };
  }

  @override
  String toString() => 'CppSettings()';
}

/// Settings for Php client libraries.
class PhpSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.PhpSettings';

  /// Some settings.
  final CommonLanguageSettings? common;

  PhpSettings({
    this.common,
  }) : super(fullyQualifiedName);

  factory PhpSettings.fromJson(Map<String, dynamic> json) {
    return PhpSettings(
      common: decode(json['common'], CommonLanguageSettings.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (common != null) 'common': common!.toJson(),
    };
  }

  @override
  String toString() => 'PhpSettings()';
}

/// Settings for Python client libraries.
class PythonSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.PythonSettings';

  /// Some settings.
  final CommonLanguageSettings? common;

  /// Experimental features to be included during client library generation.
  final PythonSettings_ExperimentalFeatures? experimentalFeatures;

  PythonSettings({
    this.common,
    this.experimentalFeatures,
  }) : super(fullyQualifiedName);

  factory PythonSettings.fromJson(Map<String, dynamic> json) {
    return PythonSettings(
      common: decode(json['common'], CommonLanguageSettings.fromJson),
      experimentalFeatures: decode(json['experimentalFeatures'],
          PythonSettings_ExperimentalFeatures.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (common != null) 'common': common!.toJson(),
      if (experimentalFeatures != null)
        'experimentalFeatures': experimentalFeatures!.toJson(),
    };
  }

  @override
  String toString() => 'PythonSettings()';
}

/// Experimental features to be included during client library generation.
/// These fields will be deprecated once the feature graduates and is enabled
/// by default.
class PythonSettings_ExperimentalFeatures extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.PythonSettings.ExperimentalFeatures';

  /// Enables generation of asynchronous REST clients if `rest` transport is
  /// enabled. By default, asynchronous REST clients will not be generated.
  /// This feature will be enabled by default 1 month after launching the
  /// feature in preview packages.
  final bool? restAsyncIoEnabled;

  /// Enables generation of protobuf code using new types that are more
  /// Pythonic which are included in `protobuf>=5.29.x`. This feature will be
  /// enabled by default 1 month after launching the feature in preview
  /// packages.
  final bool? protobufPythonicTypesEnabled;

  /// Disables generation of an unversioned Python package for this client
  /// library. This means that the module names will need to be versioned in
  /// import statements. For example `import google.cloud.library_v2` instead
  /// of `import google.cloud.library`.
  final bool? unversionedPackageDisabled;

  PythonSettings_ExperimentalFeatures({
    this.restAsyncIoEnabled,
    this.protobufPythonicTypesEnabled,
    this.unversionedPackageDisabled,
  }) : super(fullyQualifiedName);

  factory PythonSettings_ExperimentalFeatures.fromJson(
      Map<String, dynamic> json) {
    return PythonSettings_ExperimentalFeatures(
      restAsyncIoEnabled: json['restAsyncIoEnabled'],
      protobufPythonicTypesEnabled: json['protobufPythonicTypesEnabled'],
      unversionedPackageDisabled: json['unversionedPackageDisabled'],
    );
  }

  @override
  Object toJson() {
    return {
      if (restAsyncIoEnabled != null) 'restAsyncIoEnabled': restAsyncIoEnabled,
      if (protobufPythonicTypesEnabled != null)
        'protobufPythonicTypesEnabled': protobufPythonicTypesEnabled,
      if (unversionedPackageDisabled != null)
        'unversionedPackageDisabled': unversionedPackageDisabled,
    };
  }

  @override
  String toString() {
    final contents = [
      if (restAsyncIoEnabled != null) 'restAsyncIoEnabled=$restAsyncIoEnabled',
      if (protobufPythonicTypesEnabled != null)
        'protobufPythonicTypesEnabled=$protobufPythonicTypesEnabled',
      if (unversionedPackageDisabled != null)
        'unversionedPackageDisabled=$unversionedPackageDisabled',
    ].join(',');
    return 'ExperimentalFeatures($contents)';
  }
}

/// Settings for Node client libraries.
class NodeSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.NodeSettings';

  /// Some settings.
  final CommonLanguageSettings? common;

  NodeSettings({
    this.common,
  }) : super(fullyQualifiedName);

  factory NodeSettings.fromJson(Map<String, dynamic> json) {
    return NodeSettings(
      common: decode(json['common'], CommonLanguageSettings.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (common != null) 'common': common!.toJson(),
    };
  }

  @override
  String toString() => 'NodeSettings()';
}

/// Settings for Dotnet client libraries.
class DotnetSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.DotnetSettings';

  /// Some settings.
  final CommonLanguageSettings? common;

  /// Map from original service names to renamed versions.
  /// This is used when the default generated types
  /// would cause a naming conflict. (Neither name is
  /// fully-qualified.)
  /// Example: Subscriber to SubscriberServiceApi.
  final Map<String, String>? renamedServices;

  /// Map from full resource types to the effective short name
  /// for the resource. This is used when otherwise resource
  /// named from different services would cause naming collisions.
  /// Example entry:
  /// "datalabeling.googleapis.com/Dataset": "DataLabelingDataset"
  final Map<String, String>? renamedResources;

  /// List of full resource types to ignore during generation.
  /// This is typically used for API-specific Location resources,
  /// which should be handled by the generator as if they were actually
  /// the common Location resources.
  /// Example entry: "documentai.googleapis.com/Location"
  final List<String>? ignoredResources;

  /// Namespaces which must be aliased in snippets due to
  /// a known (but non-generator-predictable) naming collision
  final List<String>? forcedNamespaceAliases;

  /// Method signatures (in the form "service.method(signature)")
  /// which are provided separately, so shouldn't be generated.
  /// Snippets *calling* these methods are still generated, however.
  final List<String>? handwrittenSignatures;

  DotnetSettings({
    this.common,
    this.renamedServices,
    this.renamedResources,
    this.ignoredResources,
    this.forcedNamespaceAliases,
    this.handwrittenSignatures,
  }) : super(fullyQualifiedName);

  factory DotnetSettings.fromJson(Map<String, dynamic> json) {
    return DotnetSettings(
      common: decode(json['common'], CommonLanguageSettings.fromJson),
      renamedServices: decodeMap(json['renamedServices']),
      renamedResources: decodeMap(json['renamedResources']),
      ignoredResources: decodeList(json['ignoredResources']),
      forcedNamespaceAliases: decodeList(json['forcedNamespaceAliases']),
      handwrittenSignatures: decodeList(json['handwrittenSignatures']),
    );
  }

  @override
  Object toJson() {
    return {
      if (common != null) 'common': common!.toJson(),
      if (renamedServices != null) 'renamedServices': renamedServices,
      if (renamedResources != null) 'renamedResources': renamedResources,
      if (ignoredResources != null) 'ignoredResources': ignoredResources,
      if (forcedNamespaceAliases != null)
        'forcedNamespaceAliases': forcedNamespaceAliases,
      if (handwrittenSignatures != null)
        'handwrittenSignatures': handwrittenSignatures,
    };
  }

  @override
  String toString() => 'DotnetSettings()';
}

/// Settings for Ruby client libraries.
class RubySettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.RubySettings';

  /// Some settings.
  final CommonLanguageSettings? common;

  RubySettings({
    this.common,
  }) : super(fullyQualifiedName);

  factory RubySettings.fromJson(Map<String, dynamic> json) {
    return RubySettings(
      common: decode(json['common'], CommonLanguageSettings.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (common != null) 'common': common!.toJson(),
    };
  }

  @override
  String toString() => 'RubySettings()';
}

/// Settings for Go client libraries.
class GoSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.GoSettings';

  /// Some settings.
  final CommonLanguageSettings? common;

  /// Map of service names to renamed services. Keys are the package relative
  /// service names and values are the name to be used for the service client
  /// and call options.
  ///
  /// publishing:
  ///   go_settings:
  ///     renamed_services:
  ///       Publisher: TopicAdmin
  final Map<String, String>? renamedServices;

  GoSettings({
    this.common,
    this.renamedServices,
  }) : super(fullyQualifiedName);

  factory GoSettings.fromJson(Map<String, dynamic> json) {
    return GoSettings(
      common: decode(json['common'], CommonLanguageSettings.fromJson),
      renamedServices: decodeMap(json['renamedServices']),
    );
  }

  @override
  Object toJson() {
    return {
      if (common != null) 'common': common!.toJson(),
      if (renamedServices != null) 'renamedServices': renamedServices,
    };
  }

  @override
  String toString() => 'GoSettings()';
}

/// Describes the generator configuration for a method.
class MethodSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.MethodSettings';

  /// The fully qualified name of the method, for which the options below apply.
  /// This is used to find the method to apply the options.
  ///
  /// Example:
  ///
  ///    publishing:
  ///      method_settings:
  ///      - selector: google.storage.control.v2.StorageControl.CreateFolder
  ///        # method settings for CreateFolder...
  final String? selector;

  /// Describes settings to use for long-running operations when generating
  /// API methods for RPCs. Complements RPCs that use the annotations in
  /// google/longrunning/operations.proto.
  ///
  /// Example of a YAML configuration::
  ///
  ///    publishing:
  ///      method_settings:
  ///      - selector: google.cloud.speech.v2.Speech.BatchRecognize
  ///        long_running:
  ///          initial_poll_delay: 60s # 1 minute
  ///          poll_delay_multiplier: 1.5
  ///          max_poll_delay: 360s # 6 minutes
  ///          total_poll_timeout: 54000s # 90 minutes
  final MethodSettings_LongRunning? longRunning;

  /// List of top-level fields of the request message, that should be
  /// automatically populated by the client libraries based on their
  /// (google.api.field_info).format. Currently supported format: UUID4.
  ///
  /// Example of a YAML configuration:
  ///
  ///    publishing:
  ///      method_settings:
  ///      - selector: google.example.v1.ExampleService.CreateExample
  ///        auto_populated_fields:
  ///        - request_id
  final List<String>? autoPopulatedFields;

  MethodSettings({
    this.selector,
    this.longRunning,
    this.autoPopulatedFields,
  }) : super(fullyQualifiedName);

  factory MethodSettings.fromJson(Map<String, dynamic> json) {
    return MethodSettings(
      selector: json['selector'],
      longRunning:
          decode(json['longRunning'], MethodSettings_LongRunning.fromJson),
      autoPopulatedFields: decodeList(json['autoPopulatedFields']),
    );
  }

  @override
  Object toJson() {
    return {
      if (selector != null) 'selector': selector,
      if (longRunning != null) 'longRunning': longRunning!.toJson(),
      if (autoPopulatedFields != null)
        'autoPopulatedFields': autoPopulatedFields,
    };
  }

  @override
  String toString() {
    final contents = [
      if (selector != null) 'selector=$selector',
    ].join(',');
    return 'MethodSettings($contents)';
  }
}

/// Describes settings to use when generating API methods that use the
/// long-running operation pattern.
/// All default values below are from those used in the client library
/// generators (e.g.
/// [Java](https://github.com/googleapis/gapic-generator-java/blob/04c2faa191a9b5a10b92392fe8482279c4404803/src/main/java/com/google/api/generator/gapic/composer/common/RetrySettingsComposer.java)).
class MethodSettings_LongRunning extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.MethodSettings.LongRunning';

  /// Initial delay after which the first poll request will be made.
  /// Default value: 5 seconds.
  final Duration? initialPollDelay;

  /// Multiplier to gradually increase delay between subsequent polls until it
  /// reaches max_poll_delay.
  /// Default value: 1.5.
  final double? pollDelayMultiplier;

  /// Maximum time between two subsequent poll requests.
  /// Default value: 45 seconds.
  final Duration? maxPollDelay;

  /// Total polling timeout.
  /// Default value: 5 minutes.
  final Duration? totalPollTimeout;

  MethodSettings_LongRunning({
    this.initialPollDelay,
    this.pollDelayMultiplier,
    this.maxPollDelay,
    this.totalPollTimeout,
  }) : super(fullyQualifiedName);

  factory MethodSettings_LongRunning.fromJson(Map<String, dynamic> json) {
    return MethodSettings_LongRunning(
      initialPollDelay:
          decodeCustom(json['initialPollDelay'], Duration.fromJson),
      pollDelayMultiplier: decodeDouble(json['pollDelayMultiplier']),
      maxPollDelay: decodeCustom(json['maxPollDelay'], Duration.fromJson),
      totalPollTimeout:
          decodeCustom(json['totalPollTimeout'], Duration.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (initialPollDelay != null)
        'initialPollDelay': initialPollDelay!.toJson(),
      if (pollDelayMultiplier != null)
        'pollDelayMultiplier': encodeDouble(pollDelayMultiplier),
      if (maxPollDelay != null) 'maxPollDelay': maxPollDelay!.toJson(),
      if (totalPollTimeout != null)
        'totalPollTimeout': totalPollTimeout!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (pollDelayMultiplier != null)
        'pollDelayMultiplier=$pollDelayMultiplier',
    ].join(',');
    return 'LongRunning($contents)';
  }
}

/// This message is used to configure the generation of a subset of the RPCs in
/// a service for client libraries.
class SelectiveGapicGeneration extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.SelectiveGapicGeneration';

  /// An allowlist of the fully qualified names of RPCs that should be included
  /// on public client surfaces.
  final List<String>? methods;

  /// Setting this to true indicates to the client generators that methods
  /// that would be excluded from the generation should instead be generated
  /// in a way that indicates these methods should not be consumed by
  /// end users. How this is expressed is up to individual language
  /// implementations to decide. Some examples may be: added annotations,
  /// obfuscated identifiers, or other language idiomatic patterns.
  final bool? generateOmittedAsInternal;

  SelectiveGapicGeneration({
    this.methods,
    this.generateOmittedAsInternal,
  }) : super(fullyQualifiedName);

  factory SelectiveGapicGeneration.fromJson(Map<String, dynamic> json) {
    return SelectiveGapicGeneration(
      methods: decodeList(json['methods']),
      generateOmittedAsInternal: json['generateOmittedAsInternal'],
    );
  }

  @override
  Object toJson() {
    return {
      if (methods != null) 'methods': methods,
      if (generateOmittedAsInternal != null)
        'generateOmittedAsInternal': generateOmittedAsInternal,
    };
  }

  @override
  String toString() {
    final contents = [
      if (generateOmittedAsInternal != null)
        'generateOmittedAsInternal=$generateOmittedAsInternal',
    ].join(',');
    return 'SelectiveGapicGeneration($contents)';
  }
}

/// Output generated from semantically comparing two versions of a service
/// configuration.
///
/// Includes detailed information about a field that have changed with
/// applicable advice about potential consequences for the change, such as
/// backwards-incompatibility.
class ConfigChange extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.ConfigChange';

  /// Object hierarchy path to the change, with levels separated by a '.'
  /// character. For repeated fields, an applicable unique identifier field is
  /// used for the index (usually selector, name, or id). For maps, the term
  /// 'key' is used. If the field has no unique identifier, the numeric index
  /// is used.
  /// Examples:
  /// - visibility.rules[selector=="google.LibraryService.ListBooks"].restriction
  /// - quota.metric_rules[selector=="google"].metric_costs[key=="reads"].value
  /// - logging.producer_destinations[0]
  final String? element;

  /// Value of the changed object in the old Service configuration,
  /// in JSON format. This field will not be populated if ChangeType == ADDED.
  final String? oldValue;

  /// Value of the changed object in the new Service configuration,
  /// in JSON format. This field will not be populated if ChangeType == REMOVED.
  final String? newValue;

  /// The type for this change, either ADDED, REMOVED, or MODIFIED.
  final ChangeType? changeType;

  /// Collection of advice provided for this change, useful for determining the
  /// possible impact of this change.
  final List<Advice>? advices;

  ConfigChange({
    this.element,
    this.oldValue,
    this.newValue,
    this.changeType,
    this.advices,
  }) : super(fullyQualifiedName);

  factory ConfigChange.fromJson(Map<String, dynamic> json) {
    return ConfigChange(
      element: json['element'],
      oldValue: json['oldValue'],
      newValue: json['newValue'],
      changeType: decodeEnum(json['changeType'], ChangeType.fromJson),
      advices: decodeListMessage(json['advices'], Advice.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (element != null) 'element': element,
      if (oldValue != null) 'oldValue': oldValue,
      if (newValue != null) 'newValue': newValue,
      if (changeType != null) 'changeType': changeType!.toJson(),
      if (advices != null) 'advices': encodeList(advices),
    };
  }

  @override
  String toString() {
    final contents = [
      if (element != null) 'element=$element',
      if (oldValue != null) 'oldValue=$oldValue',
      if (newValue != null) 'newValue=$newValue',
      if (changeType != null) 'changeType=$changeType',
    ].join(',');
    return 'ConfigChange($contents)';
  }
}

/// Generated advice about this change, used for providing more
/// information about how a change will affect the existing service.
class Advice extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Advice';

  /// Useful description for why this advice was applied and what actions should
  /// be taken to mitigate any implied risks.
  final String? description;

  Advice({
    this.description,
  }) : super(fullyQualifiedName);

  factory Advice.fromJson(Map<String, dynamic> json) {
    return Advice(
      description: json['description'],
    );
  }

  @override
  Object toJson() {
    return {
      if (description != null) 'description': description,
    };
  }

  @override
  String toString() {
    final contents = [
      if (description != null) 'description=$description',
    ].join(',');
    return 'Advice($contents)';
  }
}

/// A descriptor for defining project properties for a service. One service may
/// have many consumer projects, and the service may want to behave differently
/// depending on some properties on the project. For example, a project may be
/// associated with a school, or a business, or a government agency, a business
/// type property on the project may affect how a service responds to the client.
/// This descriptor defines which properties are allowed to be set on a project.
///
/// Example:
///
///    project_properties:
///      properties:
///      - name: NO_WATERMARK
///        type: BOOL
///        description: Allows usage of the API without watermarks.
///      - name: EXTENDED_TILE_CACHE_PERIOD
///        type: INT64
class ProjectProperties extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.ProjectProperties';

  /// List of per consumer project-specific properties.
  final List<Property>? properties;

  ProjectProperties({
    this.properties,
  }) : super(fullyQualifiedName);

  factory ProjectProperties.fromJson(Map<String, dynamic> json) {
    return ProjectProperties(
      properties: decodeListMessage(json['properties'], Property.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (properties != null) 'properties': encodeList(properties),
    };
  }

  @override
  String toString() => 'ProjectProperties()';
}

/// Defines project properties.
///
/// API services can define properties that can be assigned to consumer projects
/// so that backends can perform response customization without having to make
/// additional calls or maintain additional storage. For example, Maps API
/// defines properties that controls map tile cache period, or whether to embed a
/// watermark in a result.
///
/// These values can be set via API producer console. Only API providers can
/// define and set these properties.
class Property extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Property';

  /// The name of the property (a.k.a key).
  final String? name;

  /// The type of this property.
  final Property_PropertyType? type;

  /// The description of the property
  final String? description;

  Property({
    this.name,
    this.type,
    this.description,
  }) : super(fullyQualifiedName);

  factory Property.fromJson(Map<String, dynamic> json) {
    return Property(
      name: json['name'],
      type: decodeEnum(json['type'], Property_PropertyType.fromJson),
      description: json['description'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (type != null) 'type': type!.toJson(),
      if (description != null) 'description': description,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (type != null) 'type=$type',
      if (description != null) 'description=$description',
    ].join(',');
    return 'Property($contents)';
  }
}

/// Supported data type of the property values
class Property_PropertyType extends ProtoEnum {
  /// The type is unspecified, and will result in an error.
  static const unspecified = Property_PropertyType('UNSPECIFIED');

  /// The type is `int64`.
  static const int64 = Property_PropertyType('INT64');

  /// The type is `bool`.
  static const bool = Property_PropertyType('BOOL');

  /// The type is `string`.
  static const string = Property_PropertyType('STRING');

  /// The type is 'double'.
  static const double = Property_PropertyType('DOUBLE');

  const Property_PropertyType(super.value);

  factory Property_PropertyType.fromJson(String json) =>
      Property_PropertyType(json);

  @override
  String toString() => 'PropertyType.$value';
}

/// `Context` defines which contexts an API requests.
///
/// Example:
///
///     context:
///       rules:
///       - selector: "*"
///         requested:
///         - google.rpc.context.ProjectContext
///         - google.rpc.context.OriginContext
///
/// The above specifies that all methods in the API request
/// `google.rpc.context.ProjectContext` and
/// `google.rpc.context.OriginContext`.
///
/// Available context types are defined in package
/// `google.rpc.context`.
///
/// This also provides mechanism to allowlist any protobuf message extension that
/// can be sent in grpc metadata using “x-goog-ext-<extension_id>-bin” and
/// “x-goog-ext-<extension_id>-jspb” format. For example, list any service
/// specific protobuf types that can appear in grpc metadata as follows in your
/// yaml file:
///
/// Example:
///
///     context:
///       rules:
///        - selector: "google.example.library.v1.LibraryService.CreateBook"
///          allowed_request_extensions:
///          - google.foo.v1.NewExtension
///          allowed_response_extensions:
///          - google.foo.v1.NewExtension
///
/// You can also specify extension ID instead of fully qualified extension name
/// here.
class Context extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Context';

  /// A list of RPC context rules that apply to individual API methods.
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<ContextRule>? rules;

  Context({
    this.rules,
  }) : super(fullyQualifiedName);

  factory Context.fromJson(Map<String, dynamic> json) {
    return Context(
      rules: decodeListMessage(json['rules'], ContextRule.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (rules != null) 'rules': encodeList(rules),
    };
  }

  @override
  String toString() => 'Context()';
}

/// A context rule provides information about the context for an individual API
/// element.
class ContextRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.ContextRule';

  /// Selects the methods to which this rule applies.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String? selector;

  /// A list of full type names of requested contexts, only the requested context
  /// will be made available to the backend.
  final List<String>? requested;

  /// A list of full type names of provided contexts. It is used to support
  /// propagating HTTP headers and ETags from the response extension.
  final List<String>? provided;

  /// A list of full type names or extension IDs of extensions allowed in grpc
  /// side channel from client to backend.
  final List<String>? allowedRequestExtensions;

  /// A list of full type names or extension IDs of extensions allowed in grpc
  /// side channel from backend to client.
  final List<String>? allowedResponseExtensions;

  ContextRule({
    this.selector,
    this.requested,
    this.provided,
    this.allowedRequestExtensions,
    this.allowedResponseExtensions,
  }) : super(fullyQualifiedName);

  factory ContextRule.fromJson(Map<String, dynamic> json) {
    return ContextRule(
      selector: json['selector'],
      requested: decodeList(json['requested']),
      provided: decodeList(json['provided']),
      allowedRequestExtensions: decodeList(json['allowedRequestExtensions']),
      allowedResponseExtensions: decodeList(json['allowedResponseExtensions']),
    );
  }

  @override
  Object toJson() {
    return {
      if (selector != null) 'selector': selector,
      if (requested != null) 'requested': requested,
      if (provided != null) 'provided': provided,
      if (allowedRequestExtensions != null)
        'allowedRequestExtensions': allowedRequestExtensions,
      if (allowedResponseExtensions != null)
        'allowedResponseExtensions': allowedResponseExtensions,
    };
  }

  @override
  String toString() {
    final contents = [
      if (selector != null) 'selector=$selector',
    ].join(',');
    return 'ContextRule($contents)';
  }
}

/// Selects and configures the service controller used by the service.
///
/// Example:
///
///     control:
///       environment: servicecontrol.googleapis.com
class Control extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Control';

  /// The service controller environment to use. If empty, no control plane
  /// feature (like quota and billing) will be enabled. The recommended value for
  /// most services is servicecontrol.googleapis.com
  final String? environment;

  /// Defines policies applying to the API methods of the service.
  final List<MethodPolicy>? methodPolicies;

  Control({
    this.environment,
    this.methodPolicies,
  }) : super(fullyQualifiedName);

  factory Control.fromJson(Map<String, dynamic> json) {
    return Control(
      environment: json['environment'],
      methodPolicies:
          decodeListMessage(json['methodPolicies'], MethodPolicy.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (environment != null) 'environment': environment,
      if (methodPolicies != null) 'methodPolicies': encodeList(methodPolicies),
    };
  }

  @override
  String toString() {
    final contents = [
      if (environment != null) 'environment=$environment',
    ].join(',');
    return 'Control($contents)';
  }
}

/// `Distribution` contains summary statistics for a population of values. It
/// optionally contains a histogram representing the distribution of those values
/// across a set of buckets.
///
/// The summary statistics are the count, mean, sum of the squared deviation from
/// the mean, the minimum, and the maximum of the set of population of values.
/// The histogram is based on a sequence of buckets and gives a count of values
/// that fall into each bucket. The boundaries of the buckets are given either
/// explicitly or by formulas for buckets of fixed or exponentially increasing
/// widths.
///
/// Although it is not forbidden, it is generally a bad idea to include
/// non-finite values (infinities or NaNs) in the population of values, as this
/// will render the `mean` and `sum_of_squared_deviation` fields meaningless.
class Distribution extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Distribution';

  /// The number of values in the population. Must be non-negative. This value
  /// must equal the sum of the values in `bucket_counts` if a histogram is
  /// provided.
  final int? count;

  /// The arithmetic mean of the values in the population. If `count` is zero
  /// then this field must be zero.
  final double? mean;

  /// The sum of squared deviations from the mean of the values in the
  /// population. For values x_i this is:
  ///
  ///     Sum[i=1..n]((x_i - mean)^2)
  ///
  /// Knuth, "The Art of Computer Programming", Vol. 2, page 232, 3rd edition
  /// describes Welford's method for accumulating this sum in one pass.
  ///
  /// If `count` is zero then this field must be zero.
  final double? sumOfSquaredDeviation;

  /// If specified, contains the range of the population values. The field
  /// must not be present if the `count` is zero.
  final Distribution_Range? range;

  /// Defines the histogram bucket boundaries. If the distribution does not
  /// contain a histogram, then omit this field.
  final Distribution_BucketOptions? bucketOptions;

  /// The number of values in each bucket of the histogram, as described in
  /// `bucket_options`. If the distribution does not have a histogram, then omit
  /// this field. If there is a histogram, then the sum of the values in
  /// `bucket_counts` must equal the value in the `count` field of the
  /// distribution.
  ///
  /// If present, `bucket_counts` should contain N values, where N is the number
  /// of buckets specified in `bucket_options`. If you supply fewer than N
  /// values, the remaining values are assumed to be 0.
  ///
  /// The order of the values in `bucket_counts` follows the bucket numbering
  /// schemes described for the three bucket types. The first value must be the
  /// count for the underflow bucket (number 0). The next N-2 values are the
  /// counts for the finite buckets (number 1 through N-2). The N'th value in
  /// `bucket_counts` is the count for the overflow bucket (number N-1).
  final List<int>? bucketCounts;

  /// Must be in increasing order of `value` field.
  final List<Distribution_Exemplar>? exemplars;

  Distribution({
    this.count,
    this.mean,
    this.sumOfSquaredDeviation,
    this.range,
    this.bucketOptions,
    this.bucketCounts,
    this.exemplars,
  }) : super(fullyQualifiedName);

  factory Distribution.fromJson(Map<String, dynamic> json) {
    return Distribution(
      count: decodeInt64(json['count']),
      mean: decodeDouble(json['mean']),
      sumOfSquaredDeviation: decodeDouble(json['sumOfSquaredDeviation']),
      range: decode(json['range'], Distribution_Range.fromJson),
      bucketOptions:
          decode(json['bucketOptions'], Distribution_BucketOptions.fromJson),
      bucketCounts: decodeList(json['bucketCounts']),
      exemplars:
          decodeListMessage(json['exemplars'], Distribution_Exemplar.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (count != null) 'count': encodeInt64(count),
      if (mean != null) 'mean': encodeDouble(mean),
      if (sumOfSquaredDeviation != null)
        'sumOfSquaredDeviation': encodeDouble(sumOfSquaredDeviation),
      if (range != null) 'range': range!.toJson(),
      if (bucketOptions != null) 'bucketOptions': bucketOptions!.toJson(),
      if (bucketCounts != null) 'bucketCounts': bucketCounts,
      if (exemplars != null) 'exemplars': encodeList(exemplars),
    };
  }

  @override
  String toString() {
    final contents = [
      if (count != null) 'count=$count',
      if (mean != null) 'mean=$mean',
      if (sumOfSquaredDeviation != null)
        'sumOfSquaredDeviation=$sumOfSquaredDeviation',
    ].join(',');
    return 'Distribution($contents)';
  }
}

/// The range of the population values.
class Distribution_Range extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Distribution.Range';

  /// The minimum of the population values.
  final double? min;

  /// The maximum of the population values.
  final double? max;

  Distribution_Range({
    this.min,
    this.max,
  }) : super(fullyQualifiedName);

  factory Distribution_Range.fromJson(Map<String, dynamic> json) {
    return Distribution_Range(
      min: decodeDouble(json['min']),
      max: decodeDouble(json['max']),
    );
  }

  @override
  Object toJson() {
    return {
      if (min != null) 'min': encodeDouble(min),
      if (max != null) 'max': encodeDouble(max),
    };
  }

  @override
  String toString() {
    final contents = [
      if (min != null) 'min=$min',
      if (max != null) 'max=$max',
    ].join(',');
    return 'Range($contents)';
  }
}

/// `BucketOptions` describes the bucket boundaries used to create a histogram
/// for the distribution. The buckets can be in a linear sequence, an
/// exponential sequence, or each bucket can be specified explicitly.
/// `BucketOptions` does not include the number of values in each bucket.
///
/// A bucket has an inclusive lower bound and exclusive upper bound for the
/// values that are counted for that bucket. The upper bound of a bucket must
/// be strictly greater than the lower bound. The sequence of N buckets for a
/// distribution consists of an underflow bucket (number 0), zero or more
/// finite buckets (number 1 through N - 2) and an overflow bucket (number N -
/// 1). The buckets are contiguous: the lower bound of bucket i (i > 0) is the
/// same as the upper bound of bucket i - 1. The buckets span the whole range
/// of finite values: lower bound of the underflow bucket is -infinity and the
/// upper bound of the overflow bucket is +infinity. The finite buckets are
/// so-called because both bounds are finite.
class Distribution_BucketOptions extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.Distribution.BucketOptions';

  /// The linear bucket.
  final Distribution_BucketOptions_Linear? linearBuckets;

  /// The exponential buckets.
  final Distribution_BucketOptions_Exponential? exponentialBuckets;

  /// The explicit buckets.
  final Distribution_BucketOptions_Explicit? explicitBuckets;

  Distribution_BucketOptions({
    this.linearBuckets,
    this.exponentialBuckets,
    this.explicitBuckets,
  }) : super(fullyQualifiedName);

  factory Distribution_BucketOptions.fromJson(Map<String, dynamic> json) {
    return Distribution_BucketOptions(
      linearBuckets: decode(
          json['linearBuckets'], Distribution_BucketOptions_Linear.fromJson),
      exponentialBuckets: decode(json['exponentialBuckets'],
          Distribution_BucketOptions_Exponential.fromJson),
      explicitBuckets: decode(json['explicitBuckets'],
          Distribution_BucketOptions_Explicit.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (linearBuckets != null) 'linearBuckets': linearBuckets!.toJson(),
      if (exponentialBuckets != null)
        'exponentialBuckets': exponentialBuckets!.toJson(),
      if (explicitBuckets != null) 'explicitBuckets': explicitBuckets!.toJson(),
    };
  }

  @override
  String toString() => 'BucketOptions()';
}

/// Specifies a linear sequence of buckets that all have the same width
/// (except overflow and underflow). Each bucket represents a constant
/// absolute uncertainty on the specific value in the bucket.
///
/// There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the
/// following boundaries:
///
///    Upper bound (0 <= i < N-1):     offset + (width * i).
///
///    Lower bound (1 <= i < N):       offset + (width * (i - 1)).
class Distribution_BucketOptions_Linear extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.Distribution.BucketOptions.Linear';

  /// Must be greater than 0.
  final int? numFiniteBuckets;

  /// Must be greater than 0.
  final double? width;

  /// Lower bound of the first bucket.
  final double? offset;

  Distribution_BucketOptions_Linear({
    this.numFiniteBuckets,
    this.width,
    this.offset,
  }) : super(fullyQualifiedName);

  factory Distribution_BucketOptions_Linear.fromJson(
      Map<String, dynamic> json) {
    return Distribution_BucketOptions_Linear(
      numFiniteBuckets: json['numFiniteBuckets'],
      width: decodeDouble(json['width']),
      offset: decodeDouble(json['offset']),
    );
  }

  @override
  Object toJson() {
    return {
      if (numFiniteBuckets != null) 'numFiniteBuckets': numFiniteBuckets,
      if (width != null) 'width': encodeDouble(width),
      if (offset != null) 'offset': encodeDouble(offset),
    };
  }

  @override
  String toString() {
    final contents = [
      if (numFiniteBuckets != null) 'numFiniteBuckets=$numFiniteBuckets',
      if (width != null) 'width=$width',
      if (offset != null) 'offset=$offset',
    ].join(',');
    return 'Linear($contents)';
  }
}

/// Specifies an exponential sequence of buckets that have a width that is
/// proportional to the value of the lower bound. Each bucket represents a
/// constant relative uncertainty on a specific value in the bucket.
///
/// There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the
/// following boundaries:
///
///    Upper bound (0 <= i < N-1):     scale * (growth_factor ^ i).
///
///    Lower bound (1 <= i < N):       scale * (growth_factor ^ (i - 1)).
class Distribution_BucketOptions_Exponential extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.Distribution.BucketOptions.Exponential';

  /// Must be greater than 0.
  final int? numFiniteBuckets;

  /// Must be greater than 1.
  final double? growthFactor;

  /// Must be greater than 0.
  final double? scale;

  Distribution_BucketOptions_Exponential({
    this.numFiniteBuckets,
    this.growthFactor,
    this.scale,
  }) : super(fullyQualifiedName);

  factory Distribution_BucketOptions_Exponential.fromJson(
      Map<String, dynamic> json) {
    return Distribution_BucketOptions_Exponential(
      numFiniteBuckets: json['numFiniteBuckets'],
      growthFactor: decodeDouble(json['growthFactor']),
      scale: decodeDouble(json['scale']),
    );
  }

  @override
  Object toJson() {
    return {
      if (numFiniteBuckets != null) 'numFiniteBuckets': numFiniteBuckets,
      if (growthFactor != null) 'growthFactor': encodeDouble(growthFactor),
      if (scale != null) 'scale': encodeDouble(scale),
    };
  }

  @override
  String toString() {
    final contents = [
      if (numFiniteBuckets != null) 'numFiniteBuckets=$numFiniteBuckets',
      if (growthFactor != null) 'growthFactor=$growthFactor',
      if (scale != null) 'scale=$scale',
    ].join(',');
    return 'Exponential($contents)';
  }
}

/// Specifies a set of buckets with arbitrary widths.
///
/// There are `size(bounds) + 1` (= N) buckets. Bucket `i` has the following
/// boundaries:
///
///    Upper bound (0 <= i < N-1):     bounds[i]
///    Lower bound (1 <= i < N);       bounds[i - 1]
///
/// The `bounds` field must contain at least one element. If `bounds` has
/// only one element, then there are no finite buckets, and that single
/// element is the common boundary of the overflow and underflow buckets.
class Distribution_BucketOptions_Explicit extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.Distribution.BucketOptions.Explicit';

  /// The values must be monotonically increasing.
  final List<double>? bounds;

  Distribution_BucketOptions_Explicit({
    this.bounds,
  }) : super(fullyQualifiedName);

  factory Distribution_BucketOptions_Explicit.fromJson(
      Map<String, dynamic> json) {
    return Distribution_BucketOptions_Explicit(
      bounds: decodeList(json['bounds']),
    );
  }

  @override
  Object toJson() {
    return {
      if (bounds != null) 'bounds': bounds,
    };
  }

  @override
  String toString() => 'Explicit()';
}

/// Exemplars are example points that may be used to annotate aggregated
/// distribution values. They are metadata that gives information about a
/// particular value added to a Distribution bucket, such as a trace ID that
/// was active when a value was added. They may contain further information,
/// such as a example values and timestamps, origin, etc.
class Distribution_Exemplar extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Distribution.Exemplar';

  /// Value of the exemplar point. This value determines to which bucket the
  /// exemplar belongs.
  final double? value;

  /// The observation (sampling) time of the above value.
  final Timestamp? timestamp;

  /// Contextual information about the example value. Examples are:
  ///
  ///   Trace: type.googleapis.com/google.monitoring.v3.SpanContext
  ///
  ///   Literal string: type.googleapis.com/google.protobuf.StringValue
  ///
  ///   Labels dropped during aggregation:
  ///     type.googleapis.com/google.monitoring.v3.DroppedLabels
  ///
  /// There may be only a single attachment of any given message type in a
  /// single exemplar, and this is enforced by the system.
  final List<Any>? attachments;

  Distribution_Exemplar({
    this.value,
    this.timestamp,
    this.attachments,
  }) : super(fullyQualifiedName);

  factory Distribution_Exemplar.fromJson(Map<String, dynamic> json) {
    return Distribution_Exemplar(
      value: decodeDouble(json['value']),
      timestamp: decodeCustom(json['timestamp'], Timestamp.fromJson),
      attachments: decodeListMessage(json['attachments'], Any.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (value != null) 'value': encodeDouble(value),
      if (timestamp != null) 'timestamp': timestamp!.toJson(),
      if (attachments != null) 'attachments': encodeList(attachments),
    };
  }

  @override
  String toString() {
    final contents = [
      if (value != null) 'value=$value',
    ].join(',');
    return 'Exemplar($contents)';
  }
}

/// `Documentation` provides the information for describing a service.
///
/// Example:
/// <pre><code>documentation:
///   summary: >
///     The Google Calendar API gives access
///     to most calendar features.
///   pages:
///   - name: Overview
///     content: &#40;== include google/foo/overview.md ==&#41;
///   - name: Tutorial
///     content: &#40;== include google/foo/tutorial.md ==&#41;
///     subpages:
///     - name: Java
///       content: &#40;== include google/foo/tutorial_java.md ==&#41;
///   rules:
///   - selector: google.calendar.Calendar.Get
///     description: >
///       ...
///   - selector: google.calendar.Calendar.Put
///     description: >
///       ...
/// </code></pre>
/// Documentation is provided in markdown syntax. In addition to
/// standard markdown features, definition lists, tables and fenced
/// code blocks are supported. Section headers can be provided and are
/// interpreted relative to the section nesting of the context where
/// a documentation fragment is embedded.
///
/// Documentation from the IDL is merged with documentation defined
/// via the config at normalization time, where documentation provided
/// by config rules overrides IDL provided.
///
/// A number of constructs specific to the API platform are supported
/// in documentation text.
///
/// In order to reference a proto element, the following
/// notation can be used:
/// <pre><code>&#91;fully.qualified.proto.name]&#91;]</code></pre>
/// To override the display text used for the link, this can be used:
/// <pre><code>&#91;display text]&#91;fully.qualified.proto.name]</code></pre>
/// Text can be excluded from doc using the following notation:
/// <pre><code>&#40;-- internal comment --&#41;</code></pre>
///
/// A few directives are available in documentation. Note that
/// directives must appear on a single line to be properly
/// identified. The `include` directive includes a markdown file from
/// an external source:
/// <pre><code>&#40;== include path/to/file ==&#41;</code></pre>
/// The `resource_for` directive marks a message to be the resource of
/// a collection in REST view. If it is not specified, tools attempt
/// to infer the resource from the operations in a collection:
/// <pre><code>&#40;== resource_for v1.shelves.books ==&#41;</code></pre>
/// The directive `suppress_warning` does not directly affect documentation
/// and is documented together with service config validation.
class Documentation extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Documentation';

  /// A short description of what the service does. The summary must be plain
  /// text. It becomes the overview of the service displayed in Google Cloud
  /// Console.
  /// NOTE: This field is equivalent to the standard field `description`.
  final String? summary;

  /// The top level pages for the documentation set.
  final List<Page>? pages;

  /// A list of documentation rules that apply to individual API elements.
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<DocumentationRule>? rules;

  /// The URL to the root of documentation.
  final String? documentationRootUrl;

  /// Specifies the service root url if the default one (the service name
  /// from the yaml file) is not suitable. This can be seen in any fully
  /// specified service urls as well as sections that show a base that other
  /// urls are relative to.
  final String? serviceRootUrl;

  /// Declares a single overview page. For example:
  /// <pre><code>documentation:
  ///   summary: ...
  ///   overview: &#40;== include overview.md ==&#41;
  /// </code></pre>
  /// This is a shortcut for the following declaration (using pages style):
  /// <pre><code>documentation:
  ///   summary: ...
  ///   pages:
  ///   - name: Overview
  ///     content: &#40;== include overview.md ==&#41;
  /// </code></pre>
  /// Note: you cannot specify both `overview` field and `pages` field.
  final String? overview;

  Documentation({
    this.summary,
    this.pages,
    this.rules,
    this.documentationRootUrl,
    this.serviceRootUrl,
    this.overview,
  }) : super(fullyQualifiedName);

  factory Documentation.fromJson(Map<String, dynamic> json) {
    return Documentation(
      summary: json['summary'],
      pages: decodeListMessage(json['pages'], Page.fromJson),
      rules: decodeListMessage(json['rules'], DocumentationRule.fromJson),
      documentationRootUrl: json['documentationRootUrl'],
      serviceRootUrl: json['serviceRootUrl'],
      overview: json['overview'],
    );
  }

  @override
  Object toJson() {
    return {
      if (summary != null) 'summary': summary,
      if (pages != null) 'pages': encodeList(pages),
      if (rules != null) 'rules': encodeList(rules),
      if (documentationRootUrl != null)
        'documentationRootUrl': documentationRootUrl,
      if (serviceRootUrl != null) 'serviceRootUrl': serviceRootUrl,
      if (overview != null) 'overview': overview,
    };
  }

  @override
  String toString() {
    final contents = [
      if (summary != null) 'summary=$summary',
      if (documentationRootUrl != null)
        'documentationRootUrl=$documentationRootUrl',
      if (serviceRootUrl != null) 'serviceRootUrl=$serviceRootUrl',
      if (overview != null) 'overview=$overview',
    ].join(',');
    return 'Documentation($contents)';
  }
}

/// A documentation rule provides information about individual API elements.
class DocumentationRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.DocumentationRule';

  /// The selector is a comma-separated list of patterns for any element such as
  /// a method, a field, an enum value. Each pattern is a qualified name of the
  /// element which may end in "*", indicating a wildcard. Wildcards are only
  /// allowed at the end and for a whole component of the qualified name,
  /// i.e. "foo.*" is ok, but not "foo.b*" or "foo.*.bar". A wildcard will match
  /// one or more components. To specify a default for all applicable elements,
  /// the whole pattern "*" is used.
  final String? selector;

  /// Description of the selected proto element (e.g. a message, a method, a
  /// 'service' definition, or a field). Defaults to leading & trailing comments
  /// taken from the proto source definition of the proto element.
  final String? description;

  /// Deprecation description of the selected element(s). It can be provided if
  /// an element is marked as `deprecated`.
  final String? deprecationDescription;

  DocumentationRule({
    this.selector,
    this.description,
    this.deprecationDescription,
  }) : super(fullyQualifiedName);

  factory DocumentationRule.fromJson(Map<String, dynamic> json) {
    return DocumentationRule(
      selector: json['selector'],
      description: json['description'],
      deprecationDescription: json['deprecationDescription'],
    );
  }

  @override
  Object toJson() {
    return {
      if (selector != null) 'selector': selector,
      if (description != null) 'description': description,
      if (deprecationDescription != null)
        'deprecationDescription': deprecationDescription,
    };
  }

  @override
  String toString() {
    final contents = [
      if (selector != null) 'selector=$selector',
      if (description != null) 'description=$description',
      if (deprecationDescription != null)
        'deprecationDescription=$deprecationDescription',
    ].join(',');
    return 'DocumentationRule($contents)';
  }
}

/// Represents a documentation page. A page can contain subpages to represent
/// nested documentation set structure.
class Page extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Page';

  /// The name of the page. It will be used as an identity of the page to
  /// generate URI of the page, text of the link to this page in navigation,
  /// etc. The full page name (start from the root page name to this page
  /// concatenated with `.`) can be used as reference to the page in your
  /// documentation. For example:
  /// <pre><code>pages:
  /// - name: Tutorial
  ///   content: &#40;== include tutorial.md ==&#41;
  ///   subpages:
  ///   - name: Java
  ///     content: &#40;== include tutorial_java.md ==&#41;
  /// </code></pre>
  /// You can reference `Java` page using Markdown reference link syntax:
  /// ``Java``.
  final String? name;

  /// The Markdown content of the page. You can use ```(== include {path}
  /// ==)``` to include content from a Markdown file. The content can be used
  /// to produce the documentation page such as HTML format page.
  final String? content;

  /// Subpages of this page. The order of subpages specified here will be
  /// honored in the generated docset.
  final List<Page>? subpages;

  Page({
    this.name,
    this.content,
    this.subpages,
  }) : super(fullyQualifiedName);

  factory Page.fromJson(Map<String, dynamic> json) {
    return Page(
      name: json['name'],
      content: json['content'],
      subpages: decodeListMessage(json['subpages'], Page.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (content != null) 'content': content,
      if (subpages != null) 'subpages': encodeList(subpages),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (content != null) 'content=$content',
    ].join(',');
    return 'Page($contents)';
  }
}

/// `Endpoint` describes a network address of a service that serves a set of
/// APIs. It is commonly known as a service endpoint. A service may expose
/// any number of service endpoints, and all service endpoints share the same
/// service definition, such as quota limits and monitoring metrics.
///
/// Example:
///
///     type: google.api.Service
///     name: library-example.googleapis.com
///     endpoints:
///       # Declares network address `https://library-example.googleapis.com`
///       # for service `library-example.googleapis.com`. The `https` scheme
///       # is implicit for all service endpoints. Other schemes may be
///       # supported in the future.
///     - name: library-example.googleapis.com
///       allow_cors: false
///     - name: content-staging-library-example.googleapis.com
///       # Allows HTTP OPTIONS calls to be passed to the API frontend, for it
///       # to decide whether the subsequent cross-origin request is allowed
///       # to proceed.
///       allow_cors: true
class Endpoint extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Endpoint';

  /// The canonical name of this endpoint.
  final String? name;

  /// Aliases for this endpoint, these will be served by the same UrlMap as the
  /// parent endpoint, and will be provisioned in the GCP stack for the Regional
  /// Endpoints.
  final List<String>? aliases;

  /// The specification of an Internet routable address of API frontend that will
  /// handle requests to this [API
  /// Endpoint](https://cloud.google.com/apis/design/glossary). It should be
  /// either a valid IPv4 address or a fully-qualified domain name. For example,
  /// "8.8.8.8" or "myservice.appspot.com".
  final String? target;

  /// Allowing
  /// [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing), aka
  /// cross-domain traffic, would allow the backends served from this endpoint to
  /// receive and respond to HTTP OPTIONS requests. The response will be used by
  /// the browser to determine whether the subsequent cross-origin request is
  /// allowed to proceed.
  final bool? allowCors;

  Endpoint({
    this.name,
    this.aliases,
    this.target,
    this.allowCors,
  }) : super(fullyQualifiedName);

  factory Endpoint.fromJson(Map<String, dynamic> json) {
    return Endpoint(
      name: json['name'],
      aliases: decodeList(json['aliases']),
      target: json['target'],
      allowCors: json['allowCors'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (aliases != null) 'aliases': aliases,
      if (target != null) 'target': target,
      if (allowCors != null) 'allowCors': allowCors,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (target != null) 'target=$target',
      if (allowCors != null) 'allowCors=$allowCors',
    ].join(',');
    return 'Endpoint($contents)';
  }
}

/// Rich semantic information of an API field beyond basic typing.
class FieldInfo extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.FieldInfo';

  /// The standard format of a field value. This does not explicitly configure
  /// any API consumer, just documents the API's format for the field it is
  /// applied to.
  final FieldInfo_Format? format;

  /// The type(s) that the annotated, generic field may represent.
  ///
  /// Currently, this must only be used on fields of type `google.protobuf.Any`.
  /// Supporting other generic types may be considered in the future.
  final List<TypeReference>? referencedTypes;

  FieldInfo({
    this.format,
    this.referencedTypes,
  }) : super(fullyQualifiedName);

  factory FieldInfo.fromJson(Map<String, dynamic> json) {
    return FieldInfo(
      format: decodeEnum(json['format'], FieldInfo_Format.fromJson),
      referencedTypes:
          decodeListMessage(json['referencedTypes'], TypeReference.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (format != null) 'format': format!.toJson(),
      if (referencedTypes != null)
        'referencedTypes': encodeList(referencedTypes),
    };
  }

  @override
  String toString() {
    final contents = [
      if (format != null) 'format=$format',
    ].join(',');
    return 'FieldInfo($contents)';
  }
}

/// The standard format of a field value. The supported formats are all backed
/// by either an RFC defined by the IETF or a Google-defined AIP.
class FieldInfo_Format extends ProtoEnum {
  /// Default, unspecified value.
  static const formatUnspecified = FieldInfo_Format('FORMAT_UNSPECIFIED');

  /// Universally Unique Identifier, version 4, value as defined by
  /// https://datatracker.ietf.org/doc/html/rfc4122. The value may be
  /// normalized to entirely lowercase letters. For example, the value
  /// `F47AC10B-58CC-0372-8567-0E02B2C3D479` would be normalized to
  /// `f47ac10b-58cc-0372-8567-0e02b2c3d479`.
  static const uuid4 = FieldInfo_Format('UUID4');

  /// Internet Protocol v4 value as defined by [RFC
  /// 791](https://datatracker.ietf.org/doc/html/rfc791). The value may be
  /// condensed, with leading zeros in each octet stripped. For example,
  /// `001.022.233.040` would be condensed to `1.22.233.40`.
  static const ipv4 = FieldInfo_Format('IPV4');

  /// Internet Protocol v6 value as defined by [RFC
  /// 2460](https://datatracker.ietf.org/doc/html/rfc2460). The value may be
  /// normalized to entirely lowercase letters with zeros compressed, following
  /// [RFC 5952](https://datatracker.ietf.org/doc/html/rfc5952). For example,
  /// the value `2001:0DB8:0::0` would be normalized to `2001:db8::`.
  static const ipv6 = FieldInfo_Format('IPV6');

  /// An IP address in either v4 or v6 format as described by the individual
  /// values defined herein. See the comments on the IPV4 and IPV6 types for
  /// allowed normalizations of each.
  static const ipv4OrIpv6 = FieldInfo_Format('IPV4_OR_IPV6');

  const FieldInfo_Format(super.value);

  factory FieldInfo_Format.fromJson(String json) => FieldInfo_Format(json);

  @override
  String toString() => 'Format.$value';
}

/// A reference to a message type, for use in `FieldInfo`.
class TypeReference extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.TypeReference';

  /// The name of the type that the annotated, generic field may represent.
  /// If the type is in the same protobuf package, the value can be the simple
  /// message name e.g., `"MyMessage"`. Otherwise, the value must be the
  /// fully-qualified message name e.g., `"google.library.v1.Book"`.
  ///
  /// If the type(s) are unknown to the service (e.g. the field accepts generic
  /// user input), use the wildcard `"*"` to denote this behavior.
  ///
  /// See [AIP-202](https://google.aip.dev/202#type-references) for more details.
  final String? typeName;

  TypeReference({
    this.typeName,
  }) : super(fullyQualifiedName);

  factory TypeReference.fromJson(Map<String, dynamic> json) {
    return TypeReference(
      typeName: json['typeName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (typeName != null) 'typeName': typeName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (typeName != null) 'typeName=$typeName',
    ].join(',');
    return 'TypeReference($contents)';
  }
}

/// Defines the HTTP configuration for an API service. It contains a list of
/// `HttpRule`, each specifying the mapping of an RPC method
/// to one or more HTTP REST API methods.
class Http extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Http';

  /// A list of HTTP configuration rules that apply to individual API methods.
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<HttpRule>? rules;

  /// When set to true, URL path parameters will be fully URI-decoded except in
  /// cases of single segment matches in reserved expansion, where "%2F" will be
  /// left encoded.
  ///
  /// The default behavior is to not decode RFC 6570 reserved characters in multi
  /// segment matches.
  final bool? fullyDecodeReservedExpansion;

  Http({
    this.rules,
    this.fullyDecodeReservedExpansion,
  }) : super(fullyQualifiedName);

  factory Http.fromJson(Map<String, dynamic> json) {
    return Http(
      rules: decodeListMessage(json['rules'], HttpRule.fromJson),
      fullyDecodeReservedExpansion: json['fullyDecodeReservedExpansion'],
    );
  }

  @override
  Object toJson() {
    return {
      if (rules != null) 'rules': encodeList(rules),
      if (fullyDecodeReservedExpansion != null)
        'fullyDecodeReservedExpansion': fullyDecodeReservedExpansion,
    };
  }

  @override
  String toString() {
    final contents = [
      if (fullyDecodeReservedExpansion != null)
        'fullyDecodeReservedExpansion=$fullyDecodeReservedExpansion',
    ].join(',');
    return 'Http($contents)';
  }
}

/// gRPC Transcoding
///
/// gRPC Transcoding is a feature for mapping between a gRPC method and one or
/// more HTTP REST endpoints. It allows developers to build a single API service
/// that supports both gRPC APIs and REST APIs. Many systems, including [Google
/// APIs](https://github.com/googleapis/googleapis),
/// [Cloud Endpoints](https://cloud.google.com/endpoints), [gRPC
/// Gateway](https://github.com/grpc-ecosystem/grpc-gateway),
/// and [Envoy](https://github.com/envoyproxy/envoy) proxy support this feature
/// and use it for large scale production services.
///
/// `HttpRule` defines the schema of the gRPC/REST mapping. The mapping specifies
/// how different portions of the gRPC request message are mapped to the URL
/// path, URL query parameters, and HTTP request body. It also controls how the
/// gRPC response message is mapped to the HTTP response body. `HttpRule` is
/// typically specified as an `google.api.http` annotation on the gRPC method.
///
/// Each mapping specifies a URL path template and an HTTP method. The path
/// template may refer to one or more fields in the gRPC request message, as long
/// as each field is a non-repeated field with a primitive (non-message) type.
/// The path template controls how fields of the request message are mapped to
/// the URL path.
///
/// Example:
///
///     service Messaging {
///       rpc GetMessage(GetMessageRequest) returns (Message) {
///         option (google.api.http) = {
///             get: "/v1/{name=messages/*}"
///         };
///       }
///     }
///     message GetMessageRequest {
///       string name = 1; // Mapped to URL path.
///     }
///     message Message {
///       string text = 1; // The resource content.
///     }
///
/// This enables an HTTP REST to gRPC mapping as below:
///
/// - HTTP: `GET /v1/messages/123456`
/// - gRPC: `GetMessage(name: "messages/123456")`
///
/// Any fields in the request message which are not bound by the path template
/// automatically become HTTP query parameters if there is no HTTP request body.
/// For example:
///
///     service Messaging {
///       rpc GetMessage(GetMessageRequest) returns (Message) {
///         option (google.api.http) = {
///             get:"/v1/messages/{message_id}"
///         };
///       }
///     }
///     message GetMessageRequest {
///       message SubMessage {
///         string subfield = 1;
///       }
///       string message_id = 1; // Mapped to URL path.
///       int64 revision = 2;    // Mapped to URL query parameter `revision`.
///       SubMessage sub = 3;    // Mapped to URL query parameter `sub.subfield`.
///     }
///
/// This enables a HTTP JSON to RPC mapping as below:
///
/// - HTTP: `GET /v1/messages/123456?revision=2&sub.subfield=foo`
/// - gRPC: `GetMessage(message_id: "123456" revision: 2 sub:
/// SubMessage(subfield: "foo"))`
///
/// Note that fields which are mapped to URL query parameters must have a
/// primitive type or a repeated primitive type or a non-repeated message type.
/// In the case of a repeated type, the parameter can be repeated in the URL
/// as `...?param=A&param=B`. In the case of a message type, each field of the
/// message is mapped to a separate parameter, such as
/// `...?foo.a=A&foo.b=B&foo.c=C`.
///
/// For HTTP methods that allow a request body, the `body` field
/// specifies the mapping. Consider a REST update method on the
/// message resource collection:
///
///     service Messaging {
///       rpc UpdateMessage(UpdateMessageRequest) returns (Message) {
///         option (google.api.http) = {
///           patch: "/v1/messages/{message_id}"
///           body: "message"
///         };
///       }
///     }
///     message UpdateMessageRequest {
///       string message_id = 1; // mapped to the URL
///       Message message = 2;   // mapped to the body
///     }
///
/// The following HTTP JSON to RPC mapping is enabled, where the
/// representation of the JSON in the request body is determined by
/// protos JSON encoding:
///
/// - HTTP: `PATCH /v1/messages/123456 { "text": "Hi!" }`
/// - gRPC: `UpdateMessage(message_id: "123456" message { text: "Hi!" })`
///
/// The special name `*` can be used in the body mapping to define that
/// every field not bound by the path template should be mapped to the
/// request body.  This enables the following alternative definition of
/// the update method:
///
///     service Messaging {
///       rpc UpdateMessage(Message) returns (Message) {
///         option (google.api.http) = {
///           patch: "/v1/messages/{message_id}"
///           body: "*"
///         };
///       }
///     }
///     message Message {
///       string message_id = 1;
///       string text = 2;
///     }
///
///
/// The following HTTP JSON to RPC mapping is enabled:
///
/// - HTTP: `PATCH /v1/messages/123456 { "text": "Hi!" }`
/// - gRPC: `UpdateMessage(message_id: "123456" text: "Hi!")`
///
/// Note that when using `*` in the body mapping, it is not possible to
/// have HTTP parameters, as all fields not bound by the path end in
/// the body. This makes this option more rarely used in practice when
/// defining REST APIs. The common usage of `*` is in custom methods
/// which don't use the URL at all for transferring data.
///
/// It is possible to define multiple HTTP methods for one RPC by using
/// the `additional_bindings` option. Example:
///
///     service Messaging {
///       rpc GetMessage(GetMessageRequest) returns (Message) {
///         option (google.api.http) = {
///           get: "/v1/messages/{message_id}"
///           additional_bindings {
///             get: "/v1/users/{user_id}/messages/{message_id}"
///           }
///         };
///       }
///     }
///     message GetMessageRequest {
///       string message_id = 1;
///       string user_id = 2;
///     }
///
/// This enables the following two alternative HTTP JSON to RPC mappings:
///
/// - HTTP: `GET /v1/messages/123456`
/// - gRPC: `GetMessage(message_id: "123456")`
///
/// - HTTP: `GET /v1/users/me/messages/123456`
/// - gRPC: `GetMessage(user_id: "me" message_id: "123456")`
///
/// Rules for HTTP mapping
///
/// 1. Leaf request fields (recursive expansion nested messages in the request
///    message) are classified into three categories:
///    - Fields referred by the path template. They are passed via the URL path.
///    - Fields referred by the `HttpRule.body`. They
///    are passed via the HTTP
///      request body.
///    - All other fields are passed via the URL query parameters, and the
///      parameter name is the field path in the request message. A repeated
///      field can be represented as multiple query parameters under the same
///      name.
///  2. If `HttpRule.body` is "*", there is no URL
///  query parameter, all fields
///     are passed via URL path and HTTP request body.
///  3. If `HttpRule.body` is omitted, there is no HTTP
///  request body, all
///     fields are passed via URL path and URL query parameters.
///
/// Path template syntax
///
///     Template = "/" Segments [ Verb ] ;
///     Segments = Segment { "/" Segment } ;
///     Segment  = "*" | "**" | LITERAL | Variable ;
///     Variable = "{" FieldPath [ "=" Segments ] "}" ;
///     FieldPath = IDENT { "." IDENT } ;
///     Verb     = ":" LITERAL ;
///
/// The syntax `*` matches a single URL path segment. The syntax `**` matches
/// zero or more URL path segments, which must be the last part of the URL path
/// except the `Verb`.
///
/// The syntax `Variable` matches part of the URL path as specified by its
/// template. A variable template must not contain other variables. If a variable
/// matches a single path segment, its template may be omitted, e.g. `{var}`
/// is equivalent to `{var=*}`.
///
/// The syntax `LITERAL` matches literal text in the URL path. If the `LITERAL`
/// contains any reserved character, such characters should be percent-encoded
/// before the matching.
///
/// If a variable contains exactly one path segment, such as `"{var}"` or
/// `"{var=*}"`, when such a variable is expanded into a URL path on the client
/// side, all characters except `[-_.~0-9a-zA-Z]` are percent-encoded. The
/// server side does the reverse decoding. Such variables show up in the
/// [Discovery
/// Document](https://developers.google.com/discovery/v1/reference/apis) as
/// `{var}`.
///
/// If a variable contains multiple path segments, such as `"{var=foo/*}"`
/// or `"{var=**}"`, when such a variable is expanded into a URL path on the
/// client side, all characters except `[-_.~/0-9a-zA-Z]` are percent-encoded.
/// The server side does the reverse decoding, except "%2F" and "%2f" are left
/// unchanged. Such variables show up in the
/// [Discovery
/// Document](https://developers.google.com/discovery/v1/reference/apis) as
/// `{+var}`.
///
/// Using gRPC API Service Configuration
///
/// gRPC API Service Configuration (service config) is a configuration language
/// for configuring a gRPC service to become a user-facing product. The
/// service config is simply the YAML representation of the `google.api.Service`
/// proto message.
///
/// As an alternative to annotating your proto file, you can configure gRPC
/// transcoding in your service config YAML files. You do this by specifying a
/// `HttpRule` that maps the gRPC method to a REST endpoint, achieving the same
/// effect as the proto annotation. This can be particularly useful if you
/// have a proto that is reused in multiple services. Note that any transcoding
/// specified in the service config will override any matching transcoding
/// configuration in the proto.
///
/// The following example selects a gRPC method and applies an `HttpRule` to it:
///
///     http:
///       rules:
///         - selector: example.v1.Messaging.GetMessage
///           get: /v1/messages/{message_id}/{sub.subfield}
///
/// Special notes
///
/// When gRPC Transcoding is used to map a gRPC to JSON REST endpoints, the
/// proto to JSON conversion must follow the [proto3
/// specification](https://developers.google.com/protocol-buffers/docs/proto3#json).
///
/// While the single segment variable follows the semantics of
/// [RFC 6570](https://tools.ietf.org/html/rfc6570) Section 3.2.2 Simple String
/// Expansion, the multi segment variable **does not** follow RFC 6570 Section
/// 3.2.3 Reserved Expansion. The reason is that the Reserved Expansion
/// does not expand special characters like `?` and `#`, which would lead
/// to invalid URLs. As the result, gRPC Transcoding uses a custom encoding
/// for multi segment variables.
///
/// The path variables **must not** refer to any repeated or mapped field,
/// because client libraries are not capable of handling such variable expansion.
///
/// The path variables **must not** capture the leading "/" character. The reason
/// is that the most common use case "{var}" does not capture the leading "/"
/// character. For consistency, all path variables must share the same behavior.
///
/// Repeated message fields must not be mapped to URL query parameters, because
/// no client library can support such complicated mapping.
///
/// If an API needs to use a JSON array for request or response body, it can map
/// the request or response body to a repeated field. However, some gRPC
/// Transcoding implementations may not support this feature.
class HttpRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.HttpRule';

  /// Selects a method to which this rule applies.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String? selector;

  /// Maps to HTTP GET. Used for listing and getting information about
  /// resources.
  final String? get;

  /// Maps to HTTP PUT. Used for replacing a resource.
  final String? put;

  /// Maps to HTTP POST. Used for creating a resource or performing an action.
  final String? post;

  /// Maps to HTTP DELETE. Used for deleting a resource.
  final String? delete;

  /// Maps to HTTP PATCH. Used for updating a resource.
  final String? patch;

  /// The custom pattern is used for specifying an HTTP method that is not
  /// included in the `pattern` field, such as HEAD, or "*" to leave the
  /// HTTP method unspecified for this rule. The wild-card rule is useful
  /// for services that provide content to Web (HTML) clients.
  final CustomHttpPattern? custom;

  /// The name of the request field whose value is mapped to the HTTP request
  /// body, or `*` for mapping all request fields not captured by the path
  /// pattern to the HTTP body, or omitted for not having any HTTP request body.
  ///
  /// NOTE: the referred field must be present at the top-level of the request
  /// message type.
  final String? body;

  /// Optional. The name of the response field whose value is mapped to the HTTP
  /// response body. When omitted, the entire response message will be used
  /// as the HTTP response body.
  ///
  /// NOTE: The referred field must be present at the top-level of the response
  /// message type.
  final String? responseBody;

  /// Additional HTTP bindings for the selector. Nested bindings must
  /// not contain an `additional_bindings` field themselves (that is,
  /// the nesting may only be one level deep).
  final List<HttpRule>? additionalBindings;

  HttpRule({
    this.selector,
    this.get,
    this.put,
    this.post,
    this.delete,
    this.patch,
    this.custom,
    this.body,
    this.responseBody,
    this.additionalBindings,
  }) : super(fullyQualifiedName);

  factory HttpRule.fromJson(Map<String, dynamic> json) {
    return HttpRule(
      selector: json['selector'],
      get: json['get'],
      put: json['put'],
      post: json['post'],
      delete: json['delete'],
      patch: json['patch'],
      custom: decode(json['custom'], CustomHttpPattern.fromJson),
      body: json['body'],
      responseBody: json['responseBody'],
      additionalBindings:
          decodeListMessage(json['additionalBindings'], HttpRule.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (selector != null) 'selector': selector,
      if (get != null) 'get': get,
      if (put != null) 'put': put,
      if (post != null) 'post': post,
      if (delete != null) 'delete': delete,
      if (patch != null) 'patch': patch,
      if (custom != null) 'custom': custom!.toJson(),
      if (body != null) 'body': body,
      if (responseBody != null) 'responseBody': responseBody,
      if (additionalBindings != null)
        'additionalBindings': encodeList(additionalBindings),
    };
  }

  @override
  String toString() {
    final contents = [
      if (selector != null) 'selector=$selector',
      if (get != null) 'get=$get',
      if (put != null) 'put=$put',
      if (post != null) 'post=$post',
      if (delete != null) 'delete=$delete',
      if (patch != null) 'patch=$patch',
      if (body != null) 'body=$body',
      if (responseBody != null) 'responseBody=$responseBody',
    ].join(',');
    return 'HttpRule($contents)';
  }
}

/// A custom pattern is used for defining custom HTTP verb.
class CustomHttpPattern extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.CustomHttpPattern';

  /// The name of this custom HTTP verb.
  final String? kind;

  /// The path matched by this custom verb.
  final String? path;

  CustomHttpPattern({
    this.kind,
    this.path,
  }) : super(fullyQualifiedName);

  factory CustomHttpPattern.fromJson(Map<String, dynamic> json) {
    return CustomHttpPattern(
      kind: json['kind'],
      path: json['path'],
    );
  }

  @override
  Object toJson() {
    return {
      if (kind != null) 'kind': kind,
      if (path != null) 'path': path,
    };
  }

  @override
  String toString() {
    final contents = [
      if (kind != null) 'kind=$kind',
      if (path != null) 'path=$path',
    ].join(',');
    return 'CustomHttpPattern($contents)';
  }
}

/// Message that represents an arbitrary HTTP body. It should only be used for
/// payload formats that can't be represented as JSON, such as raw binary or
/// an HTML page.
///
///
/// This message can be used both in streaming and non-streaming API methods in
/// the request as well as the response.
///
/// It can be used as a top-level request field, which is convenient if one
/// wants to extract parameters from either the URL or HTTP template into the
/// request fields and also want access to the raw HTTP body.
///
/// Example:
///
///     message GetResourceRequest {
///       // A unique request id.
///       string request_id = 1;
///
///       // The raw HTTP body is bound to this field.
///       google.api.HttpBody http_body = 2;
///
///     }
///
///     service ResourceService {
///       rpc GetResource(GetResourceRequest)
///         returns (google.api.HttpBody);
///       rpc UpdateResource(google.api.HttpBody)
///         returns (google.protobuf.Empty);
///
///     }
///
/// Example with streaming methods:
///
///     service CaldavService {
///       rpc GetCalendar(stream google.api.HttpBody)
///         returns (stream google.api.HttpBody);
///       rpc UpdateCalendar(stream google.api.HttpBody)
///         returns (stream google.api.HttpBody);
///
///     }
///
/// Use of this type only changes how the request and response bodies are
/// handled, all other features will continue to work unchanged.
class HttpBody extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.HttpBody';

  /// The HTTP Content-Type header value specifying the content type of the body.
  final String? contentType;

  /// The HTTP request/response body as raw binary.
  final Uint8List? data;

  /// Application specific response metadata. Must be set in the first response
  /// for streaming APIs.
  final List<Any>? extensions;

  HttpBody({
    this.contentType,
    this.data,
    this.extensions,
  }) : super(fullyQualifiedName);

  factory HttpBody.fromJson(Map<String, dynamic> json) {
    return HttpBody(
      contentType: json['contentType'],
      data: decodeBytes(json['data']),
      extensions: decodeListMessage(json['extensions'], Any.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (contentType != null) 'contentType': contentType,
      if (data != null) 'data': encodeBytes(data),
      if (extensions != null) 'extensions': encodeList(extensions),
    };
  }

  @override
  String toString() {
    final contents = [
      if (contentType != null) 'contentType=$contentType',
      if (data != null) 'data=$data',
    ].join(',');
    return 'HttpBody($contents)';
  }
}

/// A description of a label.
class LabelDescriptor extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.LabelDescriptor';

  /// The label key.
  final String? key;

  /// The type of data that can be assigned to the label.
  final LabelDescriptor_ValueType? valueType;

  /// A human-readable description for the label.
  final String? description;

  LabelDescriptor({
    this.key,
    this.valueType,
    this.description,
  }) : super(fullyQualifiedName);

  factory LabelDescriptor.fromJson(Map<String, dynamic> json) {
    return LabelDescriptor(
      key: json['key'],
      valueType:
          decodeEnum(json['valueType'], LabelDescriptor_ValueType.fromJson),
      description: json['description'],
    );
  }

  @override
  Object toJson() {
    return {
      if (key != null) 'key': key,
      if (valueType != null) 'valueType': valueType!.toJson(),
      if (description != null) 'description': description,
    };
  }

  @override
  String toString() {
    final contents = [
      if (key != null) 'key=$key',
      if (valueType != null) 'valueType=$valueType',
      if (description != null) 'description=$description',
    ].join(',');
    return 'LabelDescriptor($contents)';
  }
}

/// Value types that can be used as label values.
class LabelDescriptor_ValueType extends ProtoEnum {
  /// A variable-length string. This is the default.
  static const string = LabelDescriptor_ValueType('STRING');

  /// Boolean; true or false.
  static const bool = LabelDescriptor_ValueType('BOOL');

  /// A 64-bit signed integer.
  static const int64 = LabelDescriptor_ValueType('INT64');

  const LabelDescriptor_ValueType(super.value);

  factory LabelDescriptor_ValueType.fromJson(String json) =>
      LabelDescriptor_ValueType(json);

  @override
  String toString() => 'ValueType.$value';
}

/// A description of a log type. Example in YAML format:
///
///     - name: library.googleapis.com/activity_history
///       description: The history of borrowing and returning library items.
///       display_name: Activity
///       labels:
///       - key: /customer_id
///         description: Identifier of a library customer
class LogDescriptor extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.LogDescriptor';

  /// The name of the log. It must be less than 512 characters long and can
  /// include the following characters: upper- and lower-case alphanumeric
  /// characters [A-Za-z0-9], and punctuation characters including
  /// slash, underscore, hyphen, period [/_-.].
  final String? name;

  /// The set of labels that are available to describe a specific log entry.
  /// Runtime requests that contain labels not specified here are
  /// considered invalid.
  final List<LabelDescriptor>? labels;

  /// A human-readable description of this log. This information appears in
  /// the documentation and can contain details.
  final String? description;

  /// The human-readable name for this log. This information appears on
  /// the user interface and should be concise.
  final String? displayName;

  LogDescriptor({
    this.name,
    this.labels,
    this.description,
    this.displayName,
  }) : super(fullyQualifiedName);

  factory LogDescriptor.fromJson(Map<String, dynamic> json) {
    return LogDescriptor(
      name: json['name'],
      labels: decodeListMessage(json['labels'], LabelDescriptor.fromJson),
      description: json['description'],
      displayName: json['displayName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (labels != null) 'labels': encodeList(labels),
      if (description != null) 'description': description,
      if (displayName != null) 'displayName': displayName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (description != null) 'description=$description',
      if (displayName != null) 'displayName=$displayName',
    ].join(',');
    return 'LogDescriptor($contents)';
  }
}

/// Logging configuration of the service.
///
/// The following example shows how to configure logs to be sent to the
/// producer and consumer projects. In the example, the `activity_history`
/// log is sent to both the producer and consumer projects, whereas the
/// `purchase_history` log is only sent to the producer project.
///
///     monitored_resources:
///     - type: library.googleapis.com/branch
///       labels:
///       - key: /city
///         description: The city where the library branch is located in.
///       - key: /name
///         description: The name of the branch.
///     logs:
///     - name: activity_history
///       labels:
///       - key: /customer_id
///     - name: purchase_history
///     logging:
///       producer_destinations:
///       - monitored_resource: library.googleapis.com/branch
///         logs:
///         - activity_history
///         - purchase_history
///       consumer_destinations:
///       - monitored_resource: library.googleapis.com/branch
///         logs:
///         - activity_history
class Logging extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Logging';

  /// Logging configurations for sending logs to the producer project.
  /// There can be multiple producer destinations, each one must have a
  /// different monitored resource type. A log can be used in at most
  /// one producer destination.
  final List<Logging_LoggingDestination>? producerDestinations;

  /// Logging configurations for sending logs to the consumer project.
  /// There can be multiple consumer destinations, each one must have a
  /// different monitored resource type. A log can be used in at most
  /// one consumer destination.
  final List<Logging_LoggingDestination>? consumerDestinations;

  Logging({
    this.producerDestinations,
    this.consumerDestinations,
  }) : super(fullyQualifiedName);

  factory Logging.fromJson(Map<String, dynamic> json) {
    return Logging(
      producerDestinations: decodeListMessage(
          json['producerDestinations'], Logging_LoggingDestination.fromJson),
      consumerDestinations: decodeListMessage(
          json['consumerDestinations'], Logging_LoggingDestination.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (producerDestinations != null)
        'producerDestinations': encodeList(producerDestinations),
      if (consumerDestinations != null)
        'consumerDestinations': encodeList(consumerDestinations),
    };
  }

  @override
  String toString() => 'Logging()';
}

/// Configuration of a specific logging destination (the producer project
/// or the consumer project).
class Logging_LoggingDestination extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.Logging.LoggingDestination';

  /// The monitored resource type. The type must be defined in the
  /// `Service.monitored_resources`
  /// section.
  final String? monitoredResource;

  /// Names of the logs to be sent to this destination. Each name must
  /// be defined in the `Service.logs` section. If the
  /// log name is not a domain scoped name, it will be automatically prefixed
  /// with the service name followed by "/".
  final List<String>? logs;

  Logging_LoggingDestination({
    this.monitoredResource,
    this.logs,
  }) : super(fullyQualifiedName);

  factory Logging_LoggingDestination.fromJson(Map<String, dynamic> json) {
    return Logging_LoggingDestination(
      monitoredResource: json['monitoredResource'],
      logs: decodeList(json['logs']),
    );
  }

  @override
  Object toJson() {
    return {
      if (monitoredResource != null) 'monitoredResource': monitoredResource,
      if (logs != null) 'logs': logs,
    };
  }

  @override
  String toString() {
    final contents = [
      if (monitoredResource != null) 'monitoredResource=$monitoredResource',
    ].join(',');
    return 'LoggingDestination($contents)';
  }
}

/// Defines a metric type and its schema. Once a metric descriptor is created,
/// deleting or altering it stops data collection and makes the metric type's
/// existing data unusable.
class MetricDescriptor extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.MetricDescriptor';

  /// The resource name of the metric descriptor.
  final String? name;

  /// The metric type, including its DNS name prefix. The type is not
  /// URL-encoded. All user-defined metric types have the DNS name
  /// `custom.googleapis.com` or `external.googleapis.com`. Metric types should
  /// use a natural hierarchical grouping. For example:
  ///
  ///     "custom.googleapis.com/invoice/paid/amount"
  ///     "external.googleapis.com/prometheus/up"
  ///     "appengine.googleapis.com/http/server/response_latencies"
  final String? type;

  /// The set of labels that can be used to describe a specific
  /// instance of this metric type. For example, the
  /// `appengine.googleapis.com/http/server/response_latencies` metric
  /// type has a label for the HTTP response code, `response_code`, so
  /// you can look at latencies for successful responses or just
  /// for responses that failed.
  final List<LabelDescriptor>? labels;

  /// Whether the metric records instantaneous values, changes to a value, etc.
  /// Some combinations of `metric_kind` and `value_type` might not be supported.
  final MetricDescriptor_MetricKind? metricKind;

  /// Whether the measurement is an integer, a floating-point number, etc.
  /// Some combinations of `metric_kind` and `value_type` might not be supported.
  final MetricDescriptor_ValueType? valueType;

  /// The units in which the metric value is reported. It is only applicable
  /// if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The `unit`
  /// defines the representation of the stored metric values.
  ///
  /// Different systems might scale the values to be more easily displayed (so a
  /// value of `0.02kBy` _might_ be displayed as `20By`, and a value of
  /// `3523kBy` _might_ be displayed as `3.5MBy`). However, if the `unit` is
  /// `kBy`, then the value of the metric is always in thousands of bytes, no
  /// matter how it might be displayed.
  ///
  /// If you want a custom metric to record the exact number of CPU-seconds used
  /// by a job, you can create an `INT64 CUMULATIVE` metric whose `unit` is
  /// `s{CPU}` (or equivalently `1s{CPU}` or just `s`). If the job uses 12,005
  /// CPU-seconds, then the value is written as `12005`.
  ///
  /// Alternatively, if you want a custom metric to record data in a more
  /// granular way, you can create a `DOUBLE CUMULATIVE` metric whose `unit` is
  /// `ks{CPU}`, and then write the value `12.005` (which is `12005/1000`),
  /// or use `Kis{CPU}` and write `11.723` (which is `12005/1024`).
  ///
  /// The supported units are a subset of [The Unified Code for Units of
  /// Measure](https://unitsofmeasure.org/ucum.html) standard:
  ///
  /// **Basic units (UNIT)**
  ///
  /// * `bit`   bit
  /// * `By`    byte
  /// * `s`     second
  /// * `min`   minute
  /// * `h`     hour
  /// * `d`     day
  /// * `1`     dimensionless
  ///
  /// **Prefixes (PREFIX)**
  ///
  /// * `k`     kilo    (10^3)
  /// * `M`     mega    (10^6)
  /// * `G`     giga    (10^9)
  /// * `T`     tera    (10^12)
  /// * `P`     peta    (10^15)
  /// * `E`     exa     (10^18)
  /// * `Z`     zetta   (10^21)
  /// * `Y`     yotta   (10^24)
  ///
  /// * `m`     milli   (10^-3)
  /// * `u`     micro   (10^-6)
  /// * `n`     nano    (10^-9)
  /// * `p`     pico    (10^-12)
  /// * `f`     femto   (10^-15)
  /// * `a`     atto    (10^-18)
  /// * `z`     zepto   (10^-21)
  /// * `y`     yocto   (10^-24)
  ///
  /// * `Ki`    kibi    (2^10)
  /// * `Mi`    mebi    (2^20)
  /// * `Gi`    gibi    (2^30)
  /// * `Ti`    tebi    (2^40)
  /// * `Pi`    pebi    (2^50)
  ///
  /// **Grammar**
  ///
  /// The grammar also includes these connectors:
  ///
  /// * `/`    division or ratio (as an infix operator). For examples,
  ///          `kBy/{email}` or `MiBy/10ms` (although you should almost never
  ///          have `/s` in a metric `unit`; rates should always be computed at
  ///          query time from the underlying cumulative or delta value).
  /// * `.`    multiplication or composition (as an infix operator). For
  ///          examples, `GBy.d` or `k{watt}.h`.
  ///
  /// The grammar for a unit is as follows:
  ///
  ///     Expression = Component { "." Component } { "/" Component } ;
  ///
  ///     Component = ( [ PREFIX ] UNIT | "%" ) [ Annotation ]
  ///               | Annotation
  ///               | "1"
  ///               ;
  ///
  ///     Annotation = "{" NAME "}" ;
  ///
  /// Notes:
  ///
  /// * `Annotation` is just a comment if it follows a `UNIT`. If the annotation
  ///    is used alone, then the unit is equivalent to `1`. For examples,
  ///    `{request}/s == 1/s`, `By{transmitted}/s == By/s`.
  /// * `NAME` is a sequence of non-blank printable ASCII characters not
  ///    containing `{` or `}`.
  /// * `1` represents a unitary [dimensionless
  ///    unit](https://en.wikipedia.org/wiki/Dimensionless_quantity) of 1, such
  ///    as in `1/s`. It is typically used when none of the basic units are
  ///    appropriate. For example, "new users per day" can be represented as
  ///    `1/d` or `{new-users}/d` (and a metric value `5` would mean "5 new
  ///    users). Alternatively, "thousands of page views per day" would be
  ///    represented as `1000/d` or `k1/d` or `k{page_views}/d` (and a metric
  ///    value of `5.3` would mean "5300 page views per day").
  /// * `%` represents dimensionless value of 1/100, and annotates values giving
  ///    a percentage (so the metric values are typically in the range of 0..100,
  ///    and a metric value `3` means "3 percent").
  /// * `10^2.%` indicates a metric contains a ratio, typically in the range
  ///    0..1, that will be multiplied by 100 and displayed as a percentage
  ///    (so a metric value `0.03` means "3 percent").
  final String? unit;

  /// A detailed description of the metric, which can be used in documentation.
  final String? description;

  /// A concise name for the metric, which can be displayed in user interfaces.
  /// Use sentence case without an ending period, for example "Request count".
  /// This field is optional but it is recommended to be set for any metrics
  /// associated with user-visible concepts, such as Quota.
  final String? displayName;

  /// Optional. Metadata which can be used to guide usage of the metric.
  final MetricDescriptor_MetricDescriptorMetadata? metadata;

  /// Optional. The launch stage of the metric definition.
  final LaunchStage? launchStage;

  /// Read-only. If present, then a [time
  /// series][google.monitoring.v3.TimeSeries], which is identified partially by
  /// a metric type and a
  /// `MonitoredResourceDescriptor`, that
  /// is associated with this metric type can only be associated with one of the
  /// monitored resource types listed here.
  final List<String>? monitoredResourceTypes;

  MetricDescriptor({
    this.name,
    this.type,
    this.labels,
    this.metricKind,
    this.valueType,
    this.unit,
    this.description,
    this.displayName,
    this.metadata,
    this.launchStage,
    this.monitoredResourceTypes,
  }) : super(fullyQualifiedName);

  factory MetricDescriptor.fromJson(Map<String, dynamic> json) {
    return MetricDescriptor(
      name: json['name'],
      type: json['type'],
      labels: decodeListMessage(json['labels'], LabelDescriptor.fromJson),
      metricKind:
          decodeEnum(json['metricKind'], MetricDescriptor_MetricKind.fromJson),
      valueType:
          decodeEnum(json['valueType'], MetricDescriptor_ValueType.fromJson),
      unit: json['unit'],
      description: json['description'],
      displayName: json['displayName'],
      metadata: decode(
          json['metadata'], MetricDescriptor_MetricDescriptorMetadata.fromJson),
      launchStage: decodeEnum(json['launchStage'], LaunchStage.fromJson),
      monitoredResourceTypes: decodeList(json['monitoredResourceTypes']),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (type != null) 'type': type,
      if (labels != null) 'labels': encodeList(labels),
      if (metricKind != null) 'metricKind': metricKind!.toJson(),
      if (valueType != null) 'valueType': valueType!.toJson(),
      if (unit != null) 'unit': unit,
      if (description != null) 'description': description,
      if (displayName != null) 'displayName': displayName,
      if (metadata != null) 'metadata': metadata!.toJson(),
      if (launchStage != null) 'launchStage': launchStage!.toJson(),
      if (monitoredResourceTypes != null)
        'monitoredResourceTypes': monitoredResourceTypes,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (type != null) 'type=$type',
      if (metricKind != null) 'metricKind=$metricKind',
      if (valueType != null) 'valueType=$valueType',
      if (unit != null) 'unit=$unit',
      if (description != null) 'description=$description',
      if (displayName != null) 'displayName=$displayName',
      if (launchStage != null) 'launchStage=$launchStage',
    ].join(',');
    return 'MetricDescriptor($contents)';
  }
}

/// Additional annotations that can be used to guide the usage of a metric.
class MetricDescriptor_MetricDescriptorMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.MetricDescriptor.MetricDescriptorMetadata';

  /// Deprecated. Must use the
  /// `MetricDescriptor.launch_stage`
  /// instead.
  final LaunchStage? launchStage;

  /// The sampling period of metric data points. For metrics which are written
  /// periodically, consecutive data points are stored at this time interval,
  /// excluding data loss due to errors. Metrics with a higher granularity have
  /// a smaller sampling period.
  final Duration? samplePeriod;

  /// The delay of data points caused by ingestion. Data points older than this
  /// age are guaranteed to be ingested and available to be read, excluding
  /// data loss due to errors.
  final Duration? ingestDelay;

  /// The scope of the timeseries data of the metric.
  final List<
          MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel>?
      timeSeriesResourceHierarchyLevel;

  MetricDescriptor_MetricDescriptorMetadata({
    this.launchStage,
    this.samplePeriod,
    this.ingestDelay,
    this.timeSeriesResourceHierarchyLevel,
  }) : super(fullyQualifiedName);

  factory MetricDescriptor_MetricDescriptorMetadata.fromJson(
      Map<String, dynamic> json) {
    return MetricDescriptor_MetricDescriptorMetadata(
      launchStage: decodeEnum(json['launchStage'], LaunchStage.fromJson),
      samplePeriod: decodeCustom(json['samplePeriod'], Duration.fromJson),
      ingestDelay: decodeCustom(json['ingestDelay'], Duration.fromJson),
      timeSeriesResourceHierarchyLevel: decodeListEnum(
          json['timeSeriesResourceHierarchyLevel'],
          MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel
              .fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (launchStage != null) 'launchStage': launchStage!.toJson(),
      if (samplePeriod != null) 'samplePeriod': samplePeriod!.toJson(),
      if (ingestDelay != null) 'ingestDelay': ingestDelay!.toJson(),
      if (timeSeriesResourceHierarchyLevel != null)
        'timeSeriesResourceHierarchyLevel':
            encodeList(timeSeriesResourceHierarchyLevel),
    };
  }

  @override
  String toString() {
    final contents = [
      if (launchStage != null) 'launchStage=$launchStage',
    ].join(',');
    return 'MetricDescriptorMetadata($contents)';
  }
}

/// The resource hierarchy level of the timeseries data of a metric.
class MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel
    extends ProtoEnum {
  /// Do not use this default value.
  static const timeSeriesResourceHierarchyLevelUnspecified =
      MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel(
          'TIME_SERIES_RESOURCE_HIERARCHY_LEVEL_UNSPECIFIED');

  /// Scopes a metric to a project.
  static const project =
      MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel(
          'PROJECT');

  /// Scopes a metric to an organization.
  static const organization =
      MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel(
          'ORGANIZATION');

  /// Scopes a metric to a folder.
  static const folder =
      MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel(
          'FOLDER');

  const MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel(
      super.value);

  factory MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel.fromJson(
          String json) =>
      MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel(
          json);

  @override
  String toString() => 'TimeSeriesResourceHierarchyLevel.$value';
}

/// The kind of measurement. It describes how the data is reported.
/// For information on setting the start time and end time based on
/// the MetricKind, see `TimeInterval`.
class MetricDescriptor_MetricKind extends ProtoEnum {
  /// Do not use this default value.
  static const metricKindUnspecified =
      MetricDescriptor_MetricKind('METRIC_KIND_UNSPECIFIED');

  /// An instantaneous measurement of a value.
  static const gauge = MetricDescriptor_MetricKind('GAUGE');

  /// The change in a value during a time interval.
  static const delta = MetricDescriptor_MetricKind('DELTA');

  /// A value accumulated over a time interval.  Cumulative
  /// measurements in a time series should have the same start time
  /// and increasing end times, until an event resets the cumulative
  /// value to zero and sets a new start time for the following
  /// points.
  static const cumulative = MetricDescriptor_MetricKind('CUMULATIVE');

  const MetricDescriptor_MetricKind(super.value);

  factory MetricDescriptor_MetricKind.fromJson(String json) =>
      MetricDescriptor_MetricKind(json);

  @override
  String toString() => 'MetricKind.$value';
}

/// The value type of a metric.
class MetricDescriptor_ValueType extends ProtoEnum {
  /// Do not use this default value.
  static const valueTypeUnspecified =
      MetricDescriptor_ValueType('VALUE_TYPE_UNSPECIFIED');

  /// The value is a boolean.
  /// This value type can be used only if the metric kind is `GAUGE`.
  static const bool = MetricDescriptor_ValueType('BOOL');

  /// The value is a signed 64-bit integer.
  static const int64 = MetricDescriptor_ValueType('INT64');

  /// The value is a double precision floating point number.
  static const double = MetricDescriptor_ValueType('DOUBLE');

  /// The value is a text string.
  /// This value type can be used only if the metric kind is `GAUGE`.
  static const string = MetricDescriptor_ValueType('STRING');

  /// The value is a [`Distribution`][google.api.Distribution].
  static const distribution = MetricDescriptor_ValueType('DISTRIBUTION');

  /// The value is money.
  static const money = MetricDescriptor_ValueType('MONEY');

  const MetricDescriptor_ValueType(super.value);

  factory MetricDescriptor_ValueType.fromJson(String json) =>
      MetricDescriptor_ValueType(json);

  @override
  String toString() => 'ValueType.$value';
}

/// A specific metric, identified by specifying values for all of the
/// labels of a [`MetricDescriptor`][google.api.MetricDescriptor].
class Metric extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Metric';

  /// An existing metric type, see
  /// `google.api.MetricDescriptor`. For example,
  /// `custom.googleapis.com/invoice/paid/amount`.
  final String? type;

  /// The set of label values that uniquely identify this metric. All
  /// labels listed in the `MetricDescriptor` must be assigned values.
  final Map<String, String>? labels;

  Metric({
    this.type,
    this.labels,
  }) : super(fullyQualifiedName);

  factory Metric.fromJson(Map<String, dynamic> json) {
    return Metric(
      type: json['type'],
      labels: decodeMap(json['labels']),
    );
  }

  @override
  Object toJson() {
    return {
      if (type != null) 'type': type,
      if (labels != null) 'labels': labels,
    };
  }

  @override
  String toString() {
    final contents = [
      if (type != null) 'type=$type',
    ].join(',');
    return 'Metric($contents)';
  }
}

/// An object that describes the schema of a
/// `MonitoredResource` object using a type name
/// and a set of labels.  For example, the monitored resource descriptor for
/// Google Compute Engine VM instances has a type of
/// `"gce_instance"` and specifies the use of the labels `"instance_id"` and
/// `"zone"` to identify particular VM instances.
///
/// Different APIs can support different monitored resource types. APIs generally
/// provide a `list` method that returns the monitored resource descriptors used
/// by the API.
class MonitoredResourceDescriptor extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.MonitoredResourceDescriptor';

  /// Optional. The resource name of the monitored resource descriptor:
  /// `"projects/{project_id}/monitoredResourceDescriptors/{type}"` where
  /// {type} is the value of the `type` field in this object and
  /// {project_id} is a project ID that provides API-specific context for
  /// accessing the type.  APIs that do not use project information can use the
  /// resource name format `"monitoredResourceDescriptors/{type}"`.
  final String? name;

  /// Required. The monitored resource type. For example, the type
  /// `"cloudsql_database"` represents databases in Google Cloud SQL.
  ///  For a list of types, see [Monitored resource
  ///  types](https://cloud.google.com/monitoring/api/resources)
  /// and [Logging resource
  /// types](https://cloud.google.com/logging/docs/api/v2/resource-list).
  final String? type;

  /// Optional. A concise name for the monitored resource type that might be
  /// displayed in user interfaces. It should be a Title Cased Noun Phrase,
  /// without any article or other determiners. For example,
  /// `"Google Cloud SQL Database"`.
  final String? displayName;

  /// Optional. A detailed description of the monitored resource type that might
  /// be used in documentation.
  final String? description;

  /// Required. A set of labels used to describe instances of this monitored
  /// resource type. For example, an individual Google Cloud SQL database is
  /// identified by values for the labels `"database_id"` and `"zone"`.
  final List<LabelDescriptor>? labels;

  /// Optional. The launch stage of the monitored resource definition.
  final LaunchStage? launchStage;

  MonitoredResourceDescriptor({
    this.name,
    this.type,
    this.displayName,
    this.description,
    this.labels,
    this.launchStage,
  }) : super(fullyQualifiedName);

  factory MonitoredResourceDescriptor.fromJson(Map<String, dynamic> json) {
    return MonitoredResourceDescriptor(
      name: json['name'],
      type: json['type'],
      displayName: json['displayName'],
      description: json['description'],
      labels: decodeListMessage(json['labels'], LabelDescriptor.fromJson),
      launchStage: decodeEnum(json['launchStage'], LaunchStage.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (type != null) 'type': type,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (labels != null) 'labels': encodeList(labels),
      if (launchStage != null) 'launchStage': launchStage!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (type != null) 'type=$type',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (launchStage != null) 'launchStage=$launchStage',
    ].join(',');
    return 'MonitoredResourceDescriptor($contents)';
  }
}

/// An object representing a resource that can be used for monitoring, logging,
/// billing, or other purposes. Examples include virtual machine instances,
/// databases, and storage devices such as disks. The `type` field identifies a
/// `MonitoredResourceDescriptor` object
/// that describes the resource's schema. Information in the `labels` field
/// identifies the actual resource and its attributes according to the schema.
/// For example, a particular Compute Engine VM instance could be represented by
/// the following object, because the
/// `MonitoredResourceDescriptor` for
/// `"gce_instance"` has labels
/// `"project_id"`, `"instance_id"` and `"zone"`:
///
///     { "type": "gce_instance",
///       "labels": { "project_id": "my-project",
///                   "instance_id": "12345678901234",
///                   "zone": "us-central1-a" }}
class MonitoredResource extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.MonitoredResource';

  /// Required. The monitored resource type. This field must match
  /// the `type` field of a
  /// `MonitoredResourceDescriptor`
  /// object. For example, the type of a Compute Engine VM instance is
  /// `gce_instance`. Some descriptors include the service name in the type; for
  /// example, the type of a Datastream stream is
  /// `datastream.googleapis.com/Stream`.
  final String? type;

  /// Required. Values for all of the labels listed in the associated monitored
  /// resource descriptor. For example, Compute Engine VM instances use the
  /// labels `"project_id"`, `"instance_id"`, and `"zone"`.
  final Map<String, String>? labels;

  MonitoredResource({
    this.type,
    this.labels,
  }) : super(fullyQualifiedName);

  factory MonitoredResource.fromJson(Map<String, dynamic> json) {
    return MonitoredResource(
      type: json['type'],
      labels: decodeMap(json['labels']),
    );
  }

  @override
  Object toJson() {
    return {
      if (type != null) 'type': type,
      if (labels != null) 'labels': labels,
    };
  }

  @override
  String toString() {
    final contents = [
      if (type != null) 'type=$type',
    ].join(',');
    return 'MonitoredResource($contents)';
  }
}

/// Auxiliary metadata for a `MonitoredResource`
/// object. `MonitoredResource` objects contain the
/// minimum set of information to uniquely identify a monitored resource
/// instance. There is some other useful auxiliary metadata. Monitoring and
/// Logging use an ingestion pipeline to extract metadata for cloud resources of
/// all types, and store the metadata in this message.
class MonitoredResourceMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.MonitoredResourceMetadata';

  /// Output only. Values for predefined system metadata labels.
  /// System labels are a kind of metadata extracted by Google, including
  /// "machine_image", "vpc", "subnet_id",
  /// "security_group", "name", etc.
  /// System label values can be only strings, Boolean values, or a list of
  /// strings. For example:
  ///
  ///     { "name": "my-test-instance",
  ///       "security_group": ["a", "b", "c"],
  ///       "spot_instance": false }
  final Struct? systemLabels;

  /// Output only. A map of user-defined metadata labels.
  final Map<String, String>? userLabels;

  MonitoredResourceMetadata({
    this.systemLabels,
    this.userLabels,
  }) : super(fullyQualifiedName);

  factory MonitoredResourceMetadata.fromJson(Map<String, dynamic> json) {
    return MonitoredResourceMetadata(
      systemLabels: decodeCustom(json['systemLabels'], Struct.fromJson),
      userLabels: decodeMap(json['userLabels']),
    );
  }

  @override
  Object toJson() {
    return {
      if (systemLabels != null) 'systemLabels': systemLabels!.toJson(),
      if (userLabels != null) 'userLabels': userLabels,
    };
  }

  @override
  String toString() => 'MonitoredResourceMetadata()';
}

/// Monitoring configuration of the service.
///
/// The example below shows how to configure monitored resources and metrics
/// for monitoring. In the example, a monitored resource and two metrics are
/// defined. The `library.googleapis.com/book/returned_count` metric is sent
/// to both producer and consumer projects, whereas the
/// `library.googleapis.com/book/num_overdue` metric is only sent to the
/// consumer project.
///
///     monitored_resources:
///     - type: library.googleapis.com/Branch
///       display_name: "Library Branch"
///       description: "A branch of a library."
///       launch_stage: GA
///       labels:
///       - key: resource_container
///         description: "The Cloud container (ie. project id) for the Branch."
///       - key: location
///         description: "The location of the library branch."
///       - key: branch_id
///         description: "The id of the branch."
///     metrics:
///     - name: library.googleapis.com/book/returned_count
///       display_name: "Books Returned"
///       description: "The count of books that have been returned."
///       launch_stage: GA
///       metric_kind: DELTA
///       value_type: INT64
///       unit: "1"
///       labels:
///       - key: customer_id
///         description: "The id of the customer."
///     - name: library.googleapis.com/book/num_overdue
///       display_name: "Books Overdue"
///       description: "The current number of overdue books."
///       launch_stage: GA
///       metric_kind: GAUGE
///       value_type: INT64
///       unit: "1"
///       labels:
///       - key: customer_id
///         description: "The id of the customer."
///     monitoring:
///       producer_destinations:
///       - monitored_resource: library.googleapis.com/Branch
///         metrics:
///         - library.googleapis.com/book/returned_count
///       consumer_destinations:
///       - monitored_resource: library.googleapis.com/Branch
///         metrics:
///         - library.googleapis.com/book/returned_count
///         - library.googleapis.com/book/num_overdue
class Monitoring extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Monitoring';

  /// Monitoring configurations for sending metrics to the producer project.
  /// There can be multiple producer destinations. A monitored resource type may
  /// appear in multiple monitoring destinations if different aggregations are
  /// needed for different sets of metrics associated with that monitored
  /// resource type. A monitored resource and metric pair may only be used once
  /// in the Monitoring configuration.
  final List<Monitoring_MonitoringDestination>? producerDestinations;

  /// Monitoring configurations for sending metrics to the consumer project.
  /// There can be multiple consumer destinations. A monitored resource type may
  /// appear in multiple monitoring destinations if different aggregations are
  /// needed for different sets of metrics associated with that monitored
  /// resource type. A monitored resource and metric pair may only be used once
  /// in the Monitoring configuration.
  final List<Monitoring_MonitoringDestination>? consumerDestinations;

  Monitoring({
    this.producerDestinations,
    this.consumerDestinations,
  }) : super(fullyQualifiedName);

  factory Monitoring.fromJson(Map<String, dynamic> json) {
    return Monitoring(
      producerDestinations: decodeListMessage(json['producerDestinations'],
          Monitoring_MonitoringDestination.fromJson),
      consumerDestinations: decodeListMessage(json['consumerDestinations'],
          Monitoring_MonitoringDestination.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (producerDestinations != null)
        'producerDestinations': encodeList(producerDestinations),
      if (consumerDestinations != null)
        'consumerDestinations': encodeList(consumerDestinations),
    };
  }

  @override
  String toString() => 'Monitoring()';
}

/// Configuration of a specific monitoring destination (the producer project
/// or the consumer project).
class Monitoring_MonitoringDestination extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.Monitoring.MonitoringDestination';

  /// The monitored resource type. The type must be defined in
  /// `Service.monitored_resources`
  /// section.
  final String? monitoredResource;

  /// Types of the metrics to report to this monitoring destination.
  /// Each type must be defined in
  /// `Service.metrics` section.
  final List<String>? metrics;

  Monitoring_MonitoringDestination({
    this.monitoredResource,
    this.metrics,
  }) : super(fullyQualifiedName);

  factory Monitoring_MonitoringDestination.fromJson(Map<String, dynamic> json) {
    return Monitoring_MonitoringDestination(
      monitoredResource: json['monitoredResource'],
      metrics: decodeList(json['metrics']),
    );
  }

  @override
  Object toJson() {
    return {
      if (monitoredResource != null) 'monitoredResource': monitoredResource,
      if (metrics != null) 'metrics': metrics,
    };
  }

  @override
  String toString() {
    final contents = [
      if (monitoredResource != null) 'monitoredResource=$monitoredResource',
    ].join(',');
    return 'MonitoringDestination($contents)';
  }
}

/// Google API Policy Annotation
///
/// This message defines a simple API policy annotation that can be used to
/// annotate API request and response message fields with applicable policies.
/// One field may have multiple applicable policies that must all be satisfied
/// before a request can be processed. This policy annotation is used to
/// generate the overall policy that will be used for automatic runtime
/// policy enforcement and documentation generation.
class FieldPolicy extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.FieldPolicy';

  /// Selects one or more request or response message fields to apply this
  /// `FieldPolicy`.
  ///
  /// When a `FieldPolicy` is used in proto annotation, the selector must
  /// be left as empty. The service config generator will automatically fill
  /// the correct value.
  ///
  /// When a `FieldPolicy` is used in service config, the selector must be a
  /// comma-separated string with valid request or response field paths,
  /// such as "foo.bar" or "foo.bar,foo.baz".
  final String? selector;

  /// Specifies the required permission(s) for the resource referred to by the
  /// field. It requires the field contains a valid resource reference, and
  /// the request must pass the permission checks to proceed. For example,
  /// "resourcemanager.projects.get".
  final String? resourcePermission;

  /// Specifies the resource type for the resource referred to by the field.
  final String? resourceType;

  FieldPolicy({
    this.selector,
    this.resourcePermission,
    this.resourceType,
  }) : super(fullyQualifiedName);

  factory FieldPolicy.fromJson(Map<String, dynamic> json) {
    return FieldPolicy(
      selector: json['selector'],
      resourcePermission: json['resourcePermission'],
      resourceType: json['resourceType'],
    );
  }

  @override
  Object toJson() {
    return {
      if (selector != null) 'selector': selector,
      if (resourcePermission != null) 'resourcePermission': resourcePermission,
      if (resourceType != null) 'resourceType': resourceType,
    };
  }

  @override
  String toString() {
    final contents = [
      if (selector != null) 'selector=$selector',
      if (resourcePermission != null) 'resourcePermission=$resourcePermission',
      if (resourceType != null) 'resourceType=$resourceType',
    ].join(',');
    return 'FieldPolicy($contents)';
  }
}

/// Defines policies applying to an RPC method.
class MethodPolicy extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.MethodPolicy';

  /// Selects a method to which these policies should be enforced, for example,
  /// "google.pubsub.v1.Subscriber.CreateSubscription".
  ///
  /// Refer to `selector` for syntax
  /// details.
  ///
  /// NOTE: This field must not be set in the proto annotation. It will be
  /// automatically filled by the service config compiler .
  final String? selector;

  /// Policies that are applicable to the request message.
  final List<FieldPolicy>? requestPolicies;

  MethodPolicy({
    this.selector,
    this.requestPolicies,
  }) : super(fullyQualifiedName);

  factory MethodPolicy.fromJson(Map<String, dynamic> json) {
    return MethodPolicy(
      selector: json['selector'],
      requestPolicies:
          decodeListMessage(json['requestPolicies'], FieldPolicy.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (selector != null) 'selector': selector,
      if (requestPolicies != null)
        'requestPolicies': encodeList(requestPolicies),
    };
  }

  @override
  String toString() {
    final contents = [
      if (selector != null) 'selector=$selector',
    ].join(',');
    return 'MethodPolicy($contents)';
  }
}

/// Quota configuration helps to achieve fairness and budgeting in service
/// usage.
///
/// The metric based quota configuration works this way:
/// - The service configuration defines a set of metrics.
/// - For API calls, the quota.metric_rules maps methods to metrics with
///   corresponding costs.
/// - The quota.limits defines limits on the metrics, which will be used for
///   quota checks at runtime.
///
/// An example quota configuration in yaml format:
///
///    quota:
///      limits:
///
///      - name: apiWriteQpsPerProject
///        metric: library.googleapis.com/write_calls
///        unit: "1/min/{project}"  # rate limit for consumer projects
///        values:
///          STANDARD: 10000
///
///
///      (The metric rules bind all methods to the read_calls metric,
///       except for the UpdateBook and DeleteBook methods. These two methods
///       are mapped to the write_calls metric, with the UpdateBook method
///       consuming at twice rate as the DeleteBook method.)
///      metric_rules:
///      - selector: "*"
///        metric_costs:
///          library.googleapis.com/read_calls: 1
///      - selector: google.example.library.v1.LibraryService.UpdateBook
///        metric_costs:
///          library.googleapis.com/write_calls: 2
///      - selector: google.example.library.v1.LibraryService.DeleteBook
///        metric_costs:
///          library.googleapis.com/write_calls: 1
///
///  Corresponding Metric definition:
///
///      metrics:
///      - name: library.googleapis.com/read_calls
///        display_name: Read requests
///        metric_kind: DELTA
///        value_type: INT64
///
///      - name: library.googleapis.com/write_calls
///        display_name: Write requests
///        metric_kind: DELTA
///        value_type: INT64
class Quota extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Quota';

  /// List of QuotaLimit definitions for the service.
  final List<QuotaLimit>? limits;

  /// List of MetricRule definitions, each one mapping a selected method to one
  /// or more metrics.
  final List<MetricRule>? metricRules;

  Quota({
    this.limits,
    this.metricRules,
  }) : super(fullyQualifiedName);

  factory Quota.fromJson(Map<String, dynamic> json) {
    return Quota(
      limits: decodeListMessage(json['limits'], QuotaLimit.fromJson),
      metricRules: decodeListMessage(json['metricRules'], MetricRule.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (limits != null) 'limits': encodeList(limits),
      if (metricRules != null) 'metricRules': encodeList(metricRules),
    };
  }

  @override
  String toString() => 'Quota()';
}

/// Bind API methods to metrics. Binding a method to a metric causes that
/// metric's configured quota behaviors to apply to the method call.
class MetricRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.MetricRule';

  /// Selects the methods to which this rule applies.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String? selector;

  /// Metrics to update when the selected methods are called, and the associated
  /// cost applied to each metric.
  ///
  /// The key of the map is the metric name, and the values are the amount
  /// increased for the metric against which the quota limits are defined.
  /// The value must not be negative.
  final Map<String, int>? metricCosts;

  MetricRule({
    this.selector,
    this.metricCosts,
  }) : super(fullyQualifiedName);

  factory MetricRule.fromJson(Map<String, dynamic> json) {
    return MetricRule(
      selector: json['selector'],
      metricCosts: decodeMap(json['metricCosts']),
    );
  }

  @override
  Object toJson() {
    return {
      if (selector != null) 'selector': selector,
      if (metricCosts != null) 'metricCosts': metricCosts,
    };
  }

  @override
  String toString() {
    final contents = [
      if (selector != null) 'selector=$selector',
    ].join(',');
    return 'MetricRule($contents)';
  }
}

/// `QuotaLimit` defines a specific limit that applies over a specified duration
/// for a limit type. There can be at most one limit for a duration and limit
/// type combination defined within a `QuotaGroup`.
class QuotaLimit extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.QuotaLimit';

  /// Name of the quota limit.
  ///
  /// The name must be provided, and it must be unique within the service. The
  /// name can only include alphanumeric characters as well as '-'.
  ///
  /// The maximum length of the limit name is 64 characters.
  final String? name;

  /// Optional. User-visible, extended description for this quota limit.
  /// Should be used only when more context is needed to understand this limit
  /// than provided by the limit's display name (see: `display_name`).
  final String? description;

  /// Default number of tokens that can be consumed during the specified
  /// duration. This is the number of tokens assigned when a client
  /// application developer activates the service for his/her project.
  ///
  /// Specifying a value of 0 will block all requests. This can be used if you
  /// are provisioning quota to selected consumers and blocking others.
  /// Similarly, a value of -1 will indicate an unlimited quota. No other
  /// negative values are allowed.
  ///
  /// Used by group-based quotas only.
  final int? defaultLimit;

  /// Maximum number of tokens that can be consumed during the specified
  /// duration. Client application developers can override the default limit up
  /// to this maximum. If specified, this value cannot be set to a value less
  /// than the default limit. If not specified, it is set to the default limit.
  ///
  /// To allow clients to apply overrides with no upper bound, set this to -1,
  /// indicating unlimited maximum quota.
  ///
  /// Used by group-based quotas only.
  final int? maxLimit;

  /// Free tier value displayed in the Developers Console for this limit.
  /// The free tier is the number of tokens that will be subtracted from the
  /// billed amount when billing is enabled.
  /// This field can only be set on a limit with duration "1d", in a billable
  /// group; it is invalid on any other limit. If this field is not set, it
  /// defaults to 0, indicating that there is no free tier for this service.
  ///
  /// Used by group-based quotas only.
  final int? freeTier;

  /// Duration of this limit in textual notation. Must be "100s" or "1d".
  ///
  /// Used by group-based quotas only.
  final String? duration;

  /// The name of the metric this quota limit applies to. The quota limits with
  /// the same metric will be checked together during runtime. The metric must be
  /// defined within the service config.
  final String? metric;

  /// Specify the unit of the quota limit. It uses the same syntax as
  /// `MetricDescriptor.unit`. The supported
  /// unit kinds are determined by the quota backend system.
  ///
  /// Here are some examples:
  /// * "1/min/{project}" for quota per minute per project.
  ///
  /// Note: the order of unit components is insignificant.
  /// The "1" at the beginning is required to follow the metric unit syntax.
  final String? unit;

  /// Tiered limit values. You must specify this as a key:value pair, with an
  /// integer value that is the maximum number of requests allowed for the
  /// specified unit. Currently only STANDARD is supported.
  final Map<String, int>? values;

  /// User-visible display name for this limit.
  /// Optional. If not set, the UI will provide a default display name based on
  /// the quota configuration. This field can be used to override the default
  /// display name generated from the configuration.
  final String? displayName;

  QuotaLimit({
    this.name,
    this.description,
    this.defaultLimit,
    this.maxLimit,
    this.freeTier,
    this.duration,
    this.metric,
    this.unit,
    this.values,
    this.displayName,
  }) : super(fullyQualifiedName);

  factory QuotaLimit.fromJson(Map<String, dynamic> json) {
    return QuotaLimit(
      name: json['name'],
      description: json['description'],
      defaultLimit: decodeInt64(json['defaultLimit']),
      maxLimit: decodeInt64(json['maxLimit']),
      freeTier: decodeInt64(json['freeTier']),
      duration: json['duration'],
      metric: json['metric'],
      unit: json['unit'],
      values: decodeMap(json['values']),
      displayName: json['displayName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (defaultLimit != null) 'defaultLimit': encodeInt64(defaultLimit),
      if (maxLimit != null) 'maxLimit': encodeInt64(maxLimit),
      if (freeTier != null) 'freeTier': encodeInt64(freeTier),
      if (duration != null) 'duration': duration,
      if (metric != null) 'metric': metric,
      if (unit != null) 'unit': unit,
      if (values != null) 'values': values,
      if (displayName != null) 'displayName': displayName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (description != null) 'description=$description',
      if (defaultLimit != null) 'defaultLimit=$defaultLimit',
      if (maxLimit != null) 'maxLimit=$maxLimit',
      if (freeTier != null) 'freeTier=$freeTier',
      if (duration != null) 'duration=$duration',
      if (metric != null) 'metric=$metric',
      if (unit != null) 'unit=$unit',
      if (displayName != null) 'displayName=$displayName',
    ].join(',');
    return 'QuotaLimit($contents)';
  }
}

/// A simple descriptor of a resource type.
///
/// ResourceDescriptor annotates a resource message (either by means of a
/// protobuf annotation or use in the service config), and associates the
/// resource's schema, the resource type, and the pattern of the resource name.
///
/// Example:
///
///     message Topic {
///       // Indicates this message defines a resource schema.
///       // Declares the resource type in the format of {service}/{kind}.
///       // For Kubernetes resources, the format is {api group}/{kind}.
///       option (google.api.resource) = {
///         type: "pubsub.googleapis.com/Topic"
///         pattern: "projects/{project}/topics/{topic}"
///       };
///     }
///
/// The ResourceDescriptor Yaml config will look like:
///
///     resources:
///     - type: "pubsub.googleapis.com/Topic"
///       pattern: "projects/{project}/topics/{topic}"
///
/// Sometimes, resources have multiple patterns, typically because they can
/// live under multiple parents.
///
/// Example:
///
///     message LogEntry {
///       option (google.api.resource) = {
///         type: "logging.googleapis.com/LogEntry"
///         pattern: "projects/{project}/logs/{log}"
///         pattern: "folders/{folder}/logs/{log}"
///         pattern: "organizations/{organization}/logs/{log}"
///         pattern: "billingAccounts/{billing_account}/logs/{log}"
///       };
///     }
///
/// The ResourceDescriptor Yaml config will look like:
///
///     resources:
///     - type: 'logging.googleapis.com/LogEntry'
///       pattern: "projects/{project}/logs/{log}"
///       pattern: "folders/{folder}/logs/{log}"
///       pattern: "organizations/{organization}/logs/{log}"
///       pattern: "billingAccounts/{billing_account}/logs/{log}"
class ResourceDescriptor extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.ResourceDescriptor';

  /// The resource type. It must be in the format of
  /// {service_name}/{resource_type_kind}. The `resource_type_kind` must be
  /// singular and must not include version numbers.
  ///
  /// Example: `storage.googleapis.com/Bucket`
  ///
  /// The value of the resource_type_kind must follow the regular expression
  /// /[A-Za-z][a-zA-Z0-9]+/. It should start with an upper case character and
  /// should use PascalCase (UpperCamelCase). The maximum number of
  /// characters allowed for the `resource_type_kind` is 100.
  final String? type;

  /// Optional. The relative resource name pattern associated with this resource
  /// type. The DNS prefix of the full resource name shouldn't be specified here.
  ///
  /// The path pattern must follow the syntax, which aligns with HTTP binding
  /// syntax:
  ///
  ///     Template = Segment { "/" Segment } ;
  ///     Segment = LITERAL | Variable ;
  ///     Variable = "{" LITERAL "}" ;
  ///
  /// Examples:
  ///
  ///     - "projects/{project}/topics/{topic}"
  ///     - "projects/{project}/knowledgeBases/{knowledge_base}"
  ///
  /// The components in braces correspond to the IDs for each resource in the
  /// hierarchy. It is expected that, if multiple patterns are provided,
  /// the same component name (e.g. "project") refers to IDs of the same
  /// type of resource.
  final List<String>? pattern;

  /// Optional. The field on the resource that designates the resource name
  /// field. If omitted, this is assumed to be "name".
  final String? nameField;

  /// Optional. The historical or future-looking state of the resource pattern.
  ///
  /// Example:
  ///
  ///     // The InspectTemplate message originally only supported resource
  ///     // names with organization, and project was added later.
  ///     message InspectTemplate {
  ///       option (google.api.resource) = {
  ///         type: "dlp.googleapis.com/InspectTemplate"
  ///         pattern:
  ///         "organizations/{organization}/inspectTemplates/{inspect_template}"
  ///         pattern: "projects/{project}/inspectTemplates/{inspect_template}"
  ///         history: ORIGINALLY_SINGLE_PATTERN
  ///       };
  ///     }
  final ResourceDescriptor_History? history;

  /// The plural name used in the resource name and permission names, such as
  /// 'projects' for the resource name of 'projects/{project}' and the permission
  /// name of 'cloudresourcemanager.googleapis.com/projects.get'. One exception
  /// to this is for Nested Collections that have stuttering names, as defined
  /// in [AIP-122](https://google.aip.dev/122#nested-collections), where the
  /// collection ID in the resource name pattern does not necessarily directly
  /// match the `plural` value.
  ///
  /// It is the same concept of the `plural` field in k8s CRD spec
  /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/
  ///
  /// Note: The plural form is required even for singleton resources. See
  /// https://aip.dev/156
  final String? plural;

  /// The same concept of the `singular` field in k8s CRD spec
  /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/
  /// Such as "project" for the `resourcemanager.googleapis.com/Project` type.
  final String? singular;

  /// Style flag(s) for this resource.
  /// These indicate that a resource is expected to conform to a given
  /// style. See the specific style flags for additional information.
  final List<ResourceDescriptor_Style>? style;

  ResourceDescriptor({
    this.type,
    this.pattern,
    this.nameField,
    this.history,
    this.plural,
    this.singular,
    this.style,
  }) : super(fullyQualifiedName);

  factory ResourceDescriptor.fromJson(Map<String, dynamic> json) {
    return ResourceDescriptor(
      type: json['type'],
      pattern: decodeList(json['pattern']),
      nameField: json['nameField'],
      history: decodeEnum(json['history'], ResourceDescriptor_History.fromJson),
      plural: json['plural'],
      singular: json['singular'],
      style: decodeListEnum(json['style'], ResourceDescriptor_Style.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (type != null) 'type': type,
      if (pattern != null) 'pattern': pattern,
      if (nameField != null) 'nameField': nameField,
      if (history != null) 'history': history!.toJson(),
      if (plural != null) 'plural': plural,
      if (singular != null) 'singular': singular,
      if (style != null) 'style': encodeList(style),
    };
  }

  @override
  String toString() {
    final contents = [
      if (type != null) 'type=$type',
      if (nameField != null) 'nameField=$nameField',
      if (history != null) 'history=$history',
      if (plural != null) 'plural=$plural',
      if (singular != null) 'singular=$singular',
    ].join(',');
    return 'ResourceDescriptor($contents)';
  }
}

/// A description of the historical or future-looking state of the
/// resource pattern.
class ResourceDescriptor_History extends ProtoEnum {
  /// The "unset" value.
  static const historyUnspecified =
      ResourceDescriptor_History('HISTORY_UNSPECIFIED');

  /// The resource originally had one pattern and launched as such, and
  /// additional patterns were added later.
  static const originallySinglePattern =
      ResourceDescriptor_History('ORIGINALLY_SINGLE_PATTERN');

  /// The resource has one pattern, but the API owner expects to add more
  /// later. (This is the inverse of ORIGINALLY_SINGLE_PATTERN, and prevents
  /// that from being necessary once there are multiple patterns.)
  static const futureMultiPattern =
      ResourceDescriptor_History('FUTURE_MULTI_PATTERN');

  const ResourceDescriptor_History(super.value);

  factory ResourceDescriptor_History.fromJson(String json) =>
      ResourceDescriptor_History(json);

  @override
  String toString() => 'History.$value';
}

/// A flag representing a specific style that a resource claims to conform to.
class ResourceDescriptor_Style extends ProtoEnum {
  /// The unspecified value. Do not use.
  static const styleUnspecified = ResourceDescriptor_Style('STYLE_UNSPECIFIED');

  /// This resource is intended to be "declarative-friendly".
  ///
  /// Declarative-friendly resources must be more strictly consistent, and
  /// setting this to true communicates to tools that this resource should
  /// adhere to declarative-friendly expectations.
  ///
  /// Note: This is used by the API linter (linter.aip.dev) to enable
  /// additional checks.
  static const declarativeFriendly =
      ResourceDescriptor_Style('DECLARATIVE_FRIENDLY');

  const ResourceDescriptor_Style(super.value);

  factory ResourceDescriptor_Style.fromJson(String json) =>
      ResourceDescriptor_Style(json);

  @override
  String toString() => 'Style.$value';
}

/// Defines a proto annotation that describes a string field that refers to
/// an API resource.
class ResourceReference extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.ResourceReference';

  /// The resource type that the annotated field references.
  ///
  /// Example:
  ///
  ///     message Subscription {
  ///       string topic = 2 [(google.api.resource_reference) = {
  ///         type: "pubsub.googleapis.com/Topic"
  ///       }];
  ///     }
  ///
  /// Occasionally, a field may reference an arbitrary resource. In this case,
  /// APIs use the special value * in their resource reference.
  ///
  /// Example:
  ///
  ///     message GetIamPolicyRequest {
  ///       string resource = 2 [(google.api.resource_reference) = {
  ///         type: "*"
  ///       }];
  ///     }
  final String? type;

  /// The resource type of a child collection that the annotated field
  /// references. This is useful for annotating the `parent` field that
  /// doesn't have a fixed resource type.
  ///
  /// Example:
  ///
  ///     message ListLogEntriesRequest {
  ///       string parent = 1 [(google.api.resource_reference) = {
  ///         child_type: "logging.googleapis.com/LogEntry"
  ///       };
  ///     }
  final String? childType;

  ResourceReference({
    this.type,
    this.childType,
  }) : super(fullyQualifiedName);

  factory ResourceReference.fromJson(Map<String, dynamic> json) {
    return ResourceReference(
      type: json['type'],
      childType: json['childType'],
    );
  }

  @override
  Object toJson() {
    return {
      if (type != null) 'type': type,
      if (childType != null) 'childType': childType,
    };
  }

  @override
  String toString() {
    final contents = [
      if (type != null) 'type=$type',
      if (childType != null) 'childType=$childType',
    ].join(',');
    return 'ResourceReference($contents)';
  }
}

/// Specifies the routing information that should be sent along with the request
/// in the form of routing header.
/// **NOTE:** All service configuration rules follow the "last one wins" order.
///
/// The examples below will apply to an RPC which has the following request type:
///
/// Message Definition:
///
///     message Request {
///       // The name of the Table
///       // Values can be of the following formats:
///       // - `projects/<project>/tables/<table>`
///       // - `projects/<project>/instances/<instance>/tables/<table>`
///       // - `region/<region>/zones/<zone>/tables/<table>`
///       string table_name = 1;
///
///       // This value specifies routing for replication.
///       // It can be in the following formats:
///       // - `profiles/<profile_id>`
///       // - a legacy `profile_id` that can be any string
///       string app_profile_id = 2;
///     }
///
/// Example message:
///
///     {
///       table_name: projects/proj_foo/instances/instance_bar/table/table_baz,
///       app_profile_id: profiles/prof_qux
///     }
///
/// The routing header consists of one or multiple key-value pairs. Every key
/// and value must be percent-encoded, and joined together in the format of
/// `key1=value1&key2=value2`.
/// The examples below skip the percent-encoding for readability.
///
/// Example 1
///
/// Extracting a field from the request to put into the routing header
/// unchanged, with the key equal to the field name.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // Take the `app_profile_id`.
///       routing_parameters {
///         field: "app_profile_id"
///       }
///     };
///
/// result:
///
///     x-goog-request-params: app_profile_id=profiles/prof_qux
///
/// Example 2
///
/// Extracting a field from the request to put into the routing header
/// unchanged, with the key different from the field name.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // Take the `app_profile_id`, but name it `routing_id` in the header.
///       routing_parameters {
///         field: "app_profile_id"
///         path_template: "{routing_id=**}"
///       }
///     };
///
/// result:
///
///     x-goog-request-params: routing_id=profiles/prof_qux
///
/// Example 3
///
/// Extracting a field from the request to put into the routing
/// header, while matching a path template syntax on the field's value.
///
/// NB: it is more useful to send nothing than to send garbage for the purpose
/// of dynamic routing, since garbage pollutes cache. Thus the matching.
///
/// Sub-example 3a
///
/// The field matches the template.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // Take the `table_name`, if it's well-formed (with project-based
///       // syntax).
///       routing_parameters {
///         field: "table_name"
///         path_template: "{table_name=projects/*/instances/*/**}"
///       }
///     };
///
/// result:
///
///     x-goog-request-params:
///     table_name=projects/proj_foo/instances/instance_bar/table/table_baz
///
/// Sub-example 3b
///
/// The field does not match the template.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // Take the `table_name`, if it's well-formed (with region-based
///       // syntax).
///       routing_parameters {
///         field: "table_name"
///         path_template: "{table_name=regions/*/zones/*/**}"
///       }
///     };
///
/// result:
///
///     <no routing header will be sent>
///
/// Sub-example 3c
///
/// Multiple alternative conflictingly named path templates are
/// specified. The one that matches is used to construct the header.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // Take the `table_name`, if it's well-formed, whether
///       // using the region- or projects-based syntax.
///
///       routing_parameters {
///         field: "table_name"
///         path_template: "{table_name=regions/*/zones/*/**}"
///       }
///       routing_parameters {
///         field: "table_name"
///         path_template: "{table_name=projects/*/instances/*/**}"
///       }
///     };
///
/// result:
///
///     x-goog-request-params:
///     table_name=projects/proj_foo/instances/instance_bar/table/table_baz
///
/// Example 4
///
/// Extracting a single routing header key-value pair by matching a
/// template syntax on (a part of) a single request field.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // Take just the project id from the `table_name` field.
///       routing_parameters {
///         field: "table_name"
///         path_template: "{routing_id=projects/*}/**"
///       }
///     };
///
/// result:
///
///     x-goog-request-params: routing_id=projects/proj_foo
///
/// Example 5
///
/// Extracting a single routing header key-value pair by matching
/// several conflictingly named path templates on (parts of) a single request
/// field. The last template to match "wins" the conflict.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // If the `table_name` does not have instances information,
///       // take just the project id for routing.
///       // Otherwise take project + instance.
///
///       routing_parameters {
///         field: "table_name"
///         path_template: "{routing_id=projects/*}/**"
///       }
///       routing_parameters {
///         field: "table_name"
///         path_template: "{routing_id=projects/*/instances/*}/**"
///       }
///     };
///
/// result:
///
///     x-goog-request-params:
///     routing_id=projects/proj_foo/instances/instance_bar
///
/// Example 6
///
/// Extracting multiple routing header key-value pairs by matching
/// several non-conflicting path templates on (parts of) a single request field.
///
/// Sub-example 6a
///
/// Make the templates strict, so that if the `table_name` does not
/// have an instance information, nothing is sent.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // The routing code needs two keys instead of one composite
///       // but works only for the tables with the "project-instance" name
///       // syntax.
///
///       routing_parameters {
///         field: "table_name"
///         path_template: "{project_id=projects/*}/instances/*/**"
///       }
///       routing_parameters {
///         field: "table_name"
///         path_template: "projects/*/{instance_id=instances/*}/**"
///       }
///     };
///
/// result:
///
///     x-goog-request-params:
///     project_id=projects/proj_foo&instance_id=instances/instance_bar
///
/// Sub-example 6b
///
/// Make the templates loose, so that if the `table_name` does not
/// have an instance information, just the project id part is sent.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // The routing code wants two keys instead of one composite
///       // but will work with just the `project_id` for tables without
///       // an instance in the `table_name`.
///
///       routing_parameters {
///         field: "table_name"
///         path_template: "{project_id=projects/*}/**"
///       }
///       routing_parameters {
///         field: "table_name"
///         path_template: "projects/*/{instance_id=instances/*}/**"
///       }
///     };
///
/// result (is the same as 6a for our example message because it has the instance
/// information):
///
///     x-goog-request-params:
///     project_id=projects/proj_foo&instance_id=instances/instance_bar
///
/// Example 7
///
/// Extracting multiple routing header key-value pairs by matching
/// several path templates on multiple request fields.
///
/// NB: note that here there is no way to specify sending nothing if one of the
/// fields does not match its template. E.g. if the `table_name` is in the wrong
/// format, the `project_id` will not be sent, but the `routing_id` will be.
/// The backend routing code has to be aware of that and be prepared to not
/// receive a full complement of keys if it expects multiple.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // The routing needs both `project_id` and `routing_id`
///       // (from the `app_profile_id` field) for routing.
///
///       routing_parameters {
///         field: "table_name"
///         path_template: "{project_id=projects/*}/**"
///       }
///       routing_parameters {
///         field: "app_profile_id"
///         path_template: "{routing_id=**}"
///       }
///     };
///
/// result:
///
///     x-goog-request-params:
///     project_id=projects/proj_foo&routing_id=profiles/prof_qux
///
/// Example 8
///
/// Extracting a single routing header key-value pair by matching
/// several conflictingly named path templates on several request fields. The
/// last template to match "wins" the conflict.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // The `routing_id` can be a project id or a region id depending on
///       // the table name format, but only if the `app_profile_id` is not set.
///       // If `app_profile_id` is set it should be used instead.
///
///       routing_parameters {
///         field: "table_name"
///         path_template: "{routing_id=projects/*}/**"
///       }
///       routing_parameters {
///          field: "table_name"
///          path_template: "{routing_id=regions/*}/**"
///       }
///       routing_parameters {
///         field: "app_profile_id"
///         path_template: "{routing_id=**}"
///       }
///     };
///
/// result:
///
///     x-goog-request-params: routing_id=profiles/prof_qux
///
/// Example 9
///
/// Bringing it all together.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // For routing both `table_location` and a `routing_id` are needed.
///       //
///       // table_location can be either an instance id or a region+zone id.
///       //
///       // For `routing_id`, take the value of `app_profile_id`
///       // - If it's in the format `profiles/<profile_id>`, send
///       // just the `<profile_id>` part.
///       // - If it's any other literal, send it as is.
///       // If the `app_profile_id` is empty, and the `table_name` starts with
///       // the project_id, send that instead.
///
///       routing_parameters {
///         field: "table_name"
///         path_template: "projects/*/{table_location=instances/*}/tables/*"
///       }
///       routing_parameters {
///         field: "table_name"
///         path_template: "{table_location=regions/*/zones/*}/tables/*"
///       }
///       routing_parameters {
///         field: "table_name"
///         path_template: "{routing_id=projects/*}/**"
///       }
///       routing_parameters {
///         field: "app_profile_id"
///         path_template: "{routing_id=**}"
///       }
///       routing_parameters {
///         field: "app_profile_id"
///         path_template: "profiles/{routing_id=*}"
///       }
///     };
///
/// result:
///
///     x-goog-request-params:
///     table_location=instances/instance_bar&routing_id=prof_qux
class RoutingRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.RoutingRule';

  /// A collection of Routing Parameter specifications.
  /// **NOTE:** If multiple Routing Parameters describe the same key
  /// (via the `path_template` field or via the `field` field when
  /// `path_template` is not provided), "last one wins" rule
  /// determines which Parameter gets used.
  /// See the examples for more details.
  final List<RoutingParameter>? routingParameters;

  RoutingRule({
    this.routingParameters,
  }) : super(fullyQualifiedName);

  factory RoutingRule.fromJson(Map<String, dynamic> json) {
    return RoutingRule(
      routingParameters: decodeListMessage(
          json['routingParameters'], RoutingParameter.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (routingParameters != null)
        'routingParameters': encodeList(routingParameters),
    };
  }

  @override
  String toString() => 'RoutingRule()';
}

/// A projection from an input message to the GRPC or REST header.
class RoutingParameter extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.RoutingParameter';

  /// A request field to extract the header key-value pair from.
  final String? field;

  /// A pattern matching the key-value field. Optional.
  /// If not specified, the whole field specified in the `field` field will be
  /// taken as value, and its name used as key. If specified, it MUST contain
  /// exactly one named segment (along with any number of unnamed segments) The
  /// pattern will be matched over the field specified in the `field` field, then
  /// if the match is successful:
  /// - the name of the single named segment will be used as a header name,
  /// - the match value of the segment will be used as a header value;
  /// if the match is NOT successful, nothing will be sent.
  ///
  /// Example:
  ///
  ///               -- This is a field in the request message
  ///              |   that the header value will be extracted from.
  ///              |
  ///              |                     -- This is the key name in the
  ///              |                    |   routing header.
  ///              V                    |
  ///     field: "table_name"           v
  ///     path_template: "projects/*/{table_location=instances/*}/tables/*"
  ///                                                ^            ^
  ///                                                |            |
  ///       In the {} brackets is the pattern that --             |
  ///       specifies what to extract from the                    |
  ///       field as a value to be sent.                          |
  ///                                                             |
  ///      The string in the field must match the whole pattern --
  ///      before brackets, inside brackets, after brackets.
  ///
  /// When looking at this specific example, we can see that:
  /// - A key-value pair with the key `table_location`
  ///   and the value matching `instances/*` should be added
  ///   to the x-goog-request-params routing header.
  /// - The value is extracted from the request message's `table_name` field
  ///   if it matches the full pattern specified:
  ///   `projects/*/instances/*/tables/*`.
  ///
  /// **NB:** If the `path_template` field is not provided, the key name is
  /// equal to the field name, and the whole field should be sent as a value.
  /// This makes the pattern for the field and the value functionally equivalent
  /// to `**`, and the configuration
  ///
  ///     {
  ///       field: "table_name"
  ///     }
  ///
  /// is a functionally equivalent shorthand to:
  ///
  ///     {
  ///       field: "table_name"
  ///       path_template: "{table_name=**}"
  ///     }
  ///
  /// See Example 1 for more details.
  final String? pathTemplate;

  RoutingParameter({
    this.field,
    this.pathTemplate,
  }) : super(fullyQualifiedName);

  factory RoutingParameter.fromJson(Map<String, dynamic> json) {
    return RoutingParameter(
      field: json['field'],
      pathTemplate: json['pathTemplate'],
    );
  }

  @override
  Object toJson() {
    return {
      if (field != null) 'field': field,
      if (pathTemplate != null) 'pathTemplate': pathTemplate,
    };
  }

  @override
  String toString() {
    final contents = [
      if (field != null) 'field=$field',
      if (pathTemplate != null) 'pathTemplate=$pathTemplate',
    ].join(',');
    return 'RoutingParameter($contents)';
  }
}

/// `Service` is the root object of Google API service configuration (service
/// config). It describes the basic information about a logical service,
/// such as the service name and the user-facing title, and delegates other
/// aspects to sub-sections. Each sub-section is either a proto message or a
/// repeated proto message that configures a specific aspect, such as auth.
/// For more information, see each proto message definition.
///
/// Example:
///
///     type: google.api.Service
///     name: calendar.googleapis.com
///     title: Google Calendar API
///     apis:
///     - name: google.calendar.v3.Calendar
///
///     visibility:
///       rules:
///       - selector: "google.calendar.v3.*"
///         restriction: PREVIEW
///     backend:
///       rules:
///       - selector: "google.calendar.v3.*"
///         address: calendar.example.com
///
///     authentication:
///       providers:
///       - id: google_calendar_auth
///         jwks_uri: https://www.googleapis.com/oauth2/v1/certs
///         issuer: https://securetoken.google.com
///       rules:
///       - selector: "*"
///         requirements:
///           provider_id: google_calendar_auth
class Service extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Service';

  /// The service name, which is a DNS-like logical identifier for the
  /// service, such as `calendar.googleapis.com`. The service name
  /// typically goes through DNS verification to make sure the owner
  /// of the service also owns the DNS name.
  final String? name;

  /// The product title for this service, it is the name displayed in Google
  /// Cloud Console.
  final String? title;

  /// The Google project that owns this service.
  final String? producerProjectId;

  /// A unique ID for a specific instance of this message, typically assigned
  /// by the client for tracking purpose. Must be no longer than 63 characters
  /// and only lower case letters, digits, '.', '_' and '-' are allowed. If
  /// empty, the server may choose to generate one instead.
  final String? id;

  /// A list of API interfaces exported by this service. Only the `name` field
  /// of the `google.protobuf.Api` needs to be provided by
  /// the configuration author, as the remaining fields will be derived from the
  /// IDL during the normalization process. It is an error to specify an API
  /// interface here which cannot be resolved against the associated IDL files.
  final List<Api>? apis;

  /// A list of all proto message types included in this API service.
  /// Types referenced directly or indirectly by the `apis` are automatically
  /// included.  Messages which are not referenced but shall be included, such as
  /// types used by the `google.protobuf.Any` type, should be listed here by
  /// name by the configuration author. Example:
  ///
  ///     types:
  ///     - name: google.protobuf.Int32
  final List<Type>? types;

  /// A list of all enum types included in this API service.  Enums referenced
  /// directly or indirectly by the `apis` are automatically included.  Enums
  /// which are not referenced but shall be included should be listed here by
  /// name by the configuration author. Example:
  ///
  ///     enums:
  ///     - name: google.someapi.v1.SomeEnum
  final List<Enum>? enums;

  /// Additional API documentation.
  final Documentation? documentation;

  /// API backend configuration.
  final Backend? backend;

  /// HTTP configuration.
  final Http? http;

  /// Quota configuration.
  final Quota? quota;

  /// Auth configuration.
  final Authentication? authentication;

  /// Context configuration.
  final Context? context;

  /// Configuration controlling usage of this service.
  final Usage? usage;

  /// Configuration for network endpoints.  If this is empty, then an endpoint
  /// with the same name as the service is automatically generated to service all
  /// defined APIs.
  final List<Endpoint>? endpoints;

  /// Configuration for the service control plane.
  final Control? control;

  /// Defines the logs used by this service.
  final List<LogDescriptor>? logs;

  /// Defines the metrics used by this service.
  final List<MetricDescriptor>? metrics;

  /// Defines the monitored resources used by this service. This is required
  /// by the `Service.monitoring` and
  /// `Service.logging` configurations.
  final List<MonitoredResourceDescriptor>? monitoredResources;

  /// Billing configuration.
  final Billing? billing;

  /// Logging configuration.
  final Logging? logging;

  /// Monitoring configuration.
  final Monitoring? monitoring;

  /// System parameter configuration.
  final SystemParameters? systemParameters;

  /// Output only. The source information for this configuration if available.
  final SourceInfo? sourceInfo;

  /// Settings for [Google Cloud Client
  /// libraries](https://cloud.google.com/apis/docs/cloud-client-libraries)
  /// generated from APIs defined as protocol buffers.
  final Publishing? publishing;

  /// Obsolete. Do not use.
  ///
  /// This field has no semantic meaning. The service config compiler always
  /// sets this field to `3`.
  final Uint32Value? configVersion;

  Service({
    this.name,
    this.title,
    this.producerProjectId,
    this.id,
    this.apis,
    this.types,
    this.enums,
    this.documentation,
    this.backend,
    this.http,
    this.quota,
    this.authentication,
    this.context,
    this.usage,
    this.endpoints,
    this.control,
    this.logs,
    this.metrics,
    this.monitoredResources,
    this.billing,
    this.logging,
    this.monitoring,
    this.systemParameters,
    this.sourceInfo,
    this.publishing,
    this.configVersion,
  }) : super(fullyQualifiedName);

  factory Service.fromJson(Map<String, dynamic> json) {
    return Service(
      name: json['name'],
      title: json['title'],
      producerProjectId: json['producerProjectId'],
      id: json['id'],
      apis: decodeListMessage(json['apis'], Api.fromJson),
      types: decodeListMessage(json['types'], Type.fromJson),
      enums: decodeListMessage(json['enums'], Enum.fromJson),
      documentation: decode(json['documentation'], Documentation.fromJson),
      backend: decode(json['backend'], Backend.fromJson),
      http: decode(json['http'], Http.fromJson),
      quota: decode(json['quota'], Quota.fromJson),
      authentication: decode(json['authentication'], Authentication.fromJson),
      context: decode(json['context'], Context.fromJson),
      usage: decode(json['usage'], Usage.fromJson),
      endpoints: decodeListMessage(json['endpoints'], Endpoint.fromJson),
      control: decode(json['control'], Control.fromJson),
      logs: decodeListMessage(json['logs'], LogDescriptor.fromJson),
      metrics: decodeListMessage(json['metrics'], MetricDescriptor.fromJson),
      monitoredResources: decodeListMessage(
          json['monitoredResources'], MonitoredResourceDescriptor.fromJson),
      billing: decode(json['billing'], Billing.fromJson),
      logging: decode(json['logging'], Logging.fromJson),
      monitoring: decode(json['monitoring'], Monitoring.fromJson),
      systemParameters:
          decode(json['systemParameters'], SystemParameters.fromJson),
      sourceInfo: decode(json['sourceInfo'], SourceInfo.fromJson),
      publishing: decode(json['publishing'], Publishing.fromJson),
      configVersion: decodeCustom(json['configVersion'], Uint32Value.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (title != null) 'title': title,
      if (producerProjectId != null) 'producerProjectId': producerProjectId,
      if (id != null) 'id': id,
      if (apis != null) 'apis': encodeList(apis),
      if (types != null) 'types': encodeList(types),
      if (enums != null) 'enums': encodeList(enums),
      if (documentation != null) 'documentation': documentation!.toJson(),
      if (backend != null) 'backend': backend!.toJson(),
      if (http != null) 'http': http!.toJson(),
      if (quota != null) 'quota': quota!.toJson(),
      if (authentication != null) 'authentication': authentication!.toJson(),
      if (context != null) 'context': context!.toJson(),
      if (usage != null) 'usage': usage!.toJson(),
      if (endpoints != null) 'endpoints': encodeList(endpoints),
      if (control != null) 'control': control!.toJson(),
      if (logs != null) 'logs': encodeList(logs),
      if (metrics != null) 'metrics': encodeList(metrics),
      if (monitoredResources != null)
        'monitoredResources': encodeList(monitoredResources),
      if (billing != null) 'billing': billing!.toJson(),
      if (logging != null) 'logging': logging!.toJson(),
      if (monitoring != null) 'monitoring': monitoring!.toJson(),
      if (systemParameters != null)
        'systemParameters': systemParameters!.toJson(),
      if (sourceInfo != null) 'sourceInfo': sourceInfo!.toJson(),
      if (publishing != null) 'publishing': publishing!.toJson(),
      if (configVersion != null) 'configVersion': configVersion!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (title != null) 'title=$title',
      if (producerProjectId != null) 'producerProjectId=$producerProjectId',
      if (id != null) 'id=$id',
    ].join(',');
    return 'Service($contents)';
  }
}

/// Source information used to create a Service Config
class SourceInfo extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.SourceInfo';

  /// All files used during config generation.
  final List<Any>? sourceFiles;

  SourceInfo({
    this.sourceFiles,
  }) : super(fullyQualifiedName);

  factory SourceInfo.fromJson(Map<String, dynamic> json) {
    return SourceInfo(
      sourceFiles: decodeListMessage(json['sourceFiles'], Any.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (sourceFiles != null) 'sourceFiles': encodeList(sourceFiles),
    };
  }

  @override
  String toString() => 'SourceInfo()';
}

/// ### System parameter configuration
///
/// A system parameter is a special kind of parameter defined by the API
/// system, not by an individual API. It is typically mapped to an HTTP header
/// and/or a URL query parameter. This configuration specifies which methods
/// change the names of the system parameters.
class SystemParameters extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.SystemParameters';

  /// Define system parameters.
  ///
  /// The parameters defined here will override the default parameters
  /// implemented by the system. If this field is missing from the service
  /// config, default system parameters will be used. Default system parameters
  /// and names is implementation-dependent.
  ///
  /// Example: define api key for all methods
  ///
  ///     system_parameters
  ///       rules:
  ///         - selector: "*"
  ///           parameters:
  ///             - name: api_key
  ///               url_query_parameter: api_key
  ///
  ///
  /// Example: define 2 api key names for a specific method.
  ///
  ///     system_parameters
  ///       rules:
  ///         - selector: "/ListShelves"
  ///           parameters:
  ///             - name: api_key
  ///               http_header: Api-Key1
  ///             - name: api_key
  ///               http_header: Api-Key2
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<SystemParameterRule>? rules;

  SystemParameters({
    this.rules,
  }) : super(fullyQualifiedName);

  factory SystemParameters.fromJson(Map<String, dynamic> json) {
    return SystemParameters(
      rules: decodeListMessage(json['rules'], SystemParameterRule.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (rules != null) 'rules': encodeList(rules),
    };
  }

  @override
  String toString() => 'SystemParameters()';
}

/// Define a system parameter rule mapping system parameter definitions to
/// methods.
class SystemParameterRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.SystemParameterRule';

  /// Selects the methods to which this rule applies. Use '*' to indicate all
  /// methods in all APIs.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String? selector;

  /// Define parameters. Multiple names may be defined for a parameter.
  /// For a given method call, only one of them should be used. If multiple
  /// names are used the behavior is implementation-dependent.
  /// If none of the specified names are present the behavior is
  /// parameter-dependent.
  final List<SystemParameter>? parameters;

  SystemParameterRule({
    this.selector,
    this.parameters,
  }) : super(fullyQualifiedName);

  factory SystemParameterRule.fromJson(Map<String, dynamic> json) {
    return SystemParameterRule(
      selector: json['selector'],
      parameters:
          decodeListMessage(json['parameters'], SystemParameter.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (selector != null) 'selector': selector,
      if (parameters != null) 'parameters': encodeList(parameters),
    };
  }

  @override
  String toString() {
    final contents = [
      if (selector != null) 'selector=$selector',
    ].join(',');
    return 'SystemParameterRule($contents)';
  }
}

/// Define a parameter's name and location. The parameter may be passed as either
/// an HTTP header or a URL query parameter, and if both are passed the behavior
/// is implementation-dependent.
class SystemParameter extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.SystemParameter';

  /// Define the name of the parameter, such as "api_key" . It is case sensitive.
  final String? name;

  /// Define the HTTP header name to use for the parameter. It is case
  /// insensitive.
  final String? httpHeader;

  /// Define the URL query parameter name to use for the parameter. It is case
  /// sensitive.
  final String? urlQueryParameter;

  SystemParameter({
    this.name,
    this.httpHeader,
    this.urlQueryParameter,
  }) : super(fullyQualifiedName);

  factory SystemParameter.fromJson(Map<String, dynamic> json) {
    return SystemParameter(
      name: json['name'],
      httpHeader: json['httpHeader'],
      urlQueryParameter: json['urlQueryParameter'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (httpHeader != null) 'httpHeader': httpHeader,
      if (urlQueryParameter != null) 'urlQueryParameter': urlQueryParameter,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (httpHeader != null) 'httpHeader=$httpHeader',
      if (urlQueryParameter != null) 'urlQueryParameter=$urlQueryParameter',
    ].join(',');
    return 'SystemParameter($contents)';
  }
}

/// Configuration controlling usage of a service.
class Usage extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Usage';

  /// Requirements that must be satisfied before a consumer project can use the
  /// service. Each requirement is of the form <service.name>/<requirement-id>;
  /// for example 'serviceusage.googleapis.com/billing-enabled'.
  ///
  /// For Google APIs, a Terms of Service requirement must be included here.
  /// Google Cloud APIs must include "serviceusage.googleapis.com/tos/cloud".
  /// Other Google APIs should include
  /// "serviceusage.googleapis.com/tos/universal". Additional ToS can be
  /// included based on the business needs.
  final List<String>? requirements;

  /// A list of usage rules that apply to individual API methods.
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<UsageRule>? rules;

  /// The full resource name of a channel used for sending notifications to the
  /// service producer.
  ///
  /// Google Service Management currently only supports
  /// [Google Cloud Pub/Sub](https://cloud.google.com/pubsub) as a notification
  /// channel. To use Google Cloud Pub/Sub as the channel, this must be the name
  /// of a Cloud Pub/Sub topic that uses the Cloud Pub/Sub topic name format
  /// documented in https://cloud.google.com/pubsub/docs/overview.
  final String? producerNotificationChannel;

  Usage({
    this.requirements,
    this.rules,
    this.producerNotificationChannel,
  }) : super(fullyQualifiedName);

  factory Usage.fromJson(Map<String, dynamic> json) {
    return Usage(
      requirements: decodeList(json['requirements']),
      rules: decodeListMessage(json['rules'], UsageRule.fromJson),
      producerNotificationChannel: json['producerNotificationChannel'],
    );
  }

  @override
  Object toJson() {
    return {
      if (requirements != null) 'requirements': requirements,
      if (rules != null) 'rules': encodeList(rules),
      if (producerNotificationChannel != null)
        'producerNotificationChannel': producerNotificationChannel,
    };
  }

  @override
  String toString() {
    final contents = [
      if (producerNotificationChannel != null)
        'producerNotificationChannel=$producerNotificationChannel',
    ].join(',');
    return 'Usage($contents)';
  }
}

/// Usage configuration rules for the service.
///
/// NOTE: Under development.
///
///
/// Use this rule to configure unregistered calls for the service. Unregistered
/// calls are calls that do not contain consumer project identity.
/// (Example: calls that do not contain an API key).
/// By default, API methods do not allow unregistered calls, and each method call
/// must be identified by a consumer project identity. Use this rule to
/// allow/disallow unregistered calls.
///
/// Example of an API that wants to allow unregistered calls for entire service.
///
///     usage:
///       rules:
///       - selector: "*"
///         allow_unregistered_calls: true
///
/// Example of a method that wants to allow unregistered calls.
///
///     usage:
///       rules:
///       - selector: "google.example.library.v1.LibraryService.CreateBook"
///         allow_unregistered_calls: true
class UsageRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.UsageRule';

  /// Selects the methods to which this rule applies. Use '*' to indicate all
  /// methods in all APIs.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String? selector;

  /// If true, the selected method allows unregistered calls, e.g. calls
  /// that don't identify any user or application.
  final bool? allowUnregisteredCalls;

  /// If true, the selected method should skip service control and the control
  /// plane features, such as quota and billing, will not be available.
  /// This flag is used by Google Cloud Endpoints to bypass checks for internal
  /// methods, such as service health check methods.
  final bool? skipServiceControl;

  UsageRule({
    this.selector,
    this.allowUnregisteredCalls,
    this.skipServiceControl,
  }) : super(fullyQualifiedName);

  factory UsageRule.fromJson(Map<String, dynamic> json) {
    return UsageRule(
      selector: json['selector'],
      allowUnregisteredCalls: json['allowUnregisteredCalls'],
      skipServiceControl: json['skipServiceControl'],
    );
  }

  @override
  Object toJson() {
    return {
      if (selector != null) 'selector': selector,
      if (allowUnregisteredCalls != null)
        'allowUnregisteredCalls': allowUnregisteredCalls,
      if (skipServiceControl != null) 'skipServiceControl': skipServiceControl,
    };
  }

  @override
  String toString() {
    final contents = [
      if (selector != null) 'selector=$selector',
      if (allowUnregisteredCalls != null)
        'allowUnregisteredCalls=$allowUnregisteredCalls',
      if (skipServiceControl != null) 'skipServiceControl=$skipServiceControl',
    ].join(',');
    return 'UsageRule($contents)';
  }
}

/// `Visibility` restricts service consumer's access to service elements,
/// such as whether an application can call a visibility-restricted method.
/// The restriction is expressed by applying visibility labels on service
/// elements. The visibility labels are elsewhere linked to service consumers.
///
/// A service can define multiple visibility labels, but a service consumer
/// should be granted at most one visibility label. Multiple visibility
/// labels for a single service consumer are not supported.
///
/// If an element and all its parents have no visibility label, its visibility
/// is unconditionally granted.
///
/// Example:
///
///     visibility:
///       rules:
///       - selector: google.calendar.Calendar.EnhancedSearch
///         restriction: PREVIEW
///       - selector: google.calendar.Calendar.Delegate
///         restriction: INTERNAL
///
/// Here, all methods are publicly visible except for the restricted methods
/// EnhancedSearch and Delegate.
class Visibility extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Visibility';

  /// A list of visibility rules that apply to individual API elements.
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<VisibilityRule>? rules;

  Visibility({
    this.rules,
  }) : super(fullyQualifiedName);

  factory Visibility.fromJson(Map<String, dynamic> json) {
    return Visibility(
      rules: decodeListMessage(json['rules'], VisibilityRule.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (rules != null) 'rules': encodeList(rules),
    };
  }

  @override
  String toString() => 'Visibility()';
}

/// A visibility rule provides visibility configuration for an individual API
/// element.
class VisibilityRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.VisibilityRule';

  /// Selects methods, messages, fields, enums, etc. to which this rule applies.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String? selector;

  /// A comma-separated list of visibility labels that apply to the `selector`.
  /// Any of the listed labels can be used to grant the visibility.
  ///
  /// If a rule has multiple labels, removing one of the labels but not all of
  /// them can break clients.
  ///
  /// Example:
  ///
  ///     visibility:
  ///       rules:
  ///       - selector: google.calendar.Calendar.EnhancedSearch
  ///         restriction: INTERNAL, PREVIEW
  ///
  /// Removing INTERNAL from this restriction will break clients that rely on
  /// this method and only had access to it through INTERNAL.
  final String? restriction;

  VisibilityRule({
    this.selector,
    this.restriction,
  }) : super(fullyQualifiedName);

  factory VisibilityRule.fromJson(Map<String, dynamic> json) {
    return VisibilityRule(
      selector: json['selector'],
      restriction: json['restriction'],
    );
  }

  @override
  Object toJson() {
    return {
      if (selector != null) 'selector': selector,
      if (restriction != null) 'restriction': restriction,
    };
  }

  @override
  String toString() {
    final contents = [
      if (selector != null) 'selector=$selector',
      if (restriction != null) 'restriction=$restriction',
    ].join(',');
    return 'VisibilityRule($contents)';
  }
}

/// The organization for which the client libraries are being published.
/// Affects the url where generated docs are published, etc.
class ClientLibraryOrganization extends ProtoEnum {
  /// Not useful.
  static const clientLibraryOrganizationUnspecified =
      ClientLibraryOrganization('CLIENT_LIBRARY_ORGANIZATION_UNSPECIFIED');

  /// Google Cloud Platform Org.
  static const cloud = ClientLibraryOrganization('CLOUD');

  /// Ads (Advertising) Org.
  static const ads = ClientLibraryOrganization('ADS');

  /// Photos Org.
  static const photos = ClientLibraryOrganization('PHOTOS');

  /// Street View Org.
  static const streetView = ClientLibraryOrganization('STREET_VIEW');

  /// Shopping Org.
  static const shopping = ClientLibraryOrganization('SHOPPING');

  /// Geo Org.
  static const geo = ClientLibraryOrganization('GEO');

  /// Generative AI - https://developers.generativeai.google
  static const generativeAi = ClientLibraryOrganization('GENERATIVE_AI');

  const ClientLibraryOrganization(super.value);

  factory ClientLibraryOrganization.fromJson(String json) =>
      ClientLibraryOrganization(json);

  @override
  String toString() => 'ClientLibraryOrganization.$value';
}

/// To where should client libraries be published?
class ClientLibraryDestination extends ProtoEnum {
  /// Client libraries will neither be generated nor published to package
  /// managers.
  static const clientLibraryDestinationUnspecified =
      ClientLibraryDestination('CLIENT_LIBRARY_DESTINATION_UNSPECIFIED');

  /// Generate the client library in a repo under github.com/googleapis,
  /// but don't publish it to package managers.
  static const github = ClientLibraryDestination('GITHUB');

  /// Publish the library to package managers like nuget.org and npmjs.com.
  static const packageManager = ClientLibraryDestination('PACKAGE_MANAGER');

  const ClientLibraryDestination(super.value);

  factory ClientLibraryDestination.fromJson(String json) =>
      ClientLibraryDestination(json);

  @override
  String toString() => 'ClientLibraryDestination.$value';
}

/// Classifies set of possible modifications to an object in the service
/// configuration.
class ChangeType extends ProtoEnum {
  /// No value was provided.
  static const changeTypeUnspecified = ChangeType('CHANGE_TYPE_UNSPECIFIED');

  /// The changed object exists in the 'new' service configuration, but not
  /// in the 'old' service configuration.
  static const added = ChangeType('ADDED');

  /// The changed object exists in the 'old' service configuration, but not
  /// in the 'new' service configuration.
  static const removed = ChangeType('REMOVED');

  /// The changed object exists in both service configurations, but its value
  /// is different.
  static const modified = ChangeType('MODIFIED');

  const ChangeType(super.value);

  factory ChangeType.fromJson(String json) => ChangeType(json);

  @override
  String toString() => 'ChangeType.$value';
}

/// Defines the supported values for `google.rpc.ErrorInfo.reason` for the
/// `googleapis.com` error domain. This error domain is reserved for [Service
/// Infrastructure](https://cloud.google.com/service-infrastructure/docs/overview).
/// For each error info of this domain, the metadata key "service" refers to the
/// logical identifier of an API service, such as "pubsub.googleapis.com". The
/// "consumer" refers to the entity that consumes an API Service. It typically is
/// a Google project that owns the client application or the server resource,
/// such as "projects/123". Other metadata keys are specific to each error
/// reason. For more information, see the definition of the specific error
/// reason.
class ErrorReason extends ProtoEnum {
  /// Do not use this default value.
  static const errorReasonUnspecified = ErrorReason('ERROR_REASON_UNSPECIFIED');

  /// The request is calling a disabled service for a consumer.
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" contacting
  /// "pubsub.googleapis.com" service which is disabled:
  ///
  ///     { "reason": "SERVICE_DISABLED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "pubsub.googleapis.com"
  ///       }
  ///     }
  ///
  /// This response indicates the "pubsub.googleapis.com" has been disabled in
  /// "projects/123".
  static const serviceDisabled = ErrorReason('SERVICE_DISABLED');

  /// The request whose associated billing account is disabled.
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to contact
  /// "pubsub.googleapis.com" service because the associated billing account is
  /// disabled:
  ///
  ///     { "reason": "BILLING_DISABLED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "pubsub.googleapis.com"
  ///       }
  ///     }
  ///
  /// This response indicates the billing account associated has been disabled.
  static const billingDisabled = ErrorReason('BILLING_DISABLED');

  /// The request is denied because the provided [API
  /// key](https://cloud.google.com/docs/authentication/api-keys) is invalid. It
  /// may be in a bad format, cannot be found, or has been expired).
  ///
  /// Example of an ErrorInfo when the request is contacting
  /// "storage.googleapis.com" service with an invalid API key:
  ///
  ///     { "reason": "API_KEY_INVALID",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///       }
  ///     }
  static const apiKeyInvalid = ErrorReason('API_KEY_INVALID');

  /// The request is denied because it violates [API key API
  /// restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_api_restrictions).
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to call the
  /// "storage.googleapis.com" service because this service is restricted in the
  /// API key:
  ///
  ///     { "reason": "API_KEY_SERVICE_BLOCKED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const apiKeyServiceBlocked = ErrorReason('API_KEY_SERVICE_BLOCKED');

  /// The request is denied because it violates [API key HTTP
  /// restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_http_restrictions).
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to call
  /// "storage.googleapis.com" service because the http referrer of the request
  /// violates API key HTTP restrictions:
  ///
  ///     { "reason": "API_KEY_HTTP_REFERRER_BLOCKED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com",
  ///       }
  ///     }
  static const apiKeyHttpReferrerBlocked =
      ErrorReason('API_KEY_HTTP_REFERRER_BLOCKED');

  /// The request is denied because it violates [API key IP address
  /// restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_application_restrictions).
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to call
  /// "storage.googleapis.com" service because the caller IP of the request
  /// violates API key IP address restrictions:
  ///
  ///     { "reason": "API_KEY_IP_ADDRESS_BLOCKED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com",
  ///       }
  ///     }
  static const apiKeyIpAddressBlocked =
      ErrorReason('API_KEY_IP_ADDRESS_BLOCKED');

  /// The request is denied because it violates [API key Android application
  /// restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_application_restrictions).
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to call
  /// "storage.googleapis.com" service because the request from the Android apps
  /// violates the API key Android application restrictions:
  ///
  ///     { "reason": "API_KEY_ANDROID_APP_BLOCKED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const apiKeyAndroidAppBlocked =
      ErrorReason('API_KEY_ANDROID_APP_BLOCKED');

  /// The request is denied because it violates [API key iOS application
  /// restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_application_restrictions).
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to call
  /// "storage.googleapis.com" service because the request from the iOS apps
  /// violates the API key iOS application restrictions:
  ///
  ///     { "reason": "API_KEY_IOS_APP_BLOCKED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const apiKeyIosAppBlocked = ErrorReason('API_KEY_IOS_APP_BLOCKED');

  /// The request is denied because there is not enough rate quota for the
  /// consumer.
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to contact
  /// "pubsub.googleapis.com" service because consumer's rate quota usage has
  /// reached the maximum value set for the quota limit
  /// "ReadsPerMinutePerProject" on the quota metric
  /// "pubsub.googleapis.com/read_requests":
  ///
  ///     { "reason": "RATE_LIMIT_EXCEEDED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "pubsub.googleapis.com",
  ///         "quota_metric": "pubsub.googleapis.com/read_requests",
  ///         "quota_limit": "ReadsPerMinutePerProject"
  ///       }
  ///     }
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" checks quota on
  /// the service "dataflow.googleapis.com" and hits the organization quota
  /// limit "DefaultRequestsPerMinutePerOrganization" on the metric
  /// "dataflow.googleapis.com/default_requests".
  ///
  ///     { "reason": "RATE_LIMIT_EXCEEDED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "dataflow.googleapis.com",
  ///         "quota_metric": "dataflow.googleapis.com/default_requests",
  ///         "quota_limit": "DefaultRequestsPerMinutePerOrganization"
  ///       }
  ///     }
  static const rateLimitExceeded = ErrorReason('RATE_LIMIT_EXCEEDED');

  /// The request is denied because there is not enough resource quota for the
  /// consumer.
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to contact
  /// "compute.googleapis.com" service because consumer's resource quota usage
  /// has reached the maximum value set for the quota limit "VMsPerProject"
  /// on the quota metric "compute.googleapis.com/vms":
  ///
  ///     { "reason": "RESOURCE_QUOTA_EXCEEDED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "compute.googleapis.com",
  ///         "quota_metric": "compute.googleapis.com/vms",
  ///         "quota_limit": "VMsPerProject"
  ///       }
  ///     }
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" checks resource
  /// quota on the service "dataflow.googleapis.com" and hits the organization
  /// quota limit "jobs-per-organization" on the metric
  /// "dataflow.googleapis.com/job_count".
  ///
  ///     { "reason": "RESOURCE_QUOTA_EXCEEDED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "dataflow.googleapis.com",
  ///         "quota_metric": "dataflow.googleapis.com/job_count",
  ///         "quota_limit": "jobs-per-organization"
  ///       }
  ///     }
  static const resourceQuotaExceeded = ErrorReason('RESOURCE_QUOTA_EXCEEDED');

  /// The request whose associated billing account address is in a tax restricted
  /// location, violates the local tax restrictions when creating resources in
  /// the restricted region.
  ///
  /// Example of an ErrorInfo when creating the Cloud Storage Bucket in the
  /// container "projects/123" under a tax restricted region
  /// "locations/asia-northeast3":
  ///
  ///     { "reason": "LOCATION_TAX_POLICY_VIOLATED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com",
  ///         "location": "locations/asia-northeast3"
  ///       }
  ///     }
  ///
  /// This response indicates creating the Cloud Storage Bucket in
  /// "locations/asia-northeast3" violates the location tax restriction.
  static const locationTaxPolicyViolated =
      ErrorReason('LOCATION_TAX_POLICY_VIOLATED');

  /// The request is denied because the caller does not have required permission
  /// on the user project "projects/123" or the user project is invalid. For more
  /// information, check the [userProject System
  /// Parameters](https://cloud.google.com/apis/docs/system-parameters).
  ///
  /// Example of an ErrorInfo when the caller is calling Cloud Storage service
  /// with insufficient permissions on the user project:
  ///
  ///     { "reason": "USER_PROJECT_DENIED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const userProjectDenied = ErrorReason('USER_PROJECT_DENIED');

  /// The request is denied because the consumer "projects/123" is suspended due
  /// to Terms of Service(Tos) violations. Check [Project suspension
  /// guidelines](https://cloud.google.com/resource-manager/docs/project-suspension-guidelines)
  /// for more information.
  ///
  /// Example of an ErrorInfo when calling Cloud Storage service with the
  /// suspended consumer "projects/123":
  ///
  ///     { "reason": "CONSUMER_SUSPENDED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const consumerSuspended = ErrorReason('CONSUMER_SUSPENDED');

  /// The request is denied because the associated consumer is invalid. It may be
  /// in a bad format, cannot be found, or have been deleted.
  ///
  /// Example of an ErrorInfo when calling Cloud Storage service with the
  /// invalid consumer "projects/123":
  ///
  ///     { "reason": "CONSUMER_INVALID",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const consumerInvalid = ErrorReason('CONSUMER_INVALID');

  /// The request is denied because it violates [VPC Service
  /// Controls](https://cloud.google.com/vpc-service-controls/docs/overview).
  /// The 'uid' field is a random generated identifier that customer can use it
  /// to search the audit log for a request rejected by VPC Service Controls. For
  /// more information, please refer [VPC Service Controls
  /// Troubleshooting](https://cloud.google.com/vpc-service-controls/docs/troubleshooting#unique-id)
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to call
  /// Cloud Storage service because the request is prohibited by the VPC Service
  /// Controls.
  ///
  ///     { "reason": "SECURITY_POLICY_VIOLATED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "uid": "123456789abcde",
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const securityPolicyViolated = ErrorReason('SECURITY_POLICY_VIOLATED');

  /// The request is denied because the provided access token has expired.
  ///
  /// Example of an ErrorInfo when the request is calling Cloud Storage service
  /// with an expired access token:
  ///
  ///     { "reason": "ACCESS_TOKEN_EXPIRED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///         "method": "google.storage.v1.Storage.GetObject"
  ///       }
  ///     }
  static const accessTokenExpired = ErrorReason('ACCESS_TOKEN_EXPIRED');

  /// The request is denied because the provided access token doesn't have at
  /// least one of the acceptable scopes required for the API. Please check
  /// [OAuth 2.0 Scopes for Google
  /// APIs](https://developers.google.com/identity/protocols/oauth2/scopes) for
  /// the list of the OAuth 2.0 scopes that you might need to request to access
  /// the API.
  ///
  /// Example of an ErrorInfo when the request is calling Cloud Storage service
  /// with an access token that is missing required scopes:
  ///
  ///     { "reason": "ACCESS_TOKEN_SCOPE_INSUFFICIENT",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///         "method": "google.storage.v1.Storage.GetObject"
  ///       }
  ///     }
  static const accessTokenScopeInsufficient =
      ErrorReason('ACCESS_TOKEN_SCOPE_INSUFFICIENT');

  /// The request is denied because the account associated with the provided
  /// access token is in an invalid state, such as disabled or deleted.
  /// For more information, see https://cloud.google.com/docs/authentication.
  ///
  /// Warning: For privacy reasons, the server may not be able to disclose the
  /// email address for some accounts. The client MUST NOT depend on the
  /// availability of the `email` attribute.
  ///
  /// Example of an ErrorInfo when the request is to the Cloud Storage API with
  /// an access token that is associated with a disabled or deleted [service
  /// account](http://cloud/iam/docs/service-accounts):
  ///
  ///     { "reason": "ACCOUNT_STATE_INVALID",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///         "method": "google.storage.v1.Storage.GetObject",
  ///         "email": "user@123.iam.gserviceaccount.com"
  ///       }
  ///     }
  static const accountStateInvalid = ErrorReason('ACCOUNT_STATE_INVALID');

  /// The request is denied because the type of the provided access token is not
  /// supported by the API being called.
  ///
  /// Example of an ErrorInfo when the request is to the Cloud Storage API with
  /// an unsupported token type.
  ///
  ///     { "reason": "ACCESS_TOKEN_TYPE_UNSUPPORTED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///         "method": "google.storage.v1.Storage.GetObject"
  ///       }
  ///     }
  static const accessTokenTypeUnsupported =
      ErrorReason('ACCESS_TOKEN_TYPE_UNSUPPORTED');

  /// The request is denied because the request doesn't have any authentication
  /// credentials. For more information regarding the supported authentication
  /// strategies for Google Cloud APIs, see
  /// https://cloud.google.com/docs/authentication.
  ///
  /// Example of an ErrorInfo when the request is to the Cloud Storage API
  /// without any authentication credentials.
  ///
  ///     { "reason": "CREDENTIALS_MISSING",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///         "method": "google.storage.v1.Storage.GetObject"
  ///       }
  ///     }
  static const credentialsMissing = ErrorReason('CREDENTIALS_MISSING');

  /// The request is denied because the provided project owning the resource
  /// which acts as the [API
  /// consumer](https://cloud.google.com/apis/design/glossary#api_consumer) is
  /// invalid. It may be in a bad format or empty.
  ///
  /// Example of an ErrorInfo when the request is to the Cloud Functions API,
  /// but the offered resource project in the request in a bad format which can't
  /// perform the ListFunctions method.
  ///
  ///     { "reason": "RESOURCE_PROJECT_INVALID",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "cloudfunctions.googleapis.com",
  ///         "method":
  ///         "google.cloud.functions.v1.CloudFunctionsService.ListFunctions"
  ///       }
  ///     }
  static const resourceProjectInvalid = ErrorReason('RESOURCE_PROJECT_INVALID');

  /// The request is denied because the provided session cookie is missing,
  /// invalid or failed to decode.
  ///
  /// Example of an ErrorInfo when the request is calling Cloud Storage service
  /// with a SID cookie which can't be decoded.
  ///
  ///     { "reason": "SESSION_COOKIE_INVALID",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///         "method": "google.storage.v1.Storage.GetObject",
  ///         "cookie": "SID"
  ///       }
  ///     }
  static const sessionCookieInvalid = ErrorReason('SESSION_COOKIE_INVALID');

  /// The request is denied because the user is from a Google Workspace customer
  /// that blocks their users from accessing a particular service.
  ///
  /// Example scenario: https://support.google.com/a/answer/9197205?hl=en
  ///
  /// Example of an ErrorInfo when access to Google Cloud Storage service is
  /// blocked by the Google Workspace administrator:
  ///
  ///     { "reason": "USER_BLOCKED_BY_ADMIN",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///         "method": "google.storage.v1.Storage.GetObject",
  ///       }
  ///     }
  static const userBlockedByAdmin = ErrorReason('USER_BLOCKED_BY_ADMIN');

  /// The request is denied because the resource service usage is restricted
  /// by administrators according to the organization policy constraint.
  /// For more information see
  /// https://cloud.google.com/resource-manager/docs/organization-policy/restricting-services.
  ///
  /// Example of an ErrorInfo when access to Google Cloud Storage service is
  /// restricted by Resource Usage Restriction policy:
  ///
  ///     { "reason": "RESOURCE_USAGE_RESTRICTION_VIOLATED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/project-123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const resourceUsageRestrictionViolated =
      ErrorReason('RESOURCE_USAGE_RESTRICTION_VIOLATED');

  /// Unimplemented. Do not use.
  ///
  /// The request is denied because it contains unsupported system parameters in
  /// URL query parameters or HTTP headers. For more information,
  /// see https://cloud.google.com/apis/docs/system-parameters
  ///
  /// Example of an ErrorInfo when access "pubsub.googleapis.com" service with
  /// a request header of "x-goog-user-ip":
  ///
  ///     { "reason": "SYSTEM_PARAMETER_UNSUPPORTED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "pubsub.googleapis.com"
  ///         "parameter": "x-goog-user-ip"
  ///       }
  ///     }
  static const systemParameterUnsupported =
      ErrorReason('SYSTEM_PARAMETER_UNSUPPORTED');

  /// The request is denied because it violates Org Restriction: the requested
  /// resource does not belong to allowed organizations specified in
  /// "X-Goog-Allowed-Resources" header.
  ///
  /// Example of an ErrorInfo when accessing a GCP resource that is restricted by
  /// Org Restriction for "pubsub.googleapis.com" service.
  ///
  /// {
  ///   reason: "ORG_RESTRICTION_VIOLATION"
  ///   domain: "googleapis.com"
  ///   metadata {
  ///     "consumer":"projects/123456"
  ///     "service": "pubsub.googleapis.com"
  ///   }
  /// }
  static const orgRestrictionViolation =
      ErrorReason('ORG_RESTRICTION_VIOLATION');

  /// The request is denied because "X-Goog-Allowed-Resources" header is in a bad
  /// format.
  ///
  /// Example of an ErrorInfo when
  /// accessing "pubsub.googleapis.com" service with an invalid
  /// "X-Goog-Allowed-Resources" request header.
  ///
  /// {
  ///   reason: "ORG_RESTRICTION_HEADER_INVALID"
  ///   domain: "googleapis.com"
  ///   metadata {
  ///     "consumer":"projects/123456"
  ///     "service": "pubsub.googleapis.com"
  ///   }
  /// }
  static const orgRestrictionHeaderInvalid =
      ErrorReason('ORG_RESTRICTION_HEADER_INVALID');

  /// Unimplemented. Do not use.
  ///
  /// The request is calling a service that is not visible to the consumer.
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" contacting
  ///  "pubsub.googleapis.com" service which is not visible to the consumer.
  ///
  ///     { "reason": "SERVICE_NOT_VISIBLE",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "pubsub.googleapis.com"
  ///       }
  ///     }
  ///
  /// This response indicates the "pubsub.googleapis.com" is not visible to
  /// "projects/123" (or it may not exist).
  static const serviceNotVisible = ErrorReason('SERVICE_NOT_VISIBLE');

  /// The request is related to a project for which GCP access is suspended.
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to contact
  /// "pubsub.googleapis.com" service because GCP access is suspended:
  ///
  ///     { "reason": "GCP_SUSPENDED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "pubsub.googleapis.com"
  ///       }
  ///     }
  ///
  /// This response indicates the associated GCP account has been suspended.
  static const gcpSuspended = ErrorReason('GCP_SUSPENDED');

  /// The request violates the location policies when creating resources in
  /// the restricted region.
  ///
  /// Example of an ErrorInfo when creating the Cloud Storage Bucket by
  /// "projects/123" for service storage.googleapis.com:
  ///
  ///     { "reason": "LOCATION_POLICY_VIOLATED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com",
  ///       }
  ///     }
  ///
  /// This response indicates creating the Cloud Storage Bucket in
  /// "locations/asia-northeast3" violates at least one location policy.
  /// The troubleshooting guidance is provided in the Help links.
  static const locationPolicyViolated = ErrorReason('LOCATION_POLICY_VIOLATED');

  /// The request is denied because origin request header is missing.
  ///
  /// Example of an ErrorInfo when
  /// accessing "pubsub.googleapis.com" service with an empty "Origin" request
  /// header.
  ///
  /// {
  ///   reason: "MISSING_ORIGIN"
  ///   domain: "googleapis.com"
  ///   metadata {
  ///     "consumer":"projects/123456"
  ///     "service": "pubsub.googleapis.com"
  ///   }
  /// }
  static const missingOrigin = ErrorReason('MISSING_ORIGIN');

  /// The request is denied because the request contains more than one credential
  /// type that are individually acceptable, but not together. The customer
  /// should retry their request with only one set of credentials.
  ///
  /// Example of an ErrorInfo when
  /// accessing "pubsub.googleapis.com" service with overloaded credentials.
  ///
  /// {
  ///   reason: "OVERLOADED_CREDENTIALS"
  ///   domain: "googleapis.com"
  ///   metadata {
  ///     "consumer":"projects/123456"
  ///     "service": "pubsub.googleapis.com"
  ///   }
  /// }
  static const overloadedCredentials = ErrorReason('OVERLOADED_CREDENTIALS');

  const ErrorReason(super.value);

  factory ErrorReason.fromJson(String json) => ErrorReason(json);

  @override
  String toString() => 'ErrorReason.$value';
}

/// An indicator of the behavior of a given field (for example, that a field
/// is required in requests, or given as output but ignored as input).
/// This **does not** change the behavior in protocol buffers itself; it only
/// denotes the behavior and may affect how API tooling handles the field.
///
/// Note: This enum **may** receive new values in the future.
class FieldBehavior extends ProtoEnum {
  /// Conventional default for enums. Do not use this.
  static const fieldBehaviorUnspecified =
      FieldBehavior('FIELD_BEHAVIOR_UNSPECIFIED');

  /// Specifically denotes a field as optional.
  /// While all fields in protocol buffers are optional, this may be specified
  /// for emphasis if appropriate.
  static const optional = FieldBehavior('OPTIONAL');

  /// Denotes a field as required.
  /// This indicates that the field **must** be provided as part of the request,
  /// and failure to do so will cause an error (usually `INVALID_ARGUMENT`).
  static const required = FieldBehavior('REQUIRED');

  /// Denotes a field as output only.
  /// This indicates that the field is provided in responses, but including the
  /// field in a request does nothing (the server *must* ignore it and
  /// *must not* throw an error as a result of the field's presence).
  static const outputOnly = FieldBehavior('OUTPUT_ONLY');

  /// Denotes a field as input only.
  /// This indicates that the field is provided in requests, and the
  /// corresponding field is not included in output.
  static const inputOnly = FieldBehavior('INPUT_ONLY');

  /// Denotes a field as immutable.
  /// This indicates that the field may be set once in a request to create a
  /// resource, but may not be changed thereafter.
  static const immutable = FieldBehavior('IMMUTABLE');

  /// Denotes that a (repeated) field is an unordered list.
  /// This indicates that the service may provide the elements of the list
  /// in any arbitrary  order, rather than the order the user originally
  /// provided. Additionally, the list's order may or may not be stable.
  static const unorderedList = FieldBehavior('UNORDERED_LIST');

  /// Denotes that this field returns a non-empty default value if not set.
  /// This indicates that if the user provides the empty value in a request,
  /// a non-empty value will be returned. The user will not be aware of what
  /// non-empty value to expect.
  static const nonEmptyDefault = FieldBehavior('NON_EMPTY_DEFAULT');

  /// Denotes that the field in a resource (a message annotated with
  /// google.api.resource) is used in the resource name to uniquely identify the
  /// resource. For AIP-compliant APIs, this should only be applied to the
  /// `name` field on the resource.
  ///
  /// This behavior should not be applied to references to other resources within
  /// the message.
  ///
  /// The identifier field of resources often have different field behavior
  /// depending on the request it is embedded in (e.g. for Create methods name
  /// is optional and unused, while for Update methods it is required). Instead
  /// of method-specific annotations, only `IDENTIFIER` is required.
  static const identifier = FieldBehavior('IDENTIFIER');

  const FieldBehavior(super.value);

  factory FieldBehavior.fromJson(String json) => FieldBehavior(json);

  @override
  String toString() => 'FieldBehavior.$value';
}

/// The launch stage as defined by [Google Cloud Platform
/// Launch Stages](https://cloud.google.com/terms/launch-stages).
class LaunchStage extends ProtoEnum {
  /// Do not use this default value.
  static const launchStageUnspecified = LaunchStage('LAUNCH_STAGE_UNSPECIFIED');

  /// The feature is not yet implemented. Users can not use it.
  static const unimplemented = LaunchStage('UNIMPLEMENTED');

  /// Prelaunch features are hidden from users and are only visible internally.
  static const prelaunch = LaunchStage('PRELAUNCH');

  /// Early Access features are limited to a closed group of testers. To use
  /// these features, you must sign up in advance and sign a Trusted Tester
  /// agreement (which includes confidentiality provisions). These features may
  /// be unstable, changed in backward-incompatible ways, and are not
  /// guaranteed to be released.
  static const earlyAccess = LaunchStage('EARLY_ACCESS');

  /// Alpha is a limited availability test for releases before they are cleared
  /// for widespread use. By Alpha, all significant design issues are resolved
  /// and we are in the process of verifying functionality. Alpha customers
  /// need to apply for access, agree to applicable terms, and have their
  /// projects allowlisted. Alpha releases don't have to be feature complete,
  /// no SLAs are provided, and there are no technical support obligations, but
  /// they will be far enough along that customers can actually use them in
  /// test environments or for limited-use tests -- just like they would in
  /// normal production cases.
  static const alpha = LaunchStage('ALPHA');

  /// Beta is the point at which we are ready to open a release for any
  /// customer to use. There are no SLA or technical support obligations in a
  /// Beta release. Products will be complete from a feature perspective, but
  /// may have some open outstanding issues. Beta releases are suitable for
  /// limited production use cases.
  static const beta = LaunchStage('BETA');

  /// GA features are open to all developers and are considered stable and
  /// fully qualified for production use.
  static const ga = LaunchStage('GA');

  /// Deprecated features are scheduled to be shut down and removed. For more
  /// information, see the "Deprecation Policy" section of our [Terms of
  /// Service](https://cloud.google.com/terms/)
  /// and the [Google Cloud Platform Subject to the Deprecation
  /// Policy](https://cloud.google.com/terms/deprecation) documentation.
  static const deprecated = LaunchStage('DEPRECATED');

  const LaunchStage(super.value);

  factory LaunchStage.fromJson(String json) => LaunchStage(json);

  @override
  String toString() => 'LaunchStage.$value';
}
