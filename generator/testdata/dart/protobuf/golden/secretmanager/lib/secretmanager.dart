// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

// ignore_for_file: unused_import

/// The Google Cloud client for the Secret Manager API.
///
/// Stores sensitive data such as API keys, passwords, and certificates.
/// Provides convenience while improving security.
library;

import 'dart:typed_data';

import 'package:google_cloud_gax/common.dart';
import 'package:google_cloud_gax/src/json_helpers.dart';
import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:http/http.dart' as http;

/// Secret Manager Service
///
/// Manages secrets and operations using those secrets. Implements a REST
/// model with the following objects:
///
/// * [Secret][google.cloud.secretmanager.v1.Secret]
/// * [SecretVersion][google.cloud.secretmanager.v1.SecretVersion]
class SecretManagerService {
  static const String _host = 'secretmanager.googleapis.com';

  final ServiceClient _client;

  SecretManagerService({required http.Client httpClient})
      : _client = ServiceClient(httpClient: httpClient);

  /// Lists [Secrets][google.cloud.secretmanager.v1.Secret].
  Future<ListSecretsResponse> listSecrets(ListSecretsRequest request) async {
    final url = Uri.https(_host, '/v1/${request.parent}/secrets');
    final response = await _client.get(url);
    return ListSecretsResponse.fromJson(response);
  }

  /// Creates a new [Secret][google.cloud.secretmanager.v1.Secret] containing no
  /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion].
  Future<Secret> createSecret(CreateSecretRequest request) async {
    final url = Uri.https(_host, '/v1/${request.parent}/secrets');
    final response = await _client.post(url, body: request.secret);
    return Secret.fromJson(response);
  }

  /// Creates a new [SecretVersion][google.cloud.secretmanager.v1.SecretVersion]
  /// containing secret data and attaches it to an existing
  /// [Secret][google.cloud.secretmanager.v1.Secret].
  Future<SecretVersion> addSecretVersion(AddSecretVersionRequest request) async {
    final url = Uri.https(_host, '/v1/${request.parent}:addVersion');
    final response = await _client.post(url, body: request);
    return SecretVersion.fromJson(response);
  }

  /// Gets metadata for a given [Secret][google.cloud.secretmanager.v1.Secret].
  Future<Secret> getSecret(GetSecretRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}');
    final response = await _client.get(url);
    return Secret.fromJson(response);
  }

  /// Updates metadata of an existing
  /// [Secret][google.cloud.secretmanager.v1.Secret].
  Future<Secret> updateSecret(UpdateSecretRequest request) async {
    final url = Uri.https(_host, '/v1/${request.secret.name}');
    final response = await _client.patch(url, body: request.secret);
    return Secret.fromJson(response);
  }

  /// Deletes a [Secret][google.cloud.secretmanager.v1.Secret].
  Future<void> deleteSecret(DeleteSecretRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}');
    await _client.delete(url);
  }

  /// Lists [SecretVersions][google.cloud.secretmanager.v1.SecretVersion]. This
  /// call does not return secret data.
  Future<ListSecretVersionsResponse> listSecretVersions(ListSecretVersionsRequest request) async {
    final url = Uri.https(_host, '/v1/${request.parent}/versions');
    final response = await _client.get(url);
    return ListSecretVersionsResponse.fromJson(response);
  }

  /// Gets metadata for a
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
  ///
  /// `projects/*/secrets/*/versions/latest` is an alias to the most recently
  /// created [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
  Future<SecretVersion> getSecretVersion(GetSecretVersionRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}');
    final response = await _client.get(url);
    return SecretVersion.fromJson(response);
  }

  /// Accesses a [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
  /// This call returns the secret data.
  ///
  /// `projects/*/secrets/*/versions/latest` is an alias to the most recently
  /// created [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
  Future<AccessSecretVersionResponse> accessSecretVersion(AccessSecretVersionRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}:access');
    final response = await _client.get(url);
    return AccessSecretVersionResponse.fromJson(response);
  }

  /// Disables a [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
  ///
  /// Sets the [state][google.cloud.secretmanager.v1.SecretVersion.state] of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] to
  /// [DISABLED][google.cloud.secretmanager.v1.SecretVersion.State.DISABLED].
  Future<SecretVersion> disableSecretVersion(DisableSecretVersionRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}:disable');
    final response = await _client.post(url, body: request);
    return SecretVersion.fromJson(response);
  }

  /// Enables a [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
  ///
  /// Sets the [state][google.cloud.secretmanager.v1.SecretVersion.state] of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] to
  /// [ENABLED][google.cloud.secretmanager.v1.SecretVersion.State.ENABLED].
  Future<SecretVersion> enableSecretVersion(EnableSecretVersionRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}:enable');
    final response = await _client.post(url, body: request);
    return SecretVersion.fromJson(response);
  }

  /// Destroys a [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
  ///
  /// Sets the [state][google.cloud.secretmanager.v1.SecretVersion.state] of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] to
  /// [DESTROYED][google.cloud.secretmanager.v1.SecretVersion.State.DESTROYED]
  /// and irrevocably destroys the secret data.
  Future<SecretVersion> destroySecretVersion(DestroySecretVersionRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}:destroy');
    final response = await _client.post(url, body: request);
    return SecretVersion.fromJson(response);
  }

  /// Sets the access control policy on the specified secret. Replaces any
  /// existing policy.
  ///
  /// Permissions on
  /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] are enforced
  /// according to the policy set on the associated
  /// [Secret][google.cloud.secretmanager.v1.Secret].
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a secret.
  /// Returns empty policy if the secret exists and does not have a policy set.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1/${request.resource}:getIamPolicy');
    final response = await _client.get(url);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has for the specified secret.
  /// If the secret does not exist, this call returns an empty set of
  /// permissions, not a NOT_FOUND error.
  ///
  /// Note: This operation is designed to be used for building permission-aware
  /// UIs and command-line tools, not for authorization checking. This operation
  /// may "fail open" without warning.
  Future<TestIamPermissionsResponse> testIamPermissions(TestIamPermissionsRequest request) async {
    final url = Uri.https(_host, '/v1/${request.resource}:testIamPermissions');
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  Future<ListLocationsResponse> listLocations(ListLocationsRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}/locations');
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A [Secret][google.cloud.secretmanager.v1.Secret] is a logical secret whose
/// value and versions can be accessed.
///
/// A [Secret][google.cloud.secretmanager.v1.Secret] is made up of zero or more
/// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] that represent
/// the secret data.
class Secret extends Message {
  /// Output only. The resource name of the
  /// [Secret][google.cloud.secretmanager.v1.Secret] in the format
  /// `projects/*/secrets/*`.
  final String? name;

  /// Optional. Immutable. The replication policy of the secret data attached to
  /// the [Secret][google.cloud.secretmanager.v1.Secret].
  ///
  /// The replication policy cannot be changed after the Secret has been created.
  final Replication? replication;

  /// Output only. The time at which the
  /// [Secret][google.cloud.secretmanager.v1.Secret] was created.
  final Timestamp? createTime;

  /// The labels assigned to this Secret.
  ///
  /// Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
  /// of maximum 128 bytes, and must conform to the following PCRE regular
  /// expression: `[\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}`
  ///
  /// Label values must be between 0 and 63 characters long, have a UTF-8
  /// encoding of maximum 128 bytes, and must conform to the following PCRE
  /// regular expression: `[\p{Ll}\p{Lo}\p{N}_-]{0,63}`
  ///
  /// No more than 64 labels can be assigned to a given resource.
  final Map<String, String>? labels;

  /// Optional. A list of up to 10 Pub/Sub topics to which messages are published
  /// when control plane operations are called on the secret or its versions.
  final List<Topic>? topics;

  /// Optional. Timestamp in UTC when the
  /// [Secret][google.cloud.secretmanager.v1.Secret] is scheduled to expire.
  /// This is always provided on output, regardless of what was sent on input.
  final Timestamp? expireTime;

  /// Input only. The TTL for the
  /// [Secret][google.cloud.secretmanager.v1.Secret].
  final Duration? ttl;

  /// Optional. Etag of the currently stored
  /// [Secret][google.cloud.secretmanager.v1.Secret].
  final String? etag;

  /// Optional. Rotation policy attached to the
  /// [Secret][google.cloud.secretmanager.v1.Secret]. May be excluded if there is
  /// no rotation policy.
  final Rotation? rotation;

  /// Optional. Mapping from version alias to version name.
  ///
  /// A version alias is a string with a maximum length of 63 characters and can
  /// contain uppercase and lowercase letters, numerals, and the hyphen (`-`)
  /// and underscore ('_') characters. An alias string must start with a
  /// letter and cannot be the string 'latest' or 'NEW'.
  /// No more than 50 aliases can be assigned to a given secret.
  ///
  /// Version-Alias pairs will be viewable via GetSecret and modifiable via
  /// UpdateSecret. Access by alias is only be supported on
  /// GetSecretVersion and AccessSecretVersion.
  final Map<String, int>? versionAliases;

  /// Optional. Custom metadata about the secret.
  ///
  /// Annotations are distinct from various forms of labels.
  /// Annotations exist to allow client tools to store their own state
  /// information without requiring a database.
  ///
  /// Annotation keys must be between 1 and 63 characters long, have a UTF-8
  /// encoding of maximum 128 bytes, begin and end with an alphanumeric character
  /// ([a-z0-9A-Z]), and may have dashes (-), underscores (_), dots (.), and
  /// alphanumerics in between these symbols.
  ///
  /// The total size of annotation keys and values must be less than 16KiB.
  final Map<String, String>? annotations;

  /// Optional. Secret Version TTL after destruction request
  ///
  /// This is a part of the Delayed secret version destroy feature.
  /// For secret with TTL>0, version destruction doesn't happen immediately
  /// on calling destroy instead the version goes to a disabled state and
  /// destruction happens after the TTL expires.
  final Duration? versionDestroyTtl;

  /// Optional. The customer-managed encryption configuration of the Regionalised
  /// Secrets. If no configuration is provided, Google-managed default encryption
  /// is used.
  ///
  /// Updates to the [Secret][google.cloud.secretmanager.v1.Secret] encryption
  /// configuration only apply to
  /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] added
  /// afterwards. They do not apply retroactively to existing
  /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion].
  final CustomerManagedEncryption? customerManagedEncryption;

  Secret({
    this.name,
    this.replication,
    this.createTime,
    this.labels,
    this.topics,
    this.expireTime,
    this.ttl,
    this.etag,
    this.rotation,
    this.versionAliases,
    this.annotations,
    this.versionDestroyTtl,
    this.customerManagedEncryption,
  });

  factory Secret.fromJson(Map<String, dynamic> json) {
    return Secret(
      name: json['name'],
      replication: decode(json['replication'], Replication.fromJson),
      createTime: decode(json['createTime'], Timestamp.fromJson),
      labels: (json['labels'] as Map?)?.cast(),
      topics: decodeList(json['topics'], Topic.fromJson),
      expireTime: decode(json['expireTime'], Timestamp.fromJson),
      ttl: decode(json['ttl'], Duration.fromJson),
      etag: json['etag'],
      rotation: decode(json['rotation'], Rotation.fromJson),
      versionAliases: (json['versionAliases'] as Map?)?.cast(),
      annotations: (json['annotations'] as Map?)?.cast(),
      versionDestroyTtl: decode(json['versionDestroyTtl'], Duration.fromJson),
      customerManagedEncryption: decode(json['customerManagedEncryption'], CustomerManagedEncryption.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (replication != null) 'replication': replication!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (labels != null) 'labels': labels,
      if (topics != null) 'topics': encodeList(topics),
      if (expireTime != null) 'expireTime': expireTime!.toJson(),
      if (ttl != null) 'ttl': ttl!.toJson(),
      if (etag != null) 'etag': etag,
      if (rotation != null) 'rotation': rotation!.toJson(),
      if (versionAliases != null) 'versionAliases': versionAliases,
      if (annotations != null) 'annotations': annotations,
      if (versionDestroyTtl != null) 'versionDestroyTtl': versionDestroyTtl!.toJson(),
      if (customerManagedEncryption != null) 'customerManagedEncryption': customerManagedEncryption!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (etag != null) 'etag=$etag',
    ].join(',');
    return 'Secret($contents)';
  }
}

/// A secret version resource in the Secret Manager API.
class SecretVersion extends Message {
  /// Output only. The resource name of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] in the format
  /// `projects/*/secrets/*/versions/*`.
  ///
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] IDs in a
  /// [Secret][google.cloud.secretmanager.v1.Secret] start at 1 and are
  /// incremented for each subsequent version of the secret.
  final String? name;

  /// Output only. The time at which the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] was created.
  final Timestamp? createTime;

  /// Output only. The time this
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] was destroyed.
  /// Only present if [state][google.cloud.secretmanager.v1.SecretVersion.state]
  /// is
  /// [DESTROYED][google.cloud.secretmanager.v1.SecretVersion.State.DESTROYED].
  final Timestamp? destroyTime;

  /// Output only. The current state of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
  final SecretVersion$State? state;

  /// The replication status of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
  final ReplicationStatus? replicationStatus;

  /// Output only. Etag of the currently stored
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
  final String? etag;

  /// Output only. True if payload checksum specified in
  /// [SecretPayload][google.cloud.secretmanager.v1.SecretPayload] object has
  /// been received by
  /// [SecretManagerService][google.cloud.secretmanager.v1.SecretManagerService]
  /// on
  /// [SecretManagerService.AddSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.AddSecretVersion].
  final bool? clientSpecifiedPayloadChecksum;

  /// Optional. Output only. Scheduled destroy time for secret version.
  /// This is a part of the Delayed secret version destroy feature. For a
  /// Secret with a valid version destroy TTL, when a secert version is
  /// destroyed, the version is moved to disabled state and it is scheduled for
  /// destruction. The version is destroyed only after the
  /// `scheduled_destroy_time`.
  final Timestamp? scheduledDestroyTime;

  /// Output only. The customer-managed encryption status of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion]. Only
  /// populated if customer-managed encryption is used and
  /// [Secret][google.cloud.secretmanager.v1.Secret] is a Regionalised Secret.
  final CustomerManagedEncryptionStatus? customerManagedEncryption;

  SecretVersion({
    this.name,
    this.createTime,
    this.destroyTime,
    this.state,
    this.replicationStatus,
    this.etag,
    this.clientSpecifiedPayloadChecksum,
    this.scheduledDestroyTime,
    this.customerManagedEncryption,
  });

  factory SecretVersion.fromJson(Map<String, dynamic> json) {
    return SecretVersion(
      name: json['name'],
      createTime: decode(json['createTime'], Timestamp.fromJson),
      destroyTime: decode(json['destroyTime'], Timestamp.fromJson),
      state: decode(json['state'], SecretVersion$State.fromJson),
      replicationStatus: decode(json['replicationStatus'], ReplicationStatus.fromJson),
      etag: json['etag'],
      clientSpecifiedPayloadChecksum: json['clientSpecifiedPayloadChecksum'],
      scheduledDestroyTime: decode(json['scheduledDestroyTime'], Timestamp.fromJson),
      customerManagedEncryption: decode(json['customerManagedEncryption'], CustomerManagedEncryptionStatus.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (destroyTime != null) 'destroyTime': destroyTime!.toJson(),
      if (state != null) 'state': state!.toJson(),
      if (replicationStatus != null) 'replicationStatus': replicationStatus!.toJson(),
      if (etag != null) 'etag': etag,
      if (clientSpecifiedPayloadChecksum != null) 'clientSpecifiedPayloadChecksum': clientSpecifiedPayloadChecksum,
      if (scheduledDestroyTime != null) 'scheduledDestroyTime': scheduledDestroyTime!.toJson(),
      if (customerManagedEncryption != null) 'customerManagedEncryption': customerManagedEncryption!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (state != null) 'state=$state',
      if (etag != null) 'etag=$etag',
      if (clientSpecifiedPayloadChecksum != null) 'clientSpecifiedPayloadChecksum=$clientSpecifiedPayloadChecksum',
    ].join(',');
    return 'SecretVersion($contents)';
  }
}

/// The state of a
/// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion], indicating if
/// it can be accessed.
class SecretVersion$State extends Enum {
  /// Not specified. This value is unused and invalid.
  static const stateUnspecified = SecretVersion$State('STATE_UNSPECIFIED');

  /// The [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] may be
  /// accessed.
  static const enabled = SecretVersion$State('ENABLED');

  /// The [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] may not
  /// be accessed, but the secret data is still available and can be placed
  /// back into the
  /// [ENABLED][google.cloud.secretmanager.v1.SecretVersion.State.ENABLED]
  /// state.
  static const disabled = SecretVersion$State('DISABLED');

  /// The [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] is
  /// destroyed and the secret data is no longer stored. A version may not
  /// leave this state once entered.
  static const destroyed = SecretVersion$State('DESTROYED');

  const SecretVersion$State(super.value);

  factory SecretVersion$State.fromJson(String json) => SecretVersion$State(json);

  @override
  bool operator ==(Object other) =>
      other is SecretVersion$State && value == other.value;

  @override
  String toString() => 'State.$value';
}

/// A policy that defines the replication and encryption configuration of data.
class Replication extends Message {
  /// The [Secret][google.cloud.secretmanager.v1.Secret] will automatically be
  /// replicated without any restrictions.
  final Replication$Automatic? automatic;

  /// The [Secret][google.cloud.secretmanager.v1.Secret] will only be
  /// replicated into the locations specified.
  final Replication$UserManaged? userManaged;

  Replication({
    this.automatic,
    this.userManaged,
  });

  factory Replication.fromJson(Map<String, dynamic> json) {
    return Replication(
      automatic: decode(json['automatic'], Replication$Automatic.fromJson),
      userManaged: decode(json['userManaged'], Replication$UserManaged.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (automatic != null) 'automatic': automatic!.toJson(),
      if (userManaged != null) 'userManaged': userManaged!.toJson(),
    };
  }

  @override
  String toString() => 'Replication()';
}

/// A replication policy that replicates the
/// [Secret][google.cloud.secretmanager.v1.Secret] payload without any
/// restrictions.
class Replication$Automatic extends Message {
  /// Optional. The customer-managed encryption configuration of the
  /// [Secret][google.cloud.secretmanager.v1.Secret]. If no configuration is
  /// provided, Google-managed default encryption is used.
  ///
  /// Updates to the [Secret][google.cloud.secretmanager.v1.Secret] encryption
  /// configuration only apply to
  /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] added
  /// afterwards. They do not apply retroactively to existing
  /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion].
  final CustomerManagedEncryption? customerManagedEncryption;

  Replication$Automatic({
    this.customerManagedEncryption,
  });

  factory Replication$Automatic.fromJson(Map<String, dynamic> json) {
    return Replication$Automatic(
      customerManagedEncryption: decode(json['customerManagedEncryption'], CustomerManagedEncryption.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (customerManagedEncryption != null) 'customerManagedEncryption': customerManagedEncryption!.toJson(),
    };
  }

  @override
  String toString() => 'Automatic()';
}

/// A replication policy that replicates the
/// [Secret][google.cloud.secretmanager.v1.Secret] payload into the locations
/// specified in [Secret.replication.user_managed.replicas][]
class Replication$UserManaged extends Message {
  /// Required. The list of Replicas for this
  /// [Secret][google.cloud.secretmanager.v1.Secret].
  ///
  /// Cannot be empty.
  final List<Replication$UserManaged$Replica>? replicas;

  Replication$UserManaged({
    this.replicas,
  });

  factory Replication$UserManaged.fromJson(Map<String, dynamic> json) {
    return Replication$UserManaged(
      replicas: decodeList(json['replicas'], Replication$UserManaged$Replica.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (replicas != null) 'replicas': encodeList(replicas),
    };
  }

  @override
  String toString() => 'UserManaged()';
}

/// Represents a Replica for this
/// [Secret][google.cloud.secretmanager.v1.Secret].
class Replication$UserManaged$Replica extends Message {
  /// The canonical IDs of the location to replicate data.
  /// For example: `"us-east1"`.
  final String? location;

  /// Optional. The customer-managed encryption configuration of the
  /// [User-Managed Replica][Replication.UserManaged.Replica]. If no
  /// configuration is provided, Google-managed default encryption is used.
  ///
  /// Updates to the [Secret][google.cloud.secretmanager.v1.Secret]
  /// encryption configuration only apply to
  /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] added
  /// afterwards. They do not apply retroactively to existing
  /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion].
  final CustomerManagedEncryption? customerManagedEncryption;

  Replication$UserManaged$Replica({
    this.location,
    this.customerManagedEncryption,
  });

  factory Replication$UserManaged$Replica.fromJson(Map<String, dynamic> json) {
    return Replication$UserManaged$Replica(
      location: json['location'],
      customerManagedEncryption: decode(json['customerManagedEncryption'], CustomerManagedEncryption.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (location != null) 'location': location,
      if (customerManagedEncryption != null) 'customerManagedEncryption': customerManagedEncryption!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (location != null) 'location=$location',
    ].join(',');
    return 'Replica($contents)';
  }
}

/// Configuration for encrypting secret payloads using customer-managed
/// encryption keys (CMEK).
class CustomerManagedEncryption extends Message {
  /// Required. The resource name of the Cloud KMS CryptoKey used to encrypt
  /// secret payloads.
  ///
  /// For secrets using the
  /// [UserManaged][google.cloud.secretmanager.v1.Replication.UserManaged]
  /// replication policy type, Cloud KMS CryptoKeys must reside in the same
  /// location as the [replica location][Secret.UserManaged.Replica.location].
  ///
  /// For secrets using the
  /// [Automatic][google.cloud.secretmanager.v1.Replication.Automatic]
  /// replication policy type, Cloud KMS CryptoKeys must reside in `global`.
  ///
  /// The expected format is `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
  final String? kmsKeyName;

  CustomerManagedEncryption({
    this.kmsKeyName,
  });

  factory CustomerManagedEncryption.fromJson(Map<String, dynamic> json) {
    return CustomerManagedEncryption(
      kmsKeyName: json['kmsKeyName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (kmsKeyName != null) 'kmsKeyName': kmsKeyName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (kmsKeyName != null) 'kmsKeyName=$kmsKeyName',
    ].join(',');
    return 'CustomerManagedEncryption($contents)';
  }
}

/// The replication status of a
/// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
class ReplicationStatus extends Message {
  /// Describes the replication status of a
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] with
  /// automatic replication.
  ///
  /// Only populated if the parent
  /// [Secret][google.cloud.secretmanager.v1.Secret] has an automatic
  /// replication policy.
  final ReplicationStatus$AutomaticStatus? automatic;

  /// Describes the replication status of a
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] with
  /// user-managed replication.
  ///
  /// Only populated if the parent
  /// [Secret][google.cloud.secretmanager.v1.Secret] has a user-managed
  /// replication policy.
  final ReplicationStatus$UserManagedStatus? userManaged;

  ReplicationStatus({
    this.automatic,
    this.userManaged,
  });

  factory ReplicationStatus.fromJson(Map<String, dynamic> json) {
    return ReplicationStatus(
      automatic: decode(json['automatic'], ReplicationStatus$AutomaticStatus.fromJson),
      userManaged: decode(json['userManaged'], ReplicationStatus$UserManagedStatus.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (automatic != null) 'automatic': automatic!.toJson(),
      if (userManaged != null) 'userManaged': userManaged!.toJson(),
    };
  }

  @override
  String toString() => 'ReplicationStatus()';
}

/// The replication status of a
/// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] using
/// automatic replication.
///
/// Only populated if the parent [Secret][google.cloud.secretmanager.v1.Secret]
/// has an automatic replication policy.
class ReplicationStatus$AutomaticStatus extends Message {
  /// Output only. The customer-managed encryption status of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion]. Only
  /// populated if customer-managed encryption is used.
  final CustomerManagedEncryptionStatus? customerManagedEncryption;

  ReplicationStatus$AutomaticStatus({
    this.customerManagedEncryption,
  });

  factory ReplicationStatus$AutomaticStatus.fromJson(Map<String, dynamic> json) {
    return ReplicationStatus$AutomaticStatus(
      customerManagedEncryption: decode(json['customerManagedEncryption'], CustomerManagedEncryptionStatus.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (customerManagedEncryption != null) 'customerManagedEncryption': customerManagedEncryption!.toJson(),
    };
  }

  @override
  String toString() => 'AutomaticStatus()';
}

/// The replication status of a
/// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] using
/// user-managed replication.
///
/// Only populated if the parent [Secret][google.cloud.secretmanager.v1.Secret]
/// has a user-managed replication policy.
class ReplicationStatus$UserManagedStatus extends Message {
  /// Output only. The list of replica statuses for the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
  final List<ReplicationStatus$UserManagedStatus$ReplicaStatus>? replicas;

  ReplicationStatus$UserManagedStatus({
    this.replicas,
  });

  factory ReplicationStatus$UserManagedStatus.fromJson(Map<String, dynamic> json) {
    return ReplicationStatus$UserManagedStatus(
      replicas: decodeList(json['replicas'], ReplicationStatus$UserManagedStatus$ReplicaStatus.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (replicas != null) 'replicas': encodeList(replicas),
    };
  }

  @override
  String toString() => 'UserManagedStatus()';
}

/// Describes the status of a user-managed replica for the
/// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
class ReplicationStatus$UserManagedStatus$ReplicaStatus extends Message {
  /// Output only. The canonical ID of the replica location.
  /// For example: `"us-east1"`.
  final String? location;

  /// Output only. The customer-managed encryption status of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion]. Only
  /// populated if customer-managed encryption is used.
  final CustomerManagedEncryptionStatus? customerManagedEncryption;

  ReplicationStatus$UserManagedStatus$ReplicaStatus({
    this.location,
    this.customerManagedEncryption,
  });

  factory ReplicationStatus$UserManagedStatus$ReplicaStatus.fromJson(Map<String, dynamic> json) {
    return ReplicationStatus$UserManagedStatus$ReplicaStatus(
      location: json['location'],
      customerManagedEncryption: decode(json['customerManagedEncryption'], CustomerManagedEncryptionStatus.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (location != null) 'location': location,
      if (customerManagedEncryption != null) 'customerManagedEncryption': customerManagedEncryption!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (location != null) 'location=$location',
    ].join(',');
    return 'ReplicaStatus($contents)';
  }
}

/// Describes the status of customer-managed encryption.
class CustomerManagedEncryptionStatus extends Message {
  /// Required. The resource name of the Cloud KMS CryptoKeyVersion used to
  /// encrypt the secret payload, in the following format:
  /// `projects/*/locations/*/keyRings/*/cryptoKeys/*/versions/*`.
  final String? kmsKeyVersionName;

  CustomerManagedEncryptionStatus({
    this.kmsKeyVersionName,
  });

  factory CustomerManagedEncryptionStatus.fromJson(Map<String, dynamic> json) {
    return CustomerManagedEncryptionStatus(
      kmsKeyVersionName: json['kmsKeyVersionName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (kmsKeyVersionName != null) 'kmsKeyVersionName': kmsKeyVersionName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (kmsKeyVersionName != null) 'kmsKeyVersionName=$kmsKeyVersionName',
    ].join(',');
    return 'CustomerManagedEncryptionStatus($contents)';
  }
}

/// A Pub/Sub topic which Secret Manager will publish to when control plane
/// events occur on this secret.
class Topic extends Message {
  /// Required. The resource name of the Pub/Sub topic that will be published to,
  /// in the following format: `projects/*/topics/*`. For publication to succeed,
  /// the Secret Manager service agent must have the `pubsub.topic.publish`
  /// permission on the topic. The Pub/Sub Publisher role
  /// (`roles/pubsub.publisher`) includes this permission.
  final String? name;

  Topic({
    this.name,
  });

  factory Topic.fromJson(Map<String, dynamic> json) {
    return Topic(
      name: json['name'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
    ].join(',');
    return 'Topic($contents)';
  }
}

/// The rotation time and period for a
/// [Secret][google.cloud.secretmanager.v1.Secret]. At next_rotation_time, Secret
/// Manager will send a Pub/Sub notification to the topics configured on the
/// Secret. [Secret.topics][google.cloud.secretmanager.v1.Secret.topics] must be
/// set to configure rotation.
class Rotation extends Message {
  /// Optional. Timestamp in UTC at which the
  /// [Secret][google.cloud.secretmanager.v1.Secret] is scheduled to rotate.
  /// Cannot be set to less than 300s (5 min) in the future and at most
  /// 3153600000s (100 years).
  ///
  /// [next_rotation_time][google.cloud.secretmanager.v1.Rotation.next_rotation_time]
  /// MUST  be set if
  /// [rotation_period][google.cloud.secretmanager.v1.Rotation.rotation_period]
  /// is set.
  final Timestamp? nextRotationTime;

  /// Input only. The Duration between rotation notifications. Must be in seconds
  /// and at least 3600s (1h) and at most 3153600000s (100 years).
  ///
  /// If
  /// [rotation_period][google.cloud.secretmanager.v1.Rotation.rotation_period]
  /// is set,
  /// [next_rotation_time][google.cloud.secretmanager.v1.Rotation.next_rotation_time]
  /// must be set.
  /// [next_rotation_time][google.cloud.secretmanager.v1.Rotation.next_rotation_time]
  /// will be advanced by this period when the service automatically sends
  /// rotation notifications.
  final Duration? rotationPeriod;

  Rotation({
    this.nextRotationTime,
    this.rotationPeriod,
  });

  factory Rotation.fromJson(Map<String, dynamic> json) {
    return Rotation(
      nextRotationTime: decode(json['nextRotationTime'], Timestamp.fromJson),
      rotationPeriod: decode(json['rotationPeriod'], Duration.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (nextRotationTime != null) 'nextRotationTime': nextRotationTime!.toJson(),
      if (rotationPeriod != null) 'rotationPeriod': rotationPeriod!.toJson(),
    };
  }

  @override
  String toString() => 'Rotation()';
}

/// A secret payload resource in the Secret Manager API. This contains the
/// sensitive secret payload that is associated with a
/// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
class SecretPayload extends Message {
  /// The secret data. Must be no larger than 64KiB.
  final Uint8List? data;

  /// Optional. If specified,
  /// [SecretManagerService][google.cloud.secretmanager.v1.SecretManagerService]
  /// will verify the integrity of the received
  /// [data][google.cloud.secretmanager.v1.SecretPayload.data] on
  /// [SecretManagerService.AddSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.AddSecretVersion]
  /// calls using the crc32c checksum and store it to include in future
  /// [SecretManagerService.AccessSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.AccessSecretVersion]
  /// responses. If a checksum is not provided in the
  /// [SecretManagerService.AddSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.AddSecretVersion]
  /// request, the
  /// [SecretManagerService][google.cloud.secretmanager.v1.SecretManagerService]
  /// will generate and store one for you.
  ///
  /// The CRC32C value is encoded as a Int64 for compatibility, and can be
  /// safely downconverted to uint32 in languages that support this type.
  /// https://cloud.google.com/apis/design/design_patterns#integer_types
  final int? dataCrc32C;

  SecretPayload({
    this.data,
    this.dataCrc32C,
  });

  factory SecretPayload.fromJson(Map<String, dynamic> json) {
    return SecretPayload(
      data: json['data'],
      dataCrc32C: json['dataCrc32C'],
    );
  }

  @override
  Object toJson() {
    return {
      if (data != null) 'data': data,
      if (dataCrc32C != null) 'dataCrc32C': dataCrc32C,
    };
  }

  @override
  String toString() {
    final contents = [
      if (data != null) 'data=$data',
      if (dataCrc32C != null) 'dataCrc32C=$dataCrc32C',
    ].join(',');
    return 'SecretPayload($contents)';
  }
}

/// Request message for
/// [SecretManagerService.ListSecrets][google.cloud.secretmanager.v1.SecretManagerService.ListSecrets].
class ListSecretsRequest extends Message {
  /// Required. The resource name of the project associated with the
  /// [Secrets][google.cloud.secretmanager.v1.Secret], in the format `projects/*`
  /// or `projects/*/locations/*`
  final String parent;

  /// Optional. The maximum number of results to be returned in a single page. If
  /// set to 0, the server decides the number of results to return. If the
  /// number is greater than 25000, it is capped at 25000.
  final int? pageSize;

  /// Optional. Pagination token, returned earlier via
  /// [ListSecretsResponse.next_page_token][google.cloud.secretmanager.v1.ListSecretsResponse.next_page_token].
  final String? pageToken;

  /// Optional. Filter string, adhering to the rules in
  /// [List-operation
  /// filtering](https://cloud.google.com/secret-manager/docs/filtering). List
  /// only secrets matching the filter. If filter is empty, all secrets are
  /// listed.
  final String? filter;

  ListSecretsRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
    this.filter,
  });

  factory ListSecretsRequest.fromJson(Map<String, dynamic> json) {
    return ListSecretsRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      filter: json['filter'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (filter != null) 'filter': filter,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (filter != null) 'filter=$filter',
    ].join(',');
    return 'ListSecretsRequest($contents)';
  }
}

/// Response message for
/// [SecretManagerService.ListSecrets][google.cloud.secretmanager.v1.SecretManagerService.ListSecrets].
class ListSecretsResponse extends Message {
  /// The list of [Secrets][google.cloud.secretmanager.v1.Secret] sorted in
  /// reverse by create_time (newest first).
  final List<Secret>? secrets;

  /// A token to retrieve the next page of results. Pass this value in
  /// [ListSecretsRequest.page_token][google.cloud.secretmanager.v1.ListSecretsRequest.page_token]
  /// to retrieve the next page.
  final String? nextPageToken;

  /// The total number of [Secrets][google.cloud.secretmanager.v1.Secret] but 0
  /// when the
  /// [ListSecretsRequest.filter][google.cloud.secretmanager.v1.ListSecretsRequest.filter]
  /// field is set.
  final int? totalSize;

  ListSecretsResponse({
    this.secrets,
    this.nextPageToken,
    this.totalSize,
  });

  factory ListSecretsResponse.fromJson(Map<String, dynamic> json) {
    return ListSecretsResponse(
      secrets: decodeList(json['secrets'], Secret.fromJson),
      nextPageToken: json['nextPageToken'],
      totalSize: json['totalSize'],
    );
  }

  @override
  Object toJson() {
    return {
      if (secrets != null) 'secrets': encodeList(secrets),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
      if (totalSize != null) 'totalSize': totalSize,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
      if (totalSize != null) 'totalSize=$totalSize',
    ].join(',');
    return 'ListSecretsResponse($contents)';
  }
}

/// Request message for
/// [SecretManagerService.CreateSecret][google.cloud.secretmanager.v1.SecretManagerService.CreateSecret].
class CreateSecretRequest extends Message {
  /// Required. The resource name of the project to associate with the
  /// [Secret][google.cloud.secretmanager.v1.Secret], in the format `projects/*`
  /// or `projects/*/locations/*`.
  final String parent;

  /// Required. This must be unique within the project.
  ///
  /// A secret ID is a string with a maximum length of 255 characters and can
  /// contain uppercase and lowercase letters, numerals, and the hyphen (`-`) and
  /// underscore (`_`) characters.
  final String? secretId;

  /// Required. A [Secret][google.cloud.secretmanager.v1.Secret] with initial
  /// field values.
  final Secret secret;

  CreateSecretRequest({
    required this.parent,
    this.secretId,
    required this.secret,
  });

  factory CreateSecretRequest.fromJson(Map<String, dynamic> json) {
    return CreateSecretRequest(
      parent: json['parent'],
      secretId: json['secretId'],
      secret: Secret.fromJson(json['secret']),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (secretId != null) 'secretId': secretId,
      'secret': secret.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (secretId != null) 'secretId=$secretId',
    ].join(',');
    return 'CreateSecretRequest($contents)';
  }
}

/// Request message for
/// [SecretManagerService.AddSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.AddSecretVersion].
class AddSecretVersionRequest extends Message {
  /// Required. The resource name of the
  /// [Secret][google.cloud.secretmanager.v1.Secret] to associate with the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] in the format
  /// `projects/*/secrets/*` or `projects/*/locations/*/secrets/*`.
  final String parent;

  /// Required. The secret payload of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
  final SecretPayload? payload;

  AddSecretVersionRequest({
    required this.parent,
    this.payload,
  });

  factory AddSecretVersionRequest.fromJson(Map<String, dynamic> json) {
    return AddSecretVersionRequest(
      parent: json['parent'],
      payload: decode(json['payload'], SecretPayload.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (payload != null) 'payload': payload!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
    ].join(',');
    return 'AddSecretVersionRequest($contents)';
  }
}

/// Request message for
/// [SecretManagerService.GetSecret][google.cloud.secretmanager.v1.SecretManagerService.GetSecret].
class GetSecretRequest extends Message {
  /// Required. The resource name of the
  /// [Secret][google.cloud.secretmanager.v1.Secret], in the format
  /// `projects/*/secrets/*` or `projects/*/locations/*/secrets/*`.
  final String name;

  GetSecretRequest({
    required this.name,
  });

  factory GetSecretRequest.fromJson(Map<String, dynamic> json) {
    return GetSecretRequest(
      name: json['name'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
    ].join(',');
    return 'GetSecretRequest($contents)';
  }
}

/// Request message for
/// [SecretManagerService.ListSecretVersions][google.cloud.secretmanager.v1.SecretManagerService.ListSecretVersions].
class ListSecretVersionsRequest extends Message {
  /// Required. The resource name of the
  /// [Secret][google.cloud.secretmanager.v1.Secret] associated with the
  /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] to list, in
  /// the format `projects/*/secrets/*` or `projects/*/locations/*/secrets/*`.
  final String parent;

  /// Optional. The maximum number of results to be returned in a single page. If
  /// set to 0, the server decides the number of results to return. If the
  /// number is greater than 25000, it is capped at 25000.
  final int? pageSize;

  /// Optional. Pagination token, returned earlier via
  /// ListSecretVersionsResponse.next_page_token][].
  final String? pageToken;

  /// Optional. Filter string, adhering to the rules in
  /// [List-operation
  /// filtering](https://cloud.google.com/secret-manager/docs/filtering). List
  /// only secret versions matching the filter. If filter is empty, all secret
  /// versions are listed.
  final String? filter;

  ListSecretVersionsRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
    this.filter,
  });

  factory ListSecretVersionsRequest.fromJson(Map<String, dynamic> json) {
    return ListSecretVersionsRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      filter: json['filter'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (filter != null) 'filter': filter,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (filter != null) 'filter=$filter',
    ].join(',');
    return 'ListSecretVersionsRequest($contents)';
  }
}

/// Response message for
/// [SecretManagerService.ListSecretVersions][google.cloud.secretmanager.v1.SecretManagerService.ListSecretVersions].
class ListSecretVersionsResponse extends Message {
  /// The list of [SecretVersions][google.cloud.secretmanager.v1.SecretVersion]
  /// sorted in reverse by create_time (newest first).
  final List<SecretVersion>? versions;

  /// A token to retrieve the next page of results. Pass this value in
  /// [ListSecretVersionsRequest.page_token][google.cloud.secretmanager.v1.ListSecretVersionsRequest.page_token]
  /// to retrieve the next page.
  final String? nextPageToken;

  /// The total number of
  /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] but 0 when
  /// the
  /// [ListSecretsRequest.filter][google.cloud.secretmanager.v1.ListSecretsRequest.filter]
  /// field is set.
  final int? totalSize;

  ListSecretVersionsResponse({
    this.versions,
    this.nextPageToken,
    this.totalSize,
  });

  factory ListSecretVersionsResponse.fromJson(Map<String, dynamic> json) {
    return ListSecretVersionsResponse(
      versions: decodeList(json['versions'], SecretVersion.fromJson),
      nextPageToken: json['nextPageToken'],
      totalSize: json['totalSize'],
    );
  }

  @override
  Object toJson() {
    return {
      if (versions != null) 'versions': encodeList(versions),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
      if (totalSize != null) 'totalSize': totalSize,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
      if (totalSize != null) 'totalSize=$totalSize',
    ].join(',');
    return 'ListSecretVersionsResponse($contents)';
  }
}

/// Request message for
/// [SecretManagerService.GetSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.GetSecretVersion].
class GetSecretVersionRequest extends Message {
  /// Required. The resource name of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] in the format
  /// `projects/*/secrets/*/versions/*` or
  /// `projects/*/locations/*/secrets/*/versions/*`.
  ///
  /// `projects/*/secrets/*/versions/latest` or
  /// `projects/*/locations/*/secrets/*/versions/latest` is an alias to the most
  /// recently created
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
  final String name;

  GetSecretVersionRequest({
    required this.name,
  });

  factory GetSecretVersionRequest.fromJson(Map<String, dynamic> json) {
    return GetSecretVersionRequest(
      name: json['name'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
    ].join(',');
    return 'GetSecretVersionRequest($contents)';
  }
}

/// Request message for
/// [SecretManagerService.UpdateSecret][google.cloud.secretmanager.v1.SecretManagerService.UpdateSecret].
class UpdateSecretRequest extends Message {
  /// Required. [Secret][google.cloud.secretmanager.v1.Secret] with updated field
  /// values.
  final Secret secret;

  /// Required. Specifies the fields to be updated.
  final FieldMask? updateMask;

  UpdateSecretRequest({
    required this.secret,
    this.updateMask,
  });

  factory UpdateSecretRequest.fromJson(Map<String, dynamic> json) {
    return UpdateSecretRequest(
      secret: Secret.fromJson(json['secret']),
      updateMask: decode(json['updateMask'], FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'secret': secret.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateSecretRequest()';
}

/// Request message for
/// [SecretManagerService.AccessSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.AccessSecretVersion].
class AccessSecretVersionRequest extends Message {
  /// Required. The resource name of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] in the format
  /// `projects/*/secrets/*/versions/*` or
  /// `projects/*/locations/*/secrets/*/versions/*`.
  ///
  /// `projects/*/secrets/*/versions/latest` or
  /// `projects/*/locations/*/secrets/*/versions/latest` is an alias to the most
  /// recently created
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
  final String name;

  AccessSecretVersionRequest({
    required this.name,
  });

  factory AccessSecretVersionRequest.fromJson(Map<String, dynamic> json) {
    return AccessSecretVersionRequest(
      name: json['name'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
    ].join(',');
    return 'AccessSecretVersionRequest($contents)';
  }
}

/// Response message for
/// [SecretManagerService.AccessSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.AccessSecretVersion].
class AccessSecretVersionResponse extends Message {
  /// The resource name of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] in the format
  /// `projects/*/secrets/*/versions/*` or
  /// `projects/*/locations/*/secrets/*/versions/*`.
  final String? name;

  /// Secret payload
  final SecretPayload? payload;

  AccessSecretVersionResponse({
    this.name,
    this.payload,
  });

  factory AccessSecretVersionResponse.fromJson(Map<String, dynamic> json) {
    return AccessSecretVersionResponse(
      name: json['name'],
      payload: decode(json['payload'], SecretPayload.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (payload != null) 'payload': payload!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
    ].join(',');
    return 'AccessSecretVersionResponse($contents)';
  }
}

/// Request message for
/// [SecretManagerService.DeleteSecret][google.cloud.secretmanager.v1.SecretManagerService.DeleteSecret].
class DeleteSecretRequest extends Message {
  /// Required. The resource name of the
  /// [Secret][google.cloud.secretmanager.v1.Secret] to delete in the format
  /// `projects/*/secrets/*`.
  final String name;

  /// Optional. Etag of the [Secret][google.cloud.secretmanager.v1.Secret]. The
  /// request succeeds if it matches the etag of the currently stored secret
  /// object. If the etag is omitted, the request succeeds.
  final String? etag;

  DeleteSecretRequest({
    required this.name,
    this.etag,
  });

  factory DeleteSecretRequest.fromJson(Map<String, dynamic> json) {
    return DeleteSecretRequest(
      name: json['name'],
      etag: json['etag'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (etag != null) 'etag': etag,
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (etag != null) 'etag=$etag',
    ].join(',');
    return 'DeleteSecretRequest($contents)';
  }
}

/// Request message for
/// [SecretManagerService.DisableSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.DisableSecretVersion].
class DisableSecretVersionRequest extends Message {
  /// Required. The resource name of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] to disable in
  /// the format `projects/*/secrets/*/versions/*` or
  /// `projects/*/locations/*/secrets/*/versions/*`.
  final String name;

  /// Optional. Etag of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion]. The request
  /// succeeds if it matches the etag of the currently stored secret version
  /// object. If the etag is omitted, the request succeeds.
  final String? etag;

  DisableSecretVersionRequest({
    required this.name,
    this.etag,
  });

  factory DisableSecretVersionRequest.fromJson(Map<String, dynamic> json) {
    return DisableSecretVersionRequest(
      name: json['name'],
      etag: json['etag'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (etag != null) 'etag': etag,
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (etag != null) 'etag=$etag',
    ].join(',');
    return 'DisableSecretVersionRequest($contents)';
  }
}

/// Request message for
/// [SecretManagerService.EnableSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.EnableSecretVersion].
class EnableSecretVersionRequest extends Message {
  /// Required. The resource name of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] to enable in
  /// the format `projects/*/secrets/*/versions/*` or
  /// `projects/*/locations/*/secrets/*/versions/*`.
  final String name;

  /// Optional. Etag of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion]. The request
  /// succeeds if it matches the etag of the currently stored secret version
  /// object. If the etag is omitted, the request succeeds.
  final String? etag;

  EnableSecretVersionRequest({
    required this.name,
    this.etag,
  });

  factory EnableSecretVersionRequest.fromJson(Map<String, dynamic> json) {
    return EnableSecretVersionRequest(
      name: json['name'],
      etag: json['etag'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (etag != null) 'etag': etag,
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (etag != null) 'etag=$etag',
    ].join(',');
    return 'EnableSecretVersionRequest($contents)';
  }
}

/// Request message for
/// [SecretManagerService.DestroySecretVersion][google.cloud.secretmanager.v1.SecretManagerService.DestroySecretVersion].
class DestroySecretVersionRequest extends Message {
  /// Required. The resource name of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] to destroy in
  /// the format `projects/*/secrets/*/versions/*` or
  /// `projects/*/locations/*/secrets/*/versions/*`.
  final String name;

  /// Optional. Etag of the
  /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion]. The request
  /// succeeds if it matches the etag of the currently stored secret version
  /// object. If the etag is omitted, the request succeeds.
  final String? etag;

  DestroySecretVersionRequest({
    required this.name,
    this.etag,
  });

  factory DestroySecretVersionRequest.fromJson(Map<String, dynamic> json) {
    return DestroySecretVersionRequest(
      name: json['name'],
      etag: json['etag'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (etag != null) 'etag': etag,
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (etag != null) 'etag=$etag',
    ].join(',');
    return 'DestroySecretVersionRequest($contents)';
  }
}
