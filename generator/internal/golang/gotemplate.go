// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package golang

import (
	"fmt"
	"strings"

	"github.com/googleapis/google-cloud-rust/generator/internal/api"
	"github.com/googleapis/google-cloud-rust/generator/internal/language"
	"github.com/googleapis/google-cloud-rust/generator/internal/license"
	"github.com/iancoleman/strcase"
)

type templateData struct {
	Name              string
	Title             string
	Description       string
	PackageName       string
	SourcePackageName string
	HasServices       bool
	CopyrightYear     string
	BoilerPlate       []string
	Imports           []string
	DefaultHost       string
	Services          []*service
	Messages          []*api.Message
	Enums             []*api.Enum
	GoPackage         string
}

type service struct {
	Methods             []*method
	NameToPascal        string
	ServiceNameToPascal string
	NameToCamel         string
	ServiceName         string
	DocLines            []string
	DefaultHost         string
}

type messageAnnotation struct {
	Name           string
	QualifiedName  string
	HasNestedTypes bool
	DocLines       []string
	// The FQN is the source specification
	SourceFQN   string
	BasicFields []*api.Field
}

type method struct {
	NameToCamel         string
	NameToPascal        string
	DocLines            []string
	InputTypeName       string
	OutputTypeName      string
	PathInfo            *api.PathInfo
	PathParams          []*api.Field
	QueryParams         []*api.Field
	BodyAccessor        string
	IsPageable          bool
	ServiceNameToPascal string
	ServiceNameToCamel  string
	InputTypeID         string
	InputType           *api.Message
	OperationInfo       *operationInfo
}

type pathInfoAnnotation struct {
	Method      string
	PathFmt     string
	PathArgs    []string
	HasPathArgs bool
	HasBody     bool
}

type operationInfo struct {
	MetadataType string
	ResponseType string
}

type oneOfAnnotation struct {
	Name     string
	DocLines []string
}

type fieldAnnotation struct {
	Name             string
	DocLines         []string
	FieldType        string
	AsQueryParameter string
}

type enumAnnotation struct {
	Name     string
	DocLines []string
}

type enumValueAnnotation struct {
	DocLines []string
	Name     string
	EnumType string
}

// newTemplateData creates a struct used as input for Mustache templates.
// Fields and methods defined in this struct directly correspond to Mustache
// tags. For example, the Mustache tag {{#Services}} uses the
// [Template.Services] field.
func newTemplateData(model *api.API, options map[string]string) (*templateData, error) {
	var (
		sourceSpecificationPackageName string
		packageNameOverride            string
		packageName                    string
		generationYear                 string
		importMap                      = map[string]*goImport{}
	)

	for key, definition := range options {
		switch {
		case key == "package-name-override":
			packageNameOverride = definition
		case key == "go-package-name":
			packageName = definition
		case key == "copyright-year":
			generationYear = definition
		case strings.HasPrefix(key, "import-mapping"):
			keys := strings.Split(key, ":")
			if len(keys) != 2 {
				return nil, fmt.Errorf("key should be in the format import-mapping:proto.path, got=%q", key)
			}
			defs := strings.Split(definition, ";")
			if len(defs) != 2 {
				return nil, fmt.Errorf("%s should be in the format path;name, got=%q", definition, keys[1])
			}
			importMap[keys[1]] = &goImport{
				path: defs[0],
				name: defs[1],
			}
		}
	}
	validateModel(model, sourceSpecificationPackageName)

	loadWellKnownTypes(model.State)
	for _, e := range model.State.EnumByID {
		annotateEnum(e, model.State, importMap)
	}
	for _, m := range model.State.MessageByID {
		annotateMessage(m, model.State, importMap)
	}
	data := &templateData{
		Name:              model.Name,
		Title:             model.Title,
		Description:       model.Description,
		PackageName:       modelPackageName(model, packageNameOverride),
		SourcePackageName: sourceSpecificationPackageName,
		HasServices:       len(model.Services) > 0,
		CopyrightYear:     generationYear,
		BoilerPlate: append(license.LicenseHeaderBulk(),
			"",
			" Code generated by sidekick. DO NOT EDIT."),
		Imports: imports(importMap),
		DefaultHost: func() string {
			if len(model.Services) > 0 {
				return model.Services[0].DefaultHost
			}
			return ""
		}(),
		Services: language.MapSlice(model.Services, func(s *api.Service) *service {
			return newService(s, model.State)
		}),
		Messages:  model.Messages,
		Enums:     model.Enums,
		GoPackage: packageName,
	}

	for _, s := range data.Services {
		for _, method := range s.Methods {
			if m, ok := model.State.MessageByID[method.InputTypeID]; ok {
				method.InputType = m
			}
		}
	}
	return data, nil
}

func newService(s *api.Service, state *api.APIState) *service {
	// Some codecs skip some methods.
	methods := language.FilterSlice(s.Methods, func(m *api.Method) bool {
		return generateMethod(m)
	})
	return &service{
		Methods: language.MapSlice(methods, func(m *api.Method) *method {
			return newMethod(m, s, state)
		}),
		NameToPascal:        toPascal(s.Name),
		ServiceNameToPascal: toPascal(s.Name), // Alias for clarity
		NameToCamel:         strcase.ToLowerCamel(s.Name),
		ServiceName:         s.Name,
		DocLines:            formatDocComments(s.Documentation, state),
		DefaultHost:         s.DefaultHost,
	}
}

func annotateMessage(m *api.Message, state *api.APIState, importMap map[string]*goImport) {
	for _, f := range m.Fields {
		annotateField(f, state, importMap)
	}
	for _, f := range m.OneOfs {
		annotateOneOf(f, state)
	}
	m.Codec = &messageAnnotation{
		Name:           messageName(m, importMap),
		QualifiedName:  messageName(m, importMap),
		HasNestedTypes: language.HasNestedTypes(m),
		DocLines:       formatDocComments(m.Documentation, state),
		SourceFQN:      strings.TrimPrefix(m.ID, "."),
		BasicFields: language.FilterSlice(m.Fields, func(s *api.Field) bool {
			return !s.IsOneOf
		}),
	}
}

func newMethod(m *api.Method, s *api.Service, state *api.APIState) *method {
	pathInfoAnnotation := &pathInfoAnnotation{
		Method:   m.PathInfo.Verb,
		PathFmt:  httpPathFmt(m.PathInfo),
		PathArgs: httpPathArgs(m.PathInfo),
		HasBody:  m.PathInfo.BodyFieldPath != "",
	}
	m.PathInfo.Codec = pathInfoAnnotation
	method := &method{
		BodyAccessor:        bodyAccessor(m),
		DocLines:            formatDocComments(m.Documentation, state),
		PathInfo:            m.PathInfo,
		InputTypeName:       methodInOutTypeName(m.InputTypeID, state),
		NameToCamel:         strcase.ToCamel(m.Name),
		NameToPascal:        toPascal(m.Name),
		OutputTypeName:      methodInOutTypeName(m.OutputTypeID, state),
		PathParams:          language.PathParams(m, state),
		QueryParams:         language.QueryParams(m, state),
		IsPageable:          m.IsPageable,
		ServiceNameToPascal: toPascal(s.Name),
		InputTypeID:         m.InputTypeID,
	}
	if m.OperationInfo != nil {
		method.OperationInfo = &operationInfo{
			MetadataType: methodInOutTypeName(m.OperationInfo.MetadataTypeID, state),
			ResponseType: methodInOutTypeName(m.OperationInfo.ResponseTypeID, state),
		}
	}
	return method
}

func annotateOneOf(field *api.OneOf, state *api.APIState) {
	field.Codec = &oneOfAnnotation{
		Name:     toPascal(field.Name),
		DocLines: formatDocComments(field.Documentation, state),
	}
}

func annotateField(field *api.Field, state *api.APIState, importMap map[string]*goImport) {
	field.Codec = &fieldAnnotation{
		Name:             toPascal(field.Name),
		DocLines:         formatDocComments(field.Documentation, state),
		FieldType:        fieldType(field, state, importMap),
		AsQueryParameter: asQueryParameter(field),
	}
}

func annotateEnum(e *api.Enum, state *api.APIState, importMap map[string]*goImport) {
	for _, ev := range e.Values {
		annotateEnumValue(ev, e, state, importMap)
	}
	e.Codec = &enumAnnotation{
		Name:     enumName(e, importMap),
		DocLines: formatDocComments(e.Documentation, state),
	}
}

func annotateEnumValue(ev *api.EnumValue, e *api.Enum, state *api.APIState, importMap map[string]*goImport) {
	ev.Codec = &enumValueAnnotation{
		DocLines: formatDocComments(ev.Documentation, state),
		Name:     enumValueName(ev, importMap),
		EnumType: enumName(e, importMap),
	}
}
