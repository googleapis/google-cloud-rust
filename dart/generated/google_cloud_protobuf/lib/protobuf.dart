// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Core Protobuf Types.
///
/// Core Protobuf types used by most services.
library;

import 'package:google_cloud_gax/gax.dart';
import 'package:google_cloud_gax/src/encoding.dart';

part 'src/protobuf.p.dart';

/// Api is a light-weight descriptor for an API Interface.
///
/// Interfaces are also described as "protocol buffer services" in some contexts,
/// such as by the "service" keyword in a .proto file, but they are different
/// from API Services, which represent a concrete implementation of an interface
/// as opposed to simply a description of methods and bindings. They are also
/// sometimes simply referred to as "APIs" in other contexts, such as the name of
/// this message itself. See https://cloud.google.com/apis/design/glossary for
/// detailed terminology.
class Api extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.Api';

  /// The fully qualified name of this interface, including package name
  /// followed by the interface's simple name.
  final String? name;

  /// The methods of this interface, in unspecified order.
  final List<Method>? methods;

  /// Any metadata attached to the interface.
  final List<Option>? options;

  /// A version string for this interface. If specified, must have the form
  /// `major-version.minor-version`, as in `1.10`. If the minor version is
  /// omitted, it defaults to zero. If the entire version field is empty, the
  /// major version is derived from the package name, as outlined below. If the
  /// field is not empty, the version in the package name will be verified to be
  /// consistent with what is provided here.
  ///
  /// The versioning schema uses [semantic
  /// versioning](http://semver.org) where the major version number
  /// indicates a breaking change and the minor version an additive,
  /// non-breaking change. Both version numbers are signals to users
  /// what to expect from different versions, and should be carefully
  /// chosen based on the product plan.
  ///
  /// The major version is also reflected in the package name of the
  /// interface, which must end in `v<major-version>`, as in
  /// `google.feature.v1`. For major versions 0 and 1, the suffix can
  /// be omitted. Zero major versions must only be used for
  /// experimental, non-GA interfaces.
  final String? version;

  /// Source context for the protocol buffer service represented by this
  /// message.
  final SourceContext? sourceContext;

  /// Included interfaces. See `Mixin`.
  final List<Mixin>? mixins;

  /// The source syntax of the service.
  final Syntax? syntax;

  Api({
    this.name,
    this.methods,
    this.options,
    this.version,
    this.sourceContext,
    this.mixins,
    this.syntax,
  }) : super(fullyQualifiedName);

  factory Api.fromJson(Map<String, dynamic> json) {
    return Api(
      name: json['name'],
      methods: decodeListMessage(json['methods'], Method.fromJson),
      options: decodeListMessage(json['options'], Option.fromJson),
      version: json['version'],
      sourceContext: decode(json['sourceContext'], SourceContext.fromJson),
      mixins: decodeListMessage(json['mixins'], Mixin.fromJson),
      syntax: decodeEnum(json['syntax'], Syntax.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (methods != null) 'methods': encodeList(methods),
      if (options != null) 'options': encodeList(options),
      if (version != null) 'version': version,
      if (sourceContext != null) 'sourceContext': sourceContext!.toJson(),
      if (mixins != null) 'mixins': encodeList(mixins),
      if (syntax != null) 'syntax': syntax!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (version != null) 'version=$version',
      if (syntax != null) 'syntax=$syntax',
    ].join(',');
    return 'Api($contents)';
  }
}

/// Method represents a method of an API interface.
class Method extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.Method';

  /// The simple name of this method.
  final String? name;

  /// A URL of the input message type.
  final String? requestTypeUrl;

  /// If true, the request is streamed.
  final bool? requestStreaming;

  /// The URL of the output message type.
  final String? responseTypeUrl;

  /// If true, the response is streamed.
  final bool? responseStreaming;

  /// Any metadata attached to the method.
  final List<Option>? options;

  /// The source syntax of this method.
  final Syntax? syntax;

  Method({
    this.name,
    this.requestTypeUrl,
    this.requestStreaming,
    this.responseTypeUrl,
    this.responseStreaming,
    this.options,
    this.syntax,
  }) : super(fullyQualifiedName);

  factory Method.fromJson(Map<String, dynamic> json) {
    return Method(
      name: json['name'],
      requestTypeUrl: json['requestTypeUrl'],
      requestStreaming: json['requestStreaming'],
      responseTypeUrl: json['responseTypeUrl'],
      responseStreaming: json['responseStreaming'],
      options: decodeListMessage(json['options'], Option.fromJson),
      syntax: decodeEnum(json['syntax'], Syntax.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (requestTypeUrl != null) 'requestTypeUrl': requestTypeUrl,
      if (requestStreaming != null) 'requestStreaming': requestStreaming,
      if (responseTypeUrl != null) 'responseTypeUrl': responseTypeUrl,
      if (responseStreaming != null) 'responseStreaming': responseStreaming,
      if (options != null) 'options': encodeList(options),
      if (syntax != null) 'syntax': syntax!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (requestTypeUrl != null) 'requestTypeUrl=$requestTypeUrl',
      if (requestStreaming != null) 'requestStreaming=$requestStreaming',
      if (responseTypeUrl != null) 'responseTypeUrl=$responseTypeUrl',
      if (responseStreaming != null) 'responseStreaming=$responseStreaming',
      if (syntax != null) 'syntax=$syntax',
    ].join(',');
    return 'Method($contents)';
  }
}

/// Declares an API Interface to be included in this interface. The including
/// interface must redeclare all the methods from the included interface, but
/// documentation and options are inherited as follows:
///
/// - If after comment and whitespace stripping, the documentation
///   string of the redeclared method is empty, it will be inherited
///   from the original method.
///
/// - Each annotation belonging to the service config (http,
///   visibility) which is not set in the redeclared method will be
///   inherited.
///
/// - If an http annotation is inherited, the path pattern will be
///   modified as follows. Any version prefix will be replaced by the
///   version of the including interface plus the `root` path if
///   specified.
///
/// Example of a simple mixin:
///
///     package google.acl.v1;
///     service AccessControl {
///       // Get the underlying ACL object.
///       rpc GetAcl(GetAclRequest) returns (Acl) {
///         option (google.api.http).get = "/v1/{resource=**}:getAcl";
///       }
///     }
///
///     package google.storage.v2;
///     service Storage {
///       rpc GetAcl(GetAclRequest) returns (Acl);
///
///       // Get a data record.
///       rpc GetData(GetDataRequest) returns (Data) {
///         option (google.api.http).get = "/v2/{resource=**}";
///       }
///     }
///
/// Example of a mixin configuration:
///
///     apis:
///     - name: google.storage.v2.Storage
///       mixins:
///       - name: google.acl.v1.AccessControl
///
/// The mixin construct implies that all methods in `AccessControl` are
/// also declared with same name and request/response types in
/// `Storage`. A documentation generator or annotation processor will
/// see the effective `Storage.GetAcl` method after inheriting
/// documentation and annotations as follows:
///
///     service Storage {
///       // Get the underlying ACL object.
///       rpc GetAcl(GetAclRequest) returns (Acl) {
///         option (google.api.http).get = "/v2/{resource=**}:getAcl";
///       }
///       ...
///     }
///
/// Note how the version in the path pattern changed from `v1` to `v2`.
///
/// If the `root` field in the mixin is specified, it should be a
/// relative path under which inherited HTTP paths are placed. Example:
///
///     apis:
///     - name: google.storage.v2.Storage
///       mixins:
///       - name: google.acl.v1.AccessControl
///         root: acls
///
/// This implies the following inherited HTTP annotation:
///
///     service Storage {
///       // Get the underlying ACL object.
///       rpc GetAcl(GetAclRequest) returns (Acl) {
///         option (google.api.http).get = "/v2/acls/{resource=**}:getAcl";
///       }
///       ...
///     }
class Mixin extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.Mixin';

  /// The fully qualified name of the interface which is included.
  final String? name;

  /// If non-empty specifies a path under which inherited HTTP paths
  /// are rooted.
  final String? root;

  Mixin({this.name, this.root}) : super(fullyQualifiedName);

  factory Mixin.fromJson(Map<String, dynamic> json) {
    return Mixin(name: json['name'], root: json['root']);
  }

  @override
  Object toJson() {
    return {if (name != null) 'name': name, if (root != null) 'root': root};
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (root != null) 'root=$root',
    ].join(',');
    return 'Mixin($contents)';
  }
}

/// A Duration represents a signed, fixed-length span of time represented
/// as a count of seconds and fractions of seconds at nanosecond
/// resolution. It is independent of any calendar and concepts like "day"
/// or "month". It is related to Timestamp in that the difference between
/// two Timestamp values is a Duration and it can be added or subtracted
/// from a Timestamp. Range is approximately +-10,000 years.
///
/// # Examples
///
/// Example 1: Compute Duration from two Timestamps in pseudo code.
///
///     Timestamp start = ...;
///     Timestamp end = ...;
///     Duration duration = ...;
///
///     duration.seconds = end.seconds - start.seconds;
///     duration.nanos = end.nanos - start.nanos;
///
///     if (duration.seconds < 0 && duration.nanos > 0) {
///       duration.seconds += 1;
///       duration.nanos -= 1000000000;
///     } else if (duration.seconds > 0 && duration.nanos < 0) {
///       duration.seconds -= 1;
///       duration.nanos += 1000000000;
///     }
///
/// Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
///
///     Timestamp start = ...;
///     Duration duration = ...;
///     Timestamp end = ...;
///
///     end.seconds = start.seconds + duration.seconds;
///     end.nanos = start.nanos + duration.nanos;
///
///     if (end.nanos < 0) {
///       end.seconds -= 1;
///       end.nanos += 1000000000;
///     } else if (end.nanos >= 1000000000) {
///       end.seconds += 1;
///       end.nanos -= 1000000000;
///     }
///
/// Example 3: Compute Duration from datetime.timedelta in Python.
///
///     td = datetime.timedelta(days=3, minutes=10)
///     duration = Duration()
///     duration.FromTimedelta(td)
///
/// # JSON Mapping
///
/// In JSON format, the Duration type is encoded as a string rather than an
/// object, where the string ends in the suffix "s" (indicating seconds) and
/// is preceded by the number of seconds, with nanoseconds expressed as
/// fractional seconds. For example, 3 seconds with 0 nanoseconds should be
/// encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should
/// be expressed in JSON format as "3.000000001s", and 3 seconds and 1
/// microsecond should be expressed in JSON format as "3.000001s".
class Duration extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.Duration';

  /// Signed seconds of the span of time. Must be from -315,576,000,000
  /// to +315,576,000,000 inclusive. Note: these bounds are computed from:
  /// 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
  final int? seconds;

  /// Signed fractions of a second at nanosecond resolution of the span
  /// of time. Durations less than one second are represented with a 0
  /// `seconds` field and a positive or negative `nanos` field. For durations
  /// of one second or more, a non-zero value for the `nanos` field must be
  /// of the same sign as the `seconds` field. Must be from -999,999,999
  /// to +999,999,999 inclusive.
  final int? nanos;

  Duration({this.seconds, this.nanos}) : super(fullyQualifiedName) {
    _validate();
  }

  factory Duration.fromJson(Object json) => _DurationHelper.decode(json);

  @override
  Object toJson() => _DurationHelper.encode(this);

  @override
  String toString() {
    final contents = [
      if (seconds != null) 'seconds=$seconds',
      if (nanos != null) 'nanos=$nanos',
    ].join(',');
    return 'Duration($contents)';
  }
}

/// A generic empty message that you can re-use to avoid defining duplicated
/// empty messages in your APIs. A typical example is to use it as the request
/// or the response type of an API method. For instance:
///
///     service Foo {
///       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
///     }
class Empty extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.Empty';

  Empty() : super(fullyQualifiedName);

  factory Empty.fromJson(Map<String, dynamic> json) {
    return Empty();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'Empty()';
}

/// `FieldMask` represents a set of symbolic field paths, for example:
///
///     paths: "f.a"
///     paths: "f.b.d"
///
/// Here `f` represents a field in some root message, `a` and `b`
/// fields in the message found in `f`, and `d` a field found in the
/// message in `f.b`.
///
/// Field masks are used to specify a subset of fields that should be
/// returned by a get operation or modified by an update operation.
/// Field masks also have a custom JSON encoding (see below).
///
/// # Field Masks in Projections
///
/// When used in the context of a projection, a response message or
/// sub-message is filtered by the API to only contain those fields as
/// specified in the mask. For example, if the mask in the previous
/// example is applied to a response message as follows:
///
///     f {
///       a : 22
///       b {
///         d : 1
///         x : 2
///       }
///       y : 13
///     }
///     z: 8
///
/// The result will not contain specific values for fields x,y and z
/// (their value will be set to the default, and omitted in proto text
/// output):
///
///
///     f {
///       a : 22
///       b {
///         d : 1
///       }
///     }
///
/// A repeated field is not allowed except at the last position of a
/// paths string.
///
/// If a FieldMask object is not present in a get operation, the
/// operation applies to all fields (as if a FieldMask of all fields
/// had been specified).
///
/// Note that a field mask does not necessarily apply to the
/// top-level response message. In case of a REST get operation, the
/// field mask applies directly to the response, but in case of a REST
/// list operation, the mask instead applies to each individual message
/// in the returned resource list. In case of a REST custom method,
/// other definitions may be used. Where the mask applies will be
/// clearly documented together with its declaration in the API.  In
/// any case, the effect on the returned resource/resources is required
/// behavior for APIs.
///
/// # Field Masks in Update Operations
///
/// A field mask in update operations specifies which fields of the
/// targeted resource are going to be updated. The API is required
/// to only change the values of the fields as specified in the mask
/// and leave the others untouched. If a resource is passed in to
/// describe the updated values, the API ignores the values of all
/// fields not covered by the mask.
///
/// If a repeated field is specified for an update operation, new values will
/// be appended to the existing repeated field in the target resource. Note that
/// a repeated field is only allowed in the last position of a `paths` string.
///
/// If a sub-message is specified in the last position of the field mask for an
/// update operation, then new value will be merged into the existing sub-message
/// in the target resource.
///
/// For example, given the target message:
///
///     f {
///       b {
///         d: 1
///         x: 2
///       }
///       c: [1]
///     }
///
/// And an update message:
///
///     f {
///       b {
///         d: 10
///       }
///       c: [2]
///     }
///
/// then if the field mask is:
///
///  paths: ["f.b", "f.c"]
///
/// then the result will be:
///
///     f {
///       b {
///         d: 10
///         x: 2
///       }
///       c: [1, 2]
///     }
///
/// An implementation may provide options to override this default behavior for
/// repeated and message fields.
///
/// In order to reset a field's value to the default, the field must
/// be in the mask and set to the default value in the provided resource.
/// Hence, in order to reset all fields of a resource, provide a default
/// instance of the resource and set all fields in the mask, or do
/// not provide a mask as described below.
///
/// If a field mask is not present on update, the operation applies to
/// all fields (as if a field mask of all fields has been specified).
/// Note that in the presence of schema evolution, this may mean that
/// fields the client does not know and has therefore not filled into
/// the request will be reset to their default. If this is unwanted
/// behavior, a specific service may require a client to always specify
/// a field mask, producing an error if not.
///
/// As with get operations, the location of the resource which
/// describes the updated values in the request message depends on the
/// operation kind. In any case, the effect of the field mask is
/// required to be honored by the API.
///
/// ## Considerations for HTTP REST
///
/// The HTTP kind of an update operation which uses a field mask must
/// be set to PATCH instead of PUT in order to satisfy HTTP semantics
/// (PUT must only be used for full updates).
///
/// # JSON Encoding of Field Masks
///
/// In JSON, a field mask is encoded as a single string where paths are
/// separated by a comma. Fields name in each path are converted
/// to/from lower-camel naming conventions.
///
/// As an example, consider the following message declarations:
///
///     message Profile {
///       User user = 1;
///       Photo photo = 2;
///     }
///     message User {
///       string display_name = 1;
///       string address = 2;
///     }
///
/// In proto a field mask for `Profile` may look as such:
///
///     mask {
///       paths: "user.display_name"
///       paths: "photo"
///     }
///
/// In JSON, the same mask is represented as below:
///
///     {
///       mask: "user.displayName,photo"
///     }
///
/// # Field Masks and Oneof Fields
///
/// Field masks treat fields in oneofs just as regular fields. Consider the
/// following message:
///
///     message SampleMessage {
///       oneof test_oneof {
///         string name = 4;
///         SubMessage sub_message = 9;
///       }
///     }
///
/// The field mask can be:
///
///     mask {
///       paths: "name"
///     }
///
/// Or:
///
///     mask {
///       paths: "sub_message"
///     }
///
/// Note that oneof type names ("test_oneof" in this case) cannot be used in
/// paths.
///
/// ## Field Mask Verification
///
/// The implementation of any API method which has a FieldMask type field in the
/// request should verify the included field paths, and return an
/// `INVALID_ARGUMENT` error if any path is unmappable.
class FieldMask extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.FieldMask';

  /// The set of field mask paths.
  final List<String>? paths;

  FieldMask({this.paths}) : super(fullyQualifiedName);

  factory FieldMask.fromJson(Object json) => _FieldMaskHelper.decode(json);

  @override
  Object toJson() => _FieldMaskHelper.encode(this);

  @override
  String toString() => 'FieldMask()';
}

/// `SourceContext` represents information about the source of a
/// protobuf element, like the file in which it is defined.
class SourceContext extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.SourceContext';

  /// The path-qualified name of the .proto file that contained the associated
  /// protobuf element.  For example: `"google/protobuf/source_context.proto"`.
  final String? fileName;

  SourceContext({this.fileName}) : super(fullyQualifiedName);

  factory SourceContext.fromJson(Map<String, dynamic> json) {
    return SourceContext(fileName: json['fileName']);
  }

  @override
  Object toJson() {
    return {if (fileName != null) 'fileName': fileName};
  }

  @override
  String toString() {
    final contents = [if (fileName != null) 'fileName=$fileName'].join(',');
    return 'SourceContext($contents)';
  }
}

/// `Struct` represents a structured data value, consisting of fields
/// which map to dynamically typed values. In some languages, `Struct`
/// might be supported by a native representation. For example, in
/// scripting languages like JS a struct is represented as an
/// object. The details of that representation are described together
/// with the proto support for the language.
///
/// The JSON representation for `Struct` is JSON object.
class Struct extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.Struct';

  /// Unordered map of dynamically typed values.
  final Map<String, Value>? fields;

  Struct({this.fields}) : super(fullyQualifiedName);

  factory Struct.fromJson(Object json) => _StructHelper.decode(json);

  @override
  Object toJson() => _StructHelper.encode(this);

  @override
  String toString() => 'Struct()';
}

/// `ListValue` is a wrapper around a repeated field of values.
///
/// The JSON representation for `ListValue` is JSON array.
class ListValue extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.ListValue';

  /// Repeated field of dynamically typed values.
  final List<Value>? values;

  ListValue({this.values}) : super(fullyQualifiedName);

  factory ListValue.fromJson(Object json) => _ListValueHelper.decode(json);

  @override
  Object toJson() => _ListValueHelper.encode(this);

  @override
  String toString() => 'ListValue()';
}

/// A Timestamp represents a point in time independent of any time zone or local
/// calendar, encoded as a count of seconds and fractions of seconds at
/// nanosecond resolution. The count is relative to an epoch at UTC midnight on
/// January 1, 1970, in the proleptic Gregorian calendar which extends the
/// Gregorian calendar backwards to year one.
///
/// All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
/// second table is needed for interpretation, using a [24-hour linear
/// smear](https://developers.google.com/time/smear).
///
/// The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
/// restricting to that range, we ensure that we can convert to and from [RFC
/// 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
///
/// # Examples
///
/// Example 1: Compute Timestamp from POSIX `time()`.
///
///     Timestamp timestamp;
///     timestamp.set_seconds(time(NULL));
///     timestamp.set_nanos(0);
///
/// Example 2: Compute Timestamp from POSIX `gettimeofday()`.
///
///     struct timeval tv;
///     gettimeofday(&tv, NULL);
///
///     Timestamp timestamp;
///     timestamp.set_seconds(tv.tv_sec);
///     timestamp.set_nanos(tv.tv_usec * 1000);
///
/// Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
///
///     FILETIME ft;
///     GetSystemTimeAsFileTime(&ft);
///     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
///
///     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
///     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
///     Timestamp timestamp;
///     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
///     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
///
/// Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
///
///     long millis = System.currentTimeMillis();
///
///     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
///         .setNanos((int) ((millis % 1000) * 1000000)).build();
///
/// Example 5: Compute Timestamp from Java `Instant.now()`.
///
///     Instant now = Instant.now();
///
///     Timestamp timestamp =
///         Timestamp.newBuilder().setSeconds(now.getEpochSecond())
///             .setNanos(now.getNano()).build();
///
/// Example 6: Compute Timestamp from current time in Python.
///
///     timestamp = Timestamp()
///     timestamp.GetCurrentTime()
///
/// # JSON Mapping
///
/// In JSON format, the Timestamp type is encoded as a string in the
/// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
/// format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
/// where {year} is always expressed using four digits while {month}, {day},
/// {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
/// seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
/// are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
/// is required. A proto3 JSON serializer should always use UTC (as indicated by
/// "Z") when printing the Timestamp type and a proto3 JSON parser should be
/// able to accept both UTC and other timezones (as indicated by an offset).
///
/// For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
/// 01:30 UTC on January 15, 2017.
///
/// In JavaScript, one can convert a Date object to this format using the
/// standard
/// [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
/// method. In Python, a standard `datetime.datetime` object can be converted
/// to this format using
/// [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
/// the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
/// the Joda Time's [`ISODateTimeFormat.dateTime()`](
/// http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
/// ) to obtain a formatter capable of generating timestamps in this format.
class Timestamp extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.Timestamp';

  /// Represents seconds of UTC time since Unix epoch
  /// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
  /// 9999-12-31T23:59:59Z inclusive.
  final int? seconds;

  /// Non-negative fractions of a second at nanosecond resolution. Negative
  /// second values with fractions must still have non-negative nanos values
  /// that count forward in time. Must be from 0 to 999,999,999
  /// inclusive.
  final int? nanos;

  Timestamp({this.seconds, this.nanos}) : super(fullyQualifiedName) {
    _validate();
  }

  factory Timestamp.fromJson(Object json) => _TimestampHelper.decode(json);

  @override
  Object toJson() => _TimestampHelper.encode(this);

  @override
  String toString() {
    final contents = [
      if (seconds != null) 'seconds=$seconds',
      if (nanos != null) 'nanos=$nanos',
    ].join(',');
    return 'Timestamp($contents)';
  }
}

/// A protocol buffer message type.
class Type extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.Type';

  /// The fully qualified message name.
  final String? name;

  /// The list of fields.
  final List<Field>? fields;

  /// The list of types appearing in `oneof` definitions in this type.
  final List<String>? oneofs;

  /// The protocol buffer options.
  final List<Option>? options;

  /// The source context.
  final SourceContext? sourceContext;

  /// The source syntax.
  final Syntax? syntax;

  /// The source edition string, only valid when syntax is SYNTAX_EDITIONS.
  final String? edition;

  Type({
    this.name,
    this.fields,
    this.oneofs,
    this.options,
    this.sourceContext,
    this.syntax,
    this.edition,
  }) : super(fullyQualifiedName);

  factory Type.fromJson(Map<String, dynamic> json) {
    return Type(
      name: json['name'],
      fields: decodeListMessage(json['fields'], Field.fromJson),
      oneofs: decodeList(json['oneofs']),
      options: decodeListMessage(json['options'], Option.fromJson),
      sourceContext: decode(json['sourceContext'], SourceContext.fromJson),
      syntax: decodeEnum(json['syntax'], Syntax.fromJson),
      edition: json['edition'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (fields != null) 'fields': encodeList(fields),
      if (oneofs != null) 'oneofs': oneofs,
      if (options != null) 'options': encodeList(options),
      if (sourceContext != null) 'sourceContext': sourceContext!.toJson(),
      if (syntax != null) 'syntax': syntax!.toJson(),
      if (edition != null) 'edition': edition,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (syntax != null) 'syntax=$syntax',
      if (edition != null) 'edition=$edition',
    ].join(',');
    return 'Type($contents)';
  }
}

/// A single field of a message type.
class Field extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.Field';

  /// The field type.
  final Field_Kind? kind;

  /// The field cardinality.
  final Field_Cardinality? cardinality;

  /// The field number.
  final int? number;

  /// The field name.
  final String? name;

  /// The field type URL, without the scheme, for message or enumeration
  /// types. Example: `"type.googleapis.com/google.protobuf.Timestamp"`.
  final String? typeUrl;

  /// The index of the field type in `Type.oneofs`, for message or enumeration
  /// types. The first type has index 1; zero means the type is not in the list.
  final int? oneofIndex;

  /// Whether to use alternative packed wire representation.
  final bool? packed;

  /// The protocol buffer options.
  final List<Option>? options;

  /// The field JSON name.
  final String? jsonName;

  /// The string value of the default value of this field. Proto2 syntax only.
  final String? defaultValue;

  Field({
    this.kind,
    this.cardinality,
    this.number,
    this.name,
    this.typeUrl,
    this.oneofIndex,
    this.packed,
    this.options,
    this.jsonName,
    this.defaultValue,
  }) : super(fullyQualifiedName);

  factory Field.fromJson(Map<String, dynamic> json) {
    return Field(
      kind: decodeEnum(json['kind'], Field_Kind.fromJson),
      cardinality: decodeEnum(json['cardinality'], Field_Cardinality.fromJson),
      number: json['number'],
      name: json['name'],
      typeUrl: json['typeUrl'],
      oneofIndex: json['oneofIndex'],
      packed: json['packed'],
      options: decodeListMessage(json['options'], Option.fromJson),
      jsonName: json['jsonName'],
      defaultValue: json['defaultValue'],
    );
  }

  @override
  Object toJson() {
    return {
      if (kind != null) 'kind': kind!.toJson(),
      if (cardinality != null) 'cardinality': cardinality!.toJson(),
      if (number != null) 'number': number,
      if (name != null) 'name': name,
      if (typeUrl != null) 'typeUrl': typeUrl,
      if (oneofIndex != null) 'oneofIndex': oneofIndex,
      if (packed != null) 'packed': packed,
      if (options != null) 'options': encodeList(options),
      if (jsonName != null) 'jsonName': jsonName,
      if (defaultValue != null) 'defaultValue': defaultValue,
    };
  }

  @override
  String toString() {
    final contents = [
      if (kind != null) 'kind=$kind',
      if (cardinality != null) 'cardinality=$cardinality',
      if (number != null) 'number=$number',
      if (name != null) 'name=$name',
      if (typeUrl != null) 'typeUrl=$typeUrl',
      if (oneofIndex != null) 'oneofIndex=$oneofIndex',
      if (packed != null) 'packed=$packed',
      if (jsonName != null) 'jsonName=$jsonName',
      if (defaultValue != null) 'defaultValue=$defaultValue',
    ].join(',');
    return 'Field($contents)';
  }
}

/// Basic field types.
class Field_Kind extends ProtoEnum {
  /// Field type unknown.
  static const typeUnknown = Field_Kind('TYPE_UNKNOWN');

  /// Field type double.
  static const typeDouble = Field_Kind('TYPE_DOUBLE');

  /// Field type float.
  static const typeFloat = Field_Kind('TYPE_FLOAT');

  /// Field type int64.
  static const typeInt64 = Field_Kind('TYPE_INT64');

  /// Field type uint64.
  static const typeUint64 = Field_Kind('TYPE_UINT64');

  /// Field type int32.
  static const typeInt32 = Field_Kind('TYPE_INT32');

  /// Field type fixed64.
  static const typeFixed64 = Field_Kind('TYPE_FIXED64');

  /// Field type fixed32.
  static const typeFixed32 = Field_Kind('TYPE_FIXED32');

  /// Field type bool.
  static const typeBool = Field_Kind('TYPE_BOOL');

  /// Field type string.
  static const typeString = Field_Kind('TYPE_STRING');

  /// Field type group. Proto2 syntax only, and deprecated.
  static const typeGroup = Field_Kind('TYPE_GROUP');

  /// Field type message.
  static const typeMessage = Field_Kind('TYPE_MESSAGE');

  /// Field type bytes.
  static const typeBytes = Field_Kind('TYPE_BYTES');

  /// Field type uint32.
  static const typeUint32 = Field_Kind('TYPE_UINT32');

  /// Field type enum.
  static const typeEnum = Field_Kind('TYPE_ENUM');

  /// Field type sfixed32.
  static const typeSfixed32 = Field_Kind('TYPE_SFIXED32');

  /// Field type sfixed64.
  static const typeSfixed64 = Field_Kind('TYPE_SFIXED64');

  /// Field type sint32.
  static const typeSint32 = Field_Kind('TYPE_SINT32');

  /// Field type sint64.
  static const typeSint64 = Field_Kind('TYPE_SINT64');

  const Field_Kind(super.value);

  factory Field_Kind.fromJson(String json) => Field_Kind(json);

  @override
  String toString() => 'Kind.$value';
}

/// Whether a field is optional, required, or repeated.
class Field_Cardinality extends ProtoEnum {
  /// For fields with unknown cardinality.
  static const cardinalityUnknown = Field_Cardinality('CARDINALITY_UNKNOWN');

  /// For optional fields.
  static const cardinalityOptional = Field_Cardinality('CARDINALITY_OPTIONAL');

  /// For required fields. Proto2 syntax only.
  static const cardinalityRequired = Field_Cardinality('CARDINALITY_REQUIRED');

  /// For repeated fields.
  static const cardinalityRepeated = Field_Cardinality('CARDINALITY_REPEATED');

  const Field_Cardinality(super.value);

  factory Field_Cardinality.fromJson(String json) => Field_Cardinality(json);

  @override
  String toString() => 'Cardinality.$value';
}

/// Enum type definition.
class Enum extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.Enum';

  /// Enum type name.
  final String? name;

  /// Enum value definitions.
  final List<EnumValue>? enumvalue;

  /// Protocol buffer options.
  final List<Option>? options;

  /// The source context.
  final SourceContext? sourceContext;

  /// The source syntax.
  final Syntax? syntax;

  /// The source edition string, only valid when syntax is SYNTAX_EDITIONS.
  final String? edition;

  Enum({
    this.name,
    this.enumvalue,
    this.options,
    this.sourceContext,
    this.syntax,
    this.edition,
  }) : super(fullyQualifiedName);

  factory Enum.fromJson(Map<String, dynamic> json) {
    return Enum(
      name: json['name'],
      enumvalue: decodeListMessage(json['enumvalue'], EnumValue.fromJson),
      options: decodeListMessage(json['options'], Option.fromJson),
      sourceContext: decode(json['sourceContext'], SourceContext.fromJson),
      syntax: decodeEnum(json['syntax'], Syntax.fromJson),
      edition: json['edition'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (enumvalue != null) 'enumvalue': encodeList(enumvalue),
      if (options != null) 'options': encodeList(options),
      if (sourceContext != null) 'sourceContext': sourceContext!.toJson(),
      if (syntax != null) 'syntax': syntax!.toJson(),
      if (edition != null) 'edition': edition,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (syntax != null) 'syntax=$syntax',
      if (edition != null) 'edition=$edition',
    ].join(',');
    return 'Enum($contents)';
  }
}

/// Enum value definition.
class EnumValue extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.EnumValue';

  /// Enum value name.
  final String? name;

  /// Enum value number.
  final int? number;

  /// Protocol buffer options.
  final List<Option>? options;

  EnumValue({this.name, this.number, this.options}) : super(fullyQualifiedName);

  factory EnumValue.fromJson(Map<String, dynamic> json) {
    return EnumValue(
      name: json['name'],
      number: json['number'],
      options: decodeListMessage(json['options'], Option.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (number != null) 'number': number,
      if (options != null) 'options': encodeList(options),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (number != null) 'number=$number',
    ].join(',');
    return 'EnumValue($contents)';
  }
}

/// A protocol buffer option, which can be attached to a message, field,
/// enumeration, etc.
class Option extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.Option';

  /// The option's name. For protobuf built-in options (options defined in
  /// descriptor.proto), this is the short name. For example, `"map_entry"`.
  /// For custom options, it should be the fully-qualified name. For example,
  /// `"google.api.http"`.
  final String? name;

  /// The option's value packed in an Any message. If the value is a primitive,
  /// the corresponding wrapper type defined in google/protobuf/wrappers.proto
  /// should be used. If the value is an enum, it should be stored as an int32
  /// value using the google.protobuf.Int32Value type.
  final Any? value;

  Option({this.name, this.value}) : super(fullyQualifiedName);

  factory Option.fromJson(Map<String, dynamic> json) {
    return Option(
      name: json['name'],
      value: decode(json['value'], Any.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (value != null) 'value': value!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (name != null) 'name=$name'].join(',');
    return 'Option($contents)';
  }
}

/// Wrapper message for `double`.
///
/// The JSON representation for `DoubleValue` is JSON number.
class DoubleValue extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.DoubleValue';

  /// The double value.
  final double? value;

  DoubleValue({this.value}) : super(fullyQualifiedName);

  factory DoubleValue.fromJson(Object json) => _DoubleValueHelper.decode(json);

  @override
  Object toJson() => _DoubleValueHelper.encode(this);

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'DoubleValue($contents)';
  }
}

/// Wrapper message for `float`.
///
/// The JSON representation for `FloatValue` is JSON number.
class FloatValue extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.FloatValue';

  /// The float value.
  final double? value;

  FloatValue({this.value}) : super(fullyQualifiedName);

  factory FloatValue.fromJson(Object json) => _FloatValueHelper.decode(json);

  @override
  Object toJson() => _FloatValueHelper.encode(this);

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'FloatValue($contents)';
  }
}

/// Wrapper message for `int64`.
///
/// The JSON representation for `Int64Value` is JSON string.
class Int64Value extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.Int64Value';

  /// The int64 value.
  final int? value;

  Int64Value({this.value}) : super(fullyQualifiedName);

  factory Int64Value.fromJson(Object json) => _Int64ValueHelper.decode(json);

  @override
  Object toJson() => _Int64ValueHelper.encode(this);

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'Int64Value($contents)';
  }
}

/// Wrapper message for `uint64`.
///
/// The JSON representation for `UInt64Value` is JSON string.
class Uint64Value extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.UInt64Value';

  /// The uint64 value.
  final int? value;

  Uint64Value({this.value}) : super(fullyQualifiedName);

  factory Uint64Value.fromJson(Object json) => _Uint64ValueHelper.decode(json);

  @override
  Object toJson() => _Uint64ValueHelper.encode(this);

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'UInt64Value($contents)';
  }
}

/// Wrapper message for `int32`.
///
/// The JSON representation for `Int32Value` is JSON number.
class Int32Value extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.Int32Value';

  /// The int32 value.
  final int? value;

  Int32Value({this.value}) : super(fullyQualifiedName);

  factory Int32Value.fromJson(Object json) => _Int32ValueHelper.decode(json);

  @override
  Object toJson() => _Int32ValueHelper.encode(this);

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'Int32Value($contents)';
  }
}

/// Wrapper message for `uint32`.
///
/// The JSON representation for `UInt32Value` is JSON number.
class Uint32Value extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.UInt32Value';

  /// The uint32 value.
  final int? value;

  Uint32Value({this.value}) : super(fullyQualifiedName);

  factory Uint32Value.fromJson(Object json) => _Uint32ValueHelper.decode(json);

  @override
  Object toJson() => _Uint32ValueHelper.encode(this);

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'UInt32Value($contents)';
  }
}

/// Wrapper message for `bool`.
///
/// The JSON representation for `BoolValue` is JSON `true` and `false`.
class BoolValue extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.BoolValue';

  /// The bool value.
  final bool? value;

  BoolValue({this.value}) : super(fullyQualifiedName);

  factory BoolValue.fromJson(Object json) => _BoolValueHelper.decode(json);

  @override
  Object toJson() => _BoolValueHelper.encode(this);

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'BoolValue($contents)';
  }
}

/// Wrapper message for `string`.
///
/// The JSON representation for `StringValue` is JSON string.
class StringValue extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.StringValue';

  /// The string value.
  final String? value;

  StringValue({this.value}) : super(fullyQualifiedName);

  factory StringValue.fromJson(Object json) => _StringValueHelper.decode(json);

  @override
  Object toJson() => _StringValueHelper.encode(this);

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'StringValue($contents)';
  }
}

/// Wrapper message for `bytes`.
///
/// The JSON representation for `BytesValue` is JSON string.
class BytesValue extends ProtoMessage {
  static const String fullyQualifiedName = 'google.protobuf.BytesValue';

  /// The bytes value.
  final Uint8List? value;

  BytesValue({this.value}) : super(fullyQualifiedName);

  factory BytesValue.fromJson(Object json) => _BytesValueHelper.decode(json);

  @override
  Object toJson() => _BytesValueHelper.encode(this);

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'BytesValue($contents)';
  }
}

/// `NullValue` is a singleton enumeration to represent the null value for the
/// `Value` type union.
///
/// The JSON representation for `NullValue` is JSON `null`.
class NullValue extends ProtoEnum {
  /// Null value.
  static const nullValue = NullValue('NULL_VALUE');

  const NullValue(super.value);

  factory NullValue.fromJson(String json) => NullValue(json);

  @override
  String toString() => 'NullValue.$value';
}

/// The syntax in which a protocol buffer element is defined.
class Syntax extends ProtoEnum {
  /// Syntax `proto2`.
  static const syntaxProto2 = Syntax('SYNTAX_PROTO2');

  /// Syntax `proto3`.
  static const syntaxProto3 = Syntax('SYNTAX_PROTO3');

  /// Syntax `editions`.
  static const syntaxEditions = Syntax('SYNTAX_EDITIONS');

  const Syntax(super.value);

  factory Syntax.fromJson(String json) => Syntax(json);

  @override
  String toString() => 'Syntax.$value';
}
