// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Cloud Functions API.
///
/// Manages lightweight user-provided functions executed in response to events.
library;

import 'package:google_cloud_gax/gax.dart';
import 'package:google_cloud_gax/src/encoding.dart';
import 'package:google_cloud_iam_v1/iam.dart';
import 'package:google_cloud_location/location.dart';
import 'package:google_cloud_longrunning/longrunning.dart';
import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_rpc/rpc.dart';
import 'package:google_cloud_type/type.dart';
import 'package:http/http.dart' as http;

/// Google Cloud Functions is used to deploy functions that are executed by
/// Google in response to various events. Data connected with that event is
/// passed to a function as the input data.
///
/// A **function** is a resource which describes a function that should be
/// executed and how it is triggered.
final class FunctionService {
  static const String _host = 'cloudfunctions.googleapis.com';

  final ServiceClient _client;

  FunctionService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Returns a function with the given name from the requested project.
  Future<Function$> getFunction(GetFunctionRequest request) async {
    final url = Uri.https(_host, '/v2/${request.name}', {
      if (request.revision != null) 'revision': request.revision!,
    });
    final response = await _client.get(url);
    return Function$.fromJson(response);
  }

  /// Returns a list of functions that belong to the requested project.
  Future<ListFunctionsResponse> listFunctions(
    ListFunctionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.parent}/functions', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.filter != null) 'filter': request.filter!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListFunctionsResponse.fromJson(response);
  }

  /// Creates a new function. If a function with the given name already exists in
  /// the specified project, the long running operation will return
  /// `ALREADY_EXISTS` error.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Function$, OperationMetadata>> createFunction(
    CreateFunctionRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.parent}/functions', {
      if (request.functionId != null) 'functionId': request.functionId!,
    });
    final response = await _client.post(url, body: request.function);
    return Operation.fromJson(
      response,
      OperationHelper(Function$.fromJson, OperationMetadata.fromJson),
    );
  }

  /// Updates existing function.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Function$, OperationMetadata>> updateFunction(
    UpdateFunctionRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.function.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.function);
    return Operation.fromJson(
      response,
      OperationHelper(Function$.fromJson, OperationMetadata.fromJson),
    );
  }

  /// Deletes a function with the given name from the specified project. If the
  /// given function is used by some trigger, the trigger will be updated to
  /// remove this function.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Empty, OperationMetadata>> deleteFunction(
    DeleteFunctionRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(Empty.fromJson, OperationMetadata.fromJson),
    );
  }

  /// Returns a signed URL for uploading a function source code.
  /// For more information about the signed URL usage see:
  /// https://cloud.google.com/storage/docs/access-control/signed-urls.
  /// Once the function source code upload is complete, the used signed
  /// URL should be provided in CreateFunction or UpdateFunction request
  /// as a reference to the function source code.
  ///
  /// When uploading source code to the generated signed URL, please follow
  /// these restrictions:
  ///
  /// * Source file type should be a zip file.
  /// * No credentials should be attached - the signed URLs provide access to the
  ///   target bucket using internal service identity; if credentials were
  ///   attached, the identity from the credentials would be used, but that
  ///   identity does not have permissions to upload files to the URL.
  ///
  /// When making a HTTP PUT request, specify this header:
  ///
  /// * `content-type: application/zip`
  ///
  /// Do not specify this header:
  ///
  /// * `Authorization: Bearer YOUR_TOKEN`
  Future<GenerateUploadUrlResponse> generateUploadUrl(
    GenerateUploadUrlRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v2/${request.parent}/functions:generateUploadUrl',
    );
    final response = await _client.post(url, body: request);
    return GenerateUploadUrlResponse.fromJson(response);
  }

  /// Returns a signed URL for downloading deployed function source code.
  /// The URL is only valid for a limited period and should be used within
  /// 30 minutes of generation.
  /// For more information about the signed URL usage see:
  /// https://cloud.google.com/storage/docs/access-control/signed-urls
  Future<GenerateDownloadUrlResponse> generateDownloadUrl(
    GenerateDownloadUrlRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.name}:generateDownloadUrl');
    final response = await _client.post(url, body: request);
    return GenerateDownloadUrlResponse.fromJson(response);
  }

  /// Returns a list of runtimes that are supported for the requested project.
  Future<ListRuntimesResponse> listRuntimes(ListRuntimesRequest request) async {
    final url = Uri.https(_host, '/v2/${request.parent}/runtimes', {
      if (request.filter != null) 'filter': request.filter!,
    });
    final response = await _client.get(url);
    return ListRuntimesResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v2/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v2/${request.resource}:getIamPolicy', {
      if (request.options?.requestedPolicyVersion != null)
        'options.requestedPolicyVersion':
            '${request.options?.requestedPolicyVersion}',
    });
    final response = await _client.get(url);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.resource}:testIamPermissions');
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/v2/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Describes a Cloud Function that contains user computation executed in
/// response to an event. It encapsulates function and trigger configurations.
class Function$ extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.functions.v2.Function';

  /// A user-defined name of the function. Function names must be unique
  /// globally and match pattern `projects/*/locations/*/functions/*`
  final String? name;

  /// User-provided description of a function.
  final String? description;

  /// Describes the Build step of the function that builds a container from the
  /// given source.
  final BuildConfig? buildConfig;

  /// Describes the Service being deployed. Currently deploys services to Cloud
  /// Run (fully managed).
  final ServiceConfig? serviceConfig;

  /// An Eventarc trigger managed by Google Cloud Functions that fires events in
  /// response to a condition in another service.
  final EventTrigger? eventTrigger;

  /// Output only. State of the function.
  final Function$_State? state;

  /// Output only. The last update timestamp of a Cloud Function.
  final Timestamp? updateTime;

  /// Labels associated with this Cloud Function.
  final Map<String, String>? labels;

  /// Output only. State Messages for this Cloud Function.
  final List<StateMessage>? stateMessages;

  /// Describe whether the function is 1st Gen or 2nd Gen.
  final Environment? environment;

  /// Output only. The deployed url for the function.
  final String? url;

  /// Resource name of a KMS crypto key (managed by the user) used to
  /// encrypt/decrypt function resources.
  ///
  /// It must match the pattern
  /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
  final String? kmsKeyName;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. The create timestamp of a Cloud Function. This is only
  /// applicable to 2nd Gen functions.
  final Timestamp? createTime;

  Function$({
    this.name,
    this.description,
    this.buildConfig,
    this.serviceConfig,
    this.eventTrigger,
    this.state,
    this.updateTime,
    this.labels,
    this.stateMessages,
    this.environment,
    this.url,
    this.kmsKeyName,
    this.satisfiesPzs,
    this.createTime,
  }) : super(fullyQualifiedName);

  factory Function$.fromJson(Map<String, dynamic> json) {
    return Function$(
      name: json['name'],
      description: json['description'],
      buildConfig: decode(json['buildConfig'], BuildConfig.fromJson),
      serviceConfig: decode(json['serviceConfig'], ServiceConfig.fromJson),
      eventTrigger: decode(json['eventTrigger'], EventTrigger.fromJson),
      state: decodeEnum(json['state'], Function$_State.fromJson),
      updateTime: decodeCustom(json['updateTime'], Timestamp.fromJson),
      labels: decodeMap(json['labels']),
      stateMessages: decodeListMessage(
        json['stateMessages'],
        StateMessage.fromJson,
      ),
      environment: decodeEnum(json['environment'], Environment.fromJson),
      url: json['url'],
      kmsKeyName: json['kmsKeyName'],
      satisfiesPzs: json['satisfiesPzs'],
      createTime: decodeCustom(json['createTime'], Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (buildConfig != null) 'buildConfig': buildConfig!.toJson(),
      if (serviceConfig != null) 'serviceConfig': serviceConfig!.toJson(),
      if (eventTrigger != null) 'eventTrigger': eventTrigger!.toJson(),
      if (state != null) 'state': state!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (labels != null) 'labels': labels,
      if (stateMessages != null) 'stateMessages': encodeList(stateMessages),
      if (environment != null) 'environment': environment!.toJson(),
      if (url != null) 'url': url,
      if (kmsKeyName != null) 'kmsKeyName': kmsKeyName,
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (createTime != null) 'createTime': createTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (description != null) 'description=$description',
      if (state != null) 'state=$state',
      if (environment != null) 'environment=$environment',
      if (url != null) 'url=$url',
      if (kmsKeyName != null) 'kmsKeyName=$kmsKeyName',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
    ].join(',');
    return 'Function($contents)';
  }
}

/// Describes the current state of the function.
class Function$_State extends ProtoEnum {
  /// Not specified. Invalid state.
  static const stateUnspecified = Function$_State('STATE_UNSPECIFIED');

  /// Function has been successfully deployed and is serving.
  static const active = Function$_State('ACTIVE');

  /// Function deployment failed and the function is not serving.
  static const failed = Function$_State('FAILED');

  /// Function is being created or updated.
  static const deploying = Function$_State('DEPLOYING');

  /// Function is being deleted.
  static const deleting = Function$_State('DELETING');

  /// Function deployment failed and the function serving state is undefined.
  /// The function should be updated or deleted to move it out of this state.
  static const unknown = Function$_State('UNKNOWN');

  const Function$_State(super.value);

  factory Function$_State.fromJson(String json) => Function$_State(json);

  @override
  String toString() => 'State.$value';
}

/// Informational messages about the state of the Cloud Function or Operation.
class StateMessage extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.StateMessage';

  /// Severity of the state message.
  final StateMessage_Severity? severity;

  /// One-word CamelCase type of the state message.
  final String? type;

  /// The message.
  final String? message;

  StateMessage({this.severity, this.type, this.message})
    : super(fullyQualifiedName);

  factory StateMessage.fromJson(Map<String, dynamic> json) {
    return StateMessage(
      severity: decodeEnum(json['severity'], StateMessage_Severity.fromJson),
      type: json['type'],
      message: json['message'],
    );
  }

  @override
  Object toJson() {
    return {
      if (severity != null) 'severity': severity!.toJson(),
      if (type != null) 'type': type,
      if (message != null) 'message': message,
    };
  }

  @override
  String toString() {
    final contents = [
      if (severity != null) 'severity=$severity',
      if (type != null) 'type=$type',
      if (message != null) 'message=$message',
    ].join(',');
    return 'StateMessage($contents)';
  }
}

/// Severity of the state message.
class StateMessage_Severity extends ProtoEnum {
  /// Not specified. Invalid severity.
  static const severityUnspecified = StateMessage_Severity(
    'SEVERITY_UNSPECIFIED',
  );

  /// ERROR-level severity.
  static const error = StateMessage_Severity('ERROR');

  /// WARNING-level severity.
  static const warning = StateMessage_Severity('WARNING');

  /// INFO-level severity.
  static const info = StateMessage_Severity('INFO');

  const StateMessage_Severity(super.value);

  factory StateMessage_Severity.fromJson(String json) =>
      StateMessage_Severity(json);

  @override
  String toString() => 'Severity.$value';
}

/// Location of the source in an archive file in Google Cloud Storage.
class StorageSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.StorageSource';

  /// Google Cloud Storage bucket containing the source (see
  /// [Bucket Name
  /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
  final String? bucket;

  /// Google Cloud Storage object containing the source.
  ///
  /// This object must be a gzipped archive file (`.tar.gz`) containing source to
  /// build.
  final String? object;

  /// Google Cloud Storage generation for the object. If the generation is
  /// omitted, the latest generation will be used.
  final int? generation;

  /// When the specified storage bucket is a 1st gen function uploard url bucket,
  /// this field should be set as the generated upload url for 1st gen
  /// deployment.
  final String? sourceUploadUrl;

  StorageSource({
    this.bucket,
    this.object,
    this.generation,
    this.sourceUploadUrl,
  }) : super(fullyQualifiedName);

  factory StorageSource.fromJson(Map<String, dynamic> json) {
    return StorageSource(
      bucket: json['bucket'],
      object: json['object'],
      generation: decodeInt64(json['generation']),
      sourceUploadUrl: json['sourceUploadUrl'],
    );
  }

  @override
  Object toJson() {
    return {
      if (bucket != null) 'bucket': bucket,
      if (object != null) 'object': object,
      if (generation != null) 'generation': encodeInt64(generation),
      if (sourceUploadUrl != null) 'sourceUploadUrl': sourceUploadUrl,
    };
  }

  @override
  String toString() {
    final contents = [
      if (bucket != null) 'bucket=$bucket',
      if (object != null) 'object=$object',
      if (generation != null) 'generation=$generation',
      if (sourceUploadUrl != null) 'sourceUploadUrl=$sourceUploadUrl',
    ].join(',');
    return 'StorageSource($contents)';
  }
}

/// Location of the source in a Google Cloud Source Repository.
class RepoSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.RepoSource';

  /// Regex matching branches to build.
  ///
  /// The syntax of the regular expressions accepted is the syntax accepted by
  /// RE2 and described at https://github.com/google/re2/wiki/Syntax
  final String? branchName;

  /// Regex matching tags to build.
  ///
  /// The syntax of the regular expressions accepted is the syntax accepted by
  /// RE2 and described at https://github.com/google/re2/wiki/Syntax
  final String? tagName;

  /// Explicit commit SHA to build.
  final String? commitSha;

  /// ID of the project that owns the Cloud Source Repository. If omitted, the
  /// project ID requesting the build is assumed.
  final String? projectId;

  /// Name of the Cloud Source Repository.
  final String? repoName;

  /// Directory, relative to the source root, in which to run the build.
  ///
  /// This must be a relative path. If a step's `dir` is specified and is an
  /// absolute path, this value is ignored for that step's execution.
  /// eg. helloworld (no leading slash allowed)
  final String? dir;

  /// Only trigger a build if the revision regex does NOT match the revision
  /// regex.
  final bool? invertRegex;

  RepoSource({
    this.branchName,
    this.tagName,
    this.commitSha,
    this.projectId,
    this.repoName,
    this.dir,
    this.invertRegex,
  }) : super(fullyQualifiedName);

  factory RepoSource.fromJson(Map<String, dynamic> json) {
    return RepoSource(
      branchName: json['branchName'],
      tagName: json['tagName'],
      commitSha: json['commitSha'],
      projectId: json['projectId'],
      repoName: json['repoName'],
      dir: json['dir'],
      invertRegex: json['invertRegex'],
    );
  }

  @override
  Object toJson() {
    return {
      if (branchName != null) 'branchName': branchName,
      if (tagName != null) 'tagName': tagName,
      if (commitSha != null) 'commitSha': commitSha,
      if (projectId != null) 'projectId': projectId,
      if (repoName != null) 'repoName': repoName,
      if (dir != null) 'dir': dir,
      if (invertRegex != null) 'invertRegex': invertRegex,
    };
  }

  @override
  String toString() {
    final contents = [
      if (branchName != null) 'branchName=$branchName',
      if (tagName != null) 'tagName=$tagName',
      if (commitSha != null) 'commitSha=$commitSha',
      if (projectId != null) 'projectId=$projectId',
      if (repoName != null) 'repoName=$repoName',
      if (dir != null) 'dir=$dir',
      if (invertRegex != null) 'invertRegex=$invertRegex',
    ].join(',');
    return 'RepoSource($contents)';
  }
}

/// The location of the function source code.
class Source extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.functions.v2.Source';

  /// If provided, get the source from this location in Google Cloud Storage.
  final StorageSource? storageSource;

  /// If provided, get the source from this location in a Cloud Source
  /// Repository.
  final RepoSource? repoSource;

  /// If provided, get the source from GitHub repository. This option is valid
  /// only for GCF 1st Gen function.
  /// Example: https://github.com/<user>/<repo>/blob/<commit>/<path-to-code>
  final String? gitUri;

  Source({this.storageSource, this.repoSource, this.gitUri})
    : super(fullyQualifiedName);

  factory Source.fromJson(Map<String, dynamic> json) {
    return Source(
      storageSource: decode(json['storageSource'], StorageSource.fromJson),
      repoSource: decode(json['repoSource'], RepoSource.fromJson),
      gitUri: json['gitUri'],
    );
  }

  @override
  Object toJson() {
    return {
      if (storageSource != null) 'storageSource': storageSource!.toJson(),
      if (repoSource != null) 'repoSource': repoSource!.toJson(),
      if (gitUri != null) 'gitUri': gitUri,
    };
  }

  @override
  String toString() {
    final contents = [if (gitUri != null) 'gitUri=$gitUri'].join(',');
    return 'Source($contents)';
  }
}

/// Provenance of the source. Ways to find the original source, or verify that
/// some source was used for this build.
class SourceProvenance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.SourceProvenance';

  /// A copy of the build's `source.storage_source`, if exists, with any
  /// generations resolved.
  final StorageSource? resolvedStorageSource;

  /// A copy of the build's `source.repo_source`, if exists, with any
  /// revisions resolved.
  final RepoSource? resolvedRepoSource;

  /// A copy of the build's `source.git_uri`, if exists, with any commits
  /// resolved.
  final String? gitUri;

  SourceProvenance({
    this.resolvedStorageSource,
    this.resolvedRepoSource,
    this.gitUri,
  }) : super(fullyQualifiedName);

  factory SourceProvenance.fromJson(Map<String, dynamic> json) {
    return SourceProvenance(
      resolvedStorageSource: decode(
        json['resolvedStorageSource'],
        StorageSource.fromJson,
      ),
      resolvedRepoSource: decode(
        json['resolvedRepoSource'],
        RepoSource.fromJson,
      ),
      gitUri: json['gitUri'],
    );
  }

  @override
  Object toJson() {
    return {
      if (resolvedStorageSource != null)
        'resolvedStorageSource': resolvedStorageSource!.toJson(),
      if (resolvedRepoSource != null)
        'resolvedRepoSource': resolvedRepoSource!.toJson(),
      if (gitUri != null) 'gitUri': gitUri,
    };
  }

  @override
  String toString() {
    final contents = [if (gitUri != null) 'gitUri=$gitUri'].join(',');
    return 'SourceProvenance($contents)';
  }
}

/// Describes the Build step of the function that builds a container from the
/// given source.
class BuildConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.BuildConfig';

  final AutomaticUpdatePolicy? automaticUpdatePolicy;

  final OnDeployUpdatePolicy? onDeployUpdatePolicy;

  /// Output only. The Cloud Build name of the latest successful deployment of
  /// the function.
  final String? build;

  /// The runtime in which to run the function. Required when deploying a new
  /// function, optional when updating an existing function. For a complete
  /// list of possible choices, see the
  /// [`gcloud` command
  /// reference](https://cloud.google.com/sdk/gcloud/reference/functions/deploy#--runtime).
  final String? runtime;

  /// The name of the function (as defined in source code) that will be
  /// executed. Defaults to the resource name suffix, if not specified. For
  /// backward compatibility, if function with given name is not found, then the
  /// system will try to use function named "function".
  /// For Node.js this is name of a function exported by the module specified
  /// in `source_location`.
  final String? entryPoint;

  /// The location of the function source code.
  final Source? source;

  /// Output only. A permanent fixed identifier for source.
  final SourceProvenance? sourceProvenance;

  /// Name of the Cloud Build Custom Worker Pool that should be used to build the
  /// function. The format of this field is
  /// `projects/{project}/locations/{region}/workerPools/{workerPool}` where
  /// {project} and {region} are the project id and region respectively where the
  /// worker pool is defined and {workerPool} is the short name of the worker
  /// pool.
  ///
  /// If the project id is not the same as the function, then the Cloud
  /// Functions Service Agent
  /// (service-<project_number>@gcf-admin-robot.iam.gserviceaccount.com) must be
  /// granted the role Cloud Build Custom Workers Builder
  /// (roles/cloudbuild.customworkers.builder) in the project.
  final String? workerPool;

  /// User-provided build-time environment variables for the function
  final Map<String, String>? environmentVariables;

  /// Docker Registry to use for this deployment. This configuration is only
  /// applicable to 1st Gen functions, 2nd Gen functions can only use Artifact
  /// Registry.
  /// Deprecated: As of March 2025, `CONTAINER_REGISTRY` option is no longer
  /// available in response to Container Registry's deprecation:
  /// https://cloud.google.com/artifact-registry/docs/transition/transition-from-gcr
  /// Please use Artifact Registry instead, which is the default choice.
  ///
  /// If unspecified, it defaults to `ARTIFACT_REGISTRY`.
  /// If `docker_repository` field is specified, this field should either be left
  /// unspecified or set to `ARTIFACT_REGISTRY`.
  final BuildConfig_DockerRegistry? dockerRegistry;

  /// Repository in Artifact Registry to which the function docker image will be
  /// pushed after it is built by Cloud Build. If specified by user, it is
  /// created and managed by user with a customer managed encryption key.
  /// Otherwise, GCF will create and use a repository named 'gcf-artifacts'
  /// for every deployed region.
  ///
  /// It must match the pattern
  /// `projects/{project}/locations/{location}/repositories/{repository}`.
  /// Repository format must be 'DOCKER'.
  final String? dockerRepository;

  /// Service account to be used for building the container. The format of this
  /// field is `projects/{projectId}/serviceAccounts/{serviceAccountEmail}`.
  final String? serviceAccount;

  BuildConfig({
    this.automaticUpdatePolicy,
    this.onDeployUpdatePolicy,
    this.build,
    this.runtime,
    this.entryPoint,
    this.source,
    this.sourceProvenance,
    this.workerPool,
    this.environmentVariables,
    this.dockerRegistry,
    this.dockerRepository,
    this.serviceAccount,
  }) : super(fullyQualifiedName);

  factory BuildConfig.fromJson(Map<String, dynamic> json) {
    return BuildConfig(
      automaticUpdatePolicy: decode(
        json['automaticUpdatePolicy'],
        AutomaticUpdatePolicy.fromJson,
      ),
      onDeployUpdatePolicy: decode(
        json['onDeployUpdatePolicy'],
        OnDeployUpdatePolicy.fromJson,
      ),
      build: json['build'],
      runtime: json['runtime'],
      entryPoint: json['entryPoint'],
      source: decode(json['source'], Source.fromJson),
      sourceProvenance: decode(
        json['sourceProvenance'],
        SourceProvenance.fromJson,
      ),
      workerPool: json['workerPool'],
      environmentVariables: decodeMap(json['environmentVariables']),
      dockerRegistry: decodeEnum(
        json['dockerRegistry'],
        BuildConfig_DockerRegistry.fromJson,
      ),
      dockerRepository: json['dockerRepository'],
      serviceAccount: json['serviceAccount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (automaticUpdatePolicy != null)
        'automaticUpdatePolicy': automaticUpdatePolicy!.toJson(),
      if (onDeployUpdatePolicy != null)
        'onDeployUpdatePolicy': onDeployUpdatePolicy!.toJson(),
      if (build != null) 'build': build,
      if (runtime != null) 'runtime': runtime,
      if (entryPoint != null) 'entryPoint': entryPoint,
      if (source != null) 'source': source!.toJson(),
      if (sourceProvenance != null)
        'sourceProvenance': sourceProvenance!.toJson(),
      if (workerPool != null) 'workerPool': workerPool,
      if (environmentVariables != null)
        'environmentVariables': environmentVariables,
      if (dockerRegistry != null) 'dockerRegistry': dockerRegistry!.toJson(),
      if (dockerRepository != null) 'dockerRepository': dockerRepository,
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (build != null) 'build=$build',
      if (runtime != null) 'runtime=$runtime',
      if (entryPoint != null) 'entryPoint=$entryPoint',
      if (workerPool != null) 'workerPool=$workerPool',
      if (dockerRegistry != null) 'dockerRegistry=$dockerRegistry',
      if (dockerRepository != null) 'dockerRepository=$dockerRepository',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
    ].join(',');
    return 'BuildConfig($contents)';
  }
}

/// Docker Registry to use for storing function Docker images.
class BuildConfig_DockerRegistry extends ProtoEnum {
  /// Unspecified.
  static const dockerRegistryUnspecified = BuildConfig_DockerRegistry(
    'DOCKER_REGISTRY_UNSPECIFIED',
  );

  /// Docker images will be stored in multi-regional Container Registry
  /// repositories named `gcf`.
  static const containerRegistry = BuildConfig_DockerRegistry(
    'CONTAINER_REGISTRY',
  );

  /// Docker images will be stored in regional Artifact Registry repositories.
  /// By default, GCF will create and use repositories named `gcf-artifacts`
  /// in every region in which a function is deployed. But the repository to
  /// use can also be specified by the user using the `docker_repository`
  /// field.
  static const artifactRegistry = BuildConfig_DockerRegistry(
    'ARTIFACT_REGISTRY',
  );

  const BuildConfig_DockerRegistry(super.value);

  factory BuildConfig_DockerRegistry.fromJson(String json) =>
      BuildConfig_DockerRegistry(json);

  @override
  String toString() => 'DockerRegistry.$value';
}

/// Describes the Service being deployed.
/// Currently Supported : Cloud Run (fully managed).
class ServiceConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.ServiceConfig';

  /// Output only. Name of the service associated with a Function.
  /// The format of this field is
  /// `projects/{project}/locations/{region}/services/{service}`
  final String? service;

  /// The function execution timeout. Execution is considered failed and
  /// can be terminated if the function is not completed at the end of the
  /// timeout period. Defaults to 60 seconds.
  final int? timeoutSeconds;

  /// The amount of memory available for a function.
  /// Defaults to 256M. Supported units are k, M, G, Mi, Gi. If no unit is
  /// supplied the value is interpreted as bytes.
  /// See
  /// https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
  /// a full description.
  final String? availableMemory;

  /// The number of CPUs used in a single container instance.
  /// Default value is calculated from available memory.
  /// Supports the same values as Cloud Run, see
  /// https://cloud.google.com/run/docs/reference/rest/v1/Container#resourcerequirements
  /// Example: "1" indicates 1 vCPU
  final String? availableCpu;

  /// Environment variables that shall be available during function execution.
  final Map<String, String>? environmentVariables;

  /// The limit on the maximum number of function instances that may coexist at a
  /// given time.
  ///
  /// In some cases, such as rapid traffic surges, Cloud Functions may, for a
  /// short period of time, create more instances than the specified max
  /// instances limit. If your function cannot tolerate this temporary behavior,
  /// you may want to factor in a safety margin and set a lower max instances
  /// value than your function can tolerate.
  ///
  /// See the [Max
  /// Instances](https://cloud.google.com/functions/docs/max-instances) Guide for
  /// more details.
  final int? maxInstanceCount;

  /// The limit on the minimum number of function instances that may coexist at a
  /// given time.
  ///
  /// Function instances are kept in idle state for a short period after they
  /// finished executing the request to reduce cold start time for subsequent
  /// requests. Setting a minimum instance count will ensure that the given
  /// number of instances are kept running in idle state always. This can help
  /// with cold start times when jump in incoming request count occurs after the
  /// idle instance would have been stopped in the default case.
  final int? minInstanceCount;

  /// The Serverless VPC Access connector that this cloud function can connect
  /// to. The format of this field is `projects/*/locations/*/connectors/*`.
  final String? vpcConnector;

  /// The egress settings for the connector, controlling what traffic is diverted
  /// through it.
  final ServiceConfig_VpcConnectorEgressSettings? vpcConnectorEgressSettings;

  /// The ingress settings for the function, controlling what traffic can reach
  /// it.
  final ServiceConfig_IngressSettings? ingressSettings;

  /// Output only. URI of the Service deployed.
  final String? uri;

  /// The email of the service's service account. If empty, defaults to
  /// `{project_number}-compute@developer.gserviceaccount.com`.
  final String? serviceAccountEmail;

  /// Whether 100% of traffic is routed to the latest revision.
  /// On CreateFunction and UpdateFunction, when set to true, the revision being
  /// deployed will serve 100% of traffic, ignoring any traffic split settings,
  /// if any. On GetFunction, true will be returned if the latest revision is
  /// serving 100% of traffic.
  final bool? allTrafficOnLatestRevision;

  /// Secret environment variables configuration.
  final List<SecretEnvVar>? secretEnvironmentVariables;

  /// Secret volumes configuration.
  final List<SecretVolume>? secretVolumes;

  /// Output only. The name of service revision.
  final String? revision;

  /// Sets the maximum number of concurrent requests that each instance
  /// can receive. Defaults to 1.
  final int? maxInstanceRequestConcurrency;

  /// Security level configure whether the function only accepts https.
  /// This configuration is only applicable to 1st Gen functions with Http
  /// trigger. By default https is optional for 1st Gen functions; 2nd Gen
  /// functions are https ONLY.
  final ServiceConfig_SecurityLevel? securityLevel;

  /// Optional. The binary authorization policy to be checked when deploying the
  /// Cloud Run service.
  final String? binaryAuthorizationPolicy;

  ServiceConfig({
    this.service,
    this.timeoutSeconds,
    this.availableMemory,
    this.availableCpu,
    this.environmentVariables,
    this.maxInstanceCount,
    this.minInstanceCount,
    this.vpcConnector,
    this.vpcConnectorEgressSettings,
    this.ingressSettings,
    this.uri,
    this.serviceAccountEmail,
    this.allTrafficOnLatestRevision,
    this.secretEnvironmentVariables,
    this.secretVolumes,
    this.revision,
    this.maxInstanceRequestConcurrency,
    this.securityLevel,
    this.binaryAuthorizationPolicy,
  }) : super(fullyQualifiedName);

  factory ServiceConfig.fromJson(Map<String, dynamic> json) {
    return ServiceConfig(
      service: json['service'],
      timeoutSeconds: json['timeoutSeconds'],
      availableMemory: json['availableMemory'],
      availableCpu: json['availableCpu'],
      environmentVariables: decodeMap(json['environmentVariables']),
      maxInstanceCount: json['maxInstanceCount'],
      minInstanceCount: json['minInstanceCount'],
      vpcConnector: json['vpcConnector'],
      vpcConnectorEgressSettings: decodeEnum(
        json['vpcConnectorEgressSettings'],
        ServiceConfig_VpcConnectorEgressSettings.fromJson,
      ),
      ingressSettings: decodeEnum(
        json['ingressSettings'],
        ServiceConfig_IngressSettings.fromJson,
      ),
      uri: json['uri'],
      serviceAccountEmail: json['serviceAccountEmail'],
      allTrafficOnLatestRevision: json['allTrafficOnLatestRevision'],
      secretEnvironmentVariables: decodeListMessage(
        json['secretEnvironmentVariables'],
        SecretEnvVar.fromJson,
      ),
      secretVolumes: decodeListMessage(
        json['secretVolumes'],
        SecretVolume.fromJson,
      ),
      revision: json['revision'],
      maxInstanceRequestConcurrency: json['maxInstanceRequestConcurrency'],
      securityLevel: decodeEnum(
        json['securityLevel'],
        ServiceConfig_SecurityLevel.fromJson,
      ),
      binaryAuthorizationPolicy: json['binaryAuthorizationPolicy'],
    );
  }

  @override
  Object toJson() {
    return {
      if (service != null) 'service': service,
      if (timeoutSeconds != null) 'timeoutSeconds': timeoutSeconds,
      if (availableMemory != null) 'availableMemory': availableMemory,
      if (availableCpu != null) 'availableCpu': availableCpu,
      if (environmentVariables != null)
        'environmentVariables': environmentVariables,
      if (maxInstanceCount != null) 'maxInstanceCount': maxInstanceCount,
      if (minInstanceCount != null) 'minInstanceCount': minInstanceCount,
      if (vpcConnector != null) 'vpcConnector': vpcConnector,
      if (vpcConnectorEgressSettings != null)
        'vpcConnectorEgressSettings': vpcConnectorEgressSettings!.toJson(),
      if (ingressSettings != null) 'ingressSettings': ingressSettings!.toJson(),
      if (uri != null) 'uri': uri,
      if (serviceAccountEmail != null)
        'serviceAccountEmail': serviceAccountEmail,
      if (allTrafficOnLatestRevision != null)
        'allTrafficOnLatestRevision': allTrafficOnLatestRevision,
      if (secretEnvironmentVariables != null)
        'secretEnvironmentVariables': encodeList(secretEnvironmentVariables),
      if (secretVolumes != null) 'secretVolumes': encodeList(secretVolumes),
      if (revision != null) 'revision': revision,
      if (maxInstanceRequestConcurrency != null)
        'maxInstanceRequestConcurrency': maxInstanceRequestConcurrency,
      if (securityLevel != null) 'securityLevel': securityLevel!.toJson(),
      if (binaryAuthorizationPolicy != null)
        'binaryAuthorizationPolicy': binaryAuthorizationPolicy,
    };
  }

  @override
  String toString() {
    final contents = [
      if (service != null) 'service=$service',
      if (timeoutSeconds != null) 'timeoutSeconds=$timeoutSeconds',
      if (availableMemory != null) 'availableMemory=$availableMemory',
      if (availableCpu != null) 'availableCpu=$availableCpu',
      if (maxInstanceCount != null) 'maxInstanceCount=$maxInstanceCount',
      if (minInstanceCount != null) 'minInstanceCount=$minInstanceCount',
      if (vpcConnector != null) 'vpcConnector=$vpcConnector',
      if (vpcConnectorEgressSettings != null)
        'vpcConnectorEgressSettings=$vpcConnectorEgressSettings',
      if (ingressSettings != null) 'ingressSettings=$ingressSettings',
      if (uri != null) 'uri=$uri',
      if (serviceAccountEmail != null)
        'serviceAccountEmail=$serviceAccountEmail',
      if (allTrafficOnLatestRevision != null)
        'allTrafficOnLatestRevision=$allTrafficOnLatestRevision',
      if (revision != null) 'revision=$revision',
      if (maxInstanceRequestConcurrency != null)
        'maxInstanceRequestConcurrency=$maxInstanceRequestConcurrency',
      if (securityLevel != null) 'securityLevel=$securityLevel',
      if (binaryAuthorizationPolicy != null)
        'binaryAuthorizationPolicy=$binaryAuthorizationPolicy',
    ].join(',');
    return 'ServiceConfig($contents)';
  }
}

/// Available egress settings.
///
/// This controls what traffic is diverted through the VPC Access Connector
/// resource. By default PRIVATE_RANGES_ONLY will be used.
class ServiceConfig_VpcConnectorEgressSettings extends ProtoEnum {
  /// Unspecified.
  static const vpcConnectorEgressSettingsUnspecified =
      ServiceConfig_VpcConnectorEgressSettings(
        'VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED',
      );

  /// Use the VPC Access Connector only for private IP space from RFC1918.
  static const privateRangesOnly = ServiceConfig_VpcConnectorEgressSettings(
    'PRIVATE_RANGES_ONLY',
  );

  /// Force the use of VPC Access Connector for all egress traffic from the
  /// function.
  static const allTraffic = ServiceConfig_VpcConnectorEgressSettings(
    'ALL_TRAFFIC',
  );

  const ServiceConfig_VpcConnectorEgressSettings(super.value);

  factory ServiceConfig_VpcConnectorEgressSettings.fromJson(String json) =>
      ServiceConfig_VpcConnectorEgressSettings(json);

  @override
  String toString() => 'VpcConnectorEgressSettings.$value';
}

/// Available ingress settings.
///
/// This controls what traffic can reach the function.
///
/// If unspecified, ALLOW_ALL will be used.
class ServiceConfig_IngressSettings extends ProtoEnum {
  /// Unspecified.
  static const ingressSettingsUnspecified = ServiceConfig_IngressSettings(
    'INGRESS_SETTINGS_UNSPECIFIED',
  );

  /// Allow HTTP traffic from public and private sources.
  static const allowAll = ServiceConfig_IngressSettings('ALLOW_ALL');

  /// Allow HTTP traffic from only private VPC sources.
  static const allowInternalOnly = ServiceConfig_IngressSettings(
    'ALLOW_INTERNAL_ONLY',
  );

  /// Allow HTTP traffic from private VPC sources and through GCLB.
  static const allowInternalAndGclb = ServiceConfig_IngressSettings(
    'ALLOW_INTERNAL_AND_GCLB',
  );

  const ServiceConfig_IngressSettings(super.value);

  factory ServiceConfig_IngressSettings.fromJson(String json) =>
      ServiceConfig_IngressSettings(json);

  @override
  String toString() => 'IngressSettings.$value';
}

/// Available security level settings.
///
/// This enforces security protocol on function URL.
///
/// Security level is only configurable for 1st Gen functions, If unspecified,
/// SECURE_OPTIONAL will be used. 2nd Gen functions are SECURE_ALWAYS ONLY.
class ServiceConfig_SecurityLevel extends ProtoEnum {
  /// Unspecified.
  static const securityLevelUnspecified = ServiceConfig_SecurityLevel(
    'SECURITY_LEVEL_UNSPECIFIED',
  );

  /// Requests for a URL that match this handler that do not use HTTPS are
  /// automatically redirected to the HTTPS URL with the same path. Query
  /// parameters are reserved for the redirect.
  static const secureAlways = ServiceConfig_SecurityLevel('SECURE_ALWAYS');

  /// Both HTTP and HTTPS requests with URLs that match the handler succeed
  /// without redirects. The application can examine the request to determine
  /// which protocol was used and respond accordingly.
  static const secureOptional = ServiceConfig_SecurityLevel('SECURE_OPTIONAL');

  const ServiceConfig_SecurityLevel(super.value);

  factory ServiceConfig_SecurityLevel.fromJson(String json) =>
      ServiceConfig_SecurityLevel(json);

  @override
  String toString() => 'SecurityLevel.$value';
}

/// Configuration for a secret environment variable. It has the information
/// necessary to fetch the secret value from secret manager and expose it as an
/// environment variable.
class SecretEnvVar extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.SecretEnvVar';

  /// Name of the environment variable.
  final String? key;

  /// Project identifier (preferably project number but can also be the
  /// project ID) of the project that contains the secret. If not set, it is
  /// assumed that the secret is in the same project as the function.
  final String? projectId;

  /// Name of the secret in secret manager (not the full resource name).
  final String? secret;

  /// Version of the secret (version number or the string 'latest'). It is
  /// recommended to use a numeric version for secret environment variables as
  /// any updates to the secret value is not reflected until new instances
  /// start.
  final String? version;

  SecretEnvVar({this.key, this.projectId, this.secret, this.version})
    : super(fullyQualifiedName);

  factory SecretEnvVar.fromJson(Map<String, dynamic> json) {
    return SecretEnvVar(
      key: json['key'],
      projectId: json['projectId'],
      secret: json['secret'],
      version: json['version'],
    );
  }

  @override
  Object toJson() {
    return {
      if (key != null) 'key': key,
      if (projectId != null) 'projectId': projectId,
      if (secret != null) 'secret': secret,
      if (version != null) 'version': version,
    };
  }

  @override
  String toString() {
    final contents = [
      if (key != null) 'key=$key',
      if (projectId != null) 'projectId=$projectId',
      if (secret != null) 'secret=$secret',
      if (version != null) 'version=$version',
    ].join(',');
    return 'SecretEnvVar($contents)';
  }
}

/// Configuration for a secret volume. It has the information necessary to fetch
/// the secret value from secret manager and make it available as files mounted
/// at the requested paths within the application container.
class SecretVolume extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.SecretVolume';

  /// The path within the container to mount the secret volume. For example,
  /// setting the mount_path as `/etc/secrets` would mount the secret value files
  /// under the `/etc/secrets` directory. This directory will also be completely
  /// shadowed and unavailable to mount any other secrets.
  /// Recommended mount path: /etc/secrets
  final String? mountPath;

  /// Project identifier (preferably project number but can also be the project
  /// ID) of the project that contains the secret. If not set, it is
  /// assumed that the secret is in the same project as the function.
  final String? projectId;

  /// Name of the secret in secret manager (not the full resource name).
  final String? secret;

  /// List of secret versions to mount for this secret. If empty, the `latest`
  /// version of the secret will be made available in a file named after the
  /// secret under the mount point.
  final List<SecretVolume_SecretVersion>? versions;

  SecretVolume({this.mountPath, this.projectId, this.secret, this.versions})
    : super(fullyQualifiedName);

  factory SecretVolume.fromJson(Map<String, dynamic> json) {
    return SecretVolume(
      mountPath: json['mountPath'],
      projectId: json['projectId'],
      secret: json['secret'],
      versions: decodeListMessage(
        json['versions'],
        SecretVolume_SecretVersion.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (mountPath != null) 'mountPath': mountPath,
      if (projectId != null) 'projectId': projectId,
      if (secret != null) 'secret': secret,
      if (versions != null) 'versions': encodeList(versions),
    };
  }

  @override
  String toString() {
    final contents = [
      if (mountPath != null) 'mountPath=$mountPath',
      if (projectId != null) 'projectId=$projectId',
      if (secret != null) 'secret=$secret',
    ].join(',');
    return 'SecretVolume($contents)';
  }
}

/// Configuration for a single version.
class SecretVolume_SecretVersion extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.SecretVolume.SecretVersion';

  /// Version of the secret (version number or the string 'latest'). It is
  /// preferable to use `latest` version with secret volumes as secret value
  /// changes are reflected immediately.
  final String? version;

  /// Relative path of the file under the mount path where the secret value for
  /// this version will be fetched and made available. For example, setting the
  /// mount_path as '/etc/secrets' and path as `secret_foo` would mount the
  /// secret value file at `/etc/secrets/secret_foo`.
  final String? path;

  SecretVolume_SecretVersion({this.version, this.path})
    : super(fullyQualifiedName);

  factory SecretVolume_SecretVersion.fromJson(Map<String, dynamic> json) {
    return SecretVolume_SecretVersion(
      version: json['version'],
      path: json['path'],
    );
  }

  @override
  Object toJson() {
    return {
      if (version != null) 'version': version,
      if (path != null) 'path': path,
    };
  }

  @override
  String toString() {
    final contents = [
      if (version != null) 'version=$version',
      if (path != null) 'path=$path',
    ].join(',');
    return 'SecretVersion($contents)';
  }
}

/// Describes EventTrigger, used to request events to be sent from another
/// service.
class EventTrigger extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.EventTrigger';

  /// Output only. The resource name of the Eventarc trigger. The format of this
  /// field is `projects/{project}/locations/{region}/triggers/{trigger}`.
  final String? trigger;

  /// The region that the trigger will be in. The trigger will only receive
  /// events originating in this region. It can be the same
  /// region as the function, a different region or multi-region, or the global
  /// region. If not provided, defaults to the same region as the function.
  final String? triggerRegion;

  /// Required. The type of event to observe. For example:
  /// `google.cloud.audit.log.v1.written` or
  /// `google.cloud.pubsub.topic.v1.messagePublished`.
  final String? eventType;

  /// Criteria used to filter events.
  final List<EventFilter>? eventFilters;

  /// Optional. The name of a Pub/Sub topic in the same project that will be used
  /// as the transport topic for the event delivery. Format:
  /// `projects/{project}/topics/{topic}`.
  ///
  /// This is only valid for events of type
  /// `google.cloud.pubsub.topic.v1.messagePublished`. The topic provided here
  /// will not be deleted at function deletion.
  final String? pubsubTopic;

  /// Optional. The email of the trigger's service account. The service account
  /// must have permission to invoke Cloud Run services, the permission is
  /// `run.routes.invoke`.
  /// If empty, defaults to the Compute Engine default service account:
  /// `{project_number}-compute@developer.gserviceaccount.com`.
  final String? serviceAccountEmail;

  /// Optional. If unset, then defaults to ignoring failures (i.e. not retrying
  /// them).
  final EventTrigger_RetryPolicy? retryPolicy;

  /// Optional. The name of the channel associated with the trigger in
  /// `projects/{project}/locations/{location}/channels/{channel}` format.
  /// You must provide a channel to receive events from Eventarc SaaS partners.
  final String? channel;

  /// Optional. The hostname of the service that 1st Gen function should be
  /// observed.
  ///
  /// If no string is provided, the default service implementing the API will
  /// be used. For example, `storage.googleapis.com` is the default for all
  /// event types in the `google.storage` namespace.
  ///
  /// The field is only applicable to 1st Gen functions.
  final String? service;

  EventTrigger({
    this.trigger,
    this.triggerRegion,
    this.eventType,
    this.eventFilters,
    this.pubsubTopic,
    this.serviceAccountEmail,
    this.retryPolicy,
    this.channel,
    this.service,
  }) : super(fullyQualifiedName);

  factory EventTrigger.fromJson(Map<String, dynamic> json) {
    return EventTrigger(
      trigger: json['trigger'],
      triggerRegion: json['triggerRegion'],
      eventType: json['eventType'],
      eventFilters: decodeListMessage(
        json['eventFilters'],
        EventFilter.fromJson,
      ),
      pubsubTopic: json['pubsubTopic'],
      serviceAccountEmail: json['serviceAccountEmail'],
      retryPolicy: decodeEnum(
        json['retryPolicy'],
        EventTrigger_RetryPolicy.fromJson,
      ),
      channel: json['channel'],
      service: json['service'],
    );
  }

  @override
  Object toJson() {
    return {
      if (trigger != null) 'trigger': trigger,
      if (triggerRegion != null) 'triggerRegion': triggerRegion,
      if (eventType != null) 'eventType': eventType,
      if (eventFilters != null) 'eventFilters': encodeList(eventFilters),
      if (pubsubTopic != null) 'pubsubTopic': pubsubTopic,
      if (serviceAccountEmail != null)
        'serviceAccountEmail': serviceAccountEmail,
      if (retryPolicy != null) 'retryPolicy': retryPolicy!.toJson(),
      if (channel != null) 'channel': channel,
      if (service != null) 'service': service,
    };
  }

  @override
  String toString() {
    final contents = [
      if (trigger != null) 'trigger=$trigger',
      if (triggerRegion != null) 'triggerRegion=$triggerRegion',
      if (eventType != null) 'eventType=$eventType',
      if (pubsubTopic != null) 'pubsubTopic=$pubsubTopic',
      if (serviceAccountEmail != null)
        'serviceAccountEmail=$serviceAccountEmail',
      if (retryPolicy != null) 'retryPolicy=$retryPolicy',
      if (channel != null) 'channel=$channel',
      if (service != null) 'service=$service',
    ].join(',');
    return 'EventTrigger($contents)';
  }
}

/// Describes the retry policy in case of function's execution failure.
/// Retried execution is charged as any other execution.
class EventTrigger_RetryPolicy extends ProtoEnum {
  /// Not specified.
  static const retryPolicyUnspecified = EventTrigger_RetryPolicy(
    'RETRY_POLICY_UNSPECIFIED',
  );

  /// Do not retry.
  static const retryPolicyDoNotRetry = EventTrigger_RetryPolicy(
    'RETRY_POLICY_DO_NOT_RETRY',
  );

  /// Retry on any failure, retry up to 7 days with an exponential backoff
  /// (capped at 10 seconds).
  static const retryPolicyRetry = EventTrigger_RetryPolicy(
    'RETRY_POLICY_RETRY',
  );

  const EventTrigger_RetryPolicy(super.value);

  factory EventTrigger_RetryPolicy.fromJson(String json) =>
      EventTrigger_RetryPolicy(json);

  @override
  String toString() => 'RetryPolicy.$value';
}

/// Filters events based on exact matches on the CloudEvents attributes.
class EventFilter extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.EventFilter';

  /// Required. The name of a CloudEvents attribute.
  final String? attribute;

  /// Required. The value for the attribute.
  final String? value;

  /// Optional. The operator used for matching the events with the value of the
  /// filter. If not specified, only events that have an exact key-value pair
  /// specified in the filter are matched. The only allowed value is
  /// `match-path-pattern`.
  final String? operator;

  EventFilter({this.attribute, this.value, this.operator})
    : super(fullyQualifiedName);

  factory EventFilter.fromJson(Map<String, dynamic> json) {
    return EventFilter(
      attribute: json['attribute'],
      value: json['value'],
      operator: json['operator'],
    );
  }

  @override
  Object toJson() {
    return {
      if (attribute != null) 'attribute': attribute,
      if (value != null) 'value': value,
      if (operator != null) 'operator': operator,
    };
  }

  @override
  String toString() {
    final contents = [
      if (attribute != null) 'attribute=$attribute',
      if (value != null) 'value=$value',
      if (operator != null) 'operator=$operator',
    ].join(',');
    return 'EventFilter($contents)';
  }
}

/// Request for the `GetFunction` method.
class GetFunctionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.GetFunctionRequest';

  /// Required. The name of the function which details should be obtained.
  final String name;

  /// Optional. The optional version of the 1st gen function whose details should
  /// be obtained. The version of a 1st gen function is an integer that starts
  /// from 1 and gets incremented on redeployments. GCF may keep historical
  /// configs for old versions of 1st gen function. This field can be specified
  /// to fetch the historical configs. This field is valid only for GCF 1st gen
  /// function.
  final String? revision;

  GetFunctionRequest({required this.name, this.revision})
    : super(fullyQualifiedName);

  factory GetFunctionRequest.fromJson(Map<String, dynamic> json) {
    return GetFunctionRequest(name: json['name'], revision: json['revision']);
  }

  @override
  Object toJson() {
    return {'name': name, if (revision != null) 'revision': revision};
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (revision != null) 'revision=$revision',
    ].join(',');
    return 'GetFunctionRequest($contents)';
  }
}

/// Request for the `ListFunctions` method.
class ListFunctionsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.ListFunctionsRequest';

  /// Required. The project and location from which the function should be
  /// listed, specified in the format `projects/*/locations/*` If you want to
  /// list functions in all locations, use "-" in place of a location. When
  /// listing functions in all locations, if one or more location(s) are
  /// unreachable, the response will contain functions from all reachable
  /// locations along with the names of any unreachable locations.
  final String parent;

  /// Maximum number of functions to return per call. The largest allowed
  /// page_size is 1,000, if the page_size is omitted or specified as greater
  /// than 1,000 then it will be replaced as 1,000. The size of the list
  /// response can be less than specified when used with filters.
  final int? pageSize;

  /// The value returned by the last
  /// `ListFunctionsResponse`; indicates that
  /// this is a continuation of a prior `ListFunctions` call, and that the
  /// system should return the next page of data.
  final String? pageToken;

  /// The filter for Functions that match the filter expression,
  /// following the syntax outlined in https://google.aip.dev/160.
  final String? filter;

  /// The sorting order of the resources returned. Value should be a comma
  /// separated list of fields. The default sorting order is ascending.
  /// See https://google.aip.dev/132#ordering.
  final String? orderBy;

  ListFunctionsRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
    this.filter,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListFunctionsRequest.fromJson(Map<String, dynamic> json) {
    return ListFunctionsRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      filter: json['filter'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (filter != null) 'filter': filter,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (filter != null) 'filter=$filter',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListFunctionsRequest($contents)';
  }
}

/// Response for the `ListFunctions` method.
class ListFunctionsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.ListFunctionsResponse';

  /// The functions that match the request.
  final List<Function$>? functions;

  /// A token, which can be sent as `page_token` to retrieve the next page.
  /// If this field is omitted, there are no subsequent pages.
  final String? nextPageToken;

  /// Locations that could not be reached. The response does not include any
  /// functions from these locations.
  final List<String>? unreachable;

  ListFunctionsResponse({this.functions, this.nextPageToken, this.unreachable})
    : super(fullyQualifiedName);

  factory ListFunctionsResponse.fromJson(Map<String, dynamic> json) {
    return ListFunctionsResponse(
      functions: decodeListMessage(json['functions'], Function$.fromJson),
      nextPageToken: json['nextPageToken'],
      unreachable: decodeList(json['unreachable']),
    );
  }

  @override
  Object toJson() {
    return {
      if (functions != null) 'functions': encodeList(functions),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
      if (unreachable != null) 'unreachable': unreachable,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListFunctionsResponse($contents)';
  }
}

/// Request for the `CreateFunction` method.
class CreateFunctionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.CreateFunctionRequest';

  /// Required. The project and location in which the function should be created,
  /// specified in the format `projects/*/locations/*`
  final String parent;

  /// Required. Function to be created.
  final Function$ function;

  /// The ID to use for the function, which will become the final component of
  /// the function's resource name.
  ///
  /// This value should be 4-63 characters, and valid characters
  /// are /[a-z][0-9]-/.
  final String? functionId;

  CreateFunctionRequest({
    required this.parent,
    required this.function,
    this.functionId,
  }) : super(fullyQualifiedName);

  factory CreateFunctionRequest.fromJson(Map<String, dynamic> json) {
    return CreateFunctionRequest(
      parent: json['parent'],
      function: decode(json['function'], Function$.fromJson)!,
      functionId: json['functionId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'function': function.toJson(),
      if (functionId != null) 'functionId': functionId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (functionId != null) 'functionId=$functionId',
    ].join(',');
    return 'CreateFunctionRequest($contents)';
  }
}

/// Request for the `UpdateFunction` method.
class UpdateFunctionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.UpdateFunctionRequest';

  /// Required. New version of the function.
  final Function$ function;

  /// The list of fields to be updated.
  /// If no field mask is provided, all fields will be updated.
  final FieldMask? updateMask;

  UpdateFunctionRequest({required this.function, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateFunctionRequest.fromJson(Map<String, dynamic> json) {
    return UpdateFunctionRequest(
      function: decode(json['function'], Function$.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'function': function.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateFunctionRequest()';
}

/// Request for the `DeleteFunction` method.
class DeleteFunctionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.DeleteFunctionRequest';

  /// Required. The name of the function which should be deleted.
  final String name;

  DeleteFunctionRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteFunctionRequest.fromJson(Map<String, dynamic> json) {
    return DeleteFunctionRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteFunctionRequest($contents)';
  }
}

/// Request of `GenerateSourceUploadUrl` method.
class GenerateUploadUrlRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.GenerateUploadUrlRequest';

  /// Required. The project and location in which the Google Cloud Storage signed
  /// URL should be generated, specified in the format `projects/*/locations/*`.
  final String parent;

  /// Resource name of a KMS crypto key (managed by the user) used to
  /// encrypt/decrypt function source code objects in intermediate Cloud Storage
  /// buckets. When you generate an upload url and upload your source code, it
  /// gets copied to an intermediate Cloud Storage bucket. The source code is
  /// then copied to a versioned directory in the sources bucket in the consumer
  /// project during the function deployment.
  ///
  /// It must match the pattern
  /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
  ///
  /// The Google Cloud Functions service account
  /// (service-{project_number}@gcf-admin-robot.iam.gserviceaccount.com) must be
  /// granted the role 'Cloud KMS CryptoKey Encrypter/Decrypter
  /// (roles/cloudkms.cryptoKeyEncrypterDecrypter)' on the
  /// Key/KeyRing/Project/Organization (least access preferred).
  final String? kmsKeyName;

  /// The function environment the generated upload url will be used for.
  /// The upload url for 2nd Gen functions can also be used for 1st gen
  /// functions, but not vice versa. If not specified, 2nd generation-style
  /// upload URLs are generated.
  final Environment? environment;

  GenerateUploadUrlRequest({
    required this.parent,
    this.kmsKeyName,
    this.environment,
  }) : super(fullyQualifiedName);

  factory GenerateUploadUrlRequest.fromJson(Map<String, dynamic> json) {
    return GenerateUploadUrlRequest(
      parent: json['parent'],
      kmsKeyName: json['kmsKeyName'],
      environment: decodeEnum(json['environment'], Environment.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (kmsKeyName != null) 'kmsKeyName': kmsKeyName,
      if (environment != null) 'environment': environment!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (kmsKeyName != null) 'kmsKeyName=$kmsKeyName',
      if (environment != null) 'environment=$environment',
    ].join(',');
    return 'GenerateUploadUrlRequest($contents)';
  }
}

/// Response of `GenerateSourceUploadUrl` method.
class GenerateUploadUrlResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.GenerateUploadUrlResponse';

  /// The generated Google Cloud Storage signed URL that should be used for a
  /// function source code upload. The uploaded file should be a zip archive
  /// which contains a function.
  final String? uploadUrl;

  /// The location of the source code in the upload bucket.
  ///
  /// Once the archive is uploaded using the `upload_url` use this field to
  /// set the `function.build_config.source.storage_source`
  /// during CreateFunction and UpdateFunction.
  ///
  /// Generation defaults to 0, as Cloud Storage provides a new generation only
  /// upon uploading a new object or version of an object.
  final StorageSource? storageSource;

  GenerateUploadUrlResponse({this.uploadUrl, this.storageSource})
    : super(fullyQualifiedName);

  factory GenerateUploadUrlResponse.fromJson(Map<String, dynamic> json) {
    return GenerateUploadUrlResponse(
      uploadUrl: json['uploadUrl'],
      storageSource: decode(json['storageSource'], StorageSource.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (uploadUrl != null) 'uploadUrl': uploadUrl,
      if (storageSource != null) 'storageSource': storageSource!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (uploadUrl != null) 'uploadUrl=$uploadUrl'].join(',');
    return 'GenerateUploadUrlResponse($contents)';
  }
}

/// Request of `GenerateDownloadUrl` method.
class GenerateDownloadUrlRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.GenerateDownloadUrlRequest';

  /// Required. The name of function for which source code Google Cloud Storage
  /// signed URL should be generated.
  final String name;

  GenerateDownloadUrlRequest({required this.name}) : super(fullyQualifiedName);

  factory GenerateDownloadUrlRequest.fromJson(Map<String, dynamic> json) {
    return GenerateDownloadUrlRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GenerateDownloadUrlRequest($contents)';
  }
}

/// Response of `GenerateDownloadUrl` method.
class GenerateDownloadUrlResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.GenerateDownloadUrlResponse';

  /// The generated Google Cloud Storage signed URL that should be used for
  /// function source code download.
  final String? downloadUrl;

  GenerateDownloadUrlResponse({this.downloadUrl}) : super(fullyQualifiedName);

  factory GenerateDownloadUrlResponse.fromJson(Map<String, dynamic> json) {
    return GenerateDownloadUrlResponse(downloadUrl: json['downloadUrl']);
  }

  @override
  Object toJson() {
    return {if (downloadUrl != null) 'downloadUrl': downloadUrl};
  }

  @override
  String toString() {
    final contents = [
      if (downloadUrl != null) 'downloadUrl=$downloadUrl',
    ].join(',');
    return 'GenerateDownloadUrlResponse($contents)';
  }
}

/// Request for the `ListRuntimes` method.
class ListRuntimesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.ListRuntimesRequest';

  /// Required. The project and location from which the runtimes should be
  /// listed, specified in the format `projects/*/locations/*`
  final String parent;

  /// The filter for Runtimes that match the filter expression,
  /// following the syntax outlined in https://google.aip.dev/160.
  final String? filter;

  ListRuntimesRequest({required this.parent, this.filter})
    : super(fullyQualifiedName);

  factory ListRuntimesRequest.fromJson(Map<String, dynamic> json) {
    return ListRuntimesRequest(parent: json['parent'], filter: json['filter']);
  }

  @override
  Object toJson() {
    return {'parent': parent, if (filter != null) 'filter': filter};
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
    ].join(',');
    return 'ListRuntimesRequest($contents)';
  }
}

/// Response for the `ListRuntimes` method.
class ListRuntimesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.ListRuntimesResponse';

  /// The runtimes that match the request.
  final List<ListRuntimesResponse_Runtime>? runtimes;

  ListRuntimesResponse({this.runtimes}) : super(fullyQualifiedName);

  factory ListRuntimesResponse.fromJson(Map<String, dynamic> json) {
    return ListRuntimesResponse(
      runtimes: decodeListMessage(
        json['runtimes'],
        ListRuntimesResponse_Runtime.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (runtimes != null) 'runtimes': encodeList(runtimes)};
  }

  @override
  String toString() => 'ListRuntimesResponse()';
}

/// Describes a runtime and any special information (e.g., deprecation status)
/// related to it.
class ListRuntimesResponse_Runtime extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.ListRuntimesResponse.Runtime';

  /// The name of the runtime, e.g., 'go113', 'nodejs12', etc.
  final String? name;

  /// The user facing name, eg 'Go 1.13', 'Node.js 12', etc.
  final String? displayName;

  /// The stage of life this runtime is in, e.g., BETA, GA, etc.
  final ListRuntimesResponse_RuntimeStage? stage;

  /// Warning messages, e.g., a deprecation warning.
  final List<String>? warnings;

  /// The environment for the runtime.
  final Environment? environment;

  /// Deprecation date for the runtime.
  final Date? deprecationDate;

  /// Decommission date for the runtime.
  final Date? decommissionDate;

  ListRuntimesResponse_Runtime({
    this.name,
    this.displayName,
    this.stage,
    this.warnings,
    this.environment,
    this.deprecationDate,
    this.decommissionDate,
  }) : super(fullyQualifiedName);

  factory ListRuntimesResponse_Runtime.fromJson(Map<String, dynamic> json) {
    return ListRuntimesResponse_Runtime(
      name: json['name'],
      displayName: json['displayName'],
      stage: decodeEnum(
        json['stage'],
        ListRuntimesResponse_RuntimeStage.fromJson,
      ),
      warnings: decodeList(json['warnings']),
      environment: decodeEnum(json['environment'], Environment.fromJson),
      deprecationDate: decode(json['deprecationDate'], Date.fromJson),
      decommissionDate: decode(json['decommissionDate'], Date.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (stage != null) 'stage': stage!.toJson(),
      if (warnings != null) 'warnings': warnings,
      if (environment != null) 'environment': environment!.toJson(),
      if (deprecationDate != null) 'deprecationDate': deprecationDate!.toJson(),
      if (decommissionDate != null)
        'decommissionDate': decommissionDate!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (stage != null) 'stage=$stage',
      if (environment != null) 'environment=$environment',
    ].join(',');
    return 'Runtime($contents)';
  }
}

/// The various stages that a runtime can be in.
class ListRuntimesResponse_RuntimeStage extends ProtoEnum {
  /// Not specified.
  static const runtimeStageUnspecified = ListRuntimesResponse_RuntimeStage(
    'RUNTIME_STAGE_UNSPECIFIED',
  );

  /// The runtime is in development.
  static const development = ListRuntimesResponse_RuntimeStage('DEVELOPMENT');

  /// The runtime is in the Alpha stage.
  static const alpha = ListRuntimesResponse_RuntimeStage('ALPHA');

  /// The runtime is in the Beta stage.
  static const beta = ListRuntimesResponse_RuntimeStage('BETA');

  /// The runtime is generally available.
  static const ga = ListRuntimesResponse_RuntimeStage('GA');

  /// The runtime is deprecated.
  static const deprecated = ListRuntimesResponse_RuntimeStage('DEPRECATED');

  /// The runtime is no longer supported.
  static const decommissioned = ListRuntimesResponse_RuntimeStage(
    'DECOMMISSIONED',
  );

  const ListRuntimesResponse_RuntimeStage(super.value);

  factory ListRuntimesResponse_RuntimeStage.fromJson(String json) =>
      ListRuntimesResponse_RuntimeStage(json);

  @override
  String toString() => 'RuntimeStage.$value';
}

/// Security patches are applied automatically to the runtime without requiring
/// the function to be redeployed.
class AutomaticUpdatePolicy extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.AutomaticUpdatePolicy';

  AutomaticUpdatePolicy() : super(fullyQualifiedName);

  factory AutomaticUpdatePolicy.fromJson(Map<String, dynamic> json) {
    return AutomaticUpdatePolicy();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'AutomaticUpdatePolicy()';
}

/// Security patches are only applied when a function is redeployed.
class OnDeployUpdatePolicy extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.OnDeployUpdatePolicy';

  /// Output only. contains the runtime version which was used during latest
  /// function deployment.
  final String? runtimeVersion;

  OnDeployUpdatePolicy({this.runtimeVersion}) : super(fullyQualifiedName);

  factory OnDeployUpdatePolicy.fromJson(Map<String, dynamic> json) {
    return OnDeployUpdatePolicy(runtimeVersion: json['runtimeVersion']);
  }

  @override
  Object toJson() {
    return {if (runtimeVersion != null) 'runtimeVersion': runtimeVersion};
  }

  @override
  String toString() {
    final contents = [
      if (runtimeVersion != null) 'runtimeVersion=$runtimeVersion',
    ].join(',');
    return 'OnDeployUpdatePolicy($contents)';
  }
}

/// Represents the metadata of the long-running operation.
class OperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.OperationMetadata';

  /// The time the operation was created.
  final Timestamp? createTime;

  /// The time the operation finished running.
  final Timestamp? endTime;

  /// Server-defined resource path for the target of the operation.
  final String? target;

  /// Name of the verb executed by the operation.
  final String? verb;

  /// Human-readable status of the operation, if any.
  final String? statusDetail;

  /// Identifies whether the user has requested cancellation
  /// of the operation. Operations that have successfully been cancelled
  /// have
  /// `google.longrunning.Operation.error`
  /// value with a `google.rpc.Status.code` of 1,
  /// corresponding to `Code.CANCELLED`.
  final bool? cancelRequested;

  /// API version used to start the operation.
  final String? apiVersion;

  /// The original request that started the operation.
  final Any? requestResource;

  /// Mechanism for reporting in-progress stages
  final List<Stage>? stages;

  /// An identifier for Firebase function sources. Disclaimer: This field is only
  /// supported for Firebase function deployments.
  final String? sourceToken;

  /// The build name of the function for create and update operations.
  final String? buildName;

  /// The operation type.
  final OperationType? operationType;

  OperationMetadata({
    this.createTime,
    this.endTime,
    this.target,
    this.verb,
    this.statusDetail,
    this.cancelRequested,
    this.apiVersion,
    this.requestResource,
    this.stages,
    this.sourceToken,
    this.buildName,
    this.operationType,
  }) : super(fullyQualifiedName);

  factory OperationMetadata.fromJson(Map<String, dynamic> json) {
    return OperationMetadata(
      createTime: decodeCustom(json['createTime'], Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], Timestamp.fromJson),
      target: json['target'],
      verb: json['verb'],
      statusDetail: json['statusDetail'],
      cancelRequested: json['cancelRequested'],
      apiVersion: json['apiVersion'],
      requestResource: decode(json['requestResource'], Any.fromJson),
      stages: decodeListMessage(json['stages'], Stage.fromJson),
      sourceToken: json['sourceToken'],
      buildName: json['buildName'],
      operationType: decodeEnum(json['operationType'], OperationType.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
      if (target != null) 'target': target,
      if (verb != null) 'verb': verb,
      if (statusDetail != null) 'statusDetail': statusDetail,
      if (cancelRequested != null) 'cancelRequested': cancelRequested,
      if (apiVersion != null) 'apiVersion': apiVersion,
      if (requestResource != null) 'requestResource': requestResource!.toJson(),
      if (stages != null) 'stages': encodeList(stages),
      if (sourceToken != null) 'sourceToken': sourceToken,
      if (buildName != null) 'buildName': buildName,
      if (operationType != null) 'operationType': operationType!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (target != null) 'target=$target',
      if (verb != null) 'verb=$verb',
      if (statusDetail != null) 'statusDetail=$statusDetail',
      if (cancelRequested != null) 'cancelRequested=$cancelRequested',
      if (apiVersion != null) 'apiVersion=$apiVersion',
      if (sourceToken != null) 'sourceToken=$sourceToken',
      if (buildName != null) 'buildName=$buildName',
      if (operationType != null) 'operationType=$operationType',
    ].join(',');
    return 'OperationMetadata($contents)';
  }
}

/// Extra GCF specific location information.
class LocationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.LocationMetadata';

  /// The Cloud Function environments this location supports.
  final List<Environment>? environments;

  LocationMetadata({this.environments}) : super(fullyQualifiedName);

  factory LocationMetadata.fromJson(Map<String, dynamic> json) {
    return LocationMetadata(
      environments: decodeListEnum(json['environments'], Environment.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (environments != null) 'environments': encodeList(environments)};
  }

  @override
  String toString() => 'LocationMetadata()';
}

/// Each Stage of the deployment process
class Stage extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.functions.v2.Stage';

  /// Name of the Stage. This will be unique for each Stage.
  final Stage_Name? name;

  /// Message describing the Stage
  final String? message;

  /// Current state of the Stage
  final Stage_State? state;

  /// Resource of the Stage
  final String? resource;

  /// Link to the current Stage resource
  final String? resourceUri;

  /// State messages from the current Stage.
  final List<StateMessage>? stateMessages;

  Stage({
    this.name,
    this.message,
    this.state,
    this.resource,
    this.resourceUri,
    this.stateMessages,
  }) : super(fullyQualifiedName);

  factory Stage.fromJson(Map<String, dynamic> json) {
    return Stage(
      name: decodeEnum(json['name'], Stage_Name.fromJson),
      message: json['message'],
      state: decodeEnum(json['state'], Stage_State.fromJson),
      resource: json['resource'],
      resourceUri: json['resourceUri'],
      stateMessages: decodeListMessage(
        json['stateMessages'],
        StateMessage.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name!.toJson(),
      if (message != null) 'message': message,
      if (state != null) 'state': state!.toJson(),
      if (resource != null) 'resource': resource,
      if (resourceUri != null) 'resourceUri': resourceUri,
      if (stateMessages != null) 'stateMessages': encodeList(stateMessages),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (message != null) 'message=$message',
      if (state != null) 'state=$state',
      if (resource != null) 'resource=$resource',
      if (resourceUri != null) 'resourceUri=$resourceUri',
    ].join(',');
    return 'Stage($contents)';
  }
}

/// Possible names for a Stage
class Stage_Name extends ProtoEnum {
  /// Not specified. Invalid name.
  static const nameUnspecified = Stage_Name('NAME_UNSPECIFIED');

  /// Artifact Registry Stage
  static const artifactRegistry = Stage_Name('ARTIFACT_REGISTRY');

  /// Build Stage
  static const build = Stage_Name('BUILD');

  /// Service Stage
  static const service = Stage_Name('SERVICE');

  /// Trigger Stage
  static const trigger = Stage_Name('TRIGGER');

  /// Service Rollback Stage
  static const serviceRollback = Stage_Name('SERVICE_ROLLBACK');

  /// Trigger Rollback Stage
  static const triggerRollback = Stage_Name('TRIGGER_ROLLBACK');

  const Stage_Name(super.value);

  factory Stage_Name.fromJson(String json) => Stage_Name(json);

  @override
  String toString() => 'Name.$value';
}

/// Possible states for a Stage
class Stage_State extends ProtoEnum {
  /// Not specified. Invalid state.
  static const stateUnspecified = Stage_State('STATE_UNSPECIFIED');

  /// Stage has not started.
  static const notStarted = Stage_State('NOT_STARTED');

  /// Stage is in progress.
  static const inProgress = Stage_State('IN_PROGRESS');

  /// Stage has completed.
  static const complete = Stage_State('COMPLETE');

  const Stage_State(super.value);

  factory Stage_State.fromJson(String json) => Stage_State(json);

  @override
  String toString() => 'State.$value';
}

/// The type of the long running operation.
class OperationType extends ProtoEnum {
  /// Unspecified
  static const operationtypeUnspecified = OperationType(
    'OPERATIONTYPE_UNSPECIFIED',
  );

  /// CreateFunction
  static const createFunction = OperationType('CREATE_FUNCTION');

  /// UpdateFunction
  static const updateFunction = OperationType('UPDATE_FUNCTION');

  /// DeleteFunction
  static const deleteFunction = OperationType('DELETE_FUNCTION');

  const OperationType(super.value);

  factory OperationType.fromJson(String json) => OperationType(json);

  @override
  String toString() => 'OperationType.$value';
}

/// The environment the function is hosted on.
class Environment extends ProtoEnum {
  /// Unspecified
  static const environmentUnspecified = Environment('ENVIRONMENT_UNSPECIFIED');

  /// Gen 1
  static const gen1 = Environment('GEN_1');

  /// Gen 2
  static const gen2 = Environment('GEN_2');

  const Environment(super.value);

  factory Environment.fromJson(String json) => Environment(json);

  @override
  String toString() => 'Environment.$value';
}
