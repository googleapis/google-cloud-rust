// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Verify enums work correctly with respect to unknown values, JSON
// serialization and deserialization, and conversions to i32.
#[cfg(test)]
mod test {
    use generated::*;
    use serde_json::json;
    type TestResult = Result<(), Box<dyn std::error::Error>>;

    #[test]
    fn serialize() -> TestResult {
        let input = syntax::SYNTAX_EDITIONS;
        assert_eq!(input.value(), "SYNTAX_EDITIONS");
        assert_eq!(input.numeric_value(), Some(2));
        let got = serde_json::to_value(&input)?;
        assert_eq!(got.as_str(), Some("SYNTAX_EDITIONS"));

        let input = syntax::SYNTAX_PROTO3;
        assert_eq!(input.value(), "SYNTAX_PROTO3");
        assert_eq!(input.numeric_value(), Some(1));
        let got = serde_json::to_value(&input)?;
        assert_eq!(got.as_str(), Some("SYNTAX_PROTO3"));

        let input = syntax::SYNTAX_PROTO2;
        assert_eq!(input.value(), "SYNTAX_PROTO2");
        assert_eq!(input.numeric_value(), Some(0));
        let got = serde_json::to_value(&input)?;
        assert_eq!(got.as_str(), Some("SYNTAX_PROTO2"));

        let input = Syntax::from("UNKNOWN".to_string());
        assert_eq!(input.value(), "UNKNOWN");
        assert_eq!(input.numeric_value(), None);
        let got = serde_json::to_value(&input)?;
        assert_eq!(got.as_str(), Some("UNKNOWN"));

        let input = Syntax::from(7);
        assert_eq!(input.numeric_value(), Some(7));
        let got = serde_json::to_value(&input)?;
        assert_eq!(got.as_number().cloned(), serde_json::Number::from_i128(7));

        Ok(())
    }

    #[test]
    fn deserialize() -> TestResult {
        let input = json!("SYNTAX_EDITIONS");
        let got = serde_json::from_value::<Syntax>(input)?;
        assert_eq!(got.value(), "SYNTAX_EDITIONS");
        assert_eq!(got.numeric_value(), Some(2));

        let input = json!("SYNTAX_PROTO3");
        let got = serde_json::from_value::<Syntax>(input)?;
        assert_eq!(got.value(), "SYNTAX_PROTO3");
        assert_eq!(got.numeric_value(), Some(1));

        let input = json!("SYNTAX_PROTO2");
        let got = serde_json::from_value::<Syntax>(input)?;
        assert_eq!(got.value(), "SYNTAX_PROTO2");
        assert_eq!(got.numeric_value(), Some(0));

        let input = json!("UNKNOWN");
        let got = serde_json::from_value::<Syntax>(input)?;
        assert_eq!(got.value(), "UNKNOWN");
        assert_eq!(got.numeric_value(), None);

        Ok(())
    }

    #[test]
    fn deserialize_integer() -> TestResult {
        let input = json!(2);
        let got = serde_json::from_value::<Syntax>(input)?;
        assert_eq!(got.value(), "SYNTAX_EDITIONS");
        assert_eq!(got.numeric_value(), Some(2));

        let input = json!(1);
        let got = serde_json::from_value::<Syntax>(input)?;
        assert_eq!(got.value(), "SYNTAX_PROTO3");
        assert_eq!(got.numeric_value(), Some(1));

        let input = json!(0);
        let got = serde_json::from_value::<Syntax>(input)?;
        assert_eq!(got.value(), "SYNTAX_PROTO2");
        assert_eq!(got.numeric_value(), Some(0));

        let input = json!(7);
        let got = serde_json::from_value::<Syntax>(input)?;
        assert!(
            got.value().contains("7"),
            "got={got:?}, got.value()={}",
            got.value()
        );
        assert_eq!(got.numeric_value(), Some(7));

        Ok(())
    }

    // This is the code generated by sidekick for a simple enum.
    //
    // enum Syntax {
    //   SYNTAX_PROTO2 = 0,
    //   SYNTAX_PROTO3 = 1,
    //   SYNTAX_EDITONS = 2,
    // }
    mod generated {
        use google_cloud_wkt as wkt;

        #[derive(Clone, Debug, PartialEq)]
        pub struct Syntax(wkt::enumerations::Enumeration);

        pub mod syntax {
            use super::Syntax;
            pub const SYNTAX_PROTO2: Syntax = Syntax::known("SYNTAX_PROTO2", 0);
            pub const SYNTAX_PROTO3: Syntax = Syntax::known("SYNTAX_PROTO3", 1);
            pub const SYNTAX_EDITIONS: Syntax = Syntax::known("SYNTAX_EDITIONS", 2);
        }

        impl Syntax {
            pub(crate) const fn known(str: &'static str, val: i32) -> Self {
                Self(wkt::enumerations::Enumeration::known(str, val))
            }
            pub fn value(&self) -> &str {
                self.0.value()
            }
            pub fn numeric_value(&self) -> Option<i32> {
                self.0.numeric_value()
            }
        }

        impl serde::ser::Serialize for Syntax {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                self.0.serialize(serializer)
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Syntax {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                use wkt::enumerations::Enumeration;
                let enumeration = Enumeration::deserialize(deserializer)?;
                match enumeration {
                    Enumeration::Known { str: _, val } => Ok(Syntax::from(val)),
                    Enumeration::UnknownStr { val, str: _ } => Ok(Syntax::from(val)),
                    Enumeration::UnknownNum { str } => Ok(Syntax::from(str)),
                }
            }
        }

        impl std::convert::From<std::string::String> for Syntax {
            fn from(value: std::string::String) -> Self {
                match value.as_str() {
                    "SYNTAX_PROTO2" => syntax::SYNTAX_PROTO2,
                    "SYNTAX_PROTO3" => syntax::SYNTAX_PROTO3,
                    "SYNTAX_EDITIONS" => syntax::SYNTAX_EDITIONS,
                    _ => Self(wkt::enumerations::Enumeration::known_str(value)),
                }
            }
        }

        impl std::convert::From<i32> for Syntax {
            fn from(value: i32) -> Self {
                match value {
                    0 => syntax::SYNTAX_PROTO2,
                    1 => syntax::SYNTAX_PROTO3,
                    2 => syntax::SYNTAX_EDITIONS,
                    _ => Self(wkt::enumerations::Enumeration::known_num(value)),
                }
            }
        }

        impl std::default::Default for Syntax {
            fn default() -> Self {
                Self::from(0)
            }
        }
    }
}
