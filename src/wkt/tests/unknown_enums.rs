// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Verify enums work correctly with respect to unknown values, JSON
// serialization and deserialization, and conversions to i32.
#[cfg(test)]
mod test {
    use generated::*;
    use serde_json::json;
    type TestResult = Result<(), Box<dyn std::error::Error>>;

    #[test]
    fn serialize() -> TestResult {
        let input = syntax::SYNTAX_EDITIONS;
        assert_eq!(input.value(), "SYNTAX_EDITIONS");
        assert_eq!(input.numeric_value(), Some(2));
        let got = serde_json::to_value(&input)?;
        assert_eq!(got.as_str(), Some("SYNTAX_EDITIONS"));

        let input = syntax::SYNTAX_PROTO3;
        assert_eq!(input.value(), "SYNTAX_PROTO3");
        assert_eq!(input.numeric_value(), Some(1));
        let got = serde_json::to_value(&input)?;
        assert_eq!(got.as_str(), Some("SYNTAX_PROTO3"));

        let input = syntax::SYNTAX_PROTO2;
        assert_eq!(input.value(), "SYNTAX_PROTO2");
        assert_eq!(input.numeric_value(), Some(0));
        let got = serde_json::to_value(&input)?;
        assert_eq!(got.as_str(), Some("SYNTAX_PROTO2"));

        let input = Syntax::from("UNKNOWN".to_string());
        assert_eq!(input.value(), "UNKNOWN");
        assert_eq!(input.numeric_value(), None);
        let got = serde_json::to_value(&input)?;
        assert_eq!(got.as_str(), Some("UNKNOWN"));

        let input = Syntax::from(7);
        assert_eq!(input.numeric_value(), Some(7));
        let got = serde_json::to_value(&input)?;
        assert_eq!(got.as_number().cloned(), serde_json::Number::from_i128(7));

        Ok(())
    }

    #[test]
    fn deserialize() -> TestResult {
        let input = json!("SYNTAX_EDITIONS");
        let got = serde_json::from_value::<Syntax>(input)?;
        assert_eq!(got.value(), "SYNTAX_EDITIONS");
        assert_eq!(got.numeric_value(), Some(2));

        let input = json!("SYNTAX_PROTO3");
        let got = serde_json::from_value::<Syntax>(input)?;
        assert_eq!(got.value(), "SYNTAX_PROTO3");
        assert_eq!(got.numeric_value(), Some(1));

        let input = json!("SYNTAX_PROTO2");
        let got = serde_json::from_value::<Syntax>(input)?;
        assert_eq!(got.value(), "SYNTAX_PROTO2");
        assert_eq!(got.numeric_value(), Some(0));

        let input = json!("UNKNOWN");
        let got = serde_json::from_value::<Syntax>(input)?;
        assert_eq!(got.value(), "UNKNOWN");
        assert_eq!(got.numeric_value(), None);

        Ok(())
    }

    #[test]
    fn deserialize_integer() -> TestResult {
        let input = json!(2);
        let got = serde_json::from_value::<Syntax>(input)?;
        assert_eq!(got.value(), "SYNTAX_EDITIONS");
        assert_eq!(got.numeric_value(), Some(2));

        let input = json!(1);
        let got = serde_json::from_value::<Syntax>(input)?;
        assert_eq!(got.value(), "SYNTAX_PROTO3");
        assert_eq!(got.numeric_value(), Some(1));

        let input = json!(0);
        let got = serde_json::from_value::<Syntax>(input)?;
        assert_eq!(got.value(), "SYNTAX_PROTO2");
        assert_eq!(got.numeric_value(), Some(0));

        let input = json!(7);
        let got = serde_json::from_value::<Syntax>(input)?;
        assert!(
            got.value().contains("7"),
            "got={got:?}, got.value()={}",
            got.value()
        );
        assert_eq!(got.numeric_value(), Some(7));

        Ok(())
    }

    // This is the code generated by sidekick for a simple enum.
    //
    // enum Syntax {
    //   SYNTAX_PROTO2 = 0,
    //   SYNTAX_PROTO3 = 1,
    //   SYNTAX_EDITONS = 2,
    // }
    mod generated {
        #[derive(Clone, Debug, PartialEq)]
        pub enum Syntax {
            Known { str: &'static str, val: i32 },
            UnkwownValue { str: String },
            UnknownName { val: i32, formatted: String },
        }

        pub mod syntax {
            use super::Syntax;
            pub const SYNTAX_PROTO2: Syntax = Syntax::known("SYNTAX_PROTO2", 0);
            pub const SYNTAX_PROTO3: Syntax = Syntax::known("SYNTAX_PROTO3", 1);
            pub const SYNTAX_EDITIONS: Syntax = Syntax::known("SYNTAX_EDITIONS", 2);
        }

        impl Syntax {
            pub(crate) const fn known(str: &'static str, val: i32) -> Self {
                Self::Known { str, val }
            }
            pub(crate) fn unknown_str(str: String) -> Self {
                Self::UnkwownValue { str }
            }
            pub(crate) fn unknown_i32(val: i32) -> Self {
                let formatted = format!("UNKOWN-NAME:{}", val);
                Self::UnknownName { val, formatted }
            }
            pub fn value(&self) -> &str {
                match self {
                    Self::Known { str: s, val: _ } => s,
                    Self::UnkwownValue { str: s } => s,
                    Self::UnknownName {
                        val: _,
                        formatted: s,
                    } => s,
                }
            }
            pub fn numeric_value(&self) -> Option<i32> {
                match self {
                    Self::Known { str: _, val: v } => Some(v.clone()),
                    Self::UnkwownValue { str: _ } => None,
                    Self::UnknownName {
                        val: v,
                        formatted: _,
                    } => Some(v.clone()),
                }
            }
        }

        impl serde::ser::Serialize for Syntax {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                match self {
                    Self::Known { str: s, val: _ } => s.serialize(serializer),
                    Self::UnknownName {
                        val: v,
                        formatted: _,
                    } => v.serialize(serializer),
                    Self::UnkwownValue { str: s } => s.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Syntax {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl serde::de::Visitor<'_> for Visitor {
                    type Value = Syntax;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("integer or a string")
                    }

                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        Ok(Syntax::from(value.to_string()))
                    }
                    fn visit_u64<E>(self, value: u64) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        if value >= i32::MAX as u64 {
                            return Err(serde::de::Error::invalid_value(
                                serde::de::Unexpected::Unsigned(value),
                                &"a i32 integer",
                            ));
                        }
                        Ok(Syntax::from(value as i32))
                    }
                    fn visit_i64<E>(self, value: i64) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        if value >= i32::MAX as i64 || value <= i32::MIN as i64 {
                            return Err(serde::de::Error::invalid_value(
                                serde::de::Unexpected::Signed(value),
                                &"a i32 integer",
                            ));
                        }
                        Ok(Syntax::from(value as i32))
                    }
                }

                deserializer.deserialize_any(Visitor)
            }
        }

        impl std::convert::From<std::string::String> for Syntax {
            fn from(value: std::string::String) -> Self {
                match value.as_str() {
                    "SYNTAX_PROTO2" => syntax::SYNTAX_PROTO2,
                    "SYNTAX_PROTO3" => syntax::SYNTAX_PROTO3,
                    "SYNTAX_EDITIONS" => syntax::SYNTAX_EDITIONS,
                    _ => Self::unknown_str(value),
                }
            }
        }

        impl std::convert::From<i32> for Syntax {
            fn from(value: i32) -> Self {
                match value {
                    0 => syntax::SYNTAX_PROTO2,
                    1 => syntax::SYNTAX_PROTO3,
                    2 => syntax::SYNTAX_EDITIONS,
                    _ => Self::unknown_i32(value),
                }
            }
        }

        impl std::default::Default for Syntax {
            fn default() -> Self {
                syntax::SYNTAX_PROTO2
            }
        }
    }
}
