// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithEnum {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithEnum")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithEnum;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithEnum")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            result.singular =
                                map.next_value::<std::option::Option<
                                    crate::generated::message_with_enum::TestEnum,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            result.optional = map.next_value::<std::option::Option<
                                crate::generated::message_with_enum::TestEnum,
                            >>()?;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            result.repeated = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::generated::message_with_enum::TestEnum>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            result.map = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::generated::message_with_enum::TestEnum,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithOneOf {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __string_contents,
            __string_contents_one,
            __string_contents_two,
            __message_value,
            __another_message,
            __string,
            __duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithOneOf")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stringContents" => Ok(__FieldTag::__string_contents),
                            "string_contents" => Ok(__FieldTag::__string_contents),
                            "stringContentsOne" => Ok(__FieldTag::__string_contents_one),
                            "string_contents_one" => Ok(__FieldTag::__string_contents_one),
                            "stringContentsTwo" => Ok(__FieldTag::__string_contents_two),
                            "string_contents_two" => Ok(__FieldTag::__string_contents_two),
                            "messageValue" => Ok(__FieldTag::__message_value),
                            "message_value" => Ok(__FieldTag::__message_value),
                            "anotherMessage" => Ok(__FieldTag::__another_message),
                            "another_message" => Ok(__FieldTag::__another_message),
                            "string" => Ok(__FieldTag::__string),
                            "duration" => Ok(__FieldTag::__duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithOneOf;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithOneOf")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__string_contents => {
                            if !fields.insert(__FieldTag::__string_contents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_contents",
                                ));
                            }
                            if result.single_string.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `single_string`, a oneof with full ID .google.rust.sdk.test.MessageWithOneOf.string_contents, latest field was stringContents",
                                ));
                            }
                            result.single_string = std::option::Option::Some(
                                crate::generated::message_with_one_of::SingleString::StringContents(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__string_contents_one => {
                            if !fields.insert(__FieldTag::__string_contents_one) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_contents_one",
                                ));
                            }
                            if result.two_strings.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `two_strings`, a oneof with full ID .google.rust.sdk.test.MessageWithOneOf.string_contents_one, latest field was stringContentsOne",
                                ));
                            }
                            result.two_strings = std::option::Option::Some(
                                crate::generated::message_with_one_of::TwoStrings::StringContentsOne(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__string_contents_two => {
                            if !fields.insert(__FieldTag::__string_contents_two) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_contents_two",
                                ));
                            }
                            if result.two_strings.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `two_strings`, a oneof with full ID .google.rust.sdk.test.MessageWithOneOf.string_contents_two, latest field was stringContentsTwo",
                                ));
                            }
                            result.two_strings = std::option::Option::Some(
                                crate::generated::message_with_one_of::TwoStrings::StringContentsTwo(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__message_value => {
                            if !fields.insert(__FieldTag::__message_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_value",
                                ));
                            }
                            if result.one_message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `one_message`, a oneof with full ID .google.rust.sdk.test.MessageWithOneOf.message_value, latest field was messageValue",
                                ));
                            }
                            result.one_message = std::option::Option::Some(
                                crate::generated::message_with_one_of::OneMessage::MessageValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::generated::message_with_one_of::Message,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__another_message => {
                            if !fields.insert(__FieldTag::__another_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for another_message",
                                ));
                            }
                            if result.mixed.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mixed`, a oneof with full ID .google.rust.sdk.test.MessageWithOneOf.another_message, latest field was anotherMessage",
                                ));
                            }
                            result.mixed = std::option::Option::Some(
                                crate::generated::message_with_one_of::Mixed::AnotherMessage(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::generated::message_with_one_of::Message,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__string => {
                            if !fields.insert(__FieldTag::__string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string",
                                ));
                            }
                            if result.mixed.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mixed`, a oneof with full ID .google.rust.sdk.test.MessageWithOneOf.string, latest field was string",
                                ));
                            }
                            result.mixed = std::option::Option::Some(
                                crate::generated::message_with_one_of::Mixed::String(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            if result.mixed.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mixed`, a oneof with full ID .google.rust.sdk.test.MessageWithOneOf.duration, latest field was duration",
                                ));
                            }
                            result.mixed = std::option::Option::Some(
                                crate::generated::message_with_one_of::Mixed::Duration(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::message_with_one_of::Message {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Message")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::message_with_one_of::Message;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Message")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithComplexOneOf {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __null,
            __bool_value,
            __bytes_value,
            __string_value,
            __float_value,
            __double_value,
            __int32,
            __int64,
            __enum,
            __inner,
            __duration,
            __value,
            __optional_double,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithComplexOneOf")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "null" => Ok(__FieldTag::__null),
                            "boolValue" => Ok(__FieldTag::__bool_value),
                            "bool_value" => Ok(__FieldTag::__bool_value),
                            "bytesValue" => Ok(__FieldTag::__bytes_value),
                            "bytes_value" => Ok(__FieldTag::__bytes_value),
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            "floatValue" => Ok(__FieldTag::__float_value),
                            "float_value" => Ok(__FieldTag::__float_value),
                            "doubleValue" => Ok(__FieldTag::__double_value),
                            "double_value" => Ok(__FieldTag::__double_value),
                            "int32" => Ok(__FieldTag::__int32),
                            "int64" => Ok(__FieldTag::__int64),
                            "enum" => Ok(__FieldTag::__enum),
                            "inner" => Ok(__FieldTag::__inner),
                            "duration" => Ok(__FieldTag::__duration),
                            "value" => Ok(__FieldTag::__value),
                            "optionalDouble" => Ok(__FieldTag::__optional_double),
                            "optional_double" => Ok(__FieldTag::__optional_double),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithComplexOneOf;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithComplexOneOf")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__null => {
                            if !fields.insert(__FieldTag::__null) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for null",
                                ));
                            }
                            if result.complex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `complex`, a oneof with full ID .google.rust.sdk.test.MessageWithComplexOneOf.null, latest field was null",
                                ));
                            }
                            result.complex = std::option::Option::Some(
                                crate::generated::message_with_complex_one_of::Complex::Null(
                                    map.next_value::<std::option::Option<wkt::NullValue>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bool_value => {
                            if !fields.insert(__FieldTag::__bool_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bool_value",
                                ));
                            }
                            if result.complex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `complex`, a oneof with full ID .google.rust.sdk.test.MessageWithComplexOneOf.bool_value, latest field was boolValue",
                                ));
                            }
                            result.complex = std::option::Option::Some(
                                crate::generated::message_with_complex_one_of::Complex::BoolValue(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bytes_value => {
                            if !fields.insert(__FieldTag::__bytes_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_value",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.complex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `complex`, a oneof with full ID .google.rust.sdk.test.MessageWithComplexOneOf.bytes_value, latest field was bytesValue",
                                ));
                            }
                            result.complex = std::option::Option::Some(
                                crate::generated::message_with_complex_one_of::Complex::BytesValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.complex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `complex`, a oneof with full ID .google.rust.sdk.test.MessageWithComplexOneOf.string_value, latest field was stringValue",
                                ));
                            }
                            result.complex = std::option::Option::Some(
                                crate::generated::message_with_complex_one_of::Complex::StringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__float_value => {
                            if !fields.insert(__FieldTag::__float_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for float_value",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.complex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `complex`, a oneof with full ID .google.rust.sdk.test.MessageWithComplexOneOf.float_value, latest field was floatValue",
                                ));
                            }
                            result.complex = std::option::Option::Some(
                                crate::generated::message_with_complex_one_of::Complex::FloatValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__double_value => {
                            if !fields.insert(__FieldTag::__double_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for double_value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.complex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `complex`, a oneof with full ID .google.rust.sdk.test.MessageWithComplexOneOf.double_value, latest field was doubleValue",
                                ));
                            }
                            result.complex = std::option::Option::Some(
                                crate::generated::message_with_complex_one_of::Complex::DoubleValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__int32 => {
                            if !fields.insert(__FieldTag::__int32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for int32",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.complex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `complex`, a oneof with full ID .google.rust.sdk.test.MessageWithComplexOneOf.int32, latest field was int32",
                                ));
                            }
                            result.complex = std::option::Option::Some(
                                crate::generated::message_with_complex_one_of::Complex::Int32(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__int64 => {
                            if !fields.insert(__FieldTag::__int64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for int64",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.complex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `complex`, a oneof with full ID .google.rust.sdk.test.MessageWithComplexOneOf.int64, latest field was int64",
                                ));
                            }
                            result.complex = std::option::Option::Some(
                                crate::generated::message_with_complex_one_of::Complex::Int64(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__enum => {
                            if !fields.insert(__FieldTag::__enum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enum",
                                ));
                            }
                            if result.complex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `complex`, a oneof with full ID .google.rust.sdk.test.MessageWithComplexOneOf.enum, latest field was enum",
                                ));
                            }
                            result.complex = std::option::Option::Some(
                                crate::generated::message_with_complex_one_of::Complex::Enum(
                                    map.next_value::<std::option::Option<
                                        crate::generated::message_with_complex_one_of::TestEnum,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__inner => {
                            if !fields.insert(__FieldTag::__inner) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inner",
                                ));
                            }
                            if result.complex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `complex`, a oneof with full ID .google.rust.sdk.test.MessageWithComplexOneOf.inner, latest field was inner",
                                ));
                            }
                            result.complex = std::option::Option::Some(
                                crate::generated::message_with_complex_one_of::Complex::Inner(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::generated::message_with_complex_one_of::Inner,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            if result.complex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `complex`, a oneof with full ID .google.rust.sdk.test.MessageWithComplexOneOf.duration, latest field was duration",
                                ));
                            }
                            result.complex = std::option::Option::Some(
                                crate::generated::message_with_complex_one_of::Complex::Duration(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            if result.complex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `complex`, a oneof with full ID .google.rust.sdk.test.MessageWithComplexOneOf.value, latest field was value",
                                ));
                            }
                            result.complex = std::option::Option::Some(
                                crate::generated::message_with_complex_one_of::Complex::Value(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Value>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__optional_double => {
                            if !fields.insert(__FieldTag::__optional_double) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_double",
                                ));
                            }
                            struct __With(std::option::Option<std::boxed::Box<wkt::DoubleValue>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::boxed::Box<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            if result.complex.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `complex`, a oneof with full ID .google.rust.sdk.test.MessageWithComplexOneOf.optional_double, latest field was optionalDouble",
                                ));
                            }
                            result.complex = std::option::Option::Some(
                                crate::generated::message_with_complex_one_of::Complex::OptionalDouble(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::message_with_complex_one_of::Inner {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __strings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Inner")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "strings" => Ok(__FieldTag::__strings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::message_with_complex_one_of::Inner;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Inner")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__strings => {
                            if !fields.insert(__FieldTag::__strings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for strings",
                                ));
                            }
                            result.strings = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithF32 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithF32")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithF32;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithF32")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.singular = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, f32>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::F32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithF64 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithF64")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithF64;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithF64")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.singular = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, f64>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::F64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithI32 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map_value,
            __map_key,
            __map_key_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithI32")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "mapValue" => Ok(__FieldTag::__map_value),
                            "map_value" => Ok(__FieldTag::__map_value),
                            "mapKey" => Ok(__FieldTag::__map_key),
                            "map_key" => Ok(__FieldTag::__map_key),
                            "mapKeyValue" => Ok(__FieldTag::__map_key_value),
                            "map_key_value" => Ok(__FieldTag::__map_key_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithI32;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithI32")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.singular = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_value => {
                            if !fields.insert(__FieldTag::__map_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_value",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, i32>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::I32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_key => {
                            if !fields.insert(__FieldTag::__map_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_key",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<i32, std::string::String>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I32,
                                                serde_with::Same,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_key = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_key_value => {
                            if !fields.insert(__FieldTag::__map_key_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_key_value",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<i32, i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I32,
                                                wkt::internal::I32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_key_value =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithU32 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map_value,
            __map_key,
            __map_key_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithU32")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "mapValue" => Ok(__FieldTag::__map_value),
                            "map_value" => Ok(__FieldTag::__map_value),
                            "mapKey" => Ok(__FieldTag::__map_key),
                            "map_key" => Ok(__FieldTag::__map_key),
                            "mapKeyValue" => Ok(__FieldTag::__map_key_value),
                            "map_key_value" => Ok(__FieldTag::__map_key_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithU32;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithU32")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.singular = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<u32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_value => {
                            if !fields.insert(__FieldTag::__map_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_value",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, u32>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::U32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_key => {
                            if !fields.insert(__FieldTag::__map_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_key",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<u32, std::string::String>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::U32,
                                                serde_with::Same,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_key = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_key_value => {
                            if !fields.insert(__FieldTag::__map_key_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_key_value",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<u32, u32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::U32,
                                                wkt::internal::U32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_key_value =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithI64 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map_value,
            __map_key,
            __map_key_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithI64")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "mapValue" => Ok(__FieldTag::__map_value),
                            "map_value" => Ok(__FieldTag::__map_value),
                            "mapKey" => Ok(__FieldTag::__map_key),
                            "map_key" => Ok(__FieldTag::__map_key),
                            "mapKeyValue" => Ok(__FieldTag::__map_key_value),
                            "map_key_value" => Ok(__FieldTag::__map_key_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithI64;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithI64")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.singular = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_value => {
                            if !fields.insert(__FieldTag::__map_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_value",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, i64>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::I64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_key => {
                            if !fields.insert(__FieldTag::__map_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_key",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<i64, std::string::String>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I64,
                                                serde_with::Same,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_key = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_key_value => {
                            if !fields.insert(__FieldTag::__map_key_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_key_value",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<i64, i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I64,
                                                wkt::internal::I64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_key_value =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithU64 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map_value,
            __map_key,
            __map_key_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithU64")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "mapValue" => Ok(__FieldTag::__map_value),
                            "map_value" => Ok(__FieldTag::__map_value),
                            "mapKey" => Ok(__FieldTag::__map_key),
                            "map_key" => Ok(__FieldTag::__map_key),
                            "mapKeyValue" => Ok(__FieldTag::__map_key_value),
                            "map_key_value" => Ok(__FieldTag::__map_key_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithU64;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithU64")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.singular = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<u64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_value => {
                            if !fields.insert(__FieldTag::__map_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_value",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, u64>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::U64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_key => {
                            if !fields.insert(__FieldTag::__map_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_key",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<u64, std::string::String>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::U64,
                                                serde_with::Same,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_key = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_key_value => {
                            if !fields.insert(__FieldTag::__map_key_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_key_value",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<u64, u64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::U64,
                                                wkt::internal::U64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_key_value =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithBytes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithBytes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithBytes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithBytes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.singular = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<::bytes::Bytes>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::vec::Vec<serde_with::base64::Base64>,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, ::bytes::Bytes>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                serde_with::base64::Base64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithBool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map_value,
            __map_key,
            __map_key_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithBool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "mapValue" => Ok(__FieldTag::__map_value),
                            "map_value" => Ok(__FieldTag::__map_value),
                            "mapKey" => Ok(__FieldTag::__map_key),
                            "map_key" => Ok(__FieldTag::__map_key),
                            "mapKeyValue" => Ok(__FieldTag::__map_key_value),
                            "map_key_value" => Ok(__FieldTag::__map_key_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithBool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithBool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            result.singular = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            result.optional = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            result.repeated = map
                                .next_value::<std::option::Option<std::vec::Vec<bool>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__map_value => {
                            if !fields.insert(__FieldTag::__map_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_value",
                                ));
                            }
                            result.map_value = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, bool>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__map_key => {
                            if !fields.insert(__FieldTag::__map_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_key",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<bool, std::string::String>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::DisplayFromStr,
                                                serde_with::Same,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_key = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_key_value => {
                            if !fields.insert(__FieldTag::__map_key_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_key_value",
                                ));
                            }
                            struct __With(
                                std::option::Option<std::collections::HashMap<bool, bool>>,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::DisplayFromStr,
                                                serde_with::Same,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_key_value =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithString {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map_value,
            __map_key,
            __map_key_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithString")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "mapValue" => Ok(__FieldTag::__map_value),
                            "map_value" => Ok(__FieldTag::__map_value),
                            "mapKey" => Ok(__FieldTag::__map_key),
                            "map_key" => Ok(__FieldTag::__map_key),
                            "mapKeyValue" => Ok(__FieldTag::__map_key_value),
                            "map_key_value" => Ok(__FieldTag::__map_key_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithString;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithString")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            result.singular = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            result.optional =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            result.repeated = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__map_value => {
                            if !fields.insert(__FieldTag::__map_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_value",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<i32, std::string::String>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I32,
                                                serde_with::Same,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_key => {
                            if !fields.insert(__FieldTag::__map_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_key",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, i32>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::I32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_key = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_key_value => {
                            if !fields.insert(__FieldTag::__map_key_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_key_value",
                                ));
                            }
                            result.map_key_value = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithRecursion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithRecursion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithRecursion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithRecursion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            result.singular = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::generated::message_with_recursion::Level0>,
                            >>()?;
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            result.optional = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::generated::message_with_recursion::Level0>,
                            >>()?;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            result.repeated = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::generated::message_with_recursion::Level0>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            result.map = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::generated::message_with_recursion::Level0,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::message_with_recursion::Level0 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __level_1,
            __side,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Level0")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "level1" => Ok(__FieldTag::__level_1),
                            "level_1" => Ok(__FieldTag::__level_1),
                            "side" => Ok(__FieldTag::__side),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::message_with_recursion::Level0;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Level0")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__level_1 => {
                            if !fields.insert(__FieldTag::__level_1) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for level_1",
                                ));
                            }
                            result.level_1 = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::generated::message_with_recursion::Level1>,
                            >>()?;
                        }
                        __FieldTag::__side => {
                            if !fields.insert(__FieldTag::__side) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for side",
                                ));
                            }
                            result.side = map.next_value::<std::option::Option<
                                crate::generated::message_with_recursion::NonRecursive,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::message_with_recursion::Level1 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recurse,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Level1")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recurse" => Ok(__FieldTag::__recurse),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::message_with_recursion::Level1;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Level1")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recurse => {
                            if !fields.insert(__FieldTag::__recurse) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recurse",
                                ));
                            }
                            result.recurse = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::generated::MessageWithRecursion>,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::message_with_recursion::NonRecursive {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NonRecursive")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::message_with_recursion::NonRecursive;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NonRecursive")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            result.singular = map
                                .next_value::<std::option::Option<wkt::Value>>()?
                                .or(Some(wkt::Value::Null));
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            result.optional = map
                                .next_value::<std::option::Option<wkt::Value>>()?
                                .or(Some(wkt::Value::Null));
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            result.repeated = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Value>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            result.map = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::Value>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithStruct {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithStruct")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithStruct;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithStruct")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            result.singular =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            result.optional =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            result.repeated = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Struct>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            result.map = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::Struct>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithListValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithListValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithListValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithListValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            result.singular =
                                map.next_value::<std::option::Option<wkt::ListValue>>()?;
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            result.optional =
                                map.next_value::<std::option::Option<wkt::ListValue>>()?;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            result.repeated = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::ListValue>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            result.map = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::ListValue>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithNullValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithNullValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithNullValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithNullValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            result.singular = map
                                .next_value::<std::option::Option<wkt::NullValue>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            result.optional = map
                                .next_value::<std::option::Option<wkt::NullValue>>()?
                                .or(Some(wkt::NullValue));
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            result.repeated = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::NullValue>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            result.map = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::NullValue>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithFieldMask {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __optional,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithFieldMask")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "optional" => Ok(__FieldTag::__optional),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithFieldMask;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithFieldMask")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            result.singular =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__optional => {
                            if !fields.insert(__FieldTag::__optional) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional",
                                ));
                            }
                            result.optional =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            result.repeated = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::FieldMask>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            result.map = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::FieldMask>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithFloatValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithFloatValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithFloatValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithFloatValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            struct __With(std::option::Option<wkt::FloatValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.singular = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::FloatValue>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::FloatValue>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::F32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithDoubleValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithDoubleValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithDoubleValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithDoubleValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.singular = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::DoubleValue>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        wkt::DoubleValue,
                                    >,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::F64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithInt32Value {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithInt32Value")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithInt32Value;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithInt32Value")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.singular = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::Int32Value>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::Int32Value>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::I32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithUInt32Value {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithUInt32Value")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithUInt32Value;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithUInt32Value")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.singular = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::UInt32Value>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        wkt::UInt32Value,
                                    >,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::U32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithInt64Value {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithInt64Value")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithInt64Value;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithInt64Value")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.singular = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::Int64Value>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::Int64Value>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::I64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithUInt64Value {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithUInt64Value")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithUInt64Value;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithUInt64Value")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.singular = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::Int64Value>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::Int64Value>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::I64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithBytesValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithBytesValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithBytesValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithBytesValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            struct __With(std::option::Option<wkt::BytesValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.singular = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::BytesValue>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::vec::Vec<serde_with::base64::Base64>,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::BytesValue>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                serde_with::base64::Base64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithBoolValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithBoolValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithBoolValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithBoolValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            result.singular =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            result.repeated = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::BoolValue>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            result.map = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::BoolValue>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MessageWithStringValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __singular,
            __repeated,
            __map,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageWithStringValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singular" => Ok(__FieldTag::__singular),
                            "repeated" => Ok(__FieldTag::__repeated),
                            "map" => Ok(__FieldTag::__map),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MessageWithStringValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageWithStringValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__singular => {
                            if !fields.insert(__FieldTag::__singular) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for singular",
                                ));
                            }
                            result.singular =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__repeated => {
                            if !fields.insert(__FieldTag::__repeated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated",
                                ));
                            }
                            result.repeated = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::StringValue>>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__map => {
                            if !fields.insert(__FieldTag::__map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map",
                                ));
                            }
                            result.map = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        wkt::StringValue,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
