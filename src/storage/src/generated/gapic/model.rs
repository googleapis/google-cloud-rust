// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::invalid_html_tags)]
#![allow(rustdoc::redundant_explicit_links)]

/// Request message for DeleteBucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBucketRequest {
    /// Required. Name of a bucket to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set, only deletes the bucket if its metageneration matches this value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_match: std::option::Option<i64>,

    /// If set, only deletes the bucket if its metageneration does not match this
    /// value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_not_match: std::option::Option<i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBucketRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::DeleteBucketRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::DeleteBucketRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_not_match = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.DeleteBucketRequest"
    }
}

/// Request message for GetBucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBucketRequest {
    /// Required. Name of a bucket.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set, and if the bucket's current metageneration does not match the
    /// specified value, the request will return an error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_match: std::option::Option<i64>,

    /// If set, and if the bucket's current metageneration matches the specified
    /// value, the request will return an error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// Mask specifying which fields to read.
    /// A "*" field may be used to indicate all fields.
    /// If no mask is specified, will default to all fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBucketRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::GetBucketRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::GetBucketRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_not_match = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetBucketRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for GetBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.GetBucketRequest"
    }
}

/// Request message for CreateBucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBucketRequest {
    /// Required. The project to which this bucket will belong.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Properties of the new bucket being inserted.
    /// The name of the bucket is specified in the `bucket_id` field. Populating
    /// `bucket.name` field will result in an error.
    /// The project of the bucket must be specified in the `bucket.project` field.
    /// This field must be in `projects/{projectIdentifier}` format,
    /// {projectIdentifier} can be the project ID or project number. The `parent`
    /// field must be either empty or `projects/_`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bucket: std::option::Option<crate::model::Bucket>,

    /// Required. The ID to use for this bucket, which will become the final
    /// component of the bucket's resource name. For example, the value `foo` might
    /// result in a bucket with the name `projects/123456/buckets/foo`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_id: std::string::String,

    /// Apply a predefined set of access controls to this bucket.
    /// Valid values are "authenticatedRead", "private", "projectPrivate",
    /// "publicRead", or "publicReadWrite".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predefined_acl: std::string::String,

    /// Apply a predefined set of default object access controls to this bucket.
    /// Valid values are "authenticatedRead", "bucketOwnerFullControl",
    /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predefined_default_object_acl: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBucketRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [bucket][crate::model::CreateBucketRequest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::option::Option<crate::model::Bucket>>>(
        mut self,
        v: T,
    ) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [bucket_id][crate::model::CreateBucketRequest::bucket_id].
    pub fn set_bucket_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_id = v.into();
        self
    }

    /// Sets the value of [predefined_acl][crate::model::CreateBucketRequest::predefined_acl].
    pub fn set_predefined_acl<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predefined_acl = v.into();
        self
    }

    /// Sets the value of [predefined_default_object_acl][crate::model::CreateBucketRequest::predefined_default_object_acl].
    pub fn set_predefined_default_object_acl<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.predefined_default_object_acl = v.into();
        self
    }
}

impl wkt::message::Message for CreateBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.CreateBucketRequest"
    }
}

/// Request message for ListBuckets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBucketsRequest {
    /// Required. The project whose buckets we are listing.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of buckets to return in a single response. The service will
    /// use this parameter or 1,000 items, whichever is smaller. If "acl" is
    /// present in the read_mask, the service will use this parameter of 200 items,
    /// whichever is smaller.
    pub page_size: i32,

    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter results to buckets whose names begin with this prefix.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub prefix: std::string::String,

    /// Mask specifying which fields to read from each result.
    /// If no mask is specified, will default to all fields except items.owner,
    /// items.acl, and items.default_object_acl.
    ///
    /// * may be used to mean "all fields".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBucketsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBucketsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBucketsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBucketsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [prefix][crate::model::ListBucketsRequest::prefix].
    pub fn set_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.prefix = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListBucketsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ListBucketsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ListBucketsRequest"
    }
}

/// The result of a call to Buckets.ListBuckets
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBucketsResponse {
    /// The list of items.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub buckets: std::vec::Vec<crate::model::Bucket>,

    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBucketsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBucketsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [buckets][crate::model::ListBucketsResponse::buckets].
    pub fn set_buckets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Bucket>,
    {
        use std::iter::Iterator;
        self.buckets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBucketsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ListBucketsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBucketsResponse {
    type PageItem = crate::model::Bucket;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.buckets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for LockBucketRetentionPolicyRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LockBucketRetentionPolicyRequest {
    /// Required. Name of a bucket.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// Required. Makes the operation conditional on whether bucket's current
    /// metageneration matches the given value. Must be positive.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub if_metageneration_match: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LockBucketRetentionPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::LockBucketRetentionPolicyRequest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::LockBucketRetentionPolicyRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.if_metageneration_match = v.into();
        self
    }
}

impl wkt::message::Message for LockBucketRetentionPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.LockBucketRetentionPolicyRequest"
    }
}

/// Request for UpdateBucket method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBucketRequest {
    /// Required. The bucket to update.
    /// The bucket's `name` field will be used to identify the bucket.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bucket: std::option::Option<crate::model::Bucket>,

    /// If set, will only modify the bucket if its metageneration matches this
    /// value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_match: std::option::Option<i64>,

    /// If set, will only modify the bucket if its metageneration does not match
    /// this value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// Apply a predefined set of access controls to this bucket.
    /// Valid values are "authenticatedRead", "private", "projectPrivate",
    /// "publicRead", or "publicReadWrite".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predefined_acl: std::string::String,

    /// Apply a predefined set of default object access controls to this bucket.
    /// Valid values are "authenticatedRead", "bucketOwnerFullControl",
    /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predefined_default_object_acl: std::string::String,

    /// Required. List of fields to be updated.
    ///
    /// To specify ALL fields, equivalent to the JSON API's "update" function,
    /// specify a single field with the value `*`. Note: not recommended. If a new
    /// field is introduced at a later time, an older client updating with the `*`
    /// may accidentally reset the new field's value.
    ///
    /// Not specifying any fields is an error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::UpdateBucketRequest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::option::Option<crate::model::Bucket>>>(
        mut self,
        v: T,
    ) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::UpdateBucketRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::UpdateBucketRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_not_match = v.into();
        self
    }

    /// Sets the value of [predefined_acl][crate::model::UpdateBucketRequest::predefined_acl].
    pub fn set_predefined_acl<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predefined_acl = v.into();
        self
    }

    /// Sets the value of [predefined_default_object_acl][crate::model::UpdateBucketRequest::predefined_default_object_acl].
    pub fn set_predefined_default_object_acl<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.predefined_default_object_acl = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBucketRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.UpdateBucketRequest"
    }
}

/// Request message for ComposeObject.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComposeObjectRequest {
    /// Required. Properties of the resulting object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::Object>,

    /// The list of source objects that will be concatenated into a single object.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub source_objects: std::vec::Vec<crate::model::compose_object_request::SourceObject>,

    /// Apply a predefined set of access controls to the destination object.
    /// Valid values are "authenticatedRead", "bucketOwnerFullControl",
    /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_predefined_acl: std::string::String,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_match: std::option::Option<i64>,

    /// Resource name of the Cloud KMS key, of the form
    /// `projects/my-project/locations/my-location/keyRings/my-kr/cryptoKeys/my-key`,
    /// that will be used to encrypt the object. Overrides the object
    /// metadata's `kms_key_name` value, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,

    /// A set of parameters common to Storage API requests concerning an object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    /// The checksums of the complete object. This will be validated against the
    /// combined checksums of the component objects.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub object_checksums: std::option::Option<crate::model::ObjectChecksums>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComposeObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::ComposeObjectRequest::destination].
    pub fn set_destination<T: std::convert::Into<std::option::Option<crate::model::Object>>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [destination_predefined_acl][crate::model::ComposeObjectRequest::destination_predefined_acl].
    pub fn set_destination_predefined_acl<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_predefined_acl = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::ComposeObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::ComposeObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_match = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::ComposeObjectRequest::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::ComposeObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<
        T: std::convert::Into<std::option::Option<crate::model::CommonObjectRequestParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.common_object_request_params = v.into();
        self
    }

    /// Sets the value of [object_checksums][crate::model::ComposeObjectRequest::object_checksums].
    pub fn set_object_checksums<
        T: std::convert::Into<std::option::Option<crate::model::ObjectChecksums>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.object_checksums = v.into();
        self
    }

    /// Sets the value of [source_objects][crate::model::ComposeObjectRequest::source_objects].
    pub fn set_source_objects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::compose_object_request::SourceObject>,
    {
        use std::iter::Iterator;
        self.source_objects = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ComposeObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ComposeObjectRequest"
    }
}

/// Defines additional types related to [ComposeObjectRequest].
pub mod compose_object_request {
    #[allow(unused_imports)]
    use super::*;

    /// Description of a source object for a composition request.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SourceObject {
        /// Required. The source object's name. All source objects must reside in the
        /// same bucket.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// The generation of this object to use as the source.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub generation: i64,

        /// Conditions that must be met for this operation to execute.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub object_preconditions: std::option::Option<
            crate::model::compose_object_request::source_object::ObjectPreconditions,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SourceObject {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::compose_object_request::SourceObject::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [generation][crate::model::compose_object_request::SourceObject::generation].
        pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.generation = v.into();
            self
        }

        /// Sets the value of [object_preconditions][crate::model::compose_object_request::SourceObject::object_preconditions].
        pub fn set_object_preconditions<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::compose_object_request::source_object::ObjectPreconditions,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.object_preconditions = v.into();
            self
        }
    }

    impl wkt::message::Message for SourceObject {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.ComposeObjectRequest.SourceObject"
        }
    }

    /// Defines additional types related to [SourceObject].
    pub mod source_object {
        #[allow(unused_imports)]
        use super::*;

        /// Preconditions for a source object of a composition request.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ObjectPreconditions {
            /// Only perform the composition if the generation of the source object
            /// that would be used matches this value.  If this value and a generation
            /// are both specified, they must be the same value or the call will fail.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
            pub if_generation_match: std::option::Option<i64>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ObjectPreconditions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [if_generation_match][crate::model::compose_object_request::source_object::ObjectPreconditions::if_generation_match].
            pub fn set_if_generation_match<T: std::convert::Into<std::option::Option<i64>>>(
                mut self,
                v: T,
            ) -> Self {
                self.if_generation_match = v.into();
                self
            }
        }

        impl wkt::message::Message for ObjectPreconditions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.storage.v2.ComposeObjectRequest.SourceObject.ObjectPreconditions"
            }
        }
    }
}

/// Message for deleting an object.
/// `bucket` and `object` **must** be set.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteObjectRequest {
    /// Required. Name of the bucket in which the object resides.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// Required. The name of the finalized object to delete.
    /// Note: If you want to delete an unfinalized resumable upload please use
    /// `CancelResumableWrite`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object: std::string::String,

    /// If present, permanently deletes a specific revision of this object (as
    /// opposed to the latest version, the default).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live generation
    /// does not match the given value. If no live object exists, the precondition
    /// fails. Setting to 0 makes the operation succeed only if there is a live
    /// version of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// A set of parameters common to Storage API requests concerning an object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::DeleteObjectRequest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::DeleteObjectRequest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::DeleteObjectRequest::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::DeleteObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_match = v.into();
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::DeleteObjectRequest::if_generation_not_match].
    pub fn set_if_generation_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_not_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::DeleteObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::DeleteObjectRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_not_match = v.into();
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::DeleteObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<
        T: std::convert::Into<std::option::Option<crate::model::CommonObjectRequestParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.common_object_request_params = v.into();
        self
    }
}

impl wkt::message::Message for DeleteObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.DeleteObjectRequest"
    }
}

/// Message for restoring an object.
/// `bucket`, `object`, and `generation` **must** be set.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreObjectRequest {
    /// Required. Name of the bucket in which the object resides.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// Required. The name of the object to restore.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object: std::string::String,

    /// Required. The specific revision of the object to restore.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    /// Optional. Restore token used to differentiate soft-deleted objects with the
    /// same name and generation. Only applicable for hierarchical namespace
    /// buckets. This parameter is optional, and is only required in the rare case
    /// when there are multiple soft-deleted objects with the same name and
    /// generation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub restore_token: std::string::String,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live generation
    /// does not match the given value. If no live object exists, the precondition
    /// fails. Setting to 0 makes the operation succeed only if there is a live
    /// version of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// If false or unset, the bucket's default object ACL will be used.
    /// If true, copy the source object's access controls.
    /// Return an error if bucket has UBLA enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub copy_source_acl: std::option::Option<bool>,

    /// A set of parameters common to Storage API requests concerning an object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::RestoreObjectRequest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::RestoreObjectRequest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::RestoreObjectRequest::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [restore_token][crate::model::RestoreObjectRequest::restore_token].
    pub fn set_restore_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.restore_token = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::RestoreObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_match = v.into();
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::RestoreObjectRequest::if_generation_not_match].
    pub fn set_if_generation_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_not_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::RestoreObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::RestoreObjectRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_not_match = v.into();
        self
    }

    /// Sets the value of [copy_source_acl][crate::model::RestoreObjectRequest::copy_source_acl].
    pub fn set_copy_source_acl<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.copy_source_acl = v.into();
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::RestoreObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<
        T: std::convert::Into<std::option::Option<crate::model::CommonObjectRequestParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.common_object_request_params = v.into();
        self
    }
}

impl wkt::message::Message for RestoreObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.RestoreObjectRequest"
    }
}

/// Message for canceling an in-progress resumable upload.
/// `upload_id` **must** be set.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelResumableWriteRequest {
    /// Required. The upload_id of the resumable upload to cancel. This should be
    /// copied from the `upload_id` field of `StartResumableWriteResponse`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub upload_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelResumableWriteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [upload_id][crate::model::CancelResumableWriteRequest::upload_id].
    pub fn set_upload_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.upload_id = v.into();
        self
    }
}

impl wkt::message::Message for CancelResumableWriteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.CancelResumableWriteRequest"
    }
}

/// Empty response message for canceling an in-progress resumable upload, will be
/// extended as needed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelResumableWriteResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelResumableWriteResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelResumableWriteResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.CancelResumableWriteResponse"
    }
}

/// Request message for ReadObject.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadObjectRequest {
    /// Required. The name of the bucket containing the object to read.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// Required. The name of the object to read.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object: std::string::String,

    /// If present, selects a specific revision of this object (as opposed
    /// to the latest version, the default).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    /// The offset for the first byte to return in the read, relative to the start
    /// of the object.
    ///
    /// A negative `read_offset` value will be interpreted as the number of bytes
    /// back from the end of the object to be returned. For example, if an object's
    /// length is 15 bytes, a ReadObjectRequest with `read_offset` = -5 and
    /// `read_limit` = 3 would return bytes 10 through 12 of the object. Requesting
    /// a negative offset with magnitude larger than the size of the object will
    /// return the entire object.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub read_offset: i64,

    /// The maximum number of `data` bytes the server is allowed to return in the
    /// sum of all `Object` messages. A `read_limit` of zero indicates that there
    /// is no limit, and a negative `read_limit` will cause an error.
    ///
    /// If the stream returns fewer bytes than allowed by the `read_limit` and no
    /// error occurred, the stream includes all data from the `read_offset` to the
    /// end of the resource.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub read_limit: i64,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live generation
    /// does not match the given value. If no live object exists, the precondition
    /// fails. Setting to 0 makes the operation succeed only if there is a live
    /// version of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// A set of parameters common to Storage API requests concerning an object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    /// Mask specifying which fields to read.
    /// The checksummed_data field and its children will always be present.
    /// If no mask is specified, will default to all fields except metadata.owner
    /// and metadata.acl.
    ///
    /// * may be used to mean "all fields".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReadObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::ReadObjectRequest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::ReadObjectRequest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::ReadObjectRequest::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [read_offset][crate::model::ReadObjectRequest::read_offset].
    pub fn set_read_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.read_offset = v.into();
        self
    }

    /// Sets the value of [read_limit][crate::model::ReadObjectRequest::read_limit].
    pub fn set_read_limit<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.read_limit = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::ReadObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_match = v.into();
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::ReadObjectRequest::if_generation_not_match].
    pub fn set_if_generation_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_not_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::ReadObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::ReadObjectRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_not_match = v.into();
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::ReadObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<
        T: std::convert::Into<std::option::Option<crate::model::CommonObjectRequestParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.common_object_request_params = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ReadObjectRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }
}

impl wkt::message::Message for ReadObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ReadObjectRequest"
    }
}

/// Request message for GetObject.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetObjectRequest {
    /// Required. Name of the bucket in which the object resides.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// Required. Name of the object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object: std::string::String,

    /// If present, selects a specific revision of this object (as opposed to the
    /// latest version, the default).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    /// If true, return the soft-deleted version of this object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub soft_deleted: std::option::Option<bool>,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live generation
    /// does not match the given value. If no live object exists, the precondition
    /// fails. Setting to 0 makes the operation succeed only if there is a live
    /// version of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// A set of parameters common to Storage API requests concerning an object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    /// Mask specifying which fields to read.
    /// If no mask is specified, will default to all fields except metadata.acl and
    /// metadata.owner.
    ///
    /// * may be used to mean "all fields".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. Restore token used to differentiate soft-deleted objects with the
    /// same name and generation. Only applicable for hierarchical namespace
    /// buckets and if soft_deleted is set to true. This parameter is optional, and
    /// is only required in the rare case when there are multiple soft-deleted
    /// objects with the same name and generation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub restore_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::GetObjectRequest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::GetObjectRequest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::GetObjectRequest::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [soft_deleted][crate::model::GetObjectRequest::soft_deleted].
    pub fn set_soft_deleted<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.soft_deleted = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::GetObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_match = v.into();
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::GetObjectRequest::if_generation_not_match].
    pub fn set_if_generation_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_not_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::GetObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::GetObjectRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_not_match = v.into();
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::GetObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<
        T: std::convert::Into<std::option::Option<crate::model::CommonObjectRequestParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.common_object_request_params = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::GetObjectRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [restore_token][crate::model::GetObjectRequest::restore_token].
    pub fn set_restore_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.restore_token = v.into();
        self
    }
}

impl wkt::message::Message for GetObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.GetObjectRequest"
    }
}

/// Response message for ReadObject.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadObjectResponse {
    /// A portion of the data for the object. The service **may** leave `data`
    /// empty for any given `ReadResponse`. This enables the service to inform the
    /// client that the request is still live while it is running an operation to
    /// generate more data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub checksummed_data: std::option::Option<crate::model::ChecksummedData>,

    /// The checksums of the complete object. If the object is downloaded in full,
    /// the client should compute one of these checksums over the downloaded object
    /// and compare it against the value provided here.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub object_checksums: std::option::Option<crate::model::ObjectChecksums>,

    /// If read_offset and or read_limit was specified on the
    /// ReadObjectRequest, ContentRange will be populated on the first
    /// ReadObjectResponse message of the read stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub content_range: std::option::Option<crate::model::ContentRange>,

    /// Metadata of the object whose media is being returned.
    /// Only populated in the first response in the stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::Object>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReadObjectResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [checksummed_data][crate::model::ReadObjectResponse::checksummed_data].
    pub fn set_checksummed_data<
        T: std::convert::Into<std::option::Option<crate::model::ChecksummedData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.checksummed_data = v.into();
        self
    }

    /// Sets the value of [object_checksums][crate::model::ReadObjectResponse::object_checksums].
    pub fn set_object_checksums<
        T: std::convert::Into<std::option::Option<crate::model::ObjectChecksums>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.object_checksums = v.into();
        self
    }

    /// Sets the value of [content_range][crate::model::ReadObjectResponse::content_range].
    pub fn set_content_range<
        T: std::convert::Into<std::option::Option<crate::model::ContentRange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content_range = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ReadObjectResponse::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<crate::model::Object>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }
}

impl wkt::message::Message for ReadObjectResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ReadObjectResponse"
    }
}

/// Describes the object to read in a BidiReadObject request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BidiReadObjectSpec {
    /// Required. The name of the bucket containing the object to read.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// Required. The name of the object to read.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object: std::string::String,

    /// If present, selects a specific revision of this object (as opposed
    /// to the latest version, the default).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live generation
    /// does not match the given value. If no live object exists, the precondition
    /// fails. Setting to 0 makes the operation succeed only if there is a live
    /// version of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// A set of parameters common to Storage API requests concerning an object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    /// Mask specifying which fields to read.
    /// The checksummed_data field and its children will always be present.
    /// If no mask is specified, will default to all fields except metadata.owner
    /// and metadata.acl.
    ///
    /// * may be used to mean "all fields".
    ///   As per <https://google.aip.dev/161>, this field is deprecated.
    ///   As an alternative, grpc metadata can be used:
    ///   <https://cloud.google.com/apis/docs/system-parameters#definitions>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// The client can optionally set this field. The read handle is an optimized
    /// way of creating new streams. Read handles are generated and periodically
    /// refreshed from prior reads.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_handle: std::option::Option<crate::model::BidiReadHandle>,

    /// The routing token that influences request routing for the stream. Must be
    /// provided if a BidiReadObjectRedirectedError is returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub routing_token: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BidiReadObjectSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::BidiReadObjectSpec::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::BidiReadObjectSpec::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::BidiReadObjectSpec::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::BidiReadObjectSpec::if_generation_match].
    pub fn set_if_generation_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_match = v.into();
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::BidiReadObjectSpec::if_generation_not_match].
    pub fn set_if_generation_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_not_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::BidiReadObjectSpec::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::BidiReadObjectSpec::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_not_match = v.into();
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::BidiReadObjectSpec::common_object_request_params].
    pub fn set_common_object_request_params<
        T: std::convert::Into<std::option::Option<crate::model::CommonObjectRequestParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.common_object_request_params = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::BidiReadObjectSpec::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [read_handle][crate::model::BidiReadObjectSpec::read_handle].
    pub fn set_read_handle<
        T: std::convert::Into<std::option::Option<crate::model::BidiReadHandle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.read_handle = v.into();
        self
    }

    /// Sets the value of [routing_token][crate::model::BidiReadObjectSpec::routing_token].
    pub fn set_routing_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.routing_token = v.into();
        self
    }
}

impl wkt::message::Message for BidiReadObjectSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.BidiReadObjectSpec"
    }
}

/// Request message for BidiReadObject.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BidiReadObjectRequest {
    /// The first message of each stream should set this field. If this is not
    /// the first message, an error will be returned. Describes the object to read.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_object_spec: std::option::Option<crate::model::BidiReadObjectSpec>,

    /// Provides a list of 0 or more (up to 100) ranges to read. If a single range
    /// is large enough to require multiple responses, they are guaranteed to be
    /// delivered in increasing offset order. There are no ordering guarantees
    /// across ranges. When no ranges are provided, the response message will not
    /// include ObjectRangeData. For full object downloads, the offset and size can
    /// be set to 0.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub read_ranges: std::vec::Vec<crate::model::ReadRange>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BidiReadObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [read_object_spec][crate::model::BidiReadObjectRequest::read_object_spec].
    pub fn set_read_object_spec<
        T: std::convert::Into<std::option::Option<crate::model::BidiReadObjectSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.read_object_spec = v.into();
        self
    }

    /// Sets the value of [read_ranges][crate::model::BidiReadObjectRequest::read_ranges].
    pub fn set_read_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReadRange>,
    {
        use std::iter::Iterator;
        self.read_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BidiReadObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.BidiReadObjectRequest"
    }
}

/// Response message for BidiReadObject.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BidiReadObjectResponse {
    /// A portion of the object's data. The service **may** leave data
    /// empty for any given ReadResponse. This enables the service to inform the
    /// client that the request is still live while it is running an operation to
    /// generate more data.
    /// The service **may** pipeline multiple responses belonging to different read
    /// requests. Each ObjectRangeData entry will have a read_id
    /// set to the same value as the corresponding source read request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub object_data_ranges: std::vec::Vec<crate::model::ObjectRangeData>,

    /// Metadata of the object whose media is being returned.
    /// Only populated in the first response in the stream and not populated when
    /// the stream is opened with a read handle.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::Object>,

    /// This field will be periodically refreshed, however it may not be set in
    /// every response. It allows the client to more efficiently open subsequent
    /// bidirectional streams to the same object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_handle: std::option::Option<crate::model::BidiReadHandle>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BidiReadObjectResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metadata][crate::model::BidiReadObjectResponse::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<crate::model::Object>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [read_handle][crate::model::BidiReadObjectResponse::read_handle].
    pub fn set_read_handle<
        T: std::convert::Into<std::option::Option<crate::model::BidiReadHandle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.read_handle = v.into();
        self
    }

    /// Sets the value of [object_data_ranges][crate::model::BidiReadObjectResponse::object_data_ranges].
    pub fn set_object_data_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ObjectRangeData>,
    {
        use std::iter::Iterator;
        self.object_data_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BidiReadObjectResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.BidiReadObjectResponse"
    }
}

/// Error proto containing details for a redirected read. This error is only
/// returned on initial open in case of a redirect.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BidiReadObjectRedirectedError {
    /// The read handle for the redirected read. The client can use this for the
    /// subsequent open.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_handle: std::option::Option<crate::model::BidiReadHandle>,

    /// The routing token that should be used when reopening the read stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub routing_token: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BidiReadObjectRedirectedError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [read_handle][crate::model::BidiReadObjectRedirectedError::read_handle].
    pub fn set_read_handle<
        T: std::convert::Into<std::option::Option<crate::model::BidiReadHandle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.read_handle = v.into();
        self
    }

    /// Sets the value of [routing_token][crate::model::BidiReadObjectRedirectedError::routing_token].
    pub fn set_routing_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.routing_token = v.into();
        self
    }
}

impl wkt::message::Message for BidiReadObjectRedirectedError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.BidiReadObjectRedirectedError"
    }
}

/// Error proto containing details for a redirected write. This error is only
/// returned on initial open in case of a redirect.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BidiWriteObjectRedirectedError {
    /// The routing token that should be used when reopening the write stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub routing_token: std::option::Option<std::string::String>,

    /// Opaque value describing a previous write.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub write_handle: std::option::Option<crate::model::BidiWriteHandle>,

    /// The generation of the object that triggered the redirect.
    /// Note that if this error was returned as part of an appendable object
    /// create, this object generation is now successfully created and
    /// append_object_spec should be used when reconnecting.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub generation: std::option::Option<i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BidiWriteObjectRedirectedError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [routing_token][crate::model::BidiWriteObjectRedirectedError::routing_token].
    pub fn set_routing_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.routing_token = v.into();
        self
    }

    /// Sets the value of [write_handle][crate::model::BidiWriteObjectRedirectedError::write_handle].
    pub fn set_write_handle<
        T: std::convert::Into<std::option::Option<crate::model::BidiWriteHandle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_handle = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::BidiWriteObjectRedirectedError::generation].
    pub fn set_generation<T: std::convert::Into<std::option::Option<i64>>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }
}

impl wkt::message::Message for BidiWriteObjectRedirectedError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.BidiWriteObjectRedirectedError"
    }
}

/// Error extension proto containing details for all outstanding reads on the
/// failed stream
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BidiReadObjectError {
    /// The error code for each outstanding read_range
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub read_range_errors: std::vec::Vec<crate::model::ReadRangeError>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BidiReadObjectError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [read_range_errors][crate::model::BidiReadObjectError::read_range_errors].
    pub fn set_read_range_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReadRangeError>,
    {
        use std::iter::Iterator;
        self.read_range_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BidiReadObjectError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.BidiReadObjectError"
    }
}

/// Error extension proto containing details for a single range read
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadRangeError {
    /// The id of the corresponding read_range
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub read_id: i64,

    /// The status which should be an enum value of [google.rpc.Code].
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReadRangeError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [read_id][crate::model::ReadRangeError::read_id].
    pub fn set_read_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.read_id = v.into();
        self
    }

    /// Sets the value of [status][crate::model::ReadRangeError::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for ReadRangeError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ReadRangeError"
    }
}

/// Describes a range of bytes to read in a BidiReadObjectRanges request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReadRange {
    /// Required. The offset for the first byte to return in the read, relative to
    /// the start of the object.
    ///
    /// A negative read_offset value will be interpreted as the number of bytes
    /// back from the end of the object to be returned. For example, if an object's
    /// length is 15 bytes, a ReadObjectRequest with read_offset = -5 and
    /// read_length = 3 would return bytes 10 through 12 of the object. Requesting
    /// a negative offset with magnitude larger than the size of the object will
    /// return the entire object. A read_offset larger than the size of the object
    /// will result in an OutOfRange error.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub read_offset: i64,

    /// Optional. The maximum number of data bytes the server is allowed to return
    /// across all response messages with the same read_id. A read_length of zero
    /// indicates to read until the resource end, and a negative read_length will
    /// cause an error. If the stream returns fewer bytes than allowed by the
    /// read_length and no error occurred, the stream includes all data from the
    /// read_offset to the resource end.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub read_length: i64,

    /// Required. Read identifier provided by the client. When the client issues
    /// more than one outstanding ReadRange on the same stream, responses can be
    /// mapped back to their corresponding requests using this value. Clients must
    /// ensure that all outstanding requests have different read_id values. The
    /// server may close the stream with an error if this condition is not met.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub read_id: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReadRange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [read_offset][crate::model::ReadRange::read_offset].
    pub fn set_read_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.read_offset = v.into();
        self
    }

    /// Sets the value of [read_length][crate::model::ReadRange::read_length].
    pub fn set_read_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.read_length = v.into();
        self
    }

    /// Sets the value of [read_id][crate::model::ReadRange::read_id].
    pub fn set_read_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.read_id = v.into();
        self
    }
}

impl wkt::message::Message for ReadRange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ReadRange"
    }
}

/// Contains data and metadata for a range of an object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ObjectRangeData {
    /// A portion of the data for the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub checksummed_data: std::option::Option<crate::model::ChecksummedData>,

    /// The ReadRange describes the content being returned with read_id set to the
    /// corresponding ReadObjectRequest in the stream. Multiple ObjectRangeData
    /// messages may have the same read_id but increasing offsets.
    /// ReadObjectResponse messages with the same read_id are guaranteed to be
    /// delivered in increasing offset order.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_range: std::option::Option<crate::model::ReadRange>,

    /// If set, indicates there are no more bytes to read for the given ReadRange.
    pub range_end: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectRangeData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [checksummed_data][crate::model::ObjectRangeData::checksummed_data].
    pub fn set_checksummed_data<
        T: std::convert::Into<std::option::Option<crate::model::ChecksummedData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.checksummed_data = v.into();
        self
    }

    /// Sets the value of [read_range][crate::model::ObjectRangeData::read_range].
    pub fn set_read_range<T: std::convert::Into<std::option::Option<crate::model::ReadRange>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_range = v.into();
        self
    }

    /// Sets the value of [range_end][crate::model::ObjectRangeData::range_end].
    pub fn set_range_end<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.range_end = v.into();
        self
    }
}

impl wkt::message::Message for ObjectRangeData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ObjectRangeData"
    }
}

/// BidiReadHandle contains a handle from a previous BiDiReadObject
/// invocation. The client can use this instead of BidiReadObjectSpec as an
/// optimized way of opening subsequent bidirectional streams to the same object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BidiReadHandle {
    /// Required. Opaque value describing a previous read.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub handle: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BidiReadHandle {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [handle][crate::model::BidiReadHandle::handle].
    pub fn set_handle<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.handle = v.into();
        self
    }
}

impl wkt::message::Message for BidiReadHandle {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.BidiReadHandle"
    }
}

/// BidiWriteHandle contains a handle from a previous BidiWriteObject
/// invocation. The client can use this as an optimized way of opening subsequent
/// bidirectional streams to the same object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BidiWriteHandle {
    /// Required. Opaque value describing a previous write.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub handle: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BidiWriteHandle {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [handle][crate::model::BidiWriteHandle::handle].
    pub fn set_handle<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.handle = v.into();
        self
    }
}

impl wkt::message::Message for BidiWriteHandle {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.BidiWriteHandle"
    }
}

/// Describes an attempt to insert an object, possibly over multiple requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteObjectSpec {
    /// Required. Destination object, including its name and its metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource: std::option::Option<crate::model::Object>,

    /// Apply a predefined set of access controls to this object.
    /// Valid values are "authenticatedRead", "bucketOwnerFullControl",
    /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predefined_acl: std::string::String,

    /// Makes the operation conditional on whether the object's current
    /// generation matches the given value. Setting to 0 makes the operation
    /// succeed only if there are no live versions of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live
    /// generation does not match the given value. If no live object exists, the
    /// precondition fails. Setting to 0 makes the operation succeed only if
    /// there is a live version of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// The expected final object size being uploaded.
    /// If this value is set, closing the stream after writing fewer or more than
    /// `object_size` bytes will result in an OUT_OF_RANGE error.
    ///
    /// This situation is considered a client error, and if such an error occurs
    /// you must start the upload over from scratch, this time sending the correct
    /// number of bytes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub object_size: std::option::Option<i64>,

    /// If true, the object will be created in appendable mode.
    /// This field may only be set when using BidiWriteObject.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub appendable: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WriteObjectSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource][crate::model::WriteObjectSpec::resource].
    pub fn set_resource<T: std::convert::Into<std::option::Option<crate::model::Object>>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [predefined_acl][crate::model::WriteObjectSpec::predefined_acl].
    pub fn set_predefined_acl<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predefined_acl = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::WriteObjectSpec::if_generation_match].
    pub fn set_if_generation_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_match = v.into();
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::WriteObjectSpec::if_generation_not_match].
    pub fn set_if_generation_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_not_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::WriteObjectSpec::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::WriteObjectSpec::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_not_match = v.into();
        self
    }

    /// Sets the value of [object_size][crate::model::WriteObjectSpec::object_size].
    pub fn set_object_size<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.object_size = v.into();
        self
    }

    /// Sets the value of [appendable][crate::model::WriteObjectSpec::appendable].
    pub fn set_appendable<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.appendable = v.into();
        self
    }
}

impl wkt::message::Message for WriteObjectSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.WriteObjectSpec"
    }
}

/// Request message for WriteObject.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteObjectRequest {
    /// Required. The offset from the beginning of the object at which the data
    /// should be written.
    ///
    /// In the first `WriteObjectRequest` of a `WriteObject()` action, it
    /// indicates the initial offset for the `Write()` call. The value **must** be
    /// equal to the `persisted_size` that a call to `QueryWriteStatus()` would
    /// return (0 if this is the first write to the object).
    ///
    /// On subsequent calls, this value **must** be no larger than the sum of the
    /// first `write_offset` and the sizes of all `data` chunks sent previously on
    /// this stream.
    ///
    /// An incorrect value will cause an error.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub write_offset: i64,

    /// Checksums for the complete object. If the checksums computed by the service
    /// don't match the specified checksums the call will fail. May only be
    /// provided in the first or last request (either with first_message, or
    /// finish_write set).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub object_checksums: std::option::Option<crate::model::ObjectChecksums>,

    /// If `true`, this indicates that the write is complete. Sending any
    /// `WriteObjectRequest`s subsequent to one in which `finish_write` is `true`
    /// will cause an error.
    /// For a non-resumable write (where the upload_id was not set in the first
    /// message), it is an error not to set this field in the final message of the
    /// stream.
    pub finish_write: bool,

    /// A set of parameters common to Storage API requests concerning an object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    /// The first message of each stream should set one of the following.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub first_message: std::option::Option<crate::model::write_object_request::FirstMessage>,

    /// A portion of the data for the object.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data: std::option::Option<crate::model::write_object_request::Data>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WriteObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [write_offset][crate::model::WriteObjectRequest::write_offset].
    pub fn set_write_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.write_offset = v.into();
        self
    }

    /// Sets the value of [object_checksums][crate::model::WriteObjectRequest::object_checksums].
    pub fn set_object_checksums<
        T: std::convert::Into<std::option::Option<crate::model::ObjectChecksums>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.object_checksums = v.into();
        self
    }

    /// Sets the value of [finish_write][crate::model::WriteObjectRequest::finish_write].
    pub fn set_finish_write<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.finish_write = v.into();
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::WriteObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<
        T: std::convert::Into<std::option::Option<crate::model::CommonObjectRequestParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.common_object_request_params = v.into();
        self
    }

    /// Sets the value of [first_message][crate::model::WriteObjectRequest::first_message].
    ///
    /// Note that all the setters affecting `first_message` are mutually
    /// exclusive.
    pub fn set_first_message<
        T: std::convert::Into<std::option::Option<crate::model::write_object_request::FirstMessage>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.first_message = v.into();
        self
    }

    /// The value of [first_message][crate::model::WriteObjectRequest::first_message]
    /// if it holds a `UploadId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn upload_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.first_message.as_ref().and_then(|v| match v {
            crate::model::write_object_request::FirstMessage::UploadId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [first_message][crate::model::WriteObjectRequest::first_message]
    /// if it holds a `WriteObjectSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn write_object_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::WriteObjectSpec>> {
        #[allow(unreachable_patterns)]
        self.first_message.as_ref().and_then(|v| match v {
            crate::model::write_object_request::FirstMessage::WriteObjectSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [first_message][crate::model::WriteObjectRequest::first_message]
    /// to hold a `UploadId`.
    ///
    /// Note that all the setters affecting `first_message` are
    /// mutually exclusive.
    pub fn set_upload_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.first_message = std::option::Option::Some(
            crate::model::write_object_request::FirstMessage::UploadId(v.into()),
        );
        self
    }

    /// Sets the value of [first_message][crate::model::WriteObjectRequest::first_message]
    /// to hold a `WriteObjectSpec`.
    ///
    /// Note that all the setters affecting `first_message` are
    /// mutually exclusive.
    pub fn set_write_object_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::WriteObjectSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.first_message = std::option::Option::Some(
            crate::model::write_object_request::FirstMessage::WriteObjectSpec(v.into()),
        );
        self
    }

    /// Sets the value of [data][crate::model::WriteObjectRequest::data].
    ///
    /// Note that all the setters affecting `data` are mutually
    /// exclusive.
    pub fn set_data<
        T: std::convert::Into<std::option::Option<crate::model::write_object_request::Data>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// The value of [data][crate::model::WriteObjectRequest::data]
    /// if it holds a `ChecksummedData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn checksummed_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ChecksummedData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::write_object_request::Data::ChecksummedData(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::WriteObjectRequest::data]
    /// to hold a `ChecksummedData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_checksummed_data<
        T: std::convert::Into<std::boxed::Box<crate::model::ChecksummedData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::write_object_request::Data::ChecksummedData(v.into()),
        );
        self
    }
}

impl wkt::message::Message for WriteObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.WriteObjectRequest"
    }
}

/// Defines additional types related to [WriteObjectRequest].
pub mod write_object_request {
    #[allow(unused_imports)]
    use super::*;

    /// The first message of each stream should set one of the following.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FirstMessage {
        /// For resumable uploads. This should be the `upload_id` returned from a
        /// call to `StartResumableWriteResponse`.
        UploadId(std::string::String),
        /// For non-resumable uploads. Describes the overall upload, including the
        /// destination bucket and object name, preconditions, etc.
        WriteObjectSpec(std::boxed::Box<crate::model::WriteObjectSpec>),
    }

    impl FirstMessage {
        /// Initializes the enum to the [UploadId](Self::UploadId) branch.
        pub fn from_upload_id(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::UploadId(value.into())
        }
        /// Initializes the enum to the [WriteObjectSpec](Self::WriteObjectSpec) branch.
        pub fn from_write_object_spec(
            value: impl std::convert::Into<std::boxed::Box<crate::model::WriteObjectSpec>>,
        ) -> Self {
            Self::WriteObjectSpec(value.into())
        }
    }

    /// A portion of the data for the object.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Data {
        /// The data to insert. If a crc32c checksum is provided that doesn't match
        /// the checksum computed by the service, the request will fail.
        ChecksummedData(std::boxed::Box<crate::model::ChecksummedData>),
    }

    impl Data {
        /// Initializes the enum to the [ChecksummedData](Self::ChecksummedData) branch.
        pub fn from_checksummed_data(
            value: impl std::convert::Into<std::boxed::Box<crate::model::ChecksummedData>>,
        ) -> Self {
            Self::ChecksummedData(value.into())
        }
    }
}

/// Response message for WriteObject.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteObjectResponse {
    /// The response will set one of the following.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub write_status: std::option::Option<crate::model::write_object_response::WriteStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WriteObjectResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [write_status][crate::model::WriteObjectResponse::write_status].
    ///
    /// Note that all the setters affecting `write_status` are mutually
    /// exclusive.
    pub fn set_write_status<
        T: std::convert::Into<std::option::Option<crate::model::write_object_response::WriteStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_status = v.into();
        self
    }

    /// The value of [write_status][crate::model::WriteObjectResponse::write_status]
    /// if it holds a `PersistedSize`, `None` if the field is not set or
    /// holds a different branch.
    pub fn persisted_size(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.write_status.as_ref().and_then(|v| match v {
            crate::model::write_object_response::WriteStatus::PersistedSize(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [write_status][crate::model::WriteObjectResponse::write_status]
    /// if it holds a `Resource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn resource(&self) -> std::option::Option<&std::boxed::Box<crate::model::Object>> {
        #[allow(unreachable_patterns)]
        self.write_status.as_ref().and_then(|v| match v {
            crate::model::write_object_response::WriteStatus::Resource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [write_status][crate::model::WriteObjectResponse::write_status]
    /// to hold a `PersistedSize`.
    ///
    /// Note that all the setters affecting `write_status` are
    /// mutually exclusive.
    pub fn set_persisted_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.write_status = std::option::Option::Some(
            crate::model::write_object_response::WriteStatus::PersistedSize(v.into()),
        );
        self
    }

    /// Sets the value of [write_status][crate::model::WriteObjectResponse::write_status]
    /// to hold a `Resource`.
    ///
    /// Note that all the setters affecting `write_status` are
    /// mutually exclusive.
    pub fn set_resource<T: std::convert::Into<std::boxed::Box<crate::model::Object>>>(
        mut self,
        v: T,
    ) -> Self {
        self.write_status = std::option::Option::Some(
            crate::model::write_object_response::WriteStatus::Resource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for WriteObjectResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.WriteObjectResponse"
    }
}

/// Defines additional types related to [WriteObjectResponse].
pub mod write_object_response {
    #[allow(unused_imports)]
    use super::*;

    /// The response will set one of the following.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum WriteStatus {
        /// The total number of bytes that have been processed for the given object
        /// from all `WriteObject` calls. Only set if the upload has not finalized.
        PersistedSize(i64),
        /// A resource containing the metadata for the uploaded object. Only set if
        /// the upload has finalized.
        Resource(std::boxed::Box<crate::model::Object>),
    }

    impl WriteStatus {
        /// Initializes the enum to the [PersistedSize](Self::PersistedSize) branch.
        pub fn from_persisted_size(value: impl std::convert::Into<i64>) -> Self {
            Self::PersistedSize(value.into())
        }
        /// Initializes the enum to the [Resource](Self::Resource) branch.
        pub fn from_resource(
            value: impl std::convert::Into<std::boxed::Box<crate::model::Object>>,
        ) -> Self {
            Self::Resource(value.into())
        }
    }
}

/// Describes an attempt to append to an object, possibly over multiple requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AppendObjectSpec {
    /// Required. The name of the bucket containing the object to write.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// Required. The name of the object to open for writing.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object: std::string::String,

    /// Required. The generation number of the object to open for writing.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// An optional routing token that influences request routing for the stream.
    /// Must be provided if a BidiWriteObjectRedirectedError is returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub routing_token: std::option::Option<std::string::String>,

    /// An optional write handle returned from a previous BidiWriteObjectResponse
    /// message or a BidiWriteObjectRedirectedError error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub write_handle: std::option::Option<crate::model::BidiWriteHandle>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppendObjectSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::AppendObjectSpec::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::AppendObjectSpec::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::AppendObjectSpec::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::AppendObjectSpec::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::AppendObjectSpec::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_not_match = v.into();
        self
    }

    /// Sets the value of [routing_token][crate::model::AppendObjectSpec::routing_token].
    pub fn set_routing_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.routing_token = v.into();
        self
    }

    /// Sets the value of [write_handle][crate::model::AppendObjectSpec::write_handle].
    pub fn set_write_handle<
        T: std::convert::Into<std::option::Option<crate::model::BidiWriteHandle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_handle = v.into();
        self
    }
}

impl wkt::message::Message for AppendObjectSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.AppendObjectSpec"
    }
}

/// Request message for BidiWriteObject.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BidiWriteObjectRequest {
    /// Required. The offset from the beginning of the object at which the data
    /// should be written.
    ///
    /// In the first `WriteObjectRequest` of a `WriteObject()` action, it
    /// indicates the initial offset for the `Write()` call. The value **must** be
    /// equal to the `persisted_size` that a call to `QueryWriteStatus()` would
    /// return (0 if this is the first write to the object).
    ///
    /// On subsequent calls, this value **must** be no larger than the sum of the
    /// first `write_offset` and the sizes of all `data` chunks sent previously on
    /// this stream.
    ///
    /// An invalid value will cause an error.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub write_offset: i64,

    /// Checksums for the complete object. If the checksums computed by the service
    /// don't match the specified checksums the call will fail. May only be
    /// provided in the first request or the
    /// last request (with finish_write set).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub object_checksums: std::option::Option<crate::model::ObjectChecksums>,

    /// For each BidiWriteObjectRequest where state_lookup is `true` or the client
    /// closes the stream, the service will send a BidiWriteObjectResponse
    /// containing the current persisted size. The persisted size sent in responses
    /// covers all the bytes the server has persisted thus far and can be used to
    /// decide what data is safe for the client to drop. Note that the object's
    /// current size reported by the BidiWriteObjectResponse may lag behind the
    /// number of bytes written by the client. This field is ignored if
    /// `finish_write` is set to true.
    pub state_lookup: bool,

    /// Persists data written on the stream, up to and including the current
    /// message, to permanent storage. This option should be used sparingly as it
    /// may reduce performance. Ongoing writes will periodically be persisted on
    /// the server even when `flush` is not set. This field is ignored if
    /// `finish_write` is set to true since there's no need to checkpoint or flush
    /// if this message completes the write.
    pub flush: bool,

    /// If `true`, this indicates that the write is complete. Sending any
    /// `WriteObjectRequest`s subsequent to one in which `finish_write` is `true`
    /// will cause an error.
    /// For a non-resumable write (where the upload_id was not set in the first
    /// message), it is an error not to set this field in the final message of the
    /// stream.
    pub finish_write: bool,

    /// A set of parameters common to Storage API requests concerning an object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    /// The first message of each stream should set one of the following.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub first_message: std::option::Option<crate::model::bidi_write_object_request::FirstMessage>,

    /// A portion of the data for the object.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data: std::option::Option<crate::model::bidi_write_object_request::Data>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BidiWriteObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [write_offset][crate::model::BidiWriteObjectRequest::write_offset].
    pub fn set_write_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.write_offset = v.into();
        self
    }

    /// Sets the value of [object_checksums][crate::model::BidiWriteObjectRequest::object_checksums].
    pub fn set_object_checksums<
        T: std::convert::Into<std::option::Option<crate::model::ObjectChecksums>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.object_checksums = v.into();
        self
    }

    /// Sets the value of [state_lookup][crate::model::BidiWriteObjectRequest::state_lookup].
    pub fn set_state_lookup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.state_lookup = v.into();
        self
    }

    /// Sets the value of [flush][crate::model::BidiWriteObjectRequest::flush].
    pub fn set_flush<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.flush = v.into();
        self
    }

    /// Sets the value of [finish_write][crate::model::BidiWriteObjectRequest::finish_write].
    pub fn set_finish_write<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.finish_write = v.into();
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::BidiWriteObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<
        T: std::convert::Into<std::option::Option<crate::model::CommonObjectRequestParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.common_object_request_params = v.into();
        self
    }

    /// Sets the value of [first_message][crate::model::BidiWriteObjectRequest::first_message].
    ///
    /// Note that all the setters affecting `first_message` are mutually
    /// exclusive.
    pub fn set_first_message<
        T: std::convert::Into<
                std::option::Option<crate::model::bidi_write_object_request::FirstMessage>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.first_message = v.into();
        self
    }

    /// The value of [first_message][crate::model::BidiWriteObjectRequest::first_message]
    /// if it holds a `UploadId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn upload_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.first_message.as_ref().and_then(|v| match v {
            crate::model::bidi_write_object_request::FirstMessage::UploadId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [first_message][crate::model::BidiWriteObjectRequest::first_message]
    /// if it holds a `WriteObjectSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn write_object_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::WriteObjectSpec>> {
        #[allow(unreachable_patterns)]
        self.first_message.as_ref().and_then(|v| match v {
            crate::model::bidi_write_object_request::FirstMessage::WriteObjectSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [first_message][crate::model::BidiWriteObjectRequest::first_message]
    /// if it holds a `AppendObjectSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn append_object_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AppendObjectSpec>> {
        #[allow(unreachable_patterns)]
        self.first_message.as_ref().and_then(|v| match v {
            crate::model::bidi_write_object_request::FirstMessage::AppendObjectSpec(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [first_message][crate::model::BidiWriteObjectRequest::first_message]
    /// to hold a `UploadId`.
    ///
    /// Note that all the setters affecting `first_message` are
    /// mutually exclusive.
    pub fn set_upload_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.first_message = std::option::Option::Some(
            crate::model::bidi_write_object_request::FirstMessage::UploadId(v.into()),
        );
        self
    }

    /// Sets the value of [first_message][crate::model::BidiWriteObjectRequest::first_message]
    /// to hold a `WriteObjectSpec`.
    ///
    /// Note that all the setters affecting `first_message` are
    /// mutually exclusive.
    pub fn set_write_object_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::WriteObjectSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.first_message = std::option::Option::Some(
            crate::model::bidi_write_object_request::FirstMessage::WriteObjectSpec(v.into()),
        );
        self
    }

    /// Sets the value of [first_message][crate::model::BidiWriteObjectRequest::first_message]
    /// to hold a `AppendObjectSpec`.
    ///
    /// Note that all the setters affecting `first_message` are
    /// mutually exclusive.
    pub fn set_append_object_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::AppendObjectSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.first_message = std::option::Option::Some(
            crate::model::bidi_write_object_request::FirstMessage::AppendObjectSpec(v.into()),
        );
        self
    }

    /// Sets the value of [data][crate::model::BidiWriteObjectRequest::data].
    ///
    /// Note that all the setters affecting `data` are mutually
    /// exclusive.
    pub fn set_data<
        T: std::convert::Into<std::option::Option<crate::model::bidi_write_object_request::Data>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// The value of [data][crate::model::BidiWriteObjectRequest::data]
    /// if it holds a `ChecksummedData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn checksummed_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ChecksummedData>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::bidi_write_object_request::Data::ChecksummedData(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::BidiWriteObjectRequest::data]
    /// to hold a `ChecksummedData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_checksummed_data<
        T: std::convert::Into<std::boxed::Box<crate::model::ChecksummedData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(
            crate::model::bidi_write_object_request::Data::ChecksummedData(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BidiWriteObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.BidiWriteObjectRequest"
    }
}

/// Defines additional types related to [BidiWriteObjectRequest].
pub mod bidi_write_object_request {
    #[allow(unused_imports)]
    use super::*;

    /// The first message of each stream should set one of the following.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum FirstMessage {
        /// For resumable uploads. This should be the `upload_id` returned from a
        /// call to `StartResumableWriteResponse`.
        UploadId(std::string::String),
        /// For non-resumable uploads. Describes the overall upload, including the
        /// destination bucket and object name, preconditions, etc.
        WriteObjectSpec(std::boxed::Box<crate::model::WriteObjectSpec>),
        /// For appendable uploads. Describes the object to append to.
        AppendObjectSpec(std::boxed::Box<crate::model::AppendObjectSpec>),
    }

    impl FirstMessage {
        /// Initializes the enum to the [UploadId](Self::UploadId) branch.
        pub fn from_upload_id(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::UploadId(value.into())
        }
        /// Initializes the enum to the [WriteObjectSpec](Self::WriteObjectSpec) branch.
        pub fn from_write_object_spec(
            value: impl std::convert::Into<std::boxed::Box<crate::model::WriteObjectSpec>>,
        ) -> Self {
            Self::WriteObjectSpec(value.into())
        }
        /// Initializes the enum to the [AppendObjectSpec](Self::AppendObjectSpec) branch.
        pub fn from_append_object_spec(
            value: impl std::convert::Into<std::boxed::Box<crate::model::AppendObjectSpec>>,
        ) -> Self {
            Self::AppendObjectSpec(value.into())
        }
    }

    /// A portion of the data for the object.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Data {
        /// The data to insert. If a crc32c checksum is provided that doesn't match
        /// the checksum computed by the service, the request will fail.
        ChecksummedData(std::boxed::Box<crate::model::ChecksummedData>),
    }

    impl Data {
        /// Initializes the enum to the [ChecksummedData](Self::ChecksummedData) branch.
        pub fn from_checksummed_data(
            value: impl std::convert::Into<std::boxed::Box<crate::model::ChecksummedData>>,
        ) -> Self {
            Self::ChecksummedData(value.into())
        }
    }
}

/// Response message for BidiWriteObject.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BidiWriteObjectResponse {
    /// An optional write handle that will periodically be present in response
    /// messages. Clients should save it for later use in establishing a new stream
    /// if a connection is interrupted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub write_handle: std::option::Option<crate::model::BidiWriteHandle>,

    /// The response will set one of the following.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub write_status: std::option::Option<crate::model::bidi_write_object_response::WriteStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BidiWriteObjectResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [write_handle][crate::model::BidiWriteObjectResponse::write_handle].
    pub fn set_write_handle<
        T: std::convert::Into<std::option::Option<crate::model::BidiWriteHandle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_handle = v.into();
        self
    }

    /// Sets the value of [write_status][crate::model::BidiWriteObjectResponse::write_status].
    ///
    /// Note that all the setters affecting `write_status` are mutually
    /// exclusive.
    pub fn set_write_status<
        T: std::convert::Into<
                std::option::Option<crate::model::bidi_write_object_response::WriteStatus>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_status = v.into();
        self
    }

    /// The value of [write_status][crate::model::BidiWriteObjectResponse::write_status]
    /// if it holds a `PersistedSize`, `None` if the field is not set or
    /// holds a different branch.
    pub fn persisted_size(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.write_status.as_ref().and_then(|v| match v {
            crate::model::bidi_write_object_response::WriteStatus::PersistedSize(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [write_status][crate::model::BidiWriteObjectResponse::write_status]
    /// if it holds a `Resource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn resource(&self) -> std::option::Option<&std::boxed::Box<crate::model::Object>> {
        #[allow(unreachable_patterns)]
        self.write_status.as_ref().and_then(|v| match v {
            crate::model::bidi_write_object_response::WriteStatus::Resource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [write_status][crate::model::BidiWriteObjectResponse::write_status]
    /// to hold a `PersistedSize`.
    ///
    /// Note that all the setters affecting `write_status` are
    /// mutually exclusive.
    pub fn set_persisted_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.write_status = std::option::Option::Some(
            crate::model::bidi_write_object_response::WriteStatus::PersistedSize(v.into()),
        );
        self
    }

    /// Sets the value of [write_status][crate::model::BidiWriteObjectResponse::write_status]
    /// to hold a `Resource`.
    ///
    /// Note that all the setters affecting `write_status` are
    /// mutually exclusive.
    pub fn set_resource<T: std::convert::Into<std::boxed::Box<crate::model::Object>>>(
        mut self,
        v: T,
    ) -> Self {
        self.write_status = std::option::Option::Some(
            crate::model::bidi_write_object_response::WriteStatus::Resource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BidiWriteObjectResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.BidiWriteObjectResponse"
    }
}

/// Defines additional types related to [BidiWriteObjectResponse].
pub mod bidi_write_object_response {
    #[allow(unused_imports)]
    use super::*;

    /// The response will set one of the following.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum WriteStatus {
        /// The total number of bytes that have been processed for the given object
        /// from all `WriteObject` calls. Only set if the upload has not finalized.
        PersistedSize(i64),
        /// A resource containing the metadata for the uploaded object. Only set if
        /// the upload has finalized.
        Resource(std::boxed::Box<crate::model::Object>),
    }

    impl WriteStatus {
        /// Initializes the enum to the [PersistedSize](Self::PersistedSize) branch.
        pub fn from_persisted_size(value: impl std::convert::Into<i64>) -> Self {
            Self::PersistedSize(value.into())
        }
        /// Initializes the enum to the [Resource](Self::Resource) branch.
        pub fn from_resource(
            value: impl std::convert::Into<std::boxed::Box<crate::model::Object>>,
        ) -> Self {
            Self::Resource(value.into())
        }
    }
}

/// Request message for ListObjects.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListObjectsRequest {
    /// Required. Name of the bucket in which to look for objects.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of `items` plus `prefixes` to return
    /// in a single page of responses. As duplicate `prefixes` are
    /// omitted, fewer total results may be returned than requested. The service
    /// will use this parameter or 1,000 items, whichever is smaller.
    pub page_size: i32,

    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// If set, returns results in a directory-like mode. `items` will contain
    /// only objects whose names, aside from the `prefix`, do not
    /// contain `delimiter`. Objects whose names, aside from the
    /// `prefix`, contain `delimiter` will have their name,
    /// truncated after the `delimiter`, returned in
    /// `prefixes`. Duplicate `prefixes` are omitted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub delimiter: std::string::String,

    /// If true, objects that end in exactly one instance of `delimiter`
    /// will have their metadata included in `items` in addition to
    /// `prefixes`.
    pub include_trailing_delimiter: bool,

    /// Filter results to objects whose names begin with this prefix.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub prefix: std::string::String,

    /// If `true`, lists all versions of an object as distinct results.
    /// For more information, see
    /// [Object
    /// Versioning](https://cloud.google.com/storage/docs/object-versioning).
    pub versions: bool,

    /// Mask specifying which fields to read from each result.
    /// If no mask is specified, will default to all fields except items.acl and
    /// items.owner.
    ///
    /// * may be used to mean "all fields".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. Filter results to objects whose names are lexicographically equal
    /// to or after lexicographic_start. If lexicographic_end is also set, the
    /// objects listed have names between lexicographic_start (inclusive) and
    /// lexicographic_end (exclusive).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub lexicographic_start: std::string::String,

    /// Optional. Filter results to objects whose names are lexicographically
    /// before lexicographic_end. If lexicographic_start is also set, the objects
    /// listed have names between lexicographic_start (inclusive) and
    /// lexicographic_end (exclusive).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub lexicographic_end: std::string::String,

    /// Optional. If true, only list all soft-deleted versions of the object.
    /// Soft delete policy is required to set this option.
    pub soft_deleted: bool,

    /// Optional. If true, will also include folders and managed folders (besides
    /// objects) in the returned `prefixes`. Requires `delimiter` to be set to '/'.
    pub include_folders_as_prefixes: bool,

    /// Optional. Filter results to objects and prefixes that match this glob
    /// pattern. See [List Objects Using
    /// Glob](https://cloud.google.com/storage/docs/json_api/v1/objects/list#list-objects-and-prefixes-using-glob)
    /// for the full syntax.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub match_glob: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListObjectsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListObjectsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListObjectsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListObjectsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [delimiter][crate::model::ListObjectsRequest::delimiter].
    pub fn set_delimiter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.delimiter = v.into();
        self
    }

    /// Sets the value of [include_trailing_delimiter][crate::model::ListObjectsRequest::include_trailing_delimiter].
    pub fn set_include_trailing_delimiter<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_trailing_delimiter = v.into();
        self
    }

    /// Sets the value of [prefix][crate::model::ListObjectsRequest::prefix].
    pub fn set_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.prefix = v.into();
        self
    }

    /// Sets the value of [versions][crate::model::ListObjectsRequest::versions].
    pub fn set_versions<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.versions = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListObjectsRequest::read_mask].
    pub fn set_read_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.read_mask = v.into();
        self
    }

    /// Sets the value of [lexicographic_start][crate::model::ListObjectsRequest::lexicographic_start].
    pub fn set_lexicographic_start<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lexicographic_start = v.into();
        self
    }

    /// Sets the value of [lexicographic_end][crate::model::ListObjectsRequest::lexicographic_end].
    pub fn set_lexicographic_end<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lexicographic_end = v.into();
        self
    }

    /// Sets the value of [soft_deleted][crate::model::ListObjectsRequest::soft_deleted].
    pub fn set_soft_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.soft_deleted = v.into();
        self
    }

    /// Sets the value of [include_folders_as_prefixes][crate::model::ListObjectsRequest::include_folders_as_prefixes].
    pub fn set_include_folders_as_prefixes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_folders_as_prefixes = v.into();
        self
    }

    /// Sets the value of [match_glob][crate::model::ListObjectsRequest::match_glob].
    pub fn set_match_glob<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.match_glob = v.into();
        self
    }
}

impl wkt::message::Message for ListObjectsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ListObjectsRequest"
    }
}

/// Request object for `QueryWriteStatus`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryWriteStatusRequest {
    /// Required. The name of the resume token for the object whose write status is
    /// being requested.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub upload_id: std::string::String,

    /// A set of parameters common to Storage API requests concerning an object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryWriteStatusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [upload_id][crate::model::QueryWriteStatusRequest::upload_id].
    pub fn set_upload_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.upload_id = v.into();
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::QueryWriteStatusRequest::common_object_request_params].
    pub fn set_common_object_request_params<
        T: std::convert::Into<std::option::Option<crate::model::CommonObjectRequestParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.common_object_request_params = v.into();
        self
    }
}

impl wkt::message::Message for QueryWriteStatusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.QueryWriteStatusRequest"
    }
}

/// Response object for `QueryWriteStatus`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryWriteStatusResponse {
    /// The response will set one of the following.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub write_status: std::option::Option<crate::model::query_write_status_response::WriteStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryWriteStatusResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [write_status][crate::model::QueryWriteStatusResponse::write_status].
    ///
    /// Note that all the setters affecting `write_status` are mutually
    /// exclusive.
    pub fn set_write_status<
        T: std::convert::Into<
                std::option::Option<crate::model::query_write_status_response::WriteStatus>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_status = v.into();
        self
    }

    /// The value of [write_status][crate::model::QueryWriteStatusResponse::write_status]
    /// if it holds a `PersistedSize`, `None` if the field is not set or
    /// holds a different branch.
    pub fn persisted_size(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.write_status.as_ref().and_then(|v| match v {
            crate::model::query_write_status_response::WriteStatus::PersistedSize(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [write_status][crate::model::QueryWriteStatusResponse::write_status]
    /// if it holds a `Resource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn resource(&self) -> std::option::Option<&std::boxed::Box<crate::model::Object>> {
        #[allow(unreachable_patterns)]
        self.write_status.as_ref().and_then(|v| match v {
            crate::model::query_write_status_response::WriteStatus::Resource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [write_status][crate::model::QueryWriteStatusResponse::write_status]
    /// to hold a `PersistedSize`.
    ///
    /// Note that all the setters affecting `write_status` are
    /// mutually exclusive.
    pub fn set_persisted_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.write_status = std::option::Option::Some(
            crate::model::query_write_status_response::WriteStatus::PersistedSize(v.into()),
        );
        self
    }

    /// Sets the value of [write_status][crate::model::QueryWriteStatusResponse::write_status]
    /// to hold a `Resource`.
    ///
    /// Note that all the setters affecting `write_status` are
    /// mutually exclusive.
    pub fn set_resource<T: std::convert::Into<std::boxed::Box<crate::model::Object>>>(
        mut self,
        v: T,
    ) -> Self {
        self.write_status = std::option::Option::Some(
            crate::model::query_write_status_response::WriteStatus::Resource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for QueryWriteStatusResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.QueryWriteStatusResponse"
    }
}

/// Defines additional types related to [QueryWriteStatusResponse].
pub mod query_write_status_response {
    #[allow(unused_imports)]
    use super::*;

    /// The response will set one of the following.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum WriteStatus {
        /// The total number of bytes that have been processed for the given object
        /// from all `WriteObject` calls. This is the correct value for the
        /// 'write_offset' field to use when resuming the `WriteObject` operation.
        /// Only set if the upload has not finalized.
        PersistedSize(i64),
        /// A resource containing the metadata for the uploaded object. Only set if
        /// the upload has finalized.
        Resource(std::boxed::Box<crate::model::Object>),
    }

    impl WriteStatus {
        /// Initializes the enum to the [PersistedSize](Self::PersistedSize) branch.
        pub fn from_persisted_size(value: impl std::convert::Into<i64>) -> Self {
            Self::PersistedSize(value.into())
        }
        /// Initializes the enum to the [Resource](Self::Resource) branch.
        pub fn from_resource(
            value: impl std::convert::Into<std::boxed::Box<crate::model::Object>>,
        ) -> Self {
            Self::Resource(value.into())
        }
    }
}

/// Request message for RewriteObject.
/// If the source object is encrypted using a Customer-Supplied Encryption Key
/// the key information must be provided in the copy_source_encryption_algorithm,
/// copy_source_encryption_key_bytes, and copy_source_encryption_key_sha256_bytes
/// fields. If the destination object should be encrypted the keying information
/// should be provided in the encryption_algorithm, encryption_key_bytes, and
/// encryption_key_sha256_bytes fields of the
/// common_object_request_params.customer_encryption field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RewriteObjectRequest {
    /// Required. Immutable. The name of the destination object.
    /// See the
    /// [Naming Guidelines](https://cloud.google.com/storage/docs/objects#naming).
    /// Example: `test.txt`
    /// The `name` field by itself does not uniquely identify a Cloud Storage
    /// object. A Cloud Storage object is uniquely identified by the tuple of
    /// (bucket, object, generation).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_name: std::string::String,

    /// Required. Immutable. The name of the bucket containing the destination
    /// object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_bucket: std::string::String,

    /// The name of the Cloud KMS key that will be used to encrypt the destination
    /// object. The Cloud KMS key must be located in same location as the object.
    /// If the parameter is not specified, the request uses the destination
    /// bucket's default encryption key, if any, or else the Google-managed
    /// encryption key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_kms_key: std::string::String,

    /// Properties of the destination, post-rewrite object.
    /// The `name`, `bucket` and `kms_key` fields must not be populated (these
    /// values are specified in the `destination_name`, `destination_bucket`, and
    /// `destination_kms_key` fields).
    /// If `destination` is present it will be used to construct the destination
    /// object's metadata; otherwise the destination object's metadata will be
    /// copied from the source object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::Object>,

    /// Required. Name of the bucket in which to find the source object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_bucket: std::string::String,

    /// Required. Name of the source object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_object: std::string::String,

    /// If present, selects a specific revision of the source object (as opposed to
    /// the latest version, the default).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub source_generation: i64,

    /// Include this field (from the previous rewrite response) on each rewrite
    /// request after the first one, until the rewrite response 'done' flag is
    /// true. Calls that provide a rewriteToken can omit all other request fields,
    /// but if included those fields must match the values provided in the first
    /// rewrite request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rewrite_token: std::string::String,

    /// Apply a predefined set of access controls to the destination object.
    /// Valid values are "authenticatedRead", "bucketOwnerFullControl",
    /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_predefined_acl: std::string::String,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live generation
    /// does not match the given value. If no live object exists, the precondition
    /// fails. Setting to 0 makes the operation succeed only if there is a live
    /// version of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the destination object's current
    /// metageneration matches the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the destination object's current
    /// metageneration does not match the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the source object's live
    /// generation matches the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_source_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the source object's live
    /// generation does not match the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_source_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the source object's current
    /// metageneration matches the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_source_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the source object's current
    /// metageneration does not match the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_source_metageneration_not_match: std::option::Option<i64>,

    /// The maximum number of bytes that will be rewritten per rewrite request.
    /// Most callers
    /// shouldn't need to specify this parameter - it is primarily in place to
    /// support testing. If specified the value must be an integral multiple of
    /// 1 MiB (1048576). Also, this only applies to requests where the source and
    /// destination span locations and/or storage classes. Finally, this value must
    /// not change across rewrite calls else you'll get an error that the
    /// `rewriteToken` is invalid.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_bytes_rewritten_per_call: i64,

    /// The algorithm used to encrypt the source object, if any. Used if the source
    /// object was encrypted with a Customer-Supplied Encryption Key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub copy_source_encryption_algorithm: std::string::String,

    /// The raw bytes (not base64-encoded) AES-256 encryption key used to encrypt
    /// the source object, if it was encrypted with a Customer-Supplied Encryption
    /// Key.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub copy_source_encryption_key_bytes: ::bytes::Bytes,

    /// The raw bytes (not base64-encoded) SHA256 hash of the encryption key used
    /// to encrypt the source object, if it was encrypted with a Customer-Supplied
    /// Encryption Key.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub copy_source_encryption_key_sha256_bytes: ::bytes::Bytes,

    /// A set of parameters common to Storage API requests concerning an object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    /// The checksums of the complete object. This will be used to validate the
    /// destination object after rewriting.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub object_checksums: std::option::Option<crate::model::ObjectChecksums>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RewriteObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination_name][crate::model::RewriteObjectRequest::destination_name].
    pub fn set_destination_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_name = v.into();
        self
    }

    /// Sets the value of [destination_bucket][crate::model::RewriteObjectRequest::destination_bucket].
    pub fn set_destination_bucket<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_bucket = v.into();
        self
    }

    /// Sets the value of [destination_kms_key][crate::model::RewriteObjectRequest::destination_kms_key].
    pub fn set_destination_kms_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_kms_key = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::RewriteObjectRequest::destination].
    pub fn set_destination<T: std::convert::Into<std::option::Option<crate::model::Object>>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [source_bucket][crate::model::RewriteObjectRequest::source_bucket].
    pub fn set_source_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_bucket = v.into();
        self
    }

    /// Sets the value of [source_object][crate::model::RewriteObjectRequest::source_object].
    pub fn set_source_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_object = v.into();
        self
    }

    /// Sets the value of [source_generation][crate::model::RewriteObjectRequest::source_generation].
    pub fn set_source_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.source_generation = v.into();
        self
    }

    /// Sets the value of [rewrite_token][crate::model::RewriteObjectRequest::rewrite_token].
    pub fn set_rewrite_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rewrite_token = v.into();
        self
    }

    /// Sets the value of [destination_predefined_acl][crate::model::RewriteObjectRequest::destination_predefined_acl].
    pub fn set_destination_predefined_acl<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_predefined_acl = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::RewriteObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_match = v.into();
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::RewriteObjectRequest::if_generation_not_match].
    pub fn set_if_generation_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_not_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::RewriteObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::RewriteObjectRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_not_match = v.into();
        self
    }

    /// Sets the value of [if_source_generation_match][crate::model::RewriteObjectRequest::if_source_generation_match].
    pub fn set_if_source_generation_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_source_generation_match = v.into();
        self
    }

    /// Sets the value of [if_source_generation_not_match][crate::model::RewriteObjectRequest::if_source_generation_not_match].
    pub fn set_if_source_generation_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_source_generation_not_match = v.into();
        self
    }

    /// Sets the value of [if_source_metageneration_match][crate::model::RewriteObjectRequest::if_source_metageneration_match].
    pub fn set_if_source_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_source_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_source_metageneration_not_match][crate::model::RewriteObjectRequest::if_source_metageneration_not_match].
    pub fn set_if_source_metageneration_not_match<
        T: std::convert::Into<std::option::Option<i64>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.if_source_metageneration_not_match = v.into();
        self
    }

    /// Sets the value of [max_bytes_rewritten_per_call][crate::model::RewriteObjectRequest::max_bytes_rewritten_per_call].
    pub fn set_max_bytes_rewritten_per_call<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_bytes_rewritten_per_call = v.into();
        self
    }

    /// Sets the value of [copy_source_encryption_algorithm][crate::model::RewriteObjectRequest::copy_source_encryption_algorithm].
    pub fn set_copy_source_encryption_algorithm<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.copy_source_encryption_algorithm = v.into();
        self
    }

    /// Sets the value of [copy_source_encryption_key_bytes][crate::model::RewriteObjectRequest::copy_source_encryption_key_bytes].
    pub fn set_copy_source_encryption_key_bytes<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.copy_source_encryption_key_bytes = v.into();
        self
    }

    /// Sets the value of [copy_source_encryption_key_sha256_bytes][crate::model::RewriteObjectRequest::copy_source_encryption_key_sha256_bytes].
    pub fn set_copy_source_encryption_key_sha256_bytes<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.copy_source_encryption_key_sha256_bytes = v.into();
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::RewriteObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<
        T: std::convert::Into<std::option::Option<crate::model::CommonObjectRequestParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.common_object_request_params = v.into();
        self
    }

    /// Sets the value of [object_checksums][crate::model::RewriteObjectRequest::object_checksums].
    pub fn set_object_checksums<
        T: std::convert::Into<std::option::Option<crate::model::ObjectChecksums>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.object_checksums = v.into();
        self
    }
}

impl wkt::message::Message for RewriteObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.RewriteObjectRequest"
    }
}

/// A rewrite response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RewriteResponse {
    /// The total bytes written so far, which can be used to provide a waiting user
    /// with a progress indicator. This property is always present in the response.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_bytes_rewritten: i64,

    /// The total size of the object being copied in bytes. This property is always
    /// present in the response.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub object_size: i64,

    /// `true` if the copy is finished; otherwise, `false` if
    /// the copy is in progress. This property is always present in the response.
    pub done: bool,

    /// A token to use in subsequent requests to continue copying data. This token
    /// is present in the response only when there is more data to copy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rewrite_token: std::string::String,

    /// A resource containing the metadata for the copied-to object. This property
    /// is present in the response only when copying completes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource: std::option::Option<crate::model::Object>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RewriteResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_bytes_rewritten][crate::model::RewriteResponse::total_bytes_rewritten].
    pub fn set_total_bytes_rewritten<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_bytes_rewritten = v.into();
        self
    }

    /// Sets the value of [object_size][crate::model::RewriteResponse::object_size].
    pub fn set_object_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.object_size = v.into();
        self
    }

    /// Sets the value of [done][crate::model::RewriteResponse::done].
    pub fn set_done<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.done = v.into();
        self
    }

    /// Sets the value of [rewrite_token][crate::model::RewriteResponse::rewrite_token].
    pub fn set_rewrite_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rewrite_token = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::RewriteResponse::resource].
    pub fn set_resource<T: std::convert::Into<std::option::Option<crate::model::Object>>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }
}

impl wkt::message::Message for RewriteResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.RewriteResponse"
    }
}

/// Request message for MoveObject.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MoveObjectRequest {
    /// Required. Name of the bucket in which the object resides.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// Required. Name of the source object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_object: std::string::String,

    /// Required. Name of the destination object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_object: std::string::String,

    /// Optional. Makes the operation conditional on whether the source object's
    /// current generation matches the given value. `if_source_generation_match`
    /// and `if_source_generation_not_match` conditions are mutually exclusive:
    /// it's an error for both of them to be set in the request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_source_generation_match: std::option::Option<i64>,

    /// Optional. Makes the operation conditional on whether the source object's
    /// current generation does not match the given value.
    /// `if_source_generation_match` and `if_source_generation_not_match`
    /// conditions are mutually exclusive: it's an error for both of them to be set
    /// in the request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_source_generation_not_match: std::option::Option<i64>,

    /// Optional. Makes the operation conditional on whether the source object's
    /// current metageneration matches the given value.
    /// `if_source_metageneration_match` and `if_source_metageneration_not_match`
    /// conditions are mutually exclusive: it's an error for both of them to be set
    /// in the request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_source_metageneration_match: std::option::Option<i64>,

    /// Optional. Makes the operation conditional on whether the source object's
    /// current metageneration does not match the given value.
    /// `if_source_metageneration_match` and `if_source_metageneration_not_match`
    /// conditions are mutually exclusive: it's an error for both of them to be set
    /// in the request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_source_metageneration_not_match: std::option::Option<i64>,

    /// Optional. Makes the operation conditional on whether the destination
    /// object's current generation matches the given value. Setting to 0 makes the
    /// operation succeed only if there are no live versions of the object.
    /// `if_generation_match` and `if_generation_not_match` conditions are mutually
    /// exclusive: it's an error for both of them to be set in the request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_match: std::option::Option<i64>,

    /// Optional. Makes the operation conditional on whether the destination
    /// object's current generation does not match the given value. If no live
    /// object exists, the precondition fails. Setting to 0 makes the operation
    /// succeed only if there is a live version of the object.
    /// `if_generation_match` and `if_generation_not_match` conditions are mutually
    /// exclusive: it's an error for both of them to be set in the request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_not_match: std::option::Option<i64>,

    /// Optional. Makes the operation conditional on whether the destination
    /// object's current metageneration matches the given value.
    /// `if_metageneration_match` and `if_metageneration_not_match` conditions are
    /// mutually exclusive: it's an error for both of them to be set in the
    /// request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_match: std::option::Option<i64>,

    /// Optional. Makes the operation conditional on whether the destination
    /// object's current metageneration does not match the given value.
    /// `if_metageneration_match` and `if_metageneration_not_match` conditions are
    /// mutually exclusive: it's an error for both of them to be set in the
    /// request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_not_match: std::option::Option<i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::MoveObjectRequest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [source_object][crate::model::MoveObjectRequest::source_object].
    pub fn set_source_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_object = v.into();
        self
    }

    /// Sets the value of [destination_object][crate::model::MoveObjectRequest::destination_object].
    pub fn set_destination_object<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_object = v.into();
        self
    }

    /// Sets the value of [if_source_generation_match][crate::model::MoveObjectRequest::if_source_generation_match].
    pub fn set_if_source_generation_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_source_generation_match = v.into();
        self
    }

    /// Sets the value of [if_source_generation_not_match][crate::model::MoveObjectRequest::if_source_generation_not_match].
    pub fn set_if_source_generation_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_source_generation_not_match = v.into();
        self
    }

    /// Sets the value of [if_source_metageneration_match][crate::model::MoveObjectRequest::if_source_metageneration_match].
    pub fn set_if_source_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_source_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_source_metageneration_not_match][crate::model::MoveObjectRequest::if_source_metageneration_not_match].
    pub fn set_if_source_metageneration_not_match<
        T: std::convert::Into<std::option::Option<i64>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.if_source_metageneration_not_match = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::MoveObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_match = v.into();
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::MoveObjectRequest::if_generation_not_match].
    pub fn set_if_generation_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_not_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::MoveObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::MoveObjectRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_not_match = v.into();
        self
    }
}

impl wkt::message::Message for MoveObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.MoveObjectRequest"
    }
}

/// Request message StartResumableWrite.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartResumableWriteRequest {
    /// Required. Contains the information necessary to start a resumable write.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub write_object_spec: std::option::Option<crate::model::WriteObjectSpec>,

    /// A set of parameters common to Storage API requests related to an object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    /// The checksums of the complete object. This is used to validate the
    /// uploaded object. For each upload, `object_checksums` can be provided when
    /// initiating a resumable upload with`StartResumableWriteRequest` or when
    /// completing a write with `WriteObjectRequest` with
    /// `finish_write` set to `true`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub object_checksums: std::option::Option<crate::model::ObjectChecksums>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartResumableWriteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [write_object_spec][crate::model::StartResumableWriteRequest::write_object_spec].
    pub fn set_write_object_spec<
        T: std::convert::Into<std::option::Option<crate::model::WriteObjectSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_object_spec = v.into();
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::StartResumableWriteRequest::common_object_request_params].
    pub fn set_common_object_request_params<
        T: std::convert::Into<std::option::Option<crate::model::CommonObjectRequestParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.common_object_request_params = v.into();
        self
    }

    /// Sets the value of [object_checksums][crate::model::StartResumableWriteRequest::object_checksums].
    pub fn set_object_checksums<
        T: std::convert::Into<std::option::Option<crate::model::ObjectChecksums>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.object_checksums = v.into();
        self
    }
}

impl wkt::message::Message for StartResumableWriteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.StartResumableWriteRequest"
    }
}

/// Response object for `StartResumableWrite`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartResumableWriteResponse {
    /// A unique identifier for the initiated resumable write operation.
    /// As the ID grants write access, you should keep it confidential during
    /// the upload to prevent unauthorized access and data tampering during your
    /// upload. This ID should be included in subsequent `WriteObject` requests to
    /// upload the object data.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub upload_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartResumableWriteResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [upload_id][crate::model::StartResumableWriteResponse::upload_id].
    pub fn set_upload_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.upload_id = v.into();
        self
    }
}

impl wkt::message::Message for StartResumableWriteResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.StartResumableWriteResponse"
    }
}

/// Request message for UpdateObject.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateObjectRequest {
    /// Required. The object to update.
    /// The object's bucket and name fields are used to identify the object to
    /// update. If present, the object's generation field selects a specific
    /// revision of this object whose metadata should be updated. Otherwise,
    /// assumes the live version of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub object: std::option::Option<crate::model::Object>,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live generation
    /// does not match the given value. If no live object exists, the precondition
    /// fails. Setting to 0 makes the operation succeed only if there is a live
    /// version of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// Apply a predefined set of access controls to this object.
    /// Valid values are "authenticatedRead", "bucketOwnerFullControl",
    /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub predefined_acl: std::string::String,

    /// Required. List of fields to be updated.
    ///
    /// To specify ALL fields, equivalent to the JSON API's "update" function,
    /// specify a single field with the value `*`. Note: not recommended. If a new
    /// field is introduced at a later time, an older client updating with the `*`
    /// may accidentally reset the new field's value.
    ///
    /// Not specifying any fields is an error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// A set of parameters common to Storage API requests concerning an object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object][crate::model::UpdateObjectRequest::object].
    pub fn set_object<T: std::convert::Into<std::option::Option<crate::model::Object>>>(
        mut self,
        v: T,
    ) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::UpdateObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_match = v.into();
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::UpdateObjectRequest::if_generation_not_match].
    pub fn set_if_generation_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_generation_not_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::UpdateObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_match = v.into();
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::UpdateObjectRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.if_metageneration_not_match = v.into();
        self
    }

    /// Sets the value of [predefined_acl][crate::model::UpdateObjectRequest::predefined_acl].
    pub fn set_predefined_acl<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predefined_acl = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateObjectRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::UpdateObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<
        T: std::convert::Into<std::option::Option<crate::model::CommonObjectRequestParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.common_object_request_params = v.into();
        self
    }
}

impl wkt::message::Message for UpdateObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.UpdateObjectRequest"
    }
}

/// Parameters that can be passed to any object request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CommonObjectRequestParams {
    /// Encryption algorithm used with the Customer-Supplied Encryption Keys
    /// feature.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub encryption_algorithm: std::string::String,

    /// Encryption key used with the Customer-Supplied Encryption Keys feature.
    /// In raw bytes format (not base64-encoded).
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub encryption_key_bytes: ::bytes::Bytes,

    /// SHA256 hash of encryption key used with the Customer-Supplied Encryption
    /// Keys feature.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub encryption_key_sha256_bytes: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommonObjectRequestParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_algorithm][crate::model::CommonObjectRequestParams::encryption_algorithm].
    pub fn set_encryption_algorithm<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_algorithm = v.into();
        self
    }

    /// Sets the value of [encryption_key_bytes][crate::model::CommonObjectRequestParams::encryption_key_bytes].
    pub fn set_encryption_key_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.encryption_key_bytes = v.into();
        self
    }

    /// Sets the value of [encryption_key_sha256_bytes][crate::model::CommonObjectRequestParams::encryption_key_sha256_bytes].
    pub fn set_encryption_key_sha256_bytes<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_key_sha256_bytes = v.into();
        self
    }
}

impl wkt::message::Message for CommonObjectRequestParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.CommonObjectRequestParams"
    }
}

/// Shared constants.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceConstants {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceConstants {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ServiceConstants {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ServiceConstants"
    }
}

/// Defines additional types related to [ServiceConstants].
pub mod service_constants {
    #[allow(unused_imports)]
    use super::*;

    /// A collection of constant values meaningful to the Storage API.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Values(i32);

    impl Values {
        /// Unused. Proto3 requires first enum to be 0.
        pub const VALUES_UNSPECIFIED: Values = Values::new(0);

        /// The maximum size chunk that can will be returned in a single
        /// ReadRequest.
        /// 2 MiB.
        pub const MAX_READ_CHUNK_BYTES: Values = Values::new(2097152);

        /// The maximum size chunk that can be sent in a single WriteObjectRequest.
        /// 2 MiB.
        pub const MAX_WRITE_CHUNK_BYTES: Values = Values::new(2097152);

        /// The maximum size of an object in MB - whether written in a single stream
        /// or composed from multiple other objects.
        /// 5 TiB.
        pub const MAX_OBJECT_SIZE_MB: Values = Values::new(5242880);

        /// The maximum length field name that can be sent in a single
        /// custom metadata field.
        /// 1 KiB.
        pub const MAX_CUSTOM_METADATA_FIELD_NAME_BYTES: Values = Values::new(1024);

        /// The maximum length field value that can be sent in a single
        /// custom_metadata field.
        /// 4 KiB.
        pub const MAX_CUSTOM_METADATA_FIELD_VALUE_BYTES: Values = Values::new(4096);

        /// The maximum total bytes that can be populated into all field names and
        /// values of the custom_metadata for one object.
        /// 8 KiB.
        pub const MAX_CUSTOM_METADATA_TOTAL_SIZE_BYTES: Values = Values::new(8192);

        /// The maximum total bytes that can be populated into all bucket metadata
        /// fields.
        /// 20 KiB.
        pub const MAX_BUCKET_METADATA_TOTAL_SIZE_BYTES: Values = Values::new(20480);

        /// The maximum number of NotificationConfigs that can be registered
        /// for a given bucket.
        pub const MAX_NOTIFICATION_CONFIGS_PER_BUCKET: Values = Values::new(100);

        /// The maximum number of LifecycleRules that can be registered for a given
        /// bucket.
        pub const MAX_LIFECYCLE_RULES_PER_BUCKET: Values = Values::new(100);

        /// The maximum number of custom attributes per NotificationConfigs.
        pub const MAX_NOTIFICATION_CUSTOM_ATTRIBUTES: Values = Values::new(5);

        /// The maximum length of a custom attribute key included in
        /// NotificationConfig.
        pub const MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_KEY_LENGTH: Values = Values::new(256);

        /// The maximum length of a custom attribute value included in a
        /// NotificationConfig.
        pub const MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_VALUE_LENGTH: Values = Values::new(1024);

        /// The maximum number of key/value entries per bucket label.
        pub const MAX_LABELS_ENTRIES_COUNT: Values = Values::new(64);

        /// The maximum character length of the key or value in a bucket
        /// label map.
        pub const MAX_LABELS_KEY_VALUE_LENGTH: Values = Values::new(63);

        /// The maximum byte size of the key or value in a bucket label
        /// map.
        pub const MAX_LABELS_KEY_VALUE_BYTES: Values = Values::new(128);

        /// The maximum number of object IDs that can be included in a
        /// DeleteObjectsRequest.
        pub const MAX_OBJECT_IDS_PER_DELETE_OBJECTS_REQUEST: Values = Values::new(1000);

        /// The maximum number of days for which a token returned by the
        /// GetListObjectsSplitPoints RPC is valid.
        pub const SPLIT_TOKEN_MAX_VALID_DAYS: Values = Values::new(14);

        /// Creates a new Values instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("VALUES_UNSPECIFIED"),
                5 => std::borrow::Cow::Borrowed("MAX_NOTIFICATION_CUSTOM_ATTRIBUTES"),
                14 => std::borrow::Cow::Borrowed("SPLIT_TOKEN_MAX_VALID_DAYS"),
                63 => std::borrow::Cow::Borrowed("MAX_LABELS_KEY_VALUE_LENGTH"),
                64 => std::borrow::Cow::Borrowed("MAX_LABELS_ENTRIES_COUNT"),
                100 => std::borrow::Cow::Borrowed("MAX_LIFECYCLE_RULES_PER_BUCKET"),
                128 => std::borrow::Cow::Borrowed("MAX_LABELS_KEY_VALUE_BYTES"),
                256 => std::borrow::Cow::Borrowed("MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_KEY_LENGTH"),
                1000 => std::borrow::Cow::Borrowed("MAX_OBJECT_IDS_PER_DELETE_OBJECTS_REQUEST"),
                1024 => std::borrow::Cow::Borrowed("MAX_CUSTOM_METADATA_FIELD_NAME_BYTES"),
                4096 => std::borrow::Cow::Borrowed("MAX_CUSTOM_METADATA_FIELD_VALUE_BYTES"),
                8192 => std::borrow::Cow::Borrowed("MAX_CUSTOM_METADATA_TOTAL_SIZE_BYTES"),
                20480 => std::borrow::Cow::Borrowed("MAX_BUCKET_METADATA_TOTAL_SIZE_BYTES"),
                2097152 => std::borrow::Cow::Borrowed("MAX_READ_CHUNK_BYTES"),
                5242880 => std::borrow::Cow::Borrowed("MAX_OBJECT_SIZE_MB"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "VALUES_UNSPECIFIED" => std::option::Option::Some(Self::VALUES_UNSPECIFIED),
                "MAX_READ_CHUNK_BYTES" => std::option::Option::Some(Self::MAX_READ_CHUNK_BYTES),
                "MAX_WRITE_CHUNK_BYTES" => std::option::Option::Some(Self::MAX_WRITE_CHUNK_BYTES),
                "MAX_OBJECT_SIZE_MB" => std::option::Option::Some(Self::MAX_OBJECT_SIZE_MB),
                "MAX_CUSTOM_METADATA_FIELD_NAME_BYTES" => {
                    std::option::Option::Some(Self::MAX_CUSTOM_METADATA_FIELD_NAME_BYTES)
                }
                "MAX_CUSTOM_METADATA_FIELD_VALUE_BYTES" => {
                    std::option::Option::Some(Self::MAX_CUSTOM_METADATA_FIELD_VALUE_BYTES)
                }
                "MAX_CUSTOM_METADATA_TOTAL_SIZE_BYTES" => {
                    std::option::Option::Some(Self::MAX_CUSTOM_METADATA_TOTAL_SIZE_BYTES)
                }
                "MAX_BUCKET_METADATA_TOTAL_SIZE_BYTES" => {
                    std::option::Option::Some(Self::MAX_BUCKET_METADATA_TOTAL_SIZE_BYTES)
                }
                "MAX_NOTIFICATION_CONFIGS_PER_BUCKET" => {
                    std::option::Option::Some(Self::MAX_NOTIFICATION_CONFIGS_PER_BUCKET)
                }
                "MAX_LIFECYCLE_RULES_PER_BUCKET" => {
                    std::option::Option::Some(Self::MAX_LIFECYCLE_RULES_PER_BUCKET)
                }
                "MAX_NOTIFICATION_CUSTOM_ATTRIBUTES" => {
                    std::option::Option::Some(Self::MAX_NOTIFICATION_CUSTOM_ATTRIBUTES)
                }
                "MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_KEY_LENGTH" => {
                    std::option::Option::Some(Self::MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_KEY_LENGTH)
                }
                "MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_VALUE_LENGTH" => {
                    std::option::Option::Some(Self::MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_VALUE_LENGTH)
                }
                "MAX_LABELS_ENTRIES_COUNT" => {
                    std::option::Option::Some(Self::MAX_LABELS_ENTRIES_COUNT)
                }
                "MAX_LABELS_KEY_VALUE_LENGTH" => {
                    std::option::Option::Some(Self::MAX_LABELS_KEY_VALUE_LENGTH)
                }
                "MAX_LABELS_KEY_VALUE_BYTES" => {
                    std::option::Option::Some(Self::MAX_LABELS_KEY_VALUE_BYTES)
                }
                "MAX_OBJECT_IDS_PER_DELETE_OBJECTS_REQUEST" => {
                    std::option::Option::Some(Self::MAX_OBJECT_IDS_PER_DELETE_OBJECTS_REQUEST)
                }
                "SPLIT_TOKEN_MAX_VALID_DAYS" => {
                    std::option::Option::Some(Self::SPLIT_TOKEN_MAX_VALID_DAYS)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Values {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Values {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// A bucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Bucket {
    /// Immutable. The name of the bucket.
    /// Format: `projects/{project}/buckets/{bucket}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The user-chosen part of the bucket name. The `{bucket}`
    /// portion of the `name` field. For globally unique buckets, this is equal to
    /// the "bucket name" of other Cloud Storage APIs. Example: "pub".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_id: std::string::String,

    /// The etag of the bucket.
    /// If included in the metadata of an UpdateBucketRequest, the operation will
    /// only be performed if the etag matches that of the bucket.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Immutable. The project which owns this bucket, in the format of
    /// "projects/{projectIdentifier}".
    /// {projectIdentifier} can be the project ID or project number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Output only. The metadata generation of this bucket.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub metageneration: i64,

    /// Immutable. The location of the bucket. Object data for objects in the
    /// bucket resides in physical storage within this region.  Defaults to `US`.
    /// See the
    /// [<https://developers.google.com/storage/docs/concepts-techniques#specifyinglocations>"][developer's
    /// guide] for the authoritative list. Attempting to update this field after
    /// the bucket is created will result in an error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Output only. The location type of the bucket (region, dual-region,
    /// multi-region, etc).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_type: std::string::String,

    /// The bucket's default storage class, used whenever no storageClass is
    /// specified for a newly-created object. This defines how objects in the
    /// bucket are stored and determines the SLA and the cost of storage.
    /// If this value is not specified when the bucket is created, it will default
    /// to `STANDARD`. For more information, see
    /// <https://developers.google.com/storage/docs/storage-classes>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub storage_class: std::string::String,

    /// The recovery point objective for cross-region replication of the bucket.
    /// Applicable only for dual- and multi-region buckets. "DEFAULT" uses default
    /// replication. "ASYNC_TURBO" enables turbo replication, valid for dual-region
    /// buckets only. If rpo is not specified when the bucket is created, it
    /// defaults to "DEFAULT". For more information, see
    /// <https://cloud.google.com/storage/docs/availability-durability#turbo-replication>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rpo: std::string::String,

    /// Access controls on the bucket.
    /// If iam_config.uniform_bucket_level_access is enabled on this bucket,
    /// requests to set, read, or modify acl is an error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub acl: std::vec::Vec<crate::model::BucketAccessControl>,

    /// Default access controls to apply to new objects when no ACL is provided.
    /// If iam_config.uniform_bucket_level_access is enabled on this bucket,
    /// requests to set, read, or modify acl is an error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub default_object_acl: std::vec::Vec<crate::model::ObjectAccessControl>,

    /// The bucket's lifecycle config. See
    /// [<https://developers.google.com/storage/docs/lifecycle>]Lifecycle Management]
    /// for more information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lifecycle: std::option::Option<crate::model::bucket::Lifecycle>,

    /// Output only. The creation time of the bucket.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The bucket's [<https://www.w3.org/TR/cors/>][Cross-Origin Resource Sharing]
    /// (CORS) config.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cors: std::vec::Vec<crate::model::bucket::Cors>,

    /// Output only. The modification time of the bucket.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The default value for event-based hold on newly created objects in this
    /// bucket.  Event-based hold is a way to retain objects indefinitely until an
    /// event occurs, signified by the
    /// hold's release. After being released, such objects will be subject to
    /// bucket-level retention (if any).  One sample use case of this flag is for
    /// banks to hold loan documents for at least 3 years after loan is paid in
    /// full. Here, bucket-level retention is 3 years and the event is loan being
    /// paid in full. In this example, these objects will be held intact for any
    /// number of years until the event has occurred (event-based hold on the
    /// object is released) and then 3 more years after that. That means retention
    /// duration of the objects begins from the moment event-based hold
    /// transitioned from true to false.  Objects under event-based hold cannot be
    /// deleted, overwritten or archived until the hold is removed.
    pub default_event_based_hold: bool,

    /// User-provided labels, in key/value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The bucket's website config, controlling how the service behaves
    /// when accessing bucket contents as a web site. See the
    /// [<https://cloud.google.com/storage/docs/static-website>][Static Website
    /// Examples] for more information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub website: std::option::Option<crate::model::bucket::Website>,

    /// The bucket's versioning config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub versioning: std::option::Option<crate::model::bucket::Versioning>,

    /// The bucket's logging config, which defines the destination bucket
    /// and name prefix (if any) for the current bucket's logs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging: std::option::Option<crate::model::bucket::Logging>,

    /// Output only. The owner of the bucket. This is always the project team's
    /// owner group.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub owner: std::option::Option<crate::model::Owner>,

    /// Encryption config for a bucket.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption: std::option::Option<crate::model::bucket::Encryption>,

    /// The bucket's billing config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub billing: std::option::Option<crate::model::bucket::Billing>,

    /// The bucket's retention policy. The retention policy enforces a minimum
    /// retention time for all objects contained in the bucket, based on their
    /// creation time. Any attempt to overwrite or delete objects younger than the
    /// retention period will result in a PERMISSION_DENIED error.  An unlocked
    /// retention policy can be modified or removed from the bucket via a
    /// storage.buckets.update operation. A locked retention policy cannot be
    /// removed or shortened in duration for the lifetime of the bucket.
    /// Attempting to remove or decrease period of a locked retention policy will
    /// result in a PERMISSION_DENIED error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retention_policy: std::option::Option<crate::model::bucket::RetentionPolicy>,

    /// The bucket's IAM config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub iam_config: std::option::Option<crate::model::bucket::IamConfig>,

    /// Reserved for future use.
    pub satisfies_pzs: bool,

    /// Configuration that, if present, specifies the data placement for a
    /// [<https://cloud.google.com/storage/docs/locations#location-dr>][configurable
    /// dual-region].
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_placement_config: std::option::Option<crate::model::bucket::CustomPlacementConfig>,

    /// The bucket's Autoclass configuration. If there is no configuration, the
    /// Autoclass feature will be disabled and have no effect on the bucket.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoclass: std::option::Option<crate::model::bucket::Autoclass>,

    /// Optional. The bucket's hierarchical namespace configuration. If there is no
    /// configuration, the hierarchical namespace feature will be disabled and have
    /// no effect on the bucket.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hierarchical_namespace: std::option::Option<crate::model::bucket::HierarchicalNamespace>,

    /// Optional. The bucket's soft delete policy. The soft delete policy prevents
    /// soft-deleted objects from being permanently deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub soft_delete_policy: std::option::Option<crate::model::bucket::SoftDeletePolicy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Bucket {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Bucket::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [bucket_id][crate::model::Bucket::bucket_id].
    pub fn set_bucket_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Bucket::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [project][crate::model::Bucket::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [metageneration][crate::model::Bucket::metageneration].
    pub fn set_metageneration<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.metageneration = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Bucket::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [location_type][crate::model::Bucket::location_type].
    pub fn set_location_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_type = v.into();
        self
    }

    /// Sets the value of [storage_class][crate::model::Bucket::storage_class].
    pub fn set_storage_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_class = v.into();
        self
    }

    /// Sets the value of [rpo][crate::model::Bucket::rpo].
    pub fn set_rpo<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rpo = v.into();
        self
    }

    /// Sets the value of [lifecycle][crate::model::Bucket::lifecycle].
    pub fn set_lifecycle<
        T: std::convert::Into<std::option::Option<crate::model::bucket::Lifecycle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Bucket::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Bucket::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [default_event_based_hold][crate::model::Bucket::default_event_based_hold].
    pub fn set_default_event_based_hold<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.default_event_based_hold = v.into();
        self
    }

    /// Sets the value of [website][crate::model::Bucket::website].
    pub fn set_website<
        T: std::convert::Into<std::option::Option<crate::model::bucket::Website>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.website = v.into();
        self
    }

    /// Sets the value of [versioning][crate::model::Bucket::versioning].
    pub fn set_versioning<
        T: std::convert::Into<std::option::Option<crate::model::bucket::Versioning>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.versioning = v.into();
        self
    }

    /// Sets the value of [logging][crate::model::Bucket::logging].
    pub fn set_logging<
        T: std::convert::Into<std::option::Option<crate::model::bucket::Logging>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging = v.into();
        self
    }

    /// Sets the value of [owner][crate::model::Bucket::owner].
    pub fn set_owner<T: std::convert::Into<std::option::Option<crate::model::Owner>>>(
        mut self,
        v: T,
    ) -> Self {
        self.owner = v.into();
        self
    }

    /// Sets the value of [encryption][crate::model::Bucket::encryption].
    pub fn set_encryption<
        T: std::convert::Into<std::option::Option<crate::model::bucket::Encryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption = v.into();
        self
    }

    /// Sets the value of [billing][crate::model::Bucket::billing].
    pub fn set_billing<
        T: std::convert::Into<std::option::Option<crate::model::bucket::Billing>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.billing = v.into();
        self
    }

    /// Sets the value of [retention_policy][crate::model::Bucket::retention_policy].
    pub fn set_retention_policy<
        T: std::convert::Into<std::option::Option<crate::model::bucket::RetentionPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retention_policy = v.into();
        self
    }

    /// Sets the value of [iam_config][crate::model::Bucket::iam_config].
    pub fn set_iam_config<
        T: std::convert::Into<std::option::Option<crate::model::bucket::IamConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.iam_config = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Bucket::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [custom_placement_config][crate::model::Bucket::custom_placement_config].
    pub fn set_custom_placement_config<
        T: std::convert::Into<std::option::Option<crate::model::bucket::CustomPlacementConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.custom_placement_config = v.into();
        self
    }

    /// Sets the value of [autoclass][crate::model::Bucket::autoclass].
    pub fn set_autoclass<
        T: std::convert::Into<std::option::Option<crate::model::bucket::Autoclass>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoclass = v.into();
        self
    }

    /// Sets the value of [hierarchical_namespace][crate::model::Bucket::hierarchical_namespace].
    pub fn set_hierarchical_namespace<
        T: std::convert::Into<std::option::Option<crate::model::bucket::HierarchicalNamespace>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hierarchical_namespace = v.into();
        self
    }

    /// Sets the value of [soft_delete_policy][crate::model::Bucket::soft_delete_policy].
    pub fn set_soft_delete_policy<
        T: std::convert::Into<std::option::Option<crate::model::bucket::SoftDeletePolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.soft_delete_policy = v.into();
        self
    }

    /// Sets the value of [acl][crate::model::Bucket::acl].
    pub fn set_acl<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BucketAccessControl>,
    {
        use std::iter::Iterator;
        self.acl = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_object_acl][crate::model::Bucket::default_object_acl].
    pub fn set_default_object_acl<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ObjectAccessControl>,
    {
        use std::iter::Iterator;
        self.default_object_acl = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cors][crate::model::Bucket::cors].
    pub fn set_cors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::bucket::Cors>,
    {
        use std::iter::Iterator;
        self.cors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Bucket::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Bucket {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.Bucket"
    }
}

/// Defines additional types related to [Bucket].
pub mod bucket {
    #[allow(unused_imports)]
    use super::*;

    /// Billing properties of a bucket.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Billing {
        /// When set to true, Requester Pays is enabled for this bucket.
        pub requester_pays: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Billing {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [requester_pays][crate::model::bucket::Billing::requester_pays].
        pub fn set_requester_pays<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.requester_pays = v.into();
            self
        }
    }

    impl wkt::message::Message for Billing {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Billing"
        }
    }

    /// Cross-Origin Response sharing (CORS) properties for a bucket.
    /// For more on Cloud Storage and CORS, see
    /// <https://cloud.google.com/storage/docs/cross-origin>.
    /// For more on CORS in general, see <https://tools.ietf.org/html/rfc6454>.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Cors {
        /// The list of Origins eligible to receive CORS response headers. See
        /// [<https://tools.ietf.org/html/rfc6454>][RFC 6454] for more on origins.
        /// Note: "*" is permitted in the list of origins, and means "any Origin".
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub origin: std::vec::Vec<std::string::String>,

        /// The list of HTTP methods on which to include CORS response headers,
        /// (`GET`, `OPTIONS`, `POST`, etc) Note: "*" is permitted in the list of
        /// methods, and means "any method".
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub method: std::vec::Vec<std::string::String>,

        /// The list of HTTP headers other than the
        /// [<https://www.w3.org/TR/cors/#simple-response-header>][simple response
        /// headers] to give permission for the user-agent to share across domains.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub response_header: std::vec::Vec<std::string::String>,

        /// The value, in seconds, to return in the
        /// [<https://www.w3.org/TR/cors/#access-control-max-age-response-header>][Access-Control-Max-Age
        /// header] used in preflight responses.
        pub max_age_seconds: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Cors {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_age_seconds][crate::model::bucket::Cors::max_age_seconds].
        pub fn set_max_age_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_age_seconds = v.into();
            self
        }

        /// Sets the value of [origin][crate::model::bucket::Cors::origin].
        pub fn set_origin<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.origin = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [method][crate::model::bucket::Cors::method].
        pub fn set_method<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.method = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [response_header][crate::model::bucket::Cors::response_header].
        pub fn set_response_header<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.response_header = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Cors {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Cors"
        }
    }

    /// Encryption properties of a bucket.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Encryption {
        /// The name of the Cloud KMS key that will be used to encrypt objects
        /// inserted into this bucket, if no encryption method is specified.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub default_kms_key: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Encryption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [default_kms_key][crate::model::bucket::Encryption::default_kms_key].
        pub fn set_default_kms_key<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.default_kms_key = v.into();
            self
        }
    }

    impl wkt::message::Message for Encryption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Encryption"
        }
    }

    /// Bucket restriction options.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IamConfig {
        /// Bucket restriction options currently enforced on the bucket.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub uniform_bucket_level_access:
            std::option::Option<crate::model::bucket::iam_config::UniformBucketLevelAccess>,

        /// Whether IAM will enforce public access prevention. Valid values are
        /// "enforced" or "inherited".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub public_access_prevention: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IamConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uniform_bucket_level_access][crate::model::bucket::IamConfig::uniform_bucket_level_access].
        pub fn set_uniform_bucket_level_access<
            T: std::convert::Into<
                    std::option::Option<crate::model::bucket::iam_config::UniformBucketLevelAccess>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.uniform_bucket_level_access = v.into();
            self
        }

        /// Sets the value of [public_access_prevention][crate::model::bucket::IamConfig::public_access_prevention].
        pub fn set_public_access_prevention<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.public_access_prevention = v.into();
            self
        }
    }

    impl wkt::message::Message for IamConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.IamConfig"
        }
    }

    /// Defines additional types related to [IamConfig].
    pub mod iam_config {
        #[allow(unused_imports)]
        use super::*;

        /// Settings for Uniform Bucket level access.
        /// See <https://cloud.google.com/storage/docs/uniform-bucket-level-access>.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct UniformBucketLevelAccess {
            /// If set, access checks only use bucket-level IAM policies or above.
            pub enabled: bool,

            /// The deadline time for changing
            /// `iam_config.uniform_bucket_level_access.enabled` from `true` to
            /// `false`. Mutable until the specified deadline is reached, but not
            /// afterward.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub lock_time: std::option::Option<wkt::Timestamp>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl UniformBucketLevelAccess {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [enabled][crate::model::bucket::iam_config::UniformBucketLevelAccess::enabled].
            pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.enabled = v.into();
                self
            }

            /// Sets the value of [lock_time][crate::model::bucket::iam_config::UniformBucketLevelAccess::lock_time].
            pub fn set_lock_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
                mut self,
                v: T,
            ) -> Self {
                self.lock_time = v.into();
                self
            }
        }

        impl wkt::message::Message for UniformBucketLevelAccess {
            fn typename() -> &'static str {
                "type.googleapis.com/google.storage.v2.Bucket.IamConfig.UniformBucketLevelAccess"
            }
        }
    }

    /// Lifecycle properties of a bucket.
    /// For more information, see <https://cloud.google.com/storage/docs/lifecycle>.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Lifecycle {
        /// A lifecycle management rule, which is made of an action to take and the
        /// condition(s) under which the action will be taken.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub rule: std::vec::Vec<crate::model::bucket::lifecycle::Rule>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Lifecycle {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rule][crate::model::bucket::Lifecycle::rule].
        pub fn set_rule<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::bucket::lifecycle::Rule>,
        {
            use std::iter::Iterator;
            self.rule = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Lifecycle {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Lifecycle"
        }
    }

    /// Defines additional types related to [Lifecycle].
    pub mod lifecycle {
        #[allow(unused_imports)]
        use super::*;

        /// A lifecycle Rule, combining an action to take on an object and a
        /// condition which will trigger that action.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Rule {
            /// The action to take.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub action: std::option::Option<crate::model::bucket::lifecycle::rule::Action>,

            /// The condition(s) under which the action will be taken.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub condition: std::option::Option<crate::model::bucket::lifecycle::rule::Condition>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Rule {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [action][crate::model::bucket::lifecycle::Rule::action].
            pub fn set_action<
                T: std::convert::Into<
                        std::option::Option<crate::model::bucket::lifecycle::rule::Action>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.action = v.into();
                self
            }

            /// Sets the value of [condition][crate::model::bucket::lifecycle::Rule::condition].
            pub fn set_condition<
                T: std::convert::Into<
                        std::option::Option<crate::model::bucket::lifecycle::rule::Condition>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.condition = v.into();
                self
            }
        }

        impl wkt::message::Message for Rule {
            fn typename() -> &'static str {
                "type.googleapis.com/google.storage.v2.Bucket.Lifecycle.Rule"
            }
        }

        /// Defines additional types related to [Rule].
        pub mod rule {
            #[allow(unused_imports)]
            use super::*;

            /// An action to take on an object.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Action {
                /// Type of the action. Currently, only `Delete`, `SetStorageClass`, and
                /// `AbortIncompleteMultipartUpload` are supported.
                #[serde(rename = "type")]
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub r#type: std::string::String,

                /// Target storage class. Required iff the type of the action is
                /// SetStorageClass.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub storage_class: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Action {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [r#type][crate::model::bucket::lifecycle::rule::Action::type].
                pub fn set_type<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.r#type = v.into();
                    self
                }

                /// Sets the value of [storage_class][crate::model::bucket::lifecycle::rule::Action::storage_class].
                pub fn set_storage_class<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.storage_class = v.into();
                    self
                }
            }

            impl wkt::message::Message for Action {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.storage.v2.Bucket.Lifecycle.Rule.Action"
                }
            }

            /// A condition of an object which triggers some action.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Condition {
                /// Age of an object (in days). This condition is satisfied when an
                /// object reaches the specified age.
                /// A value of 0 indicates that all objects immediately match this
                /// condition.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub age_days: std::option::Option<i32>,

                /// This condition is satisfied when an object is created before midnight
                /// of the specified date in UTC.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub created_before: std::option::Option<gtype::model::Date>,

                /// Relevant only for versioned objects. If the value is
                /// `true`, this condition matches live objects; if the value
                /// is `false`, it matches archived objects.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub is_live: std::option::Option<bool>,

                /// Relevant only for versioned objects. If the value is N, this
                /// condition is satisfied when there are at least N versions (including
                /// the live version) newer than this version of the object.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub num_newer_versions: std::option::Option<i32>,

                /// Objects having any of the storage classes specified by this condition
                /// will be matched. Values include `MULTI_REGIONAL`, `REGIONAL`,
                /// `NEARLINE`, `COLDLINE`, `STANDARD`, and
                /// `DURABLE_REDUCED_AVAILABILITY`.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub matches_storage_class: std::vec::Vec<std::string::String>,

                /// Number of days that have elapsed since the custom timestamp set on an
                /// object.
                /// The value of the field must be a nonnegative integer.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub days_since_custom_time: std::option::Option<i32>,

                /// An object matches this condition if the custom timestamp set on the
                /// object is before the specified date in UTC.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub custom_time_before: std::option::Option<gtype::model::Date>,

                /// This condition is relevant only for versioned objects. An object
                /// version satisfies this condition only if these many days have been
                /// passed since it became noncurrent. The value of the field must be a
                /// nonnegative integer. If it's zero, the object version will become
                /// eligible for Lifecycle action as soon as it becomes noncurrent.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub days_since_noncurrent_time: std::option::Option<i32>,

                /// This condition is relevant only for versioned objects. An object
                /// version satisfies this condition only if it became noncurrent before
                /// the specified date in UTC.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub noncurrent_time_before: std::option::Option<gtype::model::Date>,

                /// List of object name prefixes. If any prefix exactly matches the
                /// beginning of the object name, the condition evaluates to true.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub matches_prefix: std::vec::Vec<std::string::String>,

                /// List of object name suffixes. If any suffix exactly matches the
                /// end of the object name, the condition evaluates to true.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub matches_suffix: std::vec::Vec<std::string::String>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Condition {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [age_days][crate::model::bucket::lifecycle::rule::Condition::age_days].
                pub fn set_age_days<T: std::convert::Into<std::option::Option<i32>>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.age_days = v.into();
                    self
                }

                /// Sets the value of [created_before][crate::model::bucket::lifecycle::rule::Condition::created_before].
                pub fn set_created_before<
                    T: std::convert::Into<std::option::Option<gtype::model::Date>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.created_before = v.into();
                    self
                }

                /// Sets the value of [is_live][crate::model::bucket::lifecycle::rule::Condition::is_live].
                pub fn set_is_live<T: std::convert::Into<std::option::Option<bool>>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.is_live = v.into();
                    self
                }

                /// Sets the value of [num_newer_versions][crate::model::bucket::lifecycle::rule::Condition::num_newer_versions].
                pub fn set_num_newer_versions<T: std::convert::Into<std::option::Option<i32>>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.num_newer_versions = v.into();
                    self
                }

                /// Sets the value of [days_since_custom_time][crate::model::bucket::lifecycle::rule::Condition::days_since_custom_time].
                pub fn set_days_since_custom_time<
                    T: std::convert::Into<std::option::Option<i32>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.days_since_custom_time = v.into();
                    self
                }

                /// Sets the value of [custom_time_before][crate::model::bucket::lifecycle::rule::Condition::custom_time_before].
                pub fn set_custom_time_before<
                    T: std::convert::Into<std::option::Option<gtype::model::Date>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.custom_time_before = v.into();
                    self
                }

                /// Sets the value of [days_since_noncurrent_time][crate::model::bucket::lifecycle::rule::Condition::days_since_noncurrent_time].
                pub fn set_days_since_noncurrent_time<
                    T: std::convert::Into<std::option::Option<i32>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.days_since_noncurrent_time = v.into();
                    self
                }

                /// Sets the value of [noncurrent_time_before][crate::model::bucket::lifecycle::rule::Condition::noncurrent_time_before].
                pub fn set_noncurrent_time_before<
                    T: std::convert::Into<std::option::Option<gtype::model::Date>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.noncurrent_time_before = v.into();
                    self
                }

                /// Sets the value of [matches_storage_class][crate::model::bucket::lifecycle::rule::Condition::matches_storage_class].
                pub fn set_matches_storage_class<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.matches_storage_class = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [matches_prefix][crate::model::bucket::lifecycle::rule::Condition::matches_prefix].
                pub fn set_matches_prefix<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.matches_prefix = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [matches_suffix][crate::model::bucket::lifecycle::rule::Condition::matches_suffix].
                pub fn set_matches_suffix<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.matches_suffix = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Condition {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.storage.v2.Bucket.Lifecycle.Rule.Condition"
                }
            }
        }
    }

    /// Logging-related properties of a bucket.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Logging {
        /// The destination bucket where the current bucket's logs should be placed,
        /// using path format (like `projects/123456/buckets/foo`).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub log_bucket: std::string::String,

        /// A prefix for log object names.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub log_object_prefix: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Logging {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [log_bucket][crate::model::bucket::Logging::log_bucket].
        pub fn set_log_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.log_bucket = v.into();
            self
        }

        /// Sets the value of [log_object_prefix][crate::model::bucket::Logging::log_object_prefix].
        pub fn set_log_object_prefix<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.log_object_prefix = v.into();
            self
        }
    }

    impl wkt::message::Message for Logging {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Logging"
        }
    }

    /// Retention policy properties of a bucket.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RetentionPolicy {
        /// Server-determined value that indicates the time from which policy was
        /// enforced and effective.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub effective_time: std::option::Option<wkt::Timestamp>,

        /// Once locked, an object retention policy cannot be modified.
        pub is_locked: bool,

        /// The duration that objects need to be retained. Retention duration must be
        /// greater than zero and less than 100 years. Note that enforcement of
        /// retention periods less than a day is not guaranteed. Such periods should
        /// only be used for testing purposes. Any `nanos` value specified will be
        /// rounded down to the nearest second.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub retention_duration: std::option::Option<wkt::Duration>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RetentionPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [effective_time][crate::model::bucket::RetentionPolicy::effective_time].
        pub fn set_effective_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.effective_time = v.into();
            self
        }

        /// Sets the value of [is_locked][crate::model::bucket::RetentionPolicy::is_locked].
        pub fn set_is_locked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.is_locked = v.into();
            self
        }

        /// Sets the value of [retention_duration][crate::model::bucket::RetentionPolicy::retention_duration].
        pub fn set_retention_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.retention_duration = v.into();
            self
        }
    }

    impl wkt::message::Message for RetentionPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.RetentionPolicy"
        }
    }

    /// Soft delete policy properties of a bucket.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SoftDeletePolicy {
        /// The period of time that soft-deleted objects in the bucket must be
        /// retained and cannot be permanently deleted. The duration must be greater
        /// than or equal to 7 days and less than 1 year.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub retention_duration: std::option::Option<wkt::Duration>,

        /// Time from which the policy was effective. This is service-provided.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub effective_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SoftDeletePolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [retention_duration][crate::model::bucket::SoftDeletePolicy::retention_duration].
        pub fn set_retention_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.retention_duration = v.into();
            self
        }

        /// Sets the value of [effective_time][crate::model::bucket::SoftDeletePolicy::effective_time].
        pub fn set_effective_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.effective_time = v.into();
            self
        }
    }

    impl wkt::message::Message for SoftDeletePolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.SoftDeletePolicy"
        }
    }

    /// Properties of a bucket related to versioning.
    /// For more on Cloud Storage versioning, see
    /// <https://cloud.google.com/storage/docs/object-versioning>.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Versioning {
        /// While set to true, versioning is fully enabled for this bucket.
        pub enabled: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Versioning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::bucket::Versioning::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for Versioning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Versioning"
        }
    }

    /// Properties of a bucket related to accessing the contents as a static
    /// website. For more on hosting a static website via Cloud Storage, see
    /// <https://cloud.google.com/storage/docs/hosting-static-website>.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Website {
        /// If the requested object path is missing, the service will ensure the path
        /// has a trailing '/', append this suffix, and attempt to retrieve the
        /// resulting object. This allows the creation of `index.html`
        /// objects to represent directory pages.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub main_page_suffix: std::string::String,

        /// If the requested object path is missing, and any
        /// `mainPageSuffix` object is missing, if applicable, the service
        /// will return the named object from this bucket as the content for a
        /// [<https://tools.ietf.org/html/rfc7231#section-6.5.4>][404 Not Found]
        /// result.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub not_found_page: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Website {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [main_page_suffix][crate::model::bucket::Website::main_page_suffix].
        pub fn set_main_page_suffix<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.main_page_suffix = v.into();
            self
        }

        /// Sets the value of [not_found_page][crate::model::bucket::Website::not_found_page].
        pub fn set_not_found_page<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.not_found_page = v.into();
            self
        }
    }

    impl wkt::message::Message for Website {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Website"
        }
    }

    /// Configuration for Custom Dual Regions.  It should specify precisely two
    /// eligible regions within the same Multiregion. More information on regions
    /// may be found [<https://cloud.google.com/storage/docs/locations>][here].
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CustomPlacementConfig {
        /// List of locations to use for data placement.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub data_locations: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CustomPlacementConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [data_locations][crate::model::bucket::CustomPlacementConfig::data_locations].
        pub fn set_data_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.data_locations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CustomPlacementConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.CustomPlacementConfig"
        }
    }

    /// Configuration for a bucket's Autoclass feature.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Autoclass {
        /// Enables Autoclass.
        pub enabled: bool,

        /// Output only. Latest instant at which the `enabled` field was set to true
        /// after being disabled/unconfigured or set to false after being enabled. If
        /// Autoclass is enabled when the bucket is created, the toggle_time is set
        /// to the bucket creation time.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub toggle_time: std::option::Option<wkt::Timestamp>,

        /// An object in an Autoclass bucket will eventually cool down to the
        /// terminal storage class if there is no access to the object.
        /// The only valid values are NEARLINE and ARCHIVE.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub terminal_storage_class: std::option::Option<std::string::String>,

        /// Output only. Latest instant at which the autoclass terminal storage class
        /// was updated.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub terminal_storage_class_update_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Autoclass {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::bucket::Autoclass::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [toggle_time][crate::model::bucket::Autoclass::toggle_time].
        pub fn set_toggle_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.toggle_time = v.into();
            self
        }

        /// Sets the value of [terminal_storage_class][crate::model::bucket::Autoclass::terminal_storage_class].
        pub fn set_terminal_storage_class<
            T: std::convert::Into<std::option::Option<std::string::String>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.terminal_storage_class = v.into();
            self
        }

        /// Sets the value of [terminal_storage_class_update_time][crate::model::bucket::Autoclass::terminal_storage_class_update_time].
        pub fn set_terminal_storage_class_update_time<
            T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.terminal_storage_class_update_time = v.into();
            self
        }
    }

    impl wkt::message::Message for Autoclass {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Autoclass"
        }
    }

    /// Configuration for a bucket's hierarchical namespace feature.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct HierarchicalNamespace {
        /// Optional. Enables the hierarchical namespace feature.
        pub enabled: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl HierarchicalNamespace {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::bucket::HierarchicalNamespace::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for HierarchicalNamespace {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.HierarchicalNamespace"
        }
    }
}

/// An access-control entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BucketAccessControl {
    /// The access permission for the entity.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub role: std::string::String,

    /// The ID of the access-control entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The entity holding the permission, in one of the following forms:
    ///
    /// * `user-{userid}`
    /// * `user-{email}`
    /// * `group-{groupid}`
    /// * `group-{email}`
    /// * `domain-{domain}`
    /// * `project-{team}-{projectnumber}`
    /// * `project-{team}-{projectid}`
    /// * `allUsers`
    /// * `allAuthenticatedUsers`
    ///   Examples:
    /// * The user `liz@example.com` would be `user-liz@example.com`.
    /// * The group `example@googlegroups.com` would be
    ///   `group-example@googlegroups.com`
    /// * All members of the Google Apps for Business domain `example.com` would be
    ///   `domain-example.com`
    ///   For project entities, `project-{team}-{projectnumber}` format will be
    ///   returned on response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity: std::string::String,

    /// Output only. The alternative entity format, if exists. For project
    /// entities, `project-{team}-{projectid}` format will be returned on response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_alt: std::string::String,

    /// The ID for the entity, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_id: std::string::String,

    /// The etag of the BucketAccessControl.
    /// If included in the metadata of an update or delete request message, the
    /// operation operation will only be performed if the etag matches that of the
    /// bucket's BucketAccessControl.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The email address associated with the entity, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub email: std::string::String,

    /// The domain associated with the entity, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub domain: std::string::String,

    /// The project team associated with the entity, if any.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub project_team: std::option::Option<crate::model::ProjectTeam>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BucketAccessControl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role][crate::model::BucketAccessControl::role].
    pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [id][crate::model::BucketAccessControl::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [entity][crate::model::BucketAccessControl::entity].
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity = v.into();
        self
    }

    /// Sets the value of [entity_alt][crate::model::BucketAccessControl::entity_alt].
    pub fn set_entity_alt<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_alt = v.into();
        self
    }

    /// Sets the value of [entity_id][crate::model::BucketAccessControl::entity_id].
    pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::BucketAccessControl::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [email][crate::model::BucketAccessControl::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::BucketAccessControl::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [project_team][crate::model::BucketAccessControl::project_team].
    pub fn set_project_team<
        T: std::convert::Into<std::option::Option<crate::model::ProjectTeam>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.project_team = v.into();
        self
    }
}

impl wkt::message::Message for BucketAccessControl {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.BucketAccessControl"
    }
}

/// Message used to convey content being read or written, along with an optional
/// checksum.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ChecksummedData {
    /// Optional. The data.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub content: ::bytes::Bytes,

    /// If set, the CRC32C digest of the content field.
    #[serde(rename = "crc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crc32c: std::option::Option<u32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChecksummedData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::ChecksummedData::content].
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [crc32c][crate::model::ChecksummedData::crc32c].
    pub fn set_crc32c<T: std::convert::Into<std::option::Option<u32>>>(mut self, v: T) -> Self {
        self.crc32c = v.into();
        self
    }
}

impl wkt::message::Message for ChecksummedData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ChecksummedData"
    }
}

/// Message used for storing full (not subrange) object checksums.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ObjectChecksums {
    /// CRC32C digest of the object data. Computed by the Cloud Storage service for
    /// all written objects.
    /// If set in a WriteObjectRequest, service will validate that the stored
    /// object matches this checksum.
    #[serde(rename = "crc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crc32c: std::option::Option<u32>,

    /// 128 bit MD5 hash of the object data.
    /// For more information about using the MD5 hash, see
    /// [<https://cloud.google.com/storage/docs/hashes-etags#json-api>][Hashes and
    /// ETags: Best Practices].
    /// Not all objects will provide an MD5 hash. For example, composite objects
    /// provide only crc32c hashes. This value is equivalent to running `cat
    /// object.txt | openssl md5 -binary`
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub md5_hash: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectChecksums {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crc32c][crate::model::ObjectChecksums::crc32c].
    pub fn set_crc32c<T: std::convert::Into<std::option::Option<u32>>>(mut self, v: T) -> Self {
        self.crc32c = v.into();
        self
    }

    /// Sets the value of [md5_hash][crate::model::ObjectChecksums::md5_hash].
    pub fn set_md5_hash<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.md5_hash = v.into();
        self
    }
}

impl wkt::message::Message for ObjectChecksums {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ObjectChecksums"
    }
}

/// Describes the Customer-Supplied Encryption Key mechanism used to store an
/// Object's data at rest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomerEncryption {
    /// The encryption algorithm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub encryption_algorithm: std::string::String,

    /// SHA256 hash value of the encryption key.
    /// In raw bytes format (not base64-encoded).
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub key_sha256_bytes: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerEncryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_algorithm][crate::model::CustomerEncryption::encryption_algorithm].
    pub fn set_encryption_algorithm<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_algorithm = v.into();
        self
    }

    /// Sets the value of [key_sha256_bytes][crate::model::CustomerEncryption::key_sha256_bytes].
    pub fn set_key_sha256_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.key_sha256_bytes = v.into();
        self
    }
}

impl wkt::message::Message for CustomerEncryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.CustomerEncryption"
    }
}

/// An object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Object {
    /// Immutable. The name of this object. Nearly any sequence of unicode
    /// characters is valid. See
    /// [Guidelines](https://cloud.google.com/storage/docs/objects#naming).
    /// Example: `test.txt`
    /// The `name` field by itself does not uniquely identify a Cloud Storage
    /// object. A Cloud Storage object is uniquely identified by the tuple of
    /// (bucket, object, generation).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Immutable. The name of the bucket containing this object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// The etag of the object.
    /// If included in the metadata of an update or delete request message, the
    /// operation will only be performed if the etag matches that of the live
    /// object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Immutable. The content generation of this object. Used for object
    /// versioning.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    /// Output only. Restore token used to differentiate deleted objects with the
    /// same name and generation. This field is output only, and only set for
    /// deleted objects in HNS buckets.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub restore_token: std::option::Option<std::string::String>,

    /// Output only. The version of the metadata for this generation of this
    /// object. Used for preconditions and for detecting changes in metadata. A
    /// metageneration number is only meaningful in the context of a particular
    /// generation of a particular object.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub metageneration: i64,

    /// Storage class of the object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub storage_class: std::string::String,

    /// Output only. Content-Length of the object data in bytes, matching
    /// [<https://tools.ietf.org/html/rfc7230#section-3.3.2>][RFC 7230 §3.3.2].
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub size: i64,

    /// Content-Encoding of the object data, matching
    /// [<https://tools.ietf.org/html/rfc7231#section-3.1.2.2>][RFC 7231 §3.1.2.2]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content_encoding: std::string::String,

    /// Content-Disposition of the object data, matching
    /// [<https://tools.ietf.org/html/rfc6266>][RFC 6266].
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content_disposition: std::string::String,

    /// Cache-Control directive for the object data, matching
    /// [<https://tools.ietf.org/html/rfc7234#section-5.2>"][RFC 7234 §5.2].
    /// If omitted, and the object is accessible to all anonymous users, the
    /// default will be `public, max-age=3600`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cache_control: std::string::String,

    /// Access controls on the object.
    /// If iam_config.uniform_bucket_level_access is enabled on the parent
    /// bucket, requests to set, read, or modify acl is an error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub acl: std::vec::Vec<crate::model::ObjectAccessControl>,

    /// Content-Language of the object data, matching
    /// [<https://tools.ietf.org/html/rfc7231#section-3.1.3.2>][RFC 7231 §3.1.3.2].
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content_language: std::string::String,

    /// Output only. If this object is noncurrent, this is the time when the object
    /// became noncurrent.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the object was finalized.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finalize_time: std::option::Option<wkt::Timestamp>,

    /// Content-Type of the object data, matching
    /// [<https://tools.ietf.org/html/rfc7231#section-3.1.1.5>][RFC 7231 §3.1.1.5].
    /// If an object is stored without a Content-Type, it is served as
    /// `application/octet-stream`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content_type: std::string::String,

    /// Output only. The creation time of the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Number of underlying components that make up this object.
    /// Components are accumulated by compose operations.
    pub component_count: i32,

    /// Output only. Hashes for the data part of this object. This field is used
    /// for output only and will be silently ignored if provided in requests. The
    /// checksums of the complete object regardless of data range. If the object is
    /// downloaded in full, the client should compute one of these checksums over
    /// the downloaded object and compare it against the value provided here.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub checksums: std::option::Option<crate::model::ObjectChecksums>,

    /// Output only. The modification time of the object metadata.
    /// Set initially to object creation time and then updated whenever any
    /// metadata of the object changes. This includes changes made by a requester,
    /// such as modifying custom metadata, as well as changes made by Cloud Storage
    /// on behalf of a requester, such as changing the storage class based on an
    /// Object Lifecycle Configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Cloud KMS Key used to encrypt this object, if the object is encrypted by
    /// such a key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,

    /// Output only. The time at which the object's storage class was last changed.
    /// When the object is initially created, it will be set to time_created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_storage_class_time: std::option::Option<wkt::Timestamp>,

    /// Whether an object is under temporary hold. While this flag is set to true,
    /// the object is protected against deletion and overwrites.  A common use case
    /// of this flag is regulatory investigations where objects need to be retained
    /// while the investigation is ongoing. Note that unlike event-based hold,
    /// temporary hold does not impact retention expiration time of an object.
    pub temporary_hold: bool,

    /// A server-determined value that specifies the earliest time that the
    /// object's retention period expires.
    /// Note 1: This field is not provided for objects with an active event-based
    /// hold, since retention expiration is unknown until the hold is removed.
    /// Note 2: This value can be provided even when temporary hold is set (so that
    /// the user can reason about policy without having to first unset the
    /// temporary hold).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retention_expire_time: std::option::Option<wkt::Timestamp>,

    /// User-provided metadata, in key/value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Whether an object is under event-based hold.
    /// An event-based hold is a way to force the retention of an object until
    /// after some event occurs. Once the hold is released by explicitly setting
    /// this field to false, the object will become subject to any bucket-level
    /// retention policy, except that the retention duration will be calculated
    /// from the time the event based hold was lifted, rather than the time the
    /// object was created.
    ///
    /// In a WriteObject request, not setting this field implies that the value
    /// should be taken from the parent bucket's "default_event_based_hold" field.
    /// In a response, this field will always be set to true or false.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub event_based_hold: std::option::Option<bool>,

    /// Output only. The owner of the object. This will always be the uploader of
    /// the object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub owner: std::option::Option<crate::model::Owner>,

    /// Metadata of Customer-Supplied Encryption Key, if the object is encrypted by
    /// such a key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub customer_encryption: std::option::Option<crate::model::CustomerEncryption>,

    /// A user-specified timestamp set on an object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_time: std::option::Option<wkt::Timestamp>,

    /// Output only. This is the time when the object became soft-deleted.
    ///
    /// Soft-deleted objects are only accessible if a soft_delete_policy is
    /// enabled. Also see hard_delete_time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub soft_delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the object will be permanently deleted.
    ///
    /// Only set when an object becomes soft-deleted with a soft_delete_policy.
    /// Otherwise, the object will not be accessible.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hard_delete_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Object {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Object::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [bucket][crate::model::Object::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Object::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::Object::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [restore_token][crate::model::Object::restore_token].
    pub fn set_restore_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.restore_token = v.into();
        self
    }

    /// Sets the value of [metageneration][crate::model::Object::metageneration].
    pub fn set_metageneration<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.metageneration = v.into();
        self
    }

    /// Sets the value of [storage_class][crate::model::Object::storage_class].
    pub fn set_storage_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_class = v.into();
        self
    }

    /// Sets the value of [size][crate::model::Object::size].
    pub fn set_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size = v.into();
        self
    }

    /// Sets the value of [content_encoding][crate::model::Object::content_encoding].
    pub fn set_content_encoding<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.content_encoding = v.into();
        self
    }

    /// Sets the value of [content_disposition][crate::model::Object::content_disposition].
    pub fn set_content_disposition<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.content_disposition = v.into();
        self
    }

    /// Sets the value of [cache_control][crate::model::Object::cache_control].
    pub fn set_cache_control<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cache_control = v.into();
        self
    }

    /// Sets the value of [content_language][crate::model::Object::content_language].
    pub fn set_content_language<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.content_language = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Object::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [finalize_time][crate::model::Object::finalize_time].
    pub fn set_finalize_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finalize_time = v.into();
        self
    }

    /// Sets the value of [content_type][crate::model::Object::content_type].
    pub fn set_content_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content_type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Object::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [component_count][crate::model::Object::component_count].
    pub fn set_component_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.component_count = v.into();
        self
    }

    /// Sets the value of [checksums][crate::model::Object::checksums].
    pub fn set_checksums<
        T: std::convert::Into<std::option::Option<crate::model::ObjectChecksums>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.checksums = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Object::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::Object::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [update_storage_class_time][crate::model::Object::update_storage_class_time].
    pub fn set_update_storage_class_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.update_storage_class_time = v.into();
        self
    }

    /// Sets the value of [temporary_hold][crate::model::Object::temporary_hold].
    pub fn set_temporary_hold<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.temporary_hold = v.into();
        self
    }

    /// Sets the value of [retention_expire_time][crate::model::Object::retention_expire_time].
    pub fn set_retention_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.retention_expire_time = v.into();
        self
    }

    /// Sets the value of [event_based_hold][crate::model::Object::event_based_hold].
    pub fn set_event_based_hold<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.event_based_hold = v.into();
        self
    }

    /// Sets the value of [owner][crate::model::Object::owner].
    pub fn set_owner<T: std::convert::Into<std::option::Option<crate::model::Owner>>>(
        mut self,
        v: T,
    ) -> Self {
        self.owner = v.into();
        self
    }

    /// Sets the value of [customer_encryption][crate::model::Object::customer_encryption].
    pub fn set_customer_encryption<
        T: std::convert::Into<std::option::Option<crate::model::CustomerEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.customer_encryption = v.into();
        self
    }

    /// Sets the value of [custom_time][crate::model::Object::custom_time].
    pub fn set_custom_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_time = v.into();
        self
    }

    /// Sets the value of [soft_delete_time][crate::model::Object::soft_delete_time].
    pub fn set_soft_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.soft_delete_time = v.into();
        self
    }

    /// Sets the value of [hard_delete_time][crate::model::Object::hard_delete_time].
    pub fn set_hard_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.hard_delete_time = v.into();
        self
    }

    /// Sets the value of [acl][crate::model::Object::acl].
    pub fn set_acl<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ObjectAccessControl>,
    {
        use std::iter::Iterator;
        self.acl = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::Object::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Object {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.Object"
    }
}

/// An access-control entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ObjectAccessControl {
    /// The access permission for the entity. One of the following values:
    ///
    /// * `READER`
    /// * `WRITER`
    /// * `OWNER`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub role: std::string::String,

    /// The ID of the access-control entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The entity holding the permission, in one of the following forms:
    ///
    /// * `user-{userid}`
    /// * `user-{email}`
    /// * `group-{groupid}`
    /// * `group-{email}`
    /// * `domain-{domain}`
    /// * `project-{team}-{projectnumber}`
    /// * `project-{team}-{projectid}`
    /// * `allUsers`
    /// * `allAuthenticatedUsers`
    ///   Examples:
    /// * The user `liz@example.com` would be `user-liz@example.com`.
    /// * The group `example@googlegroups.com` would be
    ///   `group-example@googlegroups.com`.
    /// * All members of the Google Apps for Business domain `example.com` would be
    ///   `domain-example.com`.
    ///   For project entities, `project-{team}-{projectnumber}` format will be
    ///   returned on response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity: std::string::String,

    /// Output only. The alternative entity format, if exists. For project
    /// entities, `project-{team}-{projectid}` format will be returned on response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_alt: std::string::String,

    /// The ID for the entity, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_id: std::string::String,

    /// The etag of the ObjectAccessControl.
    /// If included in the metadata of an update or delete request message, the
    /// operation will only be performed if the etag matches that of the live
    /// object's ObjectAccessControl.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The email address associated with the entity, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub email: std::string::String,

    /// The domain associated with the entity, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub domain: std::string::String,

    /// The project team associated with the entity, if any.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub project_team: std::option::Option<crate::model::ProjectTeam>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectAccessControl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role][crate::model::ObjectAccessControl::role].
    pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [id][crate::model::ObjectAccessControl::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [entity][crate::model::ObjectAccessControl::entity].
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity = v.into();
        self
    }

    /// Sets the value of [entity_alt][crate::model::ObjectAccessControl::entity_alt].
    pub fn set_entity_alt<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_alt = v.into();
        self
    }

    /// Sets the value of [entity_id][crate::model::ObjectAccessControl::entity_id].
    pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::ObjectAccessControl::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [email][crate::model::ObjectAccessControl::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::ObjectAccessControl::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [project_team][crate::model::ObjectAccessControl::project_team].
    pub fn set_project_team<
        T: std::convert::Into<std::option::Option<crate::model::ProjectTeam>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.project_team = v.into();
        self
    }
}

impl wkt::message::Message for ObjectAccessControl {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ObjectAccessControl"
    }
}

/// The result of a call to Objects.ListObjects
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListObjectsResponse {
    /// The list of items.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub objects: std::vec::Vec<crate::model::Object>,

    /// The list of prefixes of objects matching-but-not-listed up to and including
    /// the requested delimiter.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub prefixes: std::vec::Vec<std::string::String>,

    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListObjectsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListObjectsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [objects][crate::model::ListObjectsResponse::objects].
    pub fn set_objects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Object>,
    {
        use std::iter::Iterator;
        self.objects = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [prefixes][crate::model::ListObjectsResponse::prefixes].
    pub fn set_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListObjectsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ListObjectsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListObjectsResponse {
    type PageItem = crate::model::Object;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.objects
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Represents the Viewers, Editors, or Owners of a given project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProjectTeam {
    /// The project number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_number: std::string::String,

    /// The team.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub team: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProjectTeam {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_number][crate::model::ProjectTeam::project_number].
    pub fn set_project_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_number = v.into();
        self
    }

    /// Sets the value of [team][crate::model::ProjectTeam::team].
    pub fn set_team<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.team = v.into();
        self
    }
}

impl wkt::message::Message for ProjectTeam {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ProjectTeam"
    }
}

/// The owner of a specific resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Owner {
    /// The entity, in the form `user-`*userId*.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity: std::string::String,

    /// The ID for the entity.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Owner {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity][crate::model::Owner::entity].
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity = v.into();
        self
    }

    /// Sets the value of [entity_id][crate::model::Owner::entity_id].
    pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_id = v.into();
        self
    }
}

impl wkt::message::Message for Owner {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.Owner"
    }
}

/// Specifies a requested range of bytes to download.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContentRange {
    /// The starting offset of the object data. This value is inclusive.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub start: i64,

    /// The ending offset of the object data. This value is exclusive.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub end: i64,

    /// The complete length of the object data.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub complete_length: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContentRange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start][crate::model::ContentRange::start].
    pub fn set_start<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.start = v.into();
        self
    }

    /// Sets the value of [end][crate::model::ContentRange::end].
    pub fn set_end<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.end = v.into();
        self
    }

    /// Sets the value of [complete_length][crate::model::ContentRange::complete_length].
    pub fn set_complete_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.complete_length = v.into();
        self
    }
}

impl wkt::message::Message for ContentRange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ContentRange"
    }
}
