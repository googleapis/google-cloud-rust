// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]

/// Request message for DeleteBucket.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBucketRequest {
    /// Required. Name of a bucket to delete.
    pub name: std::string::String,

    /// If set, only deletes the bucket if its metageneration matches this value.
    pub if_metageneration_match: std::option::Option<i64>,

    /// If set, only deletes the bucket if its metageneration does not match this
    /// value.
    pub if_metageneration_not_match: std::option::Option<i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBucketRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::DeleteBucketRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_match][crate::model::DeleteBucketRequest::if_metageneration_match].
    pub fn set_or_clear_if_metageneration_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::DeleteBucketRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_not_match][crate::model::DeleteBucketRequest::if_metageneration_not_match].
    pub fn set_or_clear_if_metageneration_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.DeleteBucketRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBucketRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __if_metageneration_match,
            __if_metageneration_not_match,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBucketRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "if_metageneration_not_match" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBucketRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBucketRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBucketRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationMatch",
                &__With(&self.if_metageneration_match),
            )?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationNotMatch",
                &__With(&self.if_metageneration_not_match),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetBucket.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBucketRequest {
    /// Required. Name of a bucket.
    pub name: std::string::String,

    /// If set, and if the bucket's current metageneration does not match the
    /// specified value, the request will return an error.
    pub if_metageneration_match: std::option::Option<i64>,

    /// If set, and if the bucket's current metageneration matches the specified
    /// value, the request will return an error.
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// Mask specifying which fields to read.
    /// A "*" field may be used to indicate all fields.
    /// If no mask is specified, will default to all fields.
    pub read_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBucketRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::GetBucketRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_match][crate::model::GetBucketRequest::if_metageneration_match].
    pub fn set_or_clear_if_metageneration_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::GetBucketRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_not_match][crate::model::GetBucketRequest::if_metageneration_not_match].
    pub fn set_or_clear_if_metageneration_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [read_mask][crate::model::GetBucketRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::GetBucketRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.GetBucketRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBucketRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __read_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBucketRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "if_metageneration_not_match" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBucketRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBucketRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_mask",
                                ));
                            }
                            result.read_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBucketRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationMatch",
                &__With(&self.if_metageneration_match),
            )?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationNotMatch",
                &__With(&self.if_metageneration_not_match),
            )?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateBucket.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBucketRequest {
    /// Required. The project to which this bucket will belong. This field must
    /// either be empty or `projects/_`. The project ID that owns this bucket
    /// should be specified in the `bucket.project` field.
    pub parent: std::string::String,

    /// Optional. Properties of the new bucket being inserted.
    /// The name of the bucket is specified in the `bucket_id` field. Populating
    /// `bucket.name` field will result in an error.
    /// The project of the bucket must be specified in the `bucket.project` field.
    /// This field must be in `projects/{projectIdentifier}` format,
    /// {projectIdentifier} can be the project ID or project number. The `parent`
    /// field must be either empty or `projects/_`.
    pub bucket: std::option::Option<crate::model::Bucket>,

    /// Required. The ID to use for this bucket, which will become the final
    /// component of the bucket's resource name. For example, the value `foo` might
    /// result in a bucket with the name `projects/123456/buckets/foo`.
    pub bucket_id: std::string::String,

    /// Optional. Apply a predefined set of access controls to this bucket.
    /// Valid values are "authenticatedRead", "private", "projectPrivate",
    /// "publicRead", or "publicReadWrite".
    pub predefined_acl: std::string::String,

    /// Optional. Apply a predefined set of default object access controls to this
    /// bucket. Valid values are "authenticatedRead", "bucketOwnerFullControl",
    /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
    pub predefined_default_object_acl: std::string::String,

    /// Optional. If true, enable object retention on the bucket.
    pub enable_object_retention: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBucketRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [bucket][crate::model::CreateBucketRequest::bucket].
    pub fn set_bucket<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Bucket>,
    {
        self.bucket = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bucket][crate::model::CreateBucketRequest::bucket].
    pub fn set_or_clear_bucket<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Bucket>,
    {
        self.bucket = v.map(|x| x.into());
        self
    }

    /// Sets the value of [bucket_id][crate::model::CreateBucketRequest::bucket_id].
    pub fn set_bucket_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_id = v.into();
        self
    }

    /// Sets the value of [predefined_acl][crate::model::CreateBucketRequest::predefined_acl].
    pub fn set_predefined_acl<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predefined_acl = v.into();
        self
    }

    /// Sets the value of [predefined_default_object_acl][crate::model::CreateBucketRequest::predefined_default_object_acl].
    pub fn set_predefined_default_object_acl<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.predefined_default_object_acl = v.into();
        self
    }

    /// Sets the value of [enable_object_retention][crate::model::CreateBucketRequest::enable_object_retention].
    pub fn set_enable_object_retention<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_object_retention = v.into();
        self
    }
}

impl wkt::message::Message for CreateBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.CreateBucketRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBucketRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __bucket,
            __bucket_id,
            __predefined_acl,
            __predefined_default_object_acl,
            __enable_object_retention,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBucketRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "bucket" => Ok(__FieldTag::__bucket),
                            "bucketId" => Ok(__FieldTag::__bucket_id),
                            "bucket_id" => Ok(__FieldTag::__bucket_id),
                            "predefinedAcl" => Ok(__FieldTag::__predefined_acl),
                            "predefined_acl" => Ok(__FieldTag::__predefined_acl),
                            "predefinedDefaultObjectAcl" => {
                                Ok(__FieldTag::__predefined_default_object_acl)
                            }
                            "predefined_default_object_acl" => {
                                Ok(__FieldTag::__predefined_default_object_acl)
                            }
                            "enableObjectRetention" => Ok(__FieldTag::__enable_object_retention),
                            "enable_object_retention" => Ok(__FieldTag::__enable_object_retention),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBucketRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBucketRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket =
                                map.next_value::<std::option::Option<crate::model::Bucket>>()?;
                        }
                        __FieldTag::__bucket_id => {
                            if !fields.insert(__FieldTag::__bucket_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_id",
                                ));
                            }
                            result.bucket_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__predefined_acl => {
                            if !fields.insert(__FieldTag::__predefined_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predefined_acl",
                                ));
                            }
                            result.predefined_acl = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__predefined_default_object_acl => {
                            if !fields.insert(__FieldTag::__predefined_default_object_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predefined_default_object_acl",
                                ));
                            }
                            result.predefined_default_object_acl = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_object_retention => {
                            if !fields.insert(__FieldTag::__enable_object_retention) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_object_retention",
                                ));
                            }
                            result.enable_object_retention = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBucketRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.bucket.is_some() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.bucket_id.is_empty() {
            state.serialize_entry("bucketId", &self.bucket_id)?;
        }
        if !self.predefined_acl.is_empty() {
            state.serialize_entry("predefinedAcl", &self.predefined_acl)?;
        }
        if !self.predefined_default_object_acl.is_empty() {
            state.serialize_entry(
                "predefinedDefaultObjectAcl",
                &self.predefined_default_object_acl,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_object_retention) {
            state.serialize_entry("enableObjectRetention", &self.enable_object_retention)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListBuckets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBucketsRequest {
    /// Required. The project whose buckets we are listing.
    pub parent: std::string::String,

    /// Optional. Maximum number of buckets to return in a single response. The
    /// service will use this parameter or 1,000 items, whichever is smaller. If
    /// "acl" is present in the read_mask, the service will use this parameter of
    /// 200 items, whichever is smaller.
    pub page_size: i32,

    /// Optional. A previously-returned page token representing part of the larger
    /// set of results to view.
    pub page_token: std::string::String,

    /// Optional. Filter results to buckets whose names begin with this prefix.
    pub prefix: std::string::String,

    /// Mask specifying which fields to read from each result.
    /// If no mask is specified, will default to all fields except items.owner,
    /// items.acl, and items.default_object_acl.
    ///
    /// * may be used to mean "all fields".
    pub read_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBucketsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBucketsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBucketsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBucketsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [prefix][crate::model::ListBucketsRequest::prefix].
    pub fn set_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.prefix = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListBucketsRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::ListBucketsRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListBucketsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ListBucketsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBucketsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __prefix,
            __read_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBucketsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "prefix" => Ok(__FieldTag::__prefix),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBucketsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBucketsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__prefix => {
                            if !fields.insert(__FieldTag::__prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prefix",
                                ));
                            }
                            result.prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_mask",
                                ));
                            }
                            result.read_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBucketsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.prefix.is_empty() {
            state.serialize_entry("prefix", &self.prefix)?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The result of a call to Buckets.ListBuckets
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBucketsResponse {
    /// The list of items.
    pub buckets: std::vec::Vec<crate::model::Bucket>,

    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBucketsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [buckets][crate::model::ListBucketsResponse::buckets].
    pub fn set_buckets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Bucket>,
    {
        use std::iter::Iterator;
        self.buckets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBucketsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBucketsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ListBucketsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBucketsResponse {
    type PageItem = crate::model::Bucket;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.buckets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBucketsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __buckets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBucketsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "buckets" => Ok(__FieldTag::__buckets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBucketsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBucketsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__buckets => {
                            if !fields.insert(__FieldTag::__buckets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for buckets",
                                ));
                            }
                            result.buckets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Bucket>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBucketsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.buckets.is_empty() {
            state.serialize_entry("buckets", &self.buckets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for LockBucketRetentionPolicyRequest.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LockBucketRetentionPolicyRequest {
    /// Required. Name of a bucket.
    pub bucket: std::string::String,

    /// Required. Makes the operation conditional on whether bucket's current
    /// metageneration matches the given value. Must be positive.
    pub if_metageneration_match: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LockBucketRetentionPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::LockBucketRetentionPolicyRequest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::LockBucketRetentionPolicyRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.if_metageneration_match = v.into();
        self
    }
}

impl wkt::message::Message for LockBucketRetentionPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.LockBucketRetentionPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LockBucketRetentionPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __if_metageneration_match,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LockBucketRetentionPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LockBucketRetentionPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LockBucketRetentionPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LockBucketRetentionPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !wkt::internal::is_default(&self.if_metageneration_match) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "ifMetagenerationMatch",
                &__With(&self.if_metageneration_match),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for UpdateBucket method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBucketRequest {
    /// Required. The bucket to update.
    /// The bucket's `name` field will be used to identify the bucket.
    pub bucket: std::option::Option<crate::model::Bucket>,

    /// If set, will only modify the bucket if its metageneration matches this
    /// value.
    pub if_metageneration_match: std::option::Option<i64>,

    /// If set, will only modify the bucket if its metageneration does not match
    /// this value.
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// Optional. Apply a predefined set of access controls to this bucket.
    /// Valid values are "authenticatedRead", "private", "projectPrivate",
    /// "publicRead", or "publicReadWrite".
    pub predefined_acl: std::string::String,

    /// Optional. Apply a predefined set of default object access controls to this
    /// bucket. Valid values are "authenticatedRead", "bucketOwnerFullControl",
    /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
    pub predefined_default_object_acl: std::string::String,

    /// Required. List of fields to be updated.
    ///
    /// To specify ALL fields, equivalent to the JSON API's "update" function,
    /// specify a single field with the value `*`. Note: not recommended. If a new
    /// field is introduced at a later time, an older client updating with the `*`
    /// may accidentally reset the new field's value.
    ///
    /// Not specifying any fields is an error.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::UpdateBucketRequest::bucket].
    pub fn set_bucket<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Bucket>,
    {
        self.bucket = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bucket][crate::model::UpdateBucketRequest::bucket].
    pub fn set_or_clear_bucket<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Bucket>,
    {
        self.bucket = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::UpdateBucketRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_match][crate::model::UpdateBucketRequest::if_metageneration_match].
    pub fn set_or_clear_if_metageneration_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::UpdateBucketRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_not_match][crate::model::UpdateBucketRequest::if_metageneration_not_match].
    pub fn set_or_clear_if_metageneration_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [predefined_acl][crate::model::UpdateBucketRequest::predefined_acl].
    pub fn set_predefined_acl<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predefined_acl = v.into();
        self
    }

    /// Sets the value of [predefined_default_object_acl][crate::model::UpdateBucketRequest::predefined_default_object_acl].
    pub fn set_predefined_default_object_acl<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.predefined_default_object_acl = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBucketRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBucketRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.UpdateBucketRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBucketRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __predefined_acl,
            __predefined_default_object_acl,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBucketRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "if_metageneration_not_match" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "predefinedAcl" => Ok(__FieldTag::__predefined_acl),
                            "predefined_acl" => Ok(__FieldTag::__predefined_acl),
                            "predefinedDefaultObjectAcl" => {
                                Ok(__FieldTag::__predefined_default_object_acl)
                            }
                            "predefined_default_object_acl" => {
                                Ok(__FieldTag::__predefined_default_object_acl)
                            }
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBucketRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBucketRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket =
                                map.next_value::<std::option::Option<crate::model::Bucket>>()?;
                        }
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__predefined_acl => {
                            if !fields.insert(__FieldTag::__predefined_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predefined_acl",
                                ));
                            }
                            result.predefined_acl = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__predefined_default_object_acl => {
                            if !fields.insert(__FieldTag::__predefined_default_object_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predefined_default_object_acl",
                                ));
                            }
                            result.predefined_default_object_acl = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBucketRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bucket.is_some() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationMatch",
                &__With(&self.if_metageneration_match),
            )?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationNotMatch",
                &__With(&self.if_metageneration_not_match),
            )?;
        }
        if !self.predefined_acl.is_empty() {
            state.serialize_entry("predefinedAcl", &self.predefined_acl)?;
        }
        if !self.predefined_default_object_acl.is_empty() {
            state.serialize_entry(
                "predefinedDefaultObjectAcl",
                &self.predefined_default_object_acl,
            )?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ComposeObject.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComposeObjectRequest {
    /// Required. Properties of the resulting object.
    pub destination: std::option::Option<crate::model::Object>,

    /// Optional. The list of source objects that will be concatenated into a
    /// single object.
    pub source_objects: std::vec::Vec<crate::model::compose_object_request::SourceObject>,

    /// Optional. Apply a predefined set of access controls to the destination
    /// object. Valid values are "authenticatedRead", "bucketOwnerFullControl",
    /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
    pub destination_predefined_acl: std::string::String,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    pub if_metageneration_match: std::option::Option<i64>,

    /// Optional. Resource name of the Cloud KMS key, of the form
    /// `projects/my-project/locations/my-location/keyRings/my-kr/cryptoKeys/my-key`,
    /// that will be used to encrypt the object. Overrides the object
    /// metadata's `kms_key_name` value, if any.
    pub kms_key: std::string::String,

    /// Optional. A set of parameters common to Storage API requests concerning an
    /// object.
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    /// Optional. The checksums of the complete object. This will be validated
    /// against the combined checksums of the component objects.
    pub object_checksums: std::option::Option<crate::model::ObjectChecksums>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComposeObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::ComposeObjectRequest::destination].
    pub fn set_destination<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Object>,
    {
        self.destination = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destination][crate::model::ComposeObjectRequest::destination].
    pub fn set_or_clear_destination<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Object>,
    {
        self.destination = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_objects][crate::model::ComposeObjectRequest::source_objects].
    pub fn set_source_objects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::compose_object_request::SourceObject>,
    {
        use std::iter::Iterator;
        self.source_objects = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [destination_predefined_acl][crate::model::ComposeObjectRequest::destination_predefined_acl].
    pub fn set_destination_predefined_acl<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_predefined_acl = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::ComposeObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_match][crate::model::ComposeObjectRequest::if_generation_match].
    pub fn set_or_clear_if_generation_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::ComposeObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_match][crate::model::ComposeObjectRequest::if_metageneration_match].
    pub fn set_or_clear_if_metageneration_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kms_key][crate::model::ComposeObjectRequest::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::ComposeObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonObjectRequestParams>,
    {
        self.common_object_request_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_object_request_params][crate::model::ComposeObjectRequest::common_object_request_params].
    pub fn set_or_clear_common_object_request_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonObjectRequestParams>,
    {
        self.common_object_request_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [object_checksums][crate::model::ComposeObjectRequest::object_checksums].
    pub fn set_object_checksums<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ObjectChecksums>,
    {
        self.object_checksums = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object_checksums][crate::model::ComposeObjectRequest::object_checksums].
    pub fn set_or_clear_object_checksums<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ObjectChecksums>,
    {
        self.object_checksums = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ComposeObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ComposeObjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComposeObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __destination,
            __source_objects,
            __destination_predefined_acl,
            __if_generation_match,
            __if_metageneration_match,
            __kms_key,
            __common_object_request_params,
            __object_checksums,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComposeObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "destination" => Ok(__FieldTag::__destination),
                            "sourceObjects" => Ok(__FieldTag::__source_objects),
                            "source_objects" => Ok(__FieldTag::__source_objects),
                            "destinationPredefinedAcl" => {
                                Ok(__FieldTag::__destination_predefined_acl)
                            }
                            "destination_predefined_acl" => {
                                Ok(__FieldTag::__destination_predefined_acl)
                            }
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            "commonObjectRequestParams" => {
                                Ok(__FieldTag::__common_object_request_params)
                            }
                            "common_object_request_params" => {
                                Ok(__FieldTag::__common_object_request_params)
                            }
                            "objectChecksums" => Ok(__FieldTag::__object_checksums),
                            "object_checksums" => Ok(__FieldTag::__object_checksums),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComposeObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComposeObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination",
                                ));
                            }
                            result.destination =
                                map.next_value::<std::option::Option<crate::model::Object>>()?;
                        }
                        __FieldTag::__source_objects => {
                            if !fields.insert(__FieldTag::__source_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_objects",
                                ));
                            }
                            result.source_objects = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::compose_object_request::SourceObject,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_predefined_acl => {
                            if !fields.insert(__FieldTag::__destination_predefined_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_predefined_acl",
                                ));
                            }
                            result.destination_predefined_acl = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__common_object_request_params => {
                            if !fields.insert(__FieldTag::__common_object_request_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_object_request_params",
                                ));
                            }
                            result.common_object_request_params = map.next_value::<std::option::Option<crate::model::CommonObjectRequestParams>>()?
                                ;
                        }
                        __FieldTag::__object_checksums => {
                            if !fields.insert(__FieldTag::__object_checksums) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_checksums",
                                ));
                            }
                            result.object_checksums = map
                                .next_value::<std::option::Option<crate::model::ObjectChecksums>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComposeObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.destination.is_some() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if !self.source_objects.is_empty() {
            state.serialize_entry("sourceObjects", &self.source_objects)?;
        }
        if !self.destination_predefined_acl.is_empty() {
            state.serialize_entry("destinationPredefinedAcl", &self.destination_predefined_acl)?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationMatch",
                &__With(&self.if_metageneration_match),
            )?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if self.common_object_request_params.is_some() {
            state.serialize_entry(
                "commonObjectRequestParams",
                &self.common_object_request_params,
            )?;
        }
        if self.object_checksums.is_some() {
            state.serialize_entry("objectChecksums", &self.object_checksums)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ComposeObjectRequest].
pub mod compose_object_request {
    #[allow(unused_imports)]
    use super::*;

    /// Description of a source object for a composition request.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SourceObject {
        /// Required. The source object's name. All source objects must reside in the
        /// same bucket.
        pub name: std::string::String,

        /// Optional. The generation of this object to use as the source.
        pub generation: i64,

        /// Optional. Conditions that must be met for this operation to execute.
        pub object_preconditions: std::option::Option<
            crate::model::compose_object_request::source_object::ObjectPreconditions,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SourceObject {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::compose_object_request::SourceObject::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [generation][crate::model::compose_object_request::SourceObject::generation].
        pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.generation = v.into();
            self
        }

        /// Sets the value of [object_preconditions][crate::model::compose_object_request::SourceObject::object_preconditions].
        pub fn set_object_preconditions<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::compose_object_request::source_object::ObjectPreconditions,
                >,
        {
            self.object_preconditions = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [object_preconditions][crate::model::compose_object_request::SourceObject::object_preconditions].
        pub fn set_or_clear_object_preconditions<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::compose_object_request::source_object::ObjectPreconditions,
                >,
        {
            self.object_preconditions = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SourceObject {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.ComposeObjectRequest.SourceObject"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SourceObject {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __generation,
                __object_preconditions,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SourceObject")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "generation" => Ok(__FieldTag::__generation),
                                "objectPreconditions" => Ok(__FieldTag::__object_preconditions),
                                "object_preconditions" => Ok(__FieldTag::__object_preconditions),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SourceObject;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SourceObject")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__generation => {
                                if !fields.insert(__FieldTag::__generation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for generation",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.generation =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__object_preconditions => {
                                if !fields.insert(__FieldTag::__object_preconditions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for object_preconditions",
                                    ));
                                }
                                result.object_preconditions = map.next_value::<std::option::Option<crate::model::compose_object_request::source_object::ObjectPreconditions>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SourceObject {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.generation) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("generation", &__With(&self.generation))?;
            }
            if self.object_preconditions.is_some() {
                state.serialize_entry("objectPreconditions", &self.object_preconditions)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SourceObject].
    pub mod source_object {
        #[allow(unused_imports)]
        use super::*;

        /// Preconditions for a source object of a composition request.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ObjectPreconditions {
            /// Only perform the composition if the generation of the source object
            /// that would be used matches this value.  If this value and a generation
            /// are both specified, they must be the same value or the call will fail.
            pub if_generation_match: std::option::Option<i64>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ObjectPreconditions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [if_generation_match][crate::model::compose_object_request::source_object::ObjectPreconditions::if_generation_match].
            pub fn set_if_generation_match<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<i64>,
            {
                self.if_generation_match = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [if_generation_match][crate::model::compose_object_request::source_object::ObjectPreconditions::if_generation_match].
            pub fn set_or_clear_if_generation_match<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<i64>,
            {
                self.if_generation_match = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for ObjectPreconditions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.storage.v2.ComposeObjectRequest.SourceObject.ObjectPreconditions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ObjectPreconditions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __if_generation_match,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ObjectPreconditions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                                    "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ObjectPreconditions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ObjectPreconditions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__if_generation_match => {
                                    if !fields.insert(__FieldTag::__if_generation_match) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for if_generation_match",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.if_generation_match = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ObjectPreconditions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.if_generation_match.is_some() {
                    struct __With<'a>(&'a std::option::Option<i64>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state
                        .serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }
}

/// Message for deleting an object.
/// `bucket` and `object` **must** be set.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteObjectRequest {
    /// Required. Name of the bucket in which the object resides.
    pub bucket: std::string::String,

    /// Required. The name of the finalized object to delete.
    /// Note: If you want to delete an unfinalized resumable upload please use
    /// `CancelResumableWrite`.
    pub object: std::string::String,

    /// Optional. If present, permanently deletes a specific revision of this
    /// object (as opposed to the latest version, the default).
    pub generation: i64,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live generation
    /// does not match the given value. If no live object exists, the precondition
    /// fails. Setting to 0 makes the operation succeed only if there is a live
    /// version of the object.
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// Optional. A set of parameters common to Storage API requests concerning an
    /// object.
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::DeleteObjectRequest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::DeleteObjectRequest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::DeleteObjectRequest::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::DeleteObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_match][crate::model::DeleteObjectRequest::if_generation_match].
    pub fn set_or_clear_if_generation_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::DeleteObjectRequest::if_generation_not_match].
    pub fn set_if_generation_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_not_match][crate::model::DeleteObjectRequest::if_generation_not_match].
    pub fn set_or_clear_if_generation_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::DeleteObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_match][crate::model::DeleteObjectRequest::if_metageneration_match].
    pub fn set_or_clear_if_metageneration_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::DeleteObjectRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_not_match][crate::model::DeleteObjectRequest::if_metageneration_not_match].
    pub fn set_or_clear_if_metageneration_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::DeleteObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonObjectRequestParams>,
    {
        self.common_object_request_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_object_request_params][crate::model::DeleteObjectRequest::common_object_request_params].
    pub fn set_or_clear_common_object_request_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonObjectRequestParams>,
    {
        self.common_object_request_params = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.DeleteObjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __common_object_request_params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generation" => Ok(__FieldTag::__generation),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "if_metageneration_not_match" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "commonObjectRequestParams" => {
                                Ok(__FieldTag::__common_object_request_params)
                            }
                            "common_object_request_params" => {
                                Ok(__FieldTag::__common_object_request_params)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__common_object_request_params => {
                            if !fields.insert(__FieldTag::__common_object_request_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_object_request_params",
                                ));
                            }
                            result.common_object_request_params = map.next_value::<std::option::Option<crate::model::CommonObjectRequestParams>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.object.is_empty() {
            state.serialize_entry("object", &self.object)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifGenerationNotMatch",
                &__With(&self.if_generation_not_match),
            )?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationMatch",
                &__With(&self.if_metageneration_match),
            )?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationNotMatch",
                &__With(&self.if_metageneration_not_match),
            )?;
        }
        if self.common_object_request_params.is_some() {
            state.serialize_entry(
                "commonObjectRequestParams",
                &self.common_object_request_params,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for restoring an object.
/// `bucket`, `object`, and `generation` **must** be set.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreObjectRequest {
    /// Required. Name of the bucket in which the object resides.
    pub bucket: std::string::String,

    /// Required. The name of the object to restore.
    pub object: std::string::String,

    /// Required. The specific revision of the object to restore.
    pub generation: i64,

    /// Optional. Restore token used to differentiate soft-deleted objects with the
    /// same name and generation. Only applicable for hierarchical namespace
    /// buckets. This parameter is optional, and is only required in the rare case
    /// when there are multiple soft-deleted objects with the same name and
    /// generation.
    pub restore_token: std::string::String,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live generation
    /// does not match the given value. If no live object exists, the precondition
    /// fails. Setting to 0 makes the operation succeed only if there is a live
    /// version of the object.
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// If false or unset, the bucket's default object ACL will be used.
    /// If true, copy the source object's access controls.
    /// Return an error if bucket has UBLA enabled.
    pub copy_source_acl: std::option::Option<bool>,

    /// Optional. A set of parameters common to Storage API requests concerning an
    /// object.
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::RestoreObjectRequest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::RestoreObjectRequest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::RestoreObjectRequest::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [restore_token][crate::model::RestoreObjectRequest::restore_token].
    pub fn set_restore_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.restore_token = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::RestoreObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_match][crate::model::RestoreObjectRequest::if_generation_match].
    pub fn set_or_clear_if_generation_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::RestoreObjectRequest::if_generation_not_match].
    pub fn set_if_generation_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_not_match][crate::model::RestoreObjectRequest::if_generation_not_match].
    pub fn set_or_clear_if_generation_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::RestoreObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_match][crate::model::RestoreObjectRequest::if_metageneration_match].
    pub fn set_or_clear_if_metageneration_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::RestoreObjectRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_not_match][crate::model::RestoreObjectRequest::if_metageneration_not_match].
    pub fn set_or_clear_if_metageneration_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [copy_source_acl][crate::model::RestoreObjectRequest::copy_source_acl].
    pub fn set_copy_source_acl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.copy_source_acl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [copy_source_acl][crate::model::RestoreObjectRequest::copy_source_acl].
    pub fn set_or_clear_copy_source_acl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.copy_source_acl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::RestoreObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonObjectRequestParams>,
    {
        self.common_object_request_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_object_request_params][crate::model::RestoreObjectRequest::common_object_request_params].
    pub fn set_or_clear_common_object_request_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonObjectRequestParams>,
    {
        self.common_object_request_params = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RestoreObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.RestoreObjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation,
            __restore_token,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __copy_source_acl,
            __common_object_request_params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generation" => Ok(__FieldTag::__generation),
                            "restoreToken" => Ok(__FieldTag::__restore_token),
                            "restore_token" => Ok(__FieldTag::__restore_token),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "if_metageneration_not_match" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "copySourceAcl" => Ok(__FieldTag::__copy_source_acl),
                            "copy_source_acl" => Ok(__FieldTag::__copy_source_acl),
                            "commonObjectRequestParams" => {
                                Ok(__FieldTag::__common_object_request_params)
                            }
                            "common_object_request_params" => {
                                Ok(__FieldTag::__common_object_request_params)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__restore_token => {
                            if !fields.insert(__FieldTag::__restore_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_token",
                                ));
                            }
                            result.restore_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__copy_source_acl => {
                            if !fields.insert(__FieldTag::__copy_source_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for copy_source_acl",
                                ));
                            }
                            result.copy_source_acl =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__common_object_request_params => {
                            if !fields.insert(__FieldTag::__common_object_request_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_object_request_params",
                                ));
                            }
                            result.common_object_request_params = map.next_value::<std::option::Option<crate::model::CommonObjectRequestParams>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.object.is_empty() {
            state.serialize_entry("object", &self.object)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if !self.restore_token.is_empty() {
            state.serialize_entry("restoreToken", &self.restore_token)?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifGenerationNotMatch",
                &__With(&self.if_generation_not_match),
            )?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationMatch",
                &__With(&self.if_metageneration_match),
            )?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationNotMatch",
                &__With(&self.if_metageneration_not_match),
            )?;
        }
        if self.copy_source_acl.is_some() {
            state.serialize_entry("copySourceAcl", &self.copy_source_acl)?;
        }
        if self.common_object_request_params.is_some() {
            state.serialize_entry(
                "commonObjectRequestParams",
                &self.common_object_request_params,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ReadObject.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub(crate) struct ReadObjectRequest {
    /// Required. The name of the bucket containing the object to read.
    pub bucket: std::string::String,

    /// Required. The name of the object to read.
    pub object: std::string::String,

    /// Optional. If present, selects a specific revision of this object (as
    /// opposed to the latest version, the default).
    pub generation: i64,

    /// Optional. The offset for the first byte to return in the read, relative to
    /// the start of the object.
    ///
    /// A negative `read_offset` value will be interpreted as the number of bytes
    /// back from the end of the object to be returned. For example, if an object's
    /// length is 15 bytes, a ReadObjectRequest with `read_offset` = -5 and
    /// `read_limit` = 3 would return bytes 10 through 12 of the object. Requesting
    /// a negative offset with magnitude larger than the size of the object will
    /// return the entire object.
    pub read_offset: i64,

    /// Optional. The maximum number of `data` bytes the server is allowed to
    /// return in the sum of all `Object` messages. A `read_limit` of zero
    /// indicates that there is no limit, and a negative `read_limit` will cause an
    /// error.
    ///
    /// If the stream returns fewer bytes than allowed by the `read_limit` and no
    /// error occurred, the stream includes all data from the `read_offset` to the
    /// end of the resource.
    pub read_limit: i64,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live generation
    /// does not match the given value. If no live object exists, the precondition
    /// fails. Setting to 0 makes the operation succeed only if there is a live
    /// version of the object.
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// Optional. A set of parameters common to Storage API requests concerning an
    /// object.
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    /// Mask specifying which fields to read.
    /// The checksummed_data field and its children will always be present.
    /// If no mask is specified, will default to all fields except metadata.owner
    /// and metadata.acl.
    ///
    /// * may be used to mean "all fields".
    pub read_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReadObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::ReadObjectRequest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::ReadObjectRequest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::ReadObjectRequest::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [read_offset][crate::model::ReadObjectRequest::read_offset].
    pub fn set_read_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.read_offset = v.into();
        self
    }

    /// Sets the value of [read_limit][crate::model::ReadObjectRequest::read_limit].
    pub fn set_read_limit<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.read_limit = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::ReadObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_match][crate::model::ReadObjectRequest::if_generation_match].
    pub fn set_or_clear_if_generation_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::ReadObjectRequest::if_generation_not_match].
    pub fn set_if_generation_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_not_match][crate::model::ReadObjectRequest::if_generation_not_match].
    pub fn set_or_clear_if_generation_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::ReadObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_match][crate::model::ReadObjectRequest::if_metageneration_match].
    pub fn set_or_clear_if_metageneration_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::ReadObjectRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_not_match][crate::model::ReadObjectRequest::if_metageneration_not_match].
    pub fn set_or_clear_if_metageneration_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::ReadObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonObjectRequestParams>,
    {
        self.common_object_request_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_object_request_params][crate::model::ReadObjectRequest::common_object_request_params].
    pub fn set_or_clear_common_object_request_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonObjectRequestParams>,
    {
        self.common_object_request_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [read_mask][crate::model::ReadObjectRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::ReadObjectRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReadObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ReadObjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReadObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation,
            __read_offset,
            __read_limit,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __common_object_request_params,
            __read_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReadObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generation" => Ok(__FieldTag::__generation),
                            "readOffset" => Ok(__FieldTag::__read_offset),
                            "read_offset" => Ok(__FieldTag::__read_offset),
                            "readLimit" => Ok(__FieldTag::__read_limit),
                            "read_limit" => Ok(__FieldTag::__read_limit),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "if_metageneration_not_match" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "commonObjectRequestParams" => {
                                Ok(__FieldTag::__common_object_request_params)
                            }
                            "common_object_request_params" => {
                                Ok(__FieldTag::__common_object_request_params)
                            }
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReadObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReadObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__read_offset => {
                            if !fields.insert(__FieldTag::__read_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_offset",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.read_offset = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__read_limit => {
                            if !fields.insert(__FieldTag::__read_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_limit",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.read_limit = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__common_object_request_params => {
                            if !fields.insert(__FieldTag::__common_object_request_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_object_request_params",
                                ));
                            }
                            result.common_object_request_params = map.next_value::<std::option::Option<crate::model::CommonObjectRequestParams>>()?
                                ;
                        }
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_mask",
                                ));
                            }
                            result.read_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReadObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.object.is_empty() {
            state.serialize_entry("object", &self.object)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if !wkt::internal::is_default(&self.read_offset) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("readOffset", &__With(&self.read_offset))?;
        }
        if !wkt::internal::is_default(&self.read_limit) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("readLimit", &__With(&self.read_limit))?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifGenerationNotMatch",
                &__With(&self.if_generation_not_match),
            )?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationMatch",
                &__With(&self.if_metageneration_match),
            )?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationNotMatch",
                &__With(&self.if_metageneration_not_match),
            )?;
        }
        if self.common_object_request_params.is_some() {
            state.serialize_entry(
                "commonObjectRequestParams",
                &self.common_object_request_params,
            )?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetObject.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetObjectRequest {
    /// Required. Name of the bucket in which the object resides.
    pub bucket: std::string::String,

    /// Required. Name of the object.
    pub object: std::string::String,

    /// Optional. If present, selects a specific revision of this object (as
    /// opposed to the latest version, the default).
    pub generation: i64,

    /// If true, return the soft-deleted version of this object.
    pub soft_deleted: std::option::Option<bool>,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live generation
    /// does not match the given value. If no live object exists, the precondition
    /// fails. Setting to 0 makes the operation succeed only if there is a live
    /// version of the object.
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// Optional. A set of parameters common to Storage API requests concerning an
    /// object.
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    /// Mask specifying which fields to read.
    /// If no mask is specified, will default to all fields except metadata.acl and
    /// metadata.owner.
    ///
    /// * may be used to mean "all fields".
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. Restore token used to differentiate soft-deleted objects with the
    /// same name and generation. Only applicable for hierarchical namespace
    /// buckets and if soft_deleted is set to true. This parameter is optional, and
    /// is only required in the rare case when there are multiple soft-deleted
    /// objects with the same name and generation.
    pub restore_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::GetObjectRequest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::GetObjectRequest::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::GetObjectRequest::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [soft_deleted][crate::model::GetObjectRequest::soft_deleted].
    pub fn set_soft_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.soft_deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [soft_deleted][crate::model::GetObjectRequest::soft_deleted].
    pub fn set_or_clear_soft_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.soft_deleted = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_generation_match][crate::model::GetObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_match][crate::model::GetObjectRequest::if_generation_match].
    pub fn set_or_clear_if_generation_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::GetObjectRequest::if_generation_not_match].
    pub fn set_if_generation_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_not_match][crate::model::GetObjectRequest::if_generation_not_match].
    pub fn set_or_clear_if_generation_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::GetObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_match][crate::model::GetObjectRequest::if_metageneration_match].
    pub fn set_or_clear_if_metageneration_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::GetObjectRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_not_match][crate::model::GetObjectRequest::if_metageneration_not_match].
    pub fn set_or_clear_if_metageneration_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::GetObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonObjectRequestParams>,
    {
        self.common_object_request_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_object_request_params][crate::model::GetObjectRequest::common_object_request_params].
    pub fn set_or_clear_common_object_request_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonObjectRequestParams>,
    {
        self.common_object_request_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [read_mask][crate::model::GetObjectRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::GetObjectRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [restore_token][crate::model::GetObjectRequest::restore_token].
    pub fn set_restore_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.restore_token = v.into();
        self
    }
}

impl wkt::message::Message for GetObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.GetObjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation,
            __soft_deleted,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __common_object_request_params,
            __read_mask,
            __restore_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generation" => Ok(__FieldTag::__generation),
                            "softDeleted" => Ok(__FieldTag::__soft_deleted),
                            "soft_deleted" => Ok(__FieldTag::__soft_deleted),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "if_metageneration_not_match" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "commonObjectRequestParams" => {
                                Ok(__FieldTag::__common_object_request_params)
                            }
                            "common_object_request_params" => {
                                Ok(__FieldTag::__common_object_request_params)
                            }
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            "restoreToken" => Ok(__FieldTag::__restore_token),
                            "restore_token" => Ok(__FieldTag::__restore_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__soft_deleted => {
                            if !fields.insert(__FieldTag::__soft_deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for soft_deleted",
                                ));
                            }
                            result.soft_deleted = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__common_object_request_params => {
                            if !fields.insert(__FieldTag::__common_object_request_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_object_request_params",
                                ));
                            }
                            result.common_object_request_params = map.next_value::<std::option::Option<crate::model::CommonObjectRequestParams>>()?
                                ;
                        }
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_mask",
                                ));
                            }
                            result.read_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__restore_token => {
                            if !fields.insert(__FieldTag::__restore_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_token",
                                ));
                            }
                            result.restore_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.object.is_empty() {
            state.serialize_entry("object", &self.object)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if self.soft_deleted.is_some() {
            state.serialize_entry("softDeleted", &self.soft_deleted)?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifGenerationNotMatch",
                &__With(&self.if_generation_not_match),
            )?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationMatch",
                &__With(&self.if_metageneration_match),
            )?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationNotMatch",
                &__With(&self.if_metageneration_not_match),
            )?;
        }
        if self.common_object_request_params.is_some() {
            state.serialize_entry(
                "commonObjectRequestParams",
                &self.common_object_request_params,
            )?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self.restore_token.is_empty() {
            state.serialize_entry("restoreToken", &self.restore_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes an attempt to insert an object, possibly over multiple requests.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub(crate) struct WriteObjectSpec {
    /// Required. Destination object, including its name and its metadata.
    pub resource: std::option::Option<crate::model::Object>,

    /// Optional. Apply a predefined set of access controls to this object.
    /// Valid values are "authenticatedRead", "bucketOwnerFullControl",
    /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
    pub predefined_acl: std::string::String,

    /// Makes the operation conditional on whether the object's current
    /// generation matches the given value. Setting to 0 makes the operation
    /// succeed only if there are no live versions of the object.
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live
    /// generation does not match the given value. If no live object exists, the
    /// precondition fails. Setting to 0 makes the operation succeed only if
    /// there is a live version of the object.
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// The expected final object size being uploaded.
    /// If this value is set, closing the stream after writing fewer or more than
    /// `object_size` bytes will result in an OUT_OF_RANGE error.
    ///
    /// This situation is considered a client error, and if such an error occurs
    /// you must start the upload over from scratch, this time sending the correct
    /// number of bytes.
    pub object_size: std::option::Option<i64>,

    /// If true, the object will be created in appendable mode.
    /// This field may only be set when using BidiWriteObject.
    pub appendable: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WriteObjectSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource][crate::model::WriteObjectSpec::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Object>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::WriteObjectSpec::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Object>,
    {
        self.resource = v.map(|x| x.into());
        self
    }

    /// Sets the value of [predefined_acl][crate::model::WriteObjectSpec::predefined_acl].
    pub fn set_predefined_acl<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predefined_acl = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::WriteObjectSpec::if_generation_match].
    pub fn set_if_generation_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_match][crate::model::WriteObjectSpec::if_generation_match].
    pub fn set_or_clear_if_generation_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::WriteObjectSpec::if_generation_not_match].
    pub fn set_if_generation_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_not_match][crate::model::WriteObjectSpec::if_generation_not_match].
    pub fn set_or_clear_if_generation_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::WriteObjectSpec::if_metageneration_match].
    pub fn set_if_metageneration_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_match][crate::model::WriteObjectSpec::if_metageneration_match].
    pub fn set_or_clear_if_metageneration_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::WriteObjectSpec::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_not_match][crate::model::WriteObjectSpec::if_metageneration_not_match].
    pub fn set_or_clear_if_metageneration_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [object_size][crate::model::WriteObjectSpec::object_size].
    pub fn set_object_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.object_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object_size][crate::model::WriteObjectSpec::object_size].
    pub fn set_or_clear_object_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.object_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [appendable][crate::model::WriteObjectSpec::appendable].
    pub fn set_appendable<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.appendable = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [appendable][crate::model::WriteObjectSpec::appendable].
    pub fn set_or_clear_appendable<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.appendable = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WriteObjectSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.WriteObjectSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WriteObjectSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource,
            __predefined_acl,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __object_size,
            __appendable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WriteObjectSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resource" => Ok(__FieldTag::__resource),
                            "predefinedAcl" => Ok(__FieldTag::__predefined_acl),
                            "predefined_acl" => Ok(__FieldTag::__predefined_acl),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "if_metageneration_not_match" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "objectSize" => Ok(__FieldTag::__object_size),
                            "object_size" => Ok(__FieldTag::__object_size),
                            "appendable" => Ok(__FieldTag::__appendable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WriteObjectSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WriteObjectSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource =
                                map.next_value::<std::option::Option<crate::model::Object>>()?;
                        }
                        __FieldTag::__predefined_acl => {
                            if !fields.insert(__FieldTag::__predefined_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predefined_acl",
                                ));
                            }
                            result.predefined_acl = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__object_size => {
                            if !fields.insert(__FieldTag::__object_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_size",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.object_size = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__appendable => {
                            if !fields.insert(__FieldTag::__appendable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for appendable",
                                ));
                            }
                            result.appendable = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WriteObjectSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self.predefined_acl.is_empty() {
            state.serialize_entry("predefinedAcl", &self.predefined_acl)?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifGenerationNotMatch",
                &__With(&self.if_generation_not_match),
            )?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationMatch",
                &__With(&self.if_metageneration_match),
            )?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationNotMatch",
                &__With(&self.if_metageneration_not_match),
            )?;
        }
        if self.object_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("objectSize", &__With(&self.object_size))?;
        }
        if self.appendable.is_some() {
            state.serialize_entry("appendable", &self.appendable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListObjects.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListObjectsRequest {
    /// Required. Name of the bucket in which to look for objects.
    pub parent: std::string::String,

    /// Optional. Maximum number of `items` plus `prefixes` to return
    /// in a single page of responses. As duplicate `prefixes` are
    /// omitted, fewer total results may be returned than requested. The service
    /// will use this parameter or 1,000 items, whichever is smaller.
    pub page_size: i32,

    /// Optional. A previously-returned page token representing part of the larger
    /// set of results to view.
    pub page_token: std::string::String,

    /// Optional. If set, returns results in a directory-like mode. `items` will
    /// contain only objects whose names, aside from the `prefix`, do not contain
    /// `delimiter`. Objects whose names, aside from the `prefix`, contain
    /// `delimiter` will have their name, truncated after the `delimiter`, returned
    /// in `prefixes`. Duplicate `prefixes` are omitted.
    pub delimiter: std::string::String,

    /// Optional. If true, objects that end in exactly one instance of `delimiter`
    /// will have their metadata included in `items` in addition to
    /// `prefixes`.
    pub include_trailing_delimiter: bool,

    /// Optional. Filter results to objects whose names begin with this prefix.
    pub prefix: std::string::String,

    /// Optional. If `true`, lists all versions of an object as distinct results.
    /// For more information, see
    /// [Object
    /// Versioning](https://cloud.google.com/storage/docs/object-versioning).
    pub versions: bool,

    /// Mask specifying which fields to read from each result.
    /// If no mask is specified, will default to all fields except items.acl and
    /// items.owner.
    ///
    /// * may be used to mean "all fields".
    pub read_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. Filter results to objects whose names are lexicographically equal
    /// to or after lexicographic_start. If lexicographic_end is also set, the
    /// objects listed have names between lexicographic_start (inclusive) and
    /// lexicographic_end (exclusive).
    pub lexicographic_start: std::string::String,

    /// Optional. Filter results to objects whose names are lexicographically
    /// before lexicographic_end. If lexicographic_start is also set, the objects
    /// listed have names between lexicographic_start (inclusive) and
    /// lexicographic_end (exclusive).
    pub lexicographic_end: std::string::String,

    /// Optional. If true, only list all soft-deleted versions of the object.
    /// Soft delete policy is required to set this option.
    pub soft_deleted: bool,

    /// Optional. If true, will also include folders and managed folders (besides
    /// objects) in the returned `prefixes`. Requires `delimiter` to be set to '/'.
    pub include_folders_as_prefixes: bool,

    /// Optional. Filter results to objects and prefixes that match this glob
    /// pattern. See [List Objects Using
    /// Glob](https://cloud.google.com/storage/docs/json_api/v1/objects/list#list-objects-and-prefixes-using-glob)
    /// for the full syntax.
    pub match_glob: std::string::String,

    /// Optional. Filter the returned objects. Currently only supported for the
    /// `contexts` field. If `delimiter` is set, the returned `prefixes` are exempt
    /// from this filter.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListObjectsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListObjectsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListObjectsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListObjectsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [delimiter][crate::model::ListObjectsRequest::delimiter].
    pub fn set_delimiter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.delimiter = v.into();
        self
    }

    /// Sets the value of [include_trailing_delimiter][crate::model::ListObjectsRequest::include_trailing_delimiter].
    pub fn set_include_trailing_delimiter<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_trailing_delimiter = v.into();
        self
    }

    /// Sets the value of [prefix][crate::model::ListObjectsRequest::prefix].
    pub fn set_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.prefix = v.into();
        self
    }

    /// Sets the value of [versions][crate::model::ListObjectsRequest::versions].
    pub fn set_versions<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.versions = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListObjectsRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::ListObjectsRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lexicographic_start][crate::model::ListObjectsRequest::lexicographic_start].
    pub fn set_lexicographic_start<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lexicographic_start = v.into();
        self
    }

    /// Sets the value of [lexicographic_end][crate::model::ListObjectsRequest::lexicographic_end].
    pub fn set_lexicographic_end<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.lexicographic_end = v.into();
        self
    }

    /// Sets the value of [soft_deleted][crate::model::ListObjectsRequest::soft_deleted].
    pub fn set_soft_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.soft_deleted = v.into();
        self
    }

    /// Sets the value of [include_folders_as_prefixes][crate::model::ListObjectsRequest::include_folders_as_prefixes].
    pub fn set_include_folders_as_prefixes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_folders_as_prefixes = v.into();
        self
    }

    /// Sets the value of [match_glob][crate::model::ListObjectsRequest::match_glob].
    pub fn set_match_glob<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.match_glob = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListObjectsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListObjectsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ListObjectsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListObjectsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __delimiter,
            __include_trailing_delimiter,
            __prefix,
            __versions,
            __read_mask,
            __lexicographic_start,
            __lexicographic_end,
            __soft_deleted,
            __include_folders_as_prefixes,
            __match_glob,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListObjectsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "delimiter" => Ok(__FieldTag::__delimiter),
                            "includeTrailingDelimiter" => {
                                Ok(__FieldTag::__include_trailing_delimiter)
                            }
                            "include_trailing_delimiter" => {
                                Ok(__FieldTag::__include_trailing_delimiter)
                            }
                            "prefix" => Ok(__FieldTag::__prefix),
                            "versions" => Ok(__FieldTag::__versions),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            "lexicographicStart" => Ok(__FieldTag::__lexicographic_start),
                            "lexicographic_start" => Ok(__FieldTag::__lexicographic_start),
                            "lexicographicEnd" => Ok(__FieldTag::__lexicographic_end),
                            "lexicographic_end" => Ok(__FieldTag::__lexicographic_end),
                            "softDeleted" => Ok(__FieldTag::__soft_deleted),
                            "soft_deleted" => Ok(__FieldTag::__soft_deleted),
                            "includeFoldersAsPrefixes" => {
                                Ok(__FieldTag::__include_folders_as_prefixes)
                            }
                            "include_folders_as_prefixes" => {
                                Ok(__FieldTag::__include_folders_as_prefixes)
                            }
                            "matchGlob" => Ok(__FieldTag::__match_glob),
                            "match_glob" => Ok(__FieldTag::__match_glob),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListObjectsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListObjectsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delimiter => {
                            if !fields.insert(__FieldTag::__delimiter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delimiter",
                                ));
                            }
                            result.delimiter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__include_trailing_delimiter => {
                            if !fields.insert(__FieldTag::__include_trailing_delimiter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_trailing_delimiter",
                                ));
                            }
                            result.include_trailing_delimiter = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__prefix => {
                            if !fields.insert(__FieldTag::__prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prefix",
                                ));
                            }
                            result.prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versions",
                                ));
                            }
                            result.versions = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_mask",
                                ));
                            }
                            result.read_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__lexicographic_start => {
                            if !fields.insert(__FieldTag::__lexicographic_start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lexicographic_start",
                                ));
                            }
                            result.lexicographic_start = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lexicographic_end => {
                            if !fields.insert(__FieldTag::__lexicographic_end) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lexicographic_end",
                                ));
                            }
                            result.lexicographic_end = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__soft_deleted => {
                            if !fields.insert(__FieldTag::__soft_deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for soft_deleted",
                                ));
                            }
                            result.soft_deleted = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__include_folders_as_prefixes => {
                            if !fields.insert(__FieldTag::__include_folders_as_prefixes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_folders_as_prefixes",
                                ));
                            }
                            result.include_folders_as_prefixes = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__match_glob => {
                            if !fields.insert(__FieldTag::__match_glob) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match_glob",
                                ));
                            }
                            result.match_glob = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListObjectsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.delimiter.is_empty() {
            state.serialize_entry("delimiter", &self.delimiter)?;
        }
        if !wkt::internal::is_default(&self.include_trailing_delimiter) {
            state.serialize_entry("includeTrailingDelimiter", &self.include_trailing_delimiter)?;
        }
        if !self.prefix.is_empty() {
            state.serialize_entry("prefix", &self.prefix)?;
        }
        if !wkt::internal::is_default(&self.versions) {
            state.serialize_entry("versions", &self.versions)?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self.lexicographic_start.is_empty() {
            state.serialize_entry("lexicographicStart", &self.lexicographic_start)?;
        }
        if !self.lexicographic_end.is_empty() {
            state.serialize_entry("lexicographicEnd", &self.lexicographic_end)?;
        }
        if !wkt::internal::is_default(&self.soft_deleted) {
            state.serialize_entry("softDeleted", &self.soft_deleted)?;
        }
        if !wkt::internal::is_default(&self.include_folders_as_prefixes) {
            state.serialize_entry(
                "includeFoldersAsPrefixes",
                &self.include_folders_as_prefixes,
            )?;
        }
        if !self.match_glob.is_empty() {
            state.serialize_entry("matchGlob", &self.match_glob)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for RewriteObject.
/// If the source object is encrypted using a Customer-Supplied Encryption Key
/// the key information must be provided in the copy_source_encryption_algorithm,
/// copy_source_encryption_key_bytes, and copy_source_encryption_key_sha256_bytes
/// fields. If the destination object should be encrypted the keying information
/// should be provided in the encryption_algorithm, encryption_key_bytes, and
/// encryption_key_sha256_bytes fields of the
/// common_object_request_params.customer_encryption field.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RewriteObjectRequest {
    /// Required. Immutable. The name of the destination object.
    /// See the
    /// [Naming Guidelines](https://cloud.google.com/storage/docs/objects#naming).
    /// Example: `test.txt`
    /// The `name` field by itself does not uniquely identify a Cloud Storage
    /// object. A Cloud Storage object is uniquely identified by the tuple of
    /// (bucket, object, generation).
    pub destination_name: std::string::String,

    /// Required. Immutable. The name of the bucket containing the destination
    /// object.
    pub destination_bucket: std::string::String,

    /// Optional. The name of the Cloud KMS key that will be used to encrypt the
    /// destination object. The Cloud KMS key must be located in same location as
    /// the object. If the parameter is not specified, the request uses the
    /// destination bucket's default encryption key, if any, or else the
    /// Google-managed encryption key.
    pub destination_kms_key: std::string::String,

    /// Optional. Properties of the destination, post-rewrite object.
    /// The `name`, `bucket` and `kms_key` fields must not be populated (these
    /// values are specified in the `destination_name`, `destination_bucket`, and
    /// `destination_kms_key` fields).
    /// If `destination` is present it will be used to construct the destination
    /// object's metadata; otherwise the destination object's metadata will be
    /// copied from the source object.
    pub destination: std::option::Option<crate::model::Object>,

    /// Required. Name of the bucket in which to find the source object.
    pub source_bucket: std::string::String,

    /// Required. Name of the source object.
    pub source_object: std::string::String,

    /// Optional. If present, selects a specific revision of the source object (as
    /// opposed to the latest version, the default).
    pub source_generation: i64,

    /// Optional. Include this field (from the previous rewrite response) on each
    /// rewrite request after the first one, until the rewrite response 'done' flag
    /// is true. Calls that provide a rewriteToken can omit all other request
    /// fields, but if included those fields must match the values provided in the
    /// first rewrite request.
    pub rewrite_token: std::string::String,

    /// Optional. Apply a predefined set of access controls to the destination
    /// object. Valid values are "authenticatedRead", "bucketOwnerFullControl",
    /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
    pub destination_predefined_acl: std::string::String,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live generation
    /// does not match the given value. If no live object exists, the precondition
    /// fails. Setting to 0 makes the operation succeed only if there is a live
    /// version of the object.
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the destination object's current
    /// metageneration matches the given value.
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the destination object's current
    /// metageneration does not match the given value.
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the source object's live
    /// generation matches the given value.
    pub if_source_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the source object's live
    /// generation does not match the given value.
    pub if_source_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the source object's current
    /// metageneration matches the given value.
    pub if_source_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the source object's current
    /// metageneration does not match the given value.
    pub if_source_metageneration_not_match: std::option::Option<i64>,

    /// Optional. The maximum number of bytes that will be rewritten per rewrite
    /// request. Most callers shouldn't need to specify this parameter - it is
    /// primarily in place to support testing. If specified the value must be an
    /// integral multiple of 1 MiB (1048576). Also, this only applies to requests
    /// where the source and destination span locations and/or storage classes.
    /// Finally, this value must not change across rewrite calls else you'll get an
    /// error that the `rewriteToken` is invalid.
    pub max_bytes_rewritten_per_call: i64,

    /// Optional. The algorithm used to encrypt the source object, if any. Used if
    /// the source object was encrypted with a Customer-Supplied Encryption Key.
    pub copy_source_encryption_algorithm: std::string::String,

    /// Optional. The raw bytes (not base64-encoded) AES-256 encryption key used to
    /// encrypt the source object, if it was encrypted with a Customer-Supplied
    /// Encryption Key.
    pub copy_source_encryption_key_bytes: ::bytes::Bytes,

    /// Optional. The raw bytes (not base64-encoded) SHA256 hash of the encryption
    /// key used to encrypt the source object, if it was encrypted with a
    /// Customer-Supplied Encryption Key.
    pub copy_source_encryption_key_sha256_bytes: ::bytes::Bytes,

    /// Optional. A set of parameters common to Storage API requests concerning an
    /// object.
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    /// Optional. The checksums of the complete object. This will be used to
    /// validate the destination object after rewriting.
    pub object_checksums: std::option::Option<crate::model::ObjectChecksums>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RewriteObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination_name][crate::model::RewriteObjectRequest::destination_name].
    pub fn set_destination_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_name = v.into();
        self
    }

    /// Sets the value of [destination_bucket][crate::model::RewriteObjectRequest::destination_bucket].
    pub fn set_destination_bucket<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_bucket = v.into();
        self
    }

    /// Sets the value of [destination_kms_key][crate::model::RewriteObjectRequest::destination_kms_key].
    pub fn set_destination_kms_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_kms_key = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::RewriteObjectRequest::destination].
    pub fn set_destination<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Object>,
    {
        self.destination = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destination][crate::model::RewriteObjectRequest::destination].
    pub fn set_or_clear_destination<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Object>,
    {
        self.destination = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_bucket][crate::model::RewriteObjectRequest::source_bucket].
    pub fn set_source_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_bucket = v.into();
        self
    }

    /// Sets the value of [source_object][crate::model::RewriteObjectRequest::source_object].
    pub fn set_source_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_object = v.into();
        self
    }

    /// Sets the value of [source_generation][crate::model::RewriteObjectRequest::source_generation].
    pub fn set_source_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.source_generation = v.into();
        self
    }

    /// Sets the value of [rewrite_token][crate::model::RewriteObjectRequest::rewrite_token].
    pub fn set_rewrite_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rewrite_token = v.into();
        self
    }

    /// Sets the value of [destination_predefined_acl][crate::model::RewriteObjectRequest::destination_predefined_acl].
    pub fn set_destination_predefined_acl<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_predefined_acl = v.into();
        self
    }

    /// Sets the value of [if_generation_match][crate::model::RewriteObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_match][crate::model::RewriteObjectRequest::if_generation_match].
    pub fn set_or_clear_if_generation_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::RewriteObjectRequest::if_generation_not_match].
    pub fn set_if_generation_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_not_match][crate::model::RewriteObjectRequest::if_generation_not_match].
    pub fn set_or_clear_if_generation_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::RewriteObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_match][crate::model::RewriteObjectRequest::if_metageneration_match].
    pub fn set_or_clear_if_metageneration_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::RewriteObjectRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_not_match][crate::model::RewriteObjectRequest::if_metageneration_not_match].
    pub fn set_or_clear_if_metageneration_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_source_generation_match][crate::model::RewriteObjectRequest::if_source_generation_match].
    pub fn set_if_source_generation_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_generation_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_source_generation_match][crate::model::RewriteObjectRequest::if_source_generation_match].
    pub fn set_or_clear_if_source_generation_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_generation_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_source_generation_not_match][crate::model::RewriteObjectRequest::if_source_generation_not_match].
    pub fn set_if_source_generation_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_generation_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_source_generation_not_match][crate::model::RewriteObjectRequest::if_source_generation_not_match].
    pub fn set_or_clear_if_source_generation_not_match<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_generation_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_source_metageneration_match][crate::model::RewriteObjectRequest::if_source_metageneration_match].
    pub fn set_if_source_metageneration_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_metageneration_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_source_metageneration_match][crate::model::RewriteObjectRequest::if_source_metageneration_match].
    pub fn set_or_clear_if_source_metageneration_match<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_metageneration_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_source_metageneration_not_match][crate::model::RewriteObjectRequest::if_source_metageneration_not_match].
    pub fn set_if_source_metageneration_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_metageneration_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_source_metageneration_not_match][crate::model::RewriteObjectRequest::if_source_metageneration_not_match].
    pub fn set_or_clear_if_source_metageneration_not_match<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_metageneration_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_bytes_rewritten_per_call][crate::model::RewriteObjectRequest::max_bytes_rewritten_per_call].
    pub fn set_max_bytes_rewritten_per_call<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_bytes_rewritten_per_call = v.into();
        self
    }

    /// Sets the value of [copy_source_encryption_algorithm][crate::model::RewriteObjectRequest::copy_source_encryption_algorithm].
    pub fn set_copy_source_encryption_algorithm<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.copy_source_encryption_algorithm = v.into();
        self
    }

    /// Sets the value of [copy_source_encryption_key_bytes][crate::model::RewriteObjectRequest::copy_source_encryption_key_bytes].
    pub fn set_copy_source_encryption_key_bytes<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.copy_source_encryption_key_bytes = v.into();
        self
    }

    /// Sets the value of [copy_source_encryption_key_sha256_bytes][crate::model::RewriteObjectRequest::copy_source_encryption_key_sha256_bytes].
    pub fn set_copy_source_encryption_key_sha256_bytes<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.copy_source_encryption_key_sha256_bytes = v.into();
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::RewriteObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonObjectRequestParams>,
    {
        self.common_object_request_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_object_request_params][crate::model::RewriteObjectRequest::common_object_request_params].
    pub fn set_or_clear_common_object_request_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonObjectRequestParams>,
    {
        self.common_object_request_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [object_checksums][crate::model::RewriteObjectRequest::object_checksums].
    pub fn set_object_checksums<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ObjectChecksums>,
    {
        self.object_checksums = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object_checksums][crate::model::RewriteObjectRequest::object_checksums].
    pub fn set_or_clear_object_checksums<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ObjectChecksums>,
    {
        self.object_checksums = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RewriteObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.RewriteObjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RewriteObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __destination_name,
            __destination_bucket,
            __destination_kms_key,
            __destination,
            __source_bucket,
            __source_object,
            __source_generation,
            __rewrite_token,
            __destination_predefined_acl,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __if_source_generation_match,
            __if_source_generation_not_match,
            __if_source_metageneration_match,
            __if_source_metageneration_not_match,
            __max_bytes_rewritten_per_call,
            __copy_source_encryption_algorithm,
            __copy_source_encryption_key_bytes,
            __copy_source_encryption_key_sha256_bytes,
            __common_object_request_params,
            __object_checksums,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RewriteObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "destinationName" => Ok(__FieldTag::__destination_name),
                            "destination_name" => Ok(__FieldTag::__destination_name),
                            "destinationBucket" => Ok(__FieldTag::__destination_bucket),
                            "destination_bucket" => Ok(__FieldTag::__destination_bucket),
                            "destinationKmsKey" => Ok(__FieldTag::__destination_kms_key),
                            "destination_kms_key" => Ok(__FieldTag::__destination_kms_key),
                            "destination" => Ok(__FieldTag::__destination),
                            "sourceBucket" => Ok(__FieldTag::__source_bucket),
                            "source_bucket" => Ok(__FieldTag::__source_bucket),
                            "sourceObject" => Ok(__FieldTag::__source_object),
                            "source_object" => Ok(__FieldTag::__source_object),
                            "sourceGeneration" => Ok(__FieldTag::__source_generation),
                            "source_generation" => Ok(__FieldTag::__source_generation),
                            "rewriteToken" => Ok(__FieldTag::__rewrite_token),
                            "rewrite_token" => Ok(__FieldTag::__rewrite_token),
                            "destinationPredefinedAcl" => {
                                Ok(__FieldTag::__destination_predefined_acl)
                            }
                            "destination_predefined_acl" => {
                                Ok(__FieldTag::__destination_predefined_acl)
                            }
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "if_metageneration_not_match" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "ifSourceGenerationMatch" => {
                                Ok(__FieldTag::__if_source_generation_match)
                            }
                            "if_source_generation_match" => {
                                Ok(__FieldTag::__if_source_generation_match)
                            }
                            "ifSourceGenerationNotMatch" => {
                                Ok(__FieldTag::__if_source_generation_not_match)
                            }
                            "if_source_generation_not_match" => {
                                Ok(__FieldTag::__if_source_generation_not_match)
                            }
                            "ifSourceMetagenerationMatch" => {
                                Ok(__FieldTag::__if_source_metageneration_match)
                            }
                            "if_source_metageneration_match" => {
                                Ok(__FieldTag::__if_source_metageneration_match)
                            }
                            "ifSourceMetagenerationNotMatch" => {
                                Ok(__FieldTag::__if_source_metageneration_not_match)
                            }
                            "if_source_metageneration_not_match" => {
                                Ok(__FieldTag::__if_source_metageneration_not_match)
                            }
                            "maxBytesRewrittenPerCall" => {
                                Ok(__FieldTag::__max_bytes_rewritten_per_call)
                            }
                            "max_bytes_rewritten_per_call" => {
                                Ok(__FieldTag::__max_bytes_rewritten_per_call)
                            }
                            "copySourceEncryptionAlgorithm" => {
                                Ok(__FieldTag::__copy_source_encryption_algorithm)
                            }
                            "copy_source_encryption_algorithm" => {
                                Ok(__FieldTag::__copy_source_encryption_algorithm)
                            }
                            "copySourceEncryptionKeyBytes" => {
                                Ok(__FieldTag::__copy_source_encryption_key_bytes)
                            }
                            "copy_source_encryption_key_bytes" => {
                                Ok(__FieldTag::__copy_source_encryption_key_bytes)
                            }
                            "copySourceEncryptionKeySha256Bytes" => {
                                Ok(__FieldTag::__copy_source_encryption_key_sha256_bytes)
                            }
                            "copy_source_encryption_key_sha256_bytes" => {
                                Ok(__FieldTag::__copy_source_encryption_key_sha256_bytes)
                            }
                            "commonObjectRequestParams" => {
                                Ok(__FieldTag::__common_object_request_params)
                            }
                            "common_object_request_params" => {
                                Ok(__FieldTag::__common_object_request_params)
                            }
                            "objectChecksums" => Ok(__FieldTag::__object_checksums),
                            "object_checksums" => Ok(__FieldTag::__object_checksums),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RewriteObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RewriteObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__destination_name => {
                            if !fields.insert(__FieldTag::__destination_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_name",
                                ));
                            }
                            result.destination_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_bucket => {
                            if !fields.insert(__FieldTag::__destination_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_bucket",
                                ));
                            }
                            result.destination_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_kms_key => {
                            if !fields.insert(__FieldTag::__destination_kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_kms_key",
                                ));
                            }
                            result.destination_kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination",
                                ));
                            }
                            result.destination =
                                map.next_value::<std::option::Option<crate::model::Object>>()?;
                        }
                        __FieldTag::__source_bucket => {
                            if !fields.insert(__FieldTag::__source_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_bucket",
                                ));
                            }
                            result.source_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_object => {
                            if !fields.insert(__FieldTag::__source_object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_object",
                                ));
                            }
                            result.source_object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_generation => {
                            if !fields.insert(__FieldTag::__source_generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_generation =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__rewrite_token => {
                            if !fields.insert(__FieldTag::__rewrite_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rewrite_token",
                                ));
                            }
                            result.rewrite_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_predefined_acl => {
                            if !fields.insert(__FieldTag::__destination_predefined_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_predefined_acl",
                                ));
                            }
                            result.destination_predefined_acl = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_source_generation_match => {
                            if !fields.insert(__FieldTag::__if_source_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_source_generation_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_generation_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_source_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_source_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_source_generation_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_generation_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_source_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_source_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_source_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_metageneration_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_source_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_source_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_source_metageneration_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_metageneration_not_match =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__max_bytes_rewritten_per_call => {
                            if !fields.insert(__FieldTag::__max_bytes_rewritten_per_call) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_bytes_rewritten_per_call",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_bytes_rewritten_per_call =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__copy_source_encryption_algorithm => {
                            if !fields.insert(__FieldTag::__copy_source_encryption_algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for copy_source_encryption_algorithm",
                                ));
                            }
                            result.copy_source_encryption_algorithm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__copy_source_encryption_key_bytes => {
                            if !fields.insert(__FieldTag::__copy_source_encryption_key_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for copy_source_encryption_key_bytes",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.copy_source_encryption_key_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__copy_source_encryption_key_sha256_bytes => {
                            if !fields.insert(__FieldTag::__copy_source_encryption_key_sha256_bytes)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for copy_source_encryption_key_sha256_bytes",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.copy_source_encryption_key_sha256_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__common_object_request_params => {
                            if !fields.insert(__FieldTag::__common_object_request_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_object_request_params",
                                ));
                            }
                            result.common_object_request_params = map.next_value::<std::option::Option<crate::model::CommonObjectRequestParams>>()?
                                ;
                        }
                        __FieldTag::__object_checksums => {
                            if !fields.insert(__FieldTag::__object_checksums) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_checksums",
                                ));
                            }
                            result.object_checksums = map
                                .next_value::<std::option::Option<crate::model::ObjectChecksums>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RewriteObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.destination_name.is_empty() {
            state.serialize_entry("destinationName", &self.destination_name)?;
        }
        if !self.destination_bucket.is_empty() {
            state.serialize_entry("destinationBucket", &self.destination_bucket)?;
        }
        if !self.destination_kms_key.is_empty() {
            state.serialize_entry("destinationKmsKey", &self.destination_kms_key)?;
        }
        if self.destination.is_some() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if !self.source_bucket.is_empty() {
            state.serialize_entry("sourceBucket", &self.source_bucket)?;
        }
        if !self.source_object.is_empty() {
            state.serialize_entry("sourceObject", &self.source_object)?;
        }
        if !wkt::internal::is_default(&self.source_generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sourceGeneration", &__With(&self.source_generation))?;
        }
        if !self.rewrite_token.is_empty() {
            state.serialize_entry("rewriteToken", &self.rewrite_token)?;
        }
        if !self.destination_predefined_acl.is_empty() {
            state.serialize_entry("destinationPredefinedAcl", &self.destination_predefined_acl)?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifGenerationNotMatch",
                &__With(&self.if_generation_not_match),
            )?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationMatch",
                &__With(&self.if_metageneration_match),
            )?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationNotMatch",
                &__With(&self.if_metageneration_not_match),
            )?;
        }
        if self.if_source_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifSourceGenerationMatch",
                &__With(&self.if_source_generation_match),
            )?;
        }
        if self.if_source_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifSourceGenerationNotMatch",
                &__With(&self.if_source_generation_not_match),
            )?;
        }
        if self.if_source_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifSourceMetagenerationMatch",
                &__With(&self.if_source_metageneration_match),
            )?;
        }
        if self.if_source_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifSourceMetagenerationNotMatch",
                &__With(&self.if_source_metageneration_not_match),
            )?;
        }
        if !wkt::internal::is_default(&self.max_bytes_rewritten_per_call) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxBytesRewrittenPerCall",
                &__With(&self.max_bytes_rewritten_per_call),
            )?;
        }
        if !self.copy_source_encryption_algorithm.is_empty() {
            state.serialize_entry(
                "copySourceEncryptionAlgorithm",
                &self.copy_source_encryption_algorithm,
            )?;
        }
        if !self.copy_source_encryption_key_bytes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "copySourceEncryptionKeyBytes",
                &__With(&self.copy_source_encryption_key_bytes),
            )?;
        }
        if !self.copy_source_encryption_key_sha256_bytes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "copySourceEncryptionKeySha256Bytes",
                &__With(&self.copy_source_encryption_key_sha256_bytes),
            )?;
        }
        if self.common_object_request_params.is_some() {
            state.serialize_entry(
                "commonObjectRequestParams",
                &self.common_object_request_params,
            )?;
        }
        if self.object_checksums.is_some() {
            state.serialize_entry("objectChecksums", &self.object_checksums)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A rewrite response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RewriteResponse {
    /// The total bytes written so far, which can be used to provide a waiting user
    /// with a progress indicator. This property is always present in the response.
    pub total_bytes_rewritten: i64,

    /// The total size of the object being copied in bytes. This property is always
    /// present in the response.
    pub object_size: i64,

    /// `true` if the copy is finished; otherwise, `false` if
    /// the copy is in progress. This property is always present in the response.
    pub done: bool,

    /// A token to use in subsequent requests to continue copying data. This token
    /// is present in the response only when there is more data to copy.
    pub rewrite_token: std::string::String,

    /// A resource containing the metadata for the copied-to object. This property
    /// is present in the response only when copying completes.
    pub resource: std::option::Option<crate::model::Object>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RewriteResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_bytes_rewritten][crate::model::RewriteResponse::total_bytes_rewritten].
    pub fn set_total_bytes_rewritten<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_bytes_rewritten = v.into();
        self
    }

    /// Sets the value of [object_size][crate::model::RewriteResponse::object_size].
    pub fn set_object_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.object_size = v.into();
        self
    }

    /// Sets the value of [done][crate::model::RewriteResponse::done].
    pub fn set_done<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.done = v.into();
        self
    }

    /// Sets the value of [rewrite_token][crate::model::RewriteResponse::rewrite_token].
    pub fn set_rewrite_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rewrite_token = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::RewriteResponse::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Object>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::RewriteResponse::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Object>,
    {
        self.resource = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RewriteResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.RewriteResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RewriteResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __total_bytes_rewritten,
            __object_size,
            __done,
            __rewrite_token,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RewriteResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "totalBytesRewritten" => Ok(__FieldTag::__total_bytes_rewritten),
                            "total_bytes_rewritten" => Ok(__FieldTag::__total_bytes_rewritten),
                            "objectSize" => Ok(__FieldTag::__object_size),
                            "object_size" => Ok(__FieldTag::__object_size),
                            "done" => Ok(__FieldTag::__done),
                            "rewriteToken" => Ok(__FieldTag::__rewrite_token),
                            "rewrite_token" => Ok(__FieldTag::__rewrite_token),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RewriteResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RewriteResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__total_bytes_rewritten => {
                            if !fields.insert(__FieldTag::__total_bytes_rewritten) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_bytes_rewritten",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_bytes_rewritten =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__object_size => {
                            if !fields.insert(__FieldTag::__object_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_size",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.object_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__done => {
                            if !fields.insert(__FieldTag::__done) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for done",
                                ));
                            }
                            result.done = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rewrite_token => {
                            if !fields.insert(__FieldTag::__rewrite_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rewrite_token",
                                ));
                            }
                            result.rewrite_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource =
                                map.next_value::<std::option::Option<crate::model::Object>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RewriteResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.total_bytes_rewritten) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalBytesRewritten", &__With(&self.total_bytes_rewritten))?;
        }
        if !wkt::internal::is_default(&self.object_size) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("objectSize", &__With(&self.object_size))?;
        }
        if !wkt::internal::is_default(&self.done) {
            state.serialize_entry("done", &self.done)?;
        }
        if !self.rewrite_token.is_empty() {
            state.serialize_entry("rewriteToken", &self.rewrite_token)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for MoveObject.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveObjectRequest {
    /// Required. Name of the bucket in which the object resides.
    pub bucket: std::string::String,

    /// Required. Name of the source object.
    pub source_object: std::string::String,

    /// Required. Name of the destination object.
    pub destination_object: std::string::String,

    /// Optional. Makes the operation conditional on whether the source object's
    /// current generation matches the given value. `if_source_generation_match`
    /// and `if_source_generation_not_match` conditions are mutually exclusive:
    /// it's an error for both of them to be set in the request.
    pub if_source_generation_match: std::option::Option<i64>,

    /// Optional. Makes the operation conditional on whether the source object's
    /// current generation does not match the given value.
    /// `if_source_generation_match` and `if_source_generation_not_match`
    /// conditions are mutually exclusive: it's an error for both of them to be set
    /// in the request.
    pub if_source_generation_not_match: std::option::Option<i64>,

    /// Optional. Makes the operation conditional on whether the source object's
    /// current metageneration matches the given value.
    /// `if_source_metageneration_match` and `if_source_metageneration_not_match`
    /// conditions are mutually exclusive: it's an error for both of them to be set
    /// in the request.
    pub if_source_metageneration_match: std::option::Option<i64>,

    /// Optional. Makes the operation conditional on whether the source object's
    /// current metageneration does not match the given value.
    /// `if_source_metageneration_match` and `if_source_metageneration_not_match`
    /// conditions are mutually exclusive: it's an error for both of them to be set
    /// in the request.
    pub if_source_metageneration_not_match: std::option::Option<i64>,

    /// Optional. Makes the operation conditional on whether the destination
    /// object's current generation matches the given value. Setting to 0 makes the
    /// operation succeed only if there are no live versions of the object.
    /// `if_generation_match` and `if_generation_not_match` conditions are mutually
    /// exclusive: it's an error for both of them to be set in the request.
    pub if_generation_match: std::option::Option<i64>,

    /// Optional. Makes the operation conditional on whether the destination
    /// object's current generation does not match the given value. If no live
    /// object exists, the precondition fails. Setting to 0 makes the operation
    /// succeed only if there is a live version of the object.
    /// `if_generation_match` and `if_generation_not_match` conditions are mutually
    /// exclusive: it's an error for both of them to be set in the request.
    pub if_generation_not_match: std::option::Option<i64>,

    /// Optional. Makes the operation conditional on whether the destination
    /// object's current metageneration matches the given value.
    /// `if_metageneration_match` and `if_metageneration_not_match` conditions are
    /// mutually exclusive: it's an error for both of them to be set in the
    /// request.
    pub if_metageneration_match: std::option::Option<i64>,

    /// Optional. Makes the operation conditional on whether the destination
    /// object's current metageneration does not match the given value.
    /// `if_metageneration_match` and `if_metageneration_not_match` conditions are
    /// mutually exclusive: it's an error for both of them to be set in the
    /// request.
    pub if_metageneration_not_match: std::option::Option<i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::MoveObjectRequest::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [source_object][crate::model::MoveObjectRequest::source_object].
    pub fn set_source_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_object = v.into();
        self
    }

    /// Sets the value of [destination_object][crate::model::MoveObjectRequest::destination_object].
    pub fn set_destination_object<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_object = v.into();
        self
    }

    /// Sets the value of [if_source_generation_match][crate::model::MoveObjectRequest::if_source_generation_match].
    pub fn set_if_source_generation_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_generation_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_source_generation_match][crate::model::MoveObjectRequest::if_source_generation_match].
    pub fn set_or_clear_if_source_generation_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_generation_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_source_generation_not_match][crate::model::MoveObjectRequest::if_source_generation_not_match].
    pub fn set_if_source_generation_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_generation_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_source_generation_not_match][crate::model::MoveObjectRequest::if_source_generation_not_match].
    pub fn set_or_clear_if_source_generation_not_match<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_generation_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_source_metageneration_match][crate::model::MoveObjectRequest::if_source_metageneration_match].
    pub fn set_if_source_metageneration_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_metageneration_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_source_metageneration_match][crate::model::MoveObjectRequest::if_source_metageneration_match].
    pub fn set_or_clear_if_source_metageneration_match<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_metageneration_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_source_metageneration_not_match][crate::model::MoveObjectRequest::if_source_metageneration_not_match].
    pub fn set_if_source_metageneration_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_metageneration_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_source_metageneration_not_match][crate::model::MoveObjectRequest::if_source_metageneration_not_match].
    pub fn set_or_clear_if_source_metageneration_not_match<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_source_metageneration_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_generation_match][crate::model::MoveObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_match][crate::model::MoveObjectRequest::if_generation_match].
    pub fn set_or_clear_if_generation_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::MoveObjectRequest::if_generation_not_match].
    pub fn set_if_generation_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_not_match][crate::model::MoveObjectRequest::if_generation_not_match].
    pub fn set_or_clear_if_generation_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::MoveObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_match][crate::model::MoveObjectRequest::if_metageneration_match].
    pub fn set_or_clear_if_metageneration_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::MoveObjectRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_not_match][crate::model::MoveObjectRequest::if_metageneration_not_match].
    pub fn set_or_clear_if_metageneration_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MoveObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.MoveObjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MoveObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __source_object,
            __destination_object,
            __if_source_generation_match,
            __if_source_generation_not_match,
            __if_source_metageneration_match,
            __if_source_metageneration_not_match,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MoveObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "sourceObject" => Ok(__FieldTag::__source_object),
                            "source_object" => Ok(__FieldTag::__source_object),
                            "destinationObject" => Ok(__FieldTag::__destination_object),
                            "destination_object" => Ok(__FieldTag::__destination_object),
                            "ifSourceGenerationMatch" => {
                                Ok(__FieldTag::__if_source_generation_match)
                            }
                            "if_source_generation_match" => {
                                Ok(__FieldTag::__if_source_generation_match)
                            }
                            "ifSourceGenerationNotMatch" => {
                                Ok(__FieldTag::__if_source_generation_not_match)
                            }
                            "if_source_generation_not_match" => {
                                Ok(__FieldTag::__if_source_generation_not_match)
                            }
                            "ifSourceMetagenerationMatch" => {
                                Ok(__FieldTag::__if_source_metageneration_match)
                            }
                            "if_source_metageneration_match" => {
                                Ok(__FieldTag::__if_source_metageneration_match)
                            }
                            "ifSourceMetagenerationNotMatch" => {
                                Ok(__FieldTag::__if_source_metageneration_not_match)
                            }
                            "if_source_metageneration_not_match" => {
                                Ok(__FieldTag::__if_source_metageneration_not_match)
                            }
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "if_metageneration_not_match" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MoveObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MoveObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_object => {
                            if !fields.insert(__FieldTag::__source_object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_object",
                                ));
                            }
                            result.source_object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_object => {
                            if !fields.insert(__FieldTag::__destination_object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_object",
                                ));
                            }
                            result.destination_object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__if_source_generation_match => {
                            if !fields.insert(__FieldTag::__if_source_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_source_generation_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_generation_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_source_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_source_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_source_generation_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_generation_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_source_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_source_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_source_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_metageneration_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_source_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_source_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_source_metageneration_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_metageneration_not_match =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MoveObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.source_object.is_empty() {
            state.serialize_entry("sourceObject", &self.source_object)?;
        }
        if !self.destination_object.is_empty() {
            state.serialize_entry("destinationObject", &self.destination_object)?;
        }
        if self.if_source_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifSourceGenerationMatch",
                &__With(&self.if_source_generation_match),
            )?;
        }
        if self.if_source_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifSourceGenerationNotMatch",
                &__With(&self.if_source_generation_not_match),
            )?;
        }
        if self.if_source_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifSourceMetagenerationMatch",
                &__With(&self.if_source_metageneration_match),
            )?;
        }
        if self.if_source_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifSourceMetagenerationNotMatch",
                &__With(&self.if_source_metageneration_not_match),
            )?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifGenerationNotMatch",
                &__With(&self.if_generation_not_match),
            )?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationMatch",
                &__With(&self.if_metageneration_match),
            )?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationNotMatch",
                &__With(&self.if_metageneration_not_match),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateObject.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateObjectRequest {
    /// Required. The object to update.
    /// The object's bucket and name fields are used to identify the object to
    /// update. If present, the object's generation field selects a specific
    /// revision of this object whose metadata should be updated. Otherwise,
    /// assumes the live version of the object.
    pub object: std::option::Option<crate::model::Object>,

    /// Makes the operation conditional on whether the object's current generation
    /// matches the given value. Setting to 0 makes the operation succeed only if
    /// there are no live versions of the object.
    pub if_generation_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's live generation
    /// does not match the given value. If no live object exists, the precondition
    /// fails. Setting to 0 makes the operation succeed only if there is a live
    /// version of the object.
    pub if_generation_not_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    pub if_metageneration_match: std::option::Option<i64>,

    /// Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    pub if_metageneration_not_match: std::option::Option<i64>,

    /// Optional. Apply a predefined set of access controls to this object.
    /// Valid values are "authenticatedRead", "bucketOwnerFullControl",
    /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
    pub predefined_acl: std::string::String,

    /// Required. List of fields to be updated.
    ///
    /// To specify ALL fields, equivalent to the JSON API's "update" function,
    /// specify a single field with the value `*`. Note: not recommended. If a new
    /// field is introduced at a later time, an older client updating with the `*`
    /// may accidentally reset the new field's value.
    ///
    /// Not specifying any fields is an error.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. A set of parameters common to Storage API requests concerning an
    /// object.
    pub common_object_request_params: std::option::Option<crate::model::CommonObjectRequestParams>,

    /// Optional. Overrides the unlocked retention config on the object.
    pub override_unlocked_retention: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateObjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object][crate::model::UpdateObjectRequest::object].
    pub fn set_object<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Object>,
    {
        self.object = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object][crate::model::UpdateObjectRequest::object].
    pub fn set_or_clear_object<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Object>,
    {
        self.object = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_generation_match][crate::model::UpdateObjectRequest::if_generation_match].
    pub fn set_if_generation_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_match][crate::model::UpdateObjectRequest::if_generation_match].
    pub fn set_or_clear_if_generation_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_generation_not_match][crate::model::UpdateObjectRequest::if_generation_not_match].
    pub fn set_if_generation_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_generation_not_match][crate::model::UpdateObjectRequest::if_generation_not_match].
    pub fn set_or_clear_if_generation_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_generation_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_match][crate::model::UpdateObjectRequest::if_metageneration_match].
    pub fn set_if_metageneration_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_match][crate::model::UpdateObjectRequest::if_metageneration_match].
    pub fn set_or_clear_if_metageneration_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [if_metageneration_not_match][crate::model::UpdateObjectRequest::if_metageneration_not_match].
    pub fn set_if_metageneration_not_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [if_metageneration_not_match][crate::model::UpdateObjectRequest::if_metageneration_not_match].
    pub fn set_or_clear_if_metageneration_not_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.if_metageneration_not_match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [predefined_acl][crate::model::UpdateObjectRequest::predefined_acl].
    pub fn set_predefined_acl<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.predefined_acl = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateObjectRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateObjectRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [common_object_request_params][crate::model::UpdateObjectRequest::common_object_request_params].
    pub fn set_common_object_request_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonObjectRequestParams>,
    {
        self.common_object_request_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_object_request_params][crate::model::UpdateObjectRequest::common_object_request_params].
    pub fn set_or_clear_common_object_request_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonObjectRequestParams>,
    {
        self.common_object_request_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [override_unlocked_retention][crate::model::UpdateObjectRequest::override_unlocked_retention].
    pub fn set_override_unlocked_retention<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.override_unlocked_retention = v.into();
        self
    }
}

impl wkt::message::Message for UpdateObjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.UpdateObjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __object,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __predefined_acl,
            __update_mask,
            __common_object_request_params,
            __override_unlocked_retention,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "object" => Ok(__FieldTag::__object),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "if_metageneration_not_match" => {
                                Ok(__FieldTag::__if_metageneration_not_match)
                            }
                            "predefinedAcl" => Ok(__FieldTag::__predefined_acl),
                            "predefined_acl" => Ok(__FieldTag::__predefined_acl),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "commonObjectRequestParams" => {
                                Ok(__FieldTag::__common_object_request_params)
                            }
                            "common_object_request_params" => {
                                Ok(__FieldTag::__common_object_request_params)
                            }
                            "overrideUnlockedRetention" => {
                                Ok(__FieldTag::__override_unlocked_retention)
                            }
                            "override_unlocked_retention" => {
                                Ok(__FieldTag::__override_unlocked_retention)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object =
                                map.next_value::<std::option::Option<crate::model::Object>>()?;
                        }
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_generation_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for if_metageneration_not_match",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__predefined_acl => {
                            if !fields.insert(__FieldTag::__predefined_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predefined_acl",
                                ));
                            }
                            result.predefined_acl = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__common_object_request_params => {
                            if !fields.insert(__FieldTag::__common_object_request_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_object_request_params",
                                ));
                            }
                            result.common_object_request_params = map.next_value::<std::option::Option<crate::model::CommonObjectRequestParams>>()?
                                ;
                        }
                        __FieldTag::__override_unlocked_retention => {
                            if !fields.insert(__FieldTag::__override_unlocked_retention) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_unlocked_retention",
                                ));
                            }
                            result.override_unlocked_retention = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.object.is_some() {
            state.serialize_entry("object", &self.object)?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifGenerationNotMatch",
                &__With(&self.if_generation_not_match),
            )?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationMatch",
                &__With(&self.if_metageneration_match),
            )?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "ifMetagenerationNotMatch",
                &__With(&self.if_metageneration_not_match),
            )?;
        }
        if !self.predefined_acl.is_empty() {
            state.serialize_entry("predefinedAcl", &self.predefined_acl)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.common_object_request_params.is_some() {
            state.serialize_entry(
                "commonObjectRequestParams",
                &self.common_object_request_params,
            )?;
        }
        if !wkt::internal::is_default(&self.override_unlocked_retention) {
            state.serialize_entry(
                "overrideUnlockedRetention",
                &self.override_unlocked_retention,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Parameters that can be passed to any object request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CommonObjectRequestParams {
    /// Optional. Encryption algorithm used with the Customer-Supplied Encryption
    /// Keys feature.
    pub encryption_algorithm: std::string::String,

    /// Optional. Encryption key used with the Customer-Supplied Encryption Keys
    /// feature. In raw bytes format (not base64-encoded).
    pub encryption_key_bytes: ::bytes::Bytes,

    /// Optional. SHA256 hash of encryption key used with the Customer-Supplied
    /// Encryption Keys feature.
    pub encryption_key_sha256_bytes: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommonObjectRequestParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_algorithm][crate::model::CommonObjectRequestParams::encryption_algorithm].
    pub fn set_encryption_algorithm<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_algorithm = v.into();
        self
    }

    /// Sets the value of [encryption_key_bytes][crate::model::CommonObjectRequestParams::encryption_key_bytes].
    pub fn set_encryption_key_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.encryption_key_bytes = v.into();
        self
    }

    /// Sets the value of [encryption_key_sha256_bytes][crate::model::CommonObjectRequestParams::encryption_key_sha256_bytes].
    pub fn set_encryption_key_sha256_bytes<T: std::convert::Into<::bytes::Bytes>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_key_sha256_bytes = v.into();
        self
    }
}

impl wkt::message::Message for CommonObjectRequestParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.CommonObjectRequestParams"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CommonObjectRequestParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encryption_algorithm,
            __encryption_key_bytes,
            __encryption_key_sha256_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommonObjectRequestParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encryptionAlgorithm" => Ok(__FieldTag::__encryption_algorithm),
                            "encryption_algorithm" => Ok(__FieldTag::__encryption_algorithm),
                            "encryptionKeyBytes" => Ok(__FieldTag::__encryption_key_bytes),
                            "encryption_key_bytes" => Ok(__FieldTag::__encryption_key_bytes),
                            "encryptionKeySha256Bytes" => {
                                Ok(__FieldTag::__encryption_key_sha256_bytes)
                            }
                            "encryption_key_sha256_bytes" => {
                                Ok(__FieldTag::__encryption_key_sha256_bytes)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CommonObjectRequestParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommonObjectRequestParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encryption_algorithm => {
                            if !fields.insert(__FieldTag::__encryption_algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_algorithm",
                                ));
                            }
                            result.encryption_algorithm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_key_bytes => {
                            if !fields.insert(__FieldTag::__encryption_key_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_key_bytes",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.encryption_key_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__encryption_key_sha256_bytes => {
                            if !fields.insert(__FieldTag::__encryption_key_sha256_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_key_sha256_bytes",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.encryption_key_sha256_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CommonObjectRequestParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.encryption_algorithm.is_empty() {
            state.serialize_entry("encryptionAlgorithm", &self.encryption_algorithm)?;
        }
        if !self.encryption_key_bytes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("encryptionKeyBytes", &__With(&self.encryption_key_bytes))?;
        }
        if !self.encryption_key_sha256_bytes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "encryptionKeySha256Bytes",
                &__With(&self.encryption_key_sha256_bytes),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A bucket.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Bucket {
    /// Identifier. The name of the bucket.
    /// Format: `projects/{project}/buckets/{bucket}`
    pub name: std::string::String,

    /// Output only. The user-chosen part of the bucket name. The `{bucket}`
    /// portion of the `name` field. For globally unique buckets, this is equal to
    /// the "bucket name" of other Cloud Storage APIs. Example: "pub".
    pub bucket_id: std::string::String,

    /// The etag of the bucket.
    /// If included in the metadata of an UpdateBucketRequest, the operation will
    /// only be performed if the etag matches that of the bucket.
    pub etag: std::string::String,

    /// Immutable. The project which owns this bucket, in the format of
    /// "projects/{projectIdentifier}".
    /// {projectIdentifier} can be the project ID or project number.
    /// Output values will always be in project number format.
    pub project: std::string::String,

    /// Output only. The metadata generation of this bucket.
    pub metageneration: i64,

    /// Immutable. The location of the bucket. Object data for objects in the
    /// bucket resides in physical storage within this region.  Defaults to `US`.
    /// See the
    /// [<https://developers.google.com/storage/docs/concepts-techniques#specifyinglocations>"][developer's
    /// guide] for the authoritative list. Attempting to update this field after
    /// the bucket is created will result in an error.
    pub location: std::string::String,

    /// Output only. The location type of the bucket (region, dual-region,
    /// multi-region, etc).
    pub location_type: std::string::String,

    /// Optional. The bucket's default storage class, used whenever no storageClass
    /// is specified for a newly-created object. This defines how objects in the
    /// bucket are stored and determines the SLA and the cost of storage.
    /// If this value is not specified when the bucket is created, it will default
    /// to `STANDARD`. For more information, see
    /// <https://developers.google.com/storage/docs/storage-classes>.
    pub storage_class: std::string::String,

    /// Optional. The recovery point objective for cross-region replication of the
    /// bucket. Applicable only for dual- and multi-region buckets. "DEFAULT" uses
    /// default replication. "ASYNC_TURBO" enables turbo replication, valid for
    /// dual-region buckets only. If rpo is not specified when the bucket is
    /// created, it defaults to "DEFAULT". For more information, see
    /// <https://cloud.google.com/storage/docs/availability-durability#turbo-replication>.
    pub rpo: std::string::String,

    /// Optional. Access controls on the bucket.
    /// If iam_config.uniform_bucket_level_access is enabled on this bucket,
    /// requests to set, read, or modify acl is an error.
    pub acl: std::vec::Vec<crate::model::BucketAccessControl>,

    /// Optional. Default access controls to apply to new objects when no ACL is
    /// provided. If iam_config.uniform_bucket_level_access is enabled on this
    /// bucket, requests to set, read, or modify acl is an error.
    pub default_object_acl: std::vec::Vec<crate::model::ObjectAccessControl>,

    /// Optional. The bucket's lifecycle config. See
    /// [<https://developers.google.com/storage/docs/lifecycle>]Lifecycle Management]
    /// for more information.
    pub lifecycle: std::option::Option<crate::model::bucket::Lifecycle>,

    /// Output only. The creation time of the bucket.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The bucket's [<https://www.w3.org/TR/cors/>][Cross-Origin Resource
    /// Sharing] (CORS) config.
    pub cors: std::vec::Vec<crate::model::bucket::Cors>,

    /// Output only. The modification time of the bucket.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The default value for event-based hold on newly created objects
    /// in this bucket.  Event-based hold is a way to retain objects indefinitely
    /// until an event occurs, signified by the hold's release. After being
    /// released, such objects will be subject to bucket-level retention (if any).
    /// One sample use case of this flag is for banks to hold loan documents for at
    /// least 3 years after loan is paid in full. Here, bucket-level retention is 3
    /// years and the event is loan being paid in full. In this example, these
    /// objects will be held intact for any number of years until the event has
    /// occurred (event-based hold on the object is released) and then 3 more years
    /// after that. That means retention duration of the objects begins from the
    /// moment event-based hold transitioned from true to false.  Objects under
    /// event-based hold cannot be deleted, overwritten or archived until the hold
    /// is removed.
    pub default_event_based_hold: bool,

    /// Optional. User-provided labels, in key/value pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The bucket's website config, controlling how the service behaves
    /// when accessing bucket contents as a web site. See the
    /// [<https://cloud.google.com/storage/docs/static-website>][Static Website
    /// Examples] for more information.
    pub website: std::option::Option<crate::model::bucket::Website>,

    /// Optional. The bucket's versioning config.
    pub versioning: std::option::Option<crate::model::bucket::Versioning>,

    /// Optional. The bucket's logging config, which defines the destination bucket
    /// and name prefix (if any) for the current bucket's logs.
    pub logging: std::option::Option<crate::model::bucket::Logging>,

    /// Output only. The owner of the bucket. This is always the project team's
    /// owner group.
    pub owner: std::option::Option<crate::model::Owner>,

    /// Optional. Encryption config for a bucket.
    pub encryption: std::option::Option<crate::model::bucket::Encryption>,

    /// Optional. The bucket's billing config.
    pub billing: std::option::Option<crate::model::bucket::Billing>,

    /// Optional. The bucket's retention policy. The retention policy enforces a
    /// minimum retention time for all objects contained in the bucket, based on
    /// their creation time. Any attempt to overwrite or delete objects younger
    /// than the retention period will result in a PERMISSION_DENIED error.  An
    /// unlocked retention policy can be modified or removed from the bucket via a
    /// storage.buckets.update operation. A locked retention policy cannot be
    /// removed or shortened in duration for the lifetime of the bucket.
    /// Attempting to remove or decrease period of a locked retention policy will
    /// result in a PERMISSION_DENIED error.
    pub retention_policy: std::option::Option<crate::model::bucket::RetentionPolicy>,

    /// Optional. The bucket's IAM config.
    pub iam_config: std::option::Option<crate::model::bucket::IamConfig>,

    /// Optional. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Optional. Configuration that, if present, specifies the data placement for
    /// a
    /// [<https://cloud.google.com/storage/docs/locations#location-dr>][configurable
    /// dual-region].
    pub custom_placement_config: std::option::Option<crate::model::bucket::CustomPlacementConfig>,

    /// Optional. The bucket's Autoclass configuration. If there is no
    /// configuration, the Autoclass feature will be disabled and have no effect on
    /// the bucket.
    pub autoclass: std::option::Option<crate::model::bucket::Autoclass>,

    /// Optional. The bucket's hierarchical namespace configuration. If there is no
    /// configuration, the hierarchical namespace feature will be disabled and have
    /// no effect on the bucket.
    pub hierarchical_namespace: std::option::Option<crate::model::bucket::HierarchicalNamespace>,

    /// Optional. The bucket's soft delete policy. The soft delete policy prevents
    /// soft-deleted objects from being permanently deleted.
    pub soft_delete_policy: std::option::Option<crate::model::bucket::SoftDeletePolicy>,

    /// Optional. The bucket's object retention configuration. Must be enabled
    /// before objects in the bucket may have retention configured.
    pub object_retention: std::option::Option<crate::model::bucket::ObjectRetention>,

    /// Optional. The bucket's IP filter configuration.
    pub ip_filter: std::option::Option<crate::model::bucket::IpFilter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Bucket {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Bucket::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [bucket_id][crate::model::Bucket::bucket_id].
    pub fn set_bucket_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Bucket::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [project][crate::model::Bucket::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [metageneration][crate::model::Bucket::metageneration].
    pub fn set_metageneration<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.metageneration = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Bucket::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [location_type][crate::model::Bucket::location_type].
    pub fn set_location_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_type = v.into();
        self
    }

    /// Sets the value of [storage_class][crate::model::Bucket::storage_class].
    pub fn set_storage_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_class = v.into();
        self
    }

    /// Sets the value of [rpo][crate::model::Bucket::rpo].
    pub fn set_rpo<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rpo = v.into();
        self
    }

    /// Sets the value of [acl][crate::model::Bucket::acl].
    pub fn set_acl<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BucketAccessControl>,
    {
        use std::iter::Iterator;
        self.acl = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_object_acl][crate::model::Bucket::default_object_acl].
    pub fn set_default_object_acl<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ObjectAccessControl>,
    {
        use std::iter::Iterator;
        self.default_object_acl = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [lifecycle][crate::model::Bucket::lifecycle].
    pub fn set_lifecycle<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bucket::Lifecycle>,
    {
        self.lifecycle = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lifecycle][crate::model::Bucket::lifecycle].
    pub fn set_or_clear_lifecycle<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bucket::Lifecycle>,
    {
        self.lifecycle = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Bucket::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Bucket::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cors][crate::model::Bucket::cors].
    pub fn set_cors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::bucket::Cors>,
    {
        use std::iter::Iterator;
        self.cors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::Bucket::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Bucket::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_event_based_hold][crate::model::Bucket::default_event_based_hold].
    pub fn set_default_event_based_hold<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.default_event_based_hold = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Bucket::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [website][crate::model::Bucket::website].
    pub fn set_website<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bucket::Website>,
    {
        self.website = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [website][crate::model::Bucket::website].
    pub fn set_or_clear_website<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bucket::Website>,
    {
        self.website = v.map(|x| x.into());
        self
    }

    /// Sets the value of [versioning][crate::model::Bucket::versioning].
    pub fn set_versioning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bucket::Versioning>,
    {
        self.versioning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [versioning][crate::model::Bucket::versioning].
    pub fn set_or_clear_versioning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bucket::Versioning>,
    {
        self.versioning = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging][crate::model::Bucket::logging].
    pub fn set_logging<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bucket::Logging>,
    {
        self.logging = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging][crate::model::Bucket::logging].
    pub fn set_or_clear_logging<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bucket::Logging>,
    {
        self.logging = v.map(|x| x.into());
        self
    }

    /// Sets the value of [owner][crate::model::Bucket::owner].
    pub fn set_owner<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Owner>,
    {
        self.owner = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [owner][crate::model::Bucket::owner].
    pub fn set_or_clear_owner<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Owner>,
    {
        self.owner = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption][crate::model::Bucket::encryption].
    pub fn set_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bucket::Encryption>,
    {
        self.encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption][crate::model::Bucket::encryption].
    pub fn set_or_clear_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bucket::Encryption>,
    {
        self.encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [billing][crate::model::Bucket::billing].
    pub fn set_billing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bucket::Billing>,
    {
        self.billing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [billing][crate::model::Bucket::billing].
    pub fn set_or_clear_billing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bucket::Billing>,
    {
        self.billing = v.map(|x| x.into());
        self
    }

    /// Sets the value of [retention_policy][crate::model::Bucket::retention_policy].
    pub fn set_retention_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bucket::RetentionPolicy>,
    {
        self.retention_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retention_policy][crate::model::Bucket::retention_policy].
    pub fn set_or_clear_retention_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bucket::RetentionPolicy>,
    {
        self.retention_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [iam_config][crate::model::Bucket::iam_config].
    pub fn set_iam_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bucket::IamConfig>,
    {
        self.iam_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [iam_config][crate::model::Bucket::iam_config].
    pub fn set_or_clear_iam_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bucket::IamConfig>,
    {
        self.iam_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Bucket::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [custom_placement_config][crate::model::Bucket::custom_placement_config].
    pub fn set_custom_placement_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bucket::CustomPlacementConfig>,
    {
        self.custom_placement_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_placement_config][crate::model::Bucket::custom_placement_config].
    pub fn set_or_clear_custom_placement_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bucket::CustomPlacementConfig>,
    {
        self.custom_placement_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [autoclass][crate::model::Bucket::autoclass].
    pub fn set_autoclass<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bucket::Autoclass>,
    {
        self.autoclass = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoclass][crate::model::Bucket::autoclass].
    pub fn set_or_clear_autoclass<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bucket::Autoclass>,
    {
        self.autoclass = v.map(|x| x.into());
        self
    }

    /// Sets the value of [hierarchical_namespace][crate::model::Bucket::hierarchical_namespace].
    pub fn set_hierarchical_namespace<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bucket::HierarchicalNamespace>,
    {
        self.hierarchical_namespace = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hierarchical_namespace][crate::model::Bucket::hierarchical_namespace].
    pub fn set_or_clear_hierarchical_namespace<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bucket::HierarchicalNamespace>,
    {
        self.hierarchical_namespace = v.map(|x| x.into());
        self
    }

    /// Sets the value of [soft_delete_policy][crate::model::Bucket::soft_delete_policy].
    pub fn set_soft_delete_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bucket::SoftDeletePolicy>,
    {
        self.soft_delete_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [soft_delete_policy][crate::model::Bucket::soft_delete_policy].
    pub fn set_or_clear_soft_delete_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bucket::SoftDeletePolicy>,
    {
        self.soft_delete_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [object_retention][crate::model::Bucket::object_retention].
    pub fn set_object_retention<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bucket::ObjectRetention>,
    {
        self.object_retention = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object_retention][crate::model::Bucket::object_retention].
    pub fn set_or_clear_object_retention<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bucket::ObjectRetention>,
    {
        self.object_retention = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ip_filter][crate::model::Bucket::ip_filter].
    pub fn set_ip_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bucket::IpFilter>,
    {
        self.ip_filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_filter][crate::model::Bucket::ip_filter].
    pub fn set_or_clear_ip_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bucket::IpFilter>,
    {
        self.ip_filter = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Bucket {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.Bucket"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Bucket {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __bucket_id,
            __etag,
            __project,
            __metageneration,
            __location,
            __location_type,
            __storage_class,
            __rpo,
            __acl,
            __default_object_acl,
            __lifecycle,
            __create_time,
            __cors,
            __update_time,
            __default_event_based_hold,
            __labels,
            __website,
            __versioning,
            __logging,
            __owner,
            __encryption,
            __billing,
            __retention_policy,
            __iam_config,
            __satisfies_pzs,
            __custom_placement_config,
            __autoclass,
            __hierarchical_namespace,
            __soft_delete_policy,
            __object_retention,
            __ip_filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Bucket")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "bucketId" => Ok(__FieldTag::__bucket_id),
                            "bucket_id" => Ok(__FieldTag::__bucket_id),
                            "etag" => Ok(__FieldTag::__etag),
                            "project" => Ok(__FieldTag::__project),
                            "metageneration" => Ok(__FieldTag::__metageneration),
                            "location" => Ok(__FieldTag::__location),
                            "locationType" => Ok(__FieldTag::__location_type),
                            "location_type" => Ok(__FieldTag::__location_type),
                            "storageClass" => Ok(__FieldTag::__storage_class),
                            "storage_class" => Ok(__FieldTag::__storage_class),
                            "rpo" => Ok(__FieldTag::__rpo),
                            "acl" => Ok(__FieldTag::__acl),
                            "defaultObjectAcl" => Ok(__FieldTag::__default_object_acl),
                            "default_object_acl" => Ok(__FieldTag::__default_object_acl),
                            "lifecycle" => Ok(__FieldTag::__lifecycle),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "cors" => Ok(__FieldTag::__cors),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "defaultEventBasedHold" => Ok(__FieldTag::__default_event_based_hold),
                            "default_event_based_hold" => {
                                Ok(__FieldTag::__default_event_based_hold)
                            }
                            "labels" => Ok(__FieldTag::__labels),
                            "website" => Ok(__FieldTag::__website),
                            "versioning" => Ok(__FieldTag::__versioning),
                            "logging" => Ok(__FieldTag::__logging),
                            "owner" => Ok(__FieldTag::__owner),
                            "encryption" => Ok(__FieldTag::__encryption),
                            "billing" => Ok(__FieldTag::__billing),
                            "retentionPolicy" => Ok(__FieldTag::__retention_policy),
                            "retention_policy" => Ok(__FieldTag::__retention_policy),
                            "iamConfig" => Ok(__FieldTag::__iam_config),
                            "iam_config" => Ok(__FieldTag::__iam_config),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "customPlacementConfig" => Ok(__FieldTag::__custom_placement_config),
                            "custom_placement_config" => Ok(__FieldTag::__custom_placement_config),
                            "autoclass" => Ok(__FieldTag::__autoclass),
                            "hierarchicalNamespace" => Ok(__FieldTag::__hierarchical_namespace),
                            "hierarchical_namespace" => Ok(__FieldTag::__hierarchical_namespace),
                            "softDeletePolicy" => Ok(__FieldTag::__soft_delete_policy),
                            "soft_delete_policy" => Ok(__FieldTag::__soft_delete_policy),
                            "objectRetention" => Ok(__FieldTag::__object_retention),
                            "object_retention" => Ok(__FieldTag::__object_retention),
                            "ipFilter" => Ok(__FieldTag::__ip_filter),
                            "ip_filter" => Ok(__FieldTag::__ip_filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Bucket;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Bucket")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bucket_id => {
                            if !fields.insert(__FieldTag::__bucket_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_id",
                                ));
                            }
                            result.bucket_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metageneration => {
                            if !fields.insert(__FieldTag::__metageneration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metageneration",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.metageneration =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_type => {
                            if !fields.insert(__FieldTag::__location_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_type",
                                ));
                            }
                            result.location_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_class => {
                            if !fields.insert(__FieldTag::__storage_class) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_class",
                                ));
                            }
                            result.storage_class = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rpo => {
                            if !fields.insert(__FieldTag::__rpo) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rpo",
                                ));
                            }
                            result.rpo = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__acl => {
                            if !fields.insert(__FieldTag::__acl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for acl",
                                ));
                            }
                            result.acl = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BucketAccessControl>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_object_acl => {
                            if !fields.insert(__FieldTag::__default_object_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_object_acl",
                                ));
                            }
                            result.default_object_acl = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ObjectAccessControl>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lifecycle => {
                            if !fields.insert(__FieldTag::__lifecycle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifecycle",
                                ));
                            }
                            result.lifecycle = map
                                .next_value::<std::option::Option<crate::model::bucket::Lifecycle>>(
                                )?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__cors => {
                            if !fields.insert(__FieldTag::__cors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cors",
                                ));
                            }
                            result.cors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::bucket::Cors>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__default_event_based_hold => {
                            if !fields.insert(__FieldTag::__default_event_based_hold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_event_based_hold",
                                ));
                            }
                            result.default_event_based_hold = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__website => {
                            if !fields.insert(__FieldTag::__website) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for website",
                                ));
                            }
                            result.website = map
                                .next_value::<std::option::Option<crate::model::bucket::Website>>(
                                )?;
                        }
                        __FieldTag::__versioning => {
                            if !fields.insert(__FieldTag::__versioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versioning",
                                ));
                            }
                            result.versioning = map.next_value::<std::option::Option<crate::model::bucket::Versioning>>()?
                                ;
                        }
                        __FieldTag::__logging => {
                            if !fields.insert(__FieldTag::__logging) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging",
                                ));
                            }
                            result.logging = map
                                .next_value::<std::option::Option<crate::model::bucket::Logging>>(
                                )?;
                        }
                        __FieldTag::__owner => {
                            if !fields.insert(__FieldTag::__owner) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for owner",
                                ));
                            }
                            result.owner =
                                map.next_value::<std::option::Option<crate::model::Owner>>()?;
                        }
                        __FieldTag::__encryption => {
                            if !fields.insert(__FieldTag::__encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption",
                                ));
                            }
                            result.encryption = map.next_value::<std::option::Option<crate::model::bucket::Encryption>>()?
                                ;
                        }
                        __FieldTag::__billing => {
                            if !fields.insert(__FieldTag::__billing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for billing",
                                ));
                            }
                            result.billing = map
                                .next_value::<std::option::Option<crate::model::bucket::Billing>>(
                                )?;
                        }
                        __FieldTag::__retention_policy => {
                            if !fields.insert(__FieldTag::__retention_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_policy",
                                ));
                            }
                            result.retention_policy = map.next_value::<std::option::Option<crate::model::bucket::RetentionPolicy>>()?
                                ;
                        }
                        __FieldTag::__iam_config => {
                            if !fields.insert(__FieldTag::__iam_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iam_config",
                                ));
                            }
                            result.iam_config = map
                                .next_value::<std::option::Option<crate::model::bucket::IamConfig>>(
                                )?;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_placement_config => {
                            if !fields.insert(__FieldTag::__custom_placement_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_placement_config",
                                ));
                            }
                            result.custom_placement_config =
                                map.next_value::<std::option::Option<
                                    crate::model::bucket::CustomPlacementConfig,
                                >>()?;
                        }
                        __FieldTag::__autoclass => {
                            if !fields.insert(__FieldTag::__autoclass) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoclass",
                                ));
                            }
                            result.autoclass = map
                                .next_value::<std::option::Option<crate::model::bucket::Autoclass>>(
                                )?;
                        }
                        __FieldTag::__hierarchical_namespace => {
                            if !fields.insert(__FieldTag::__hierarchical_namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hierarchical_namespace",
                                ));
                            }
                            result.hierarchical_namespace =
                                map.next_value::<std::option::Option<
                                    crate::model::bucket::HierarchicalNamespace,
                                >>()?;
                        }
                        __FieldTag::__soft_delete_policy => {
                            if !fields.insert(__FieldTag::__soft_delete_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for soft_delete_policy",
                                ));
                            }
                            result.soft_delete_policy = map.next_value::<std::option::Option<crate::model::bucket::SoftDeletePolicy>>()?
                                ;
                        }
                        __FieldTag::__object_retention => {
                            if !fields.insert(__FieldTag::__object_retention) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_retention",
                                ));
                            }
                            result.object_retention = map.next_value::<std::option::Option<crate::model::bucket::ObjectRetention>>()?
                                ;
                        }
                        __FieldTag::__ip_filter => {
                            if !fields.insert(__FieldTag::__ip_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_filter",
                                ));
                            }
                            result.ip_filter = map
                                .next_value::<std::option::Option<crate::model::bucket::IpFilter>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Bucket {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.bucket_id.is_empty() {
            state.serialize_entry("bucketId", &self.bucket_id)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !wkt::internal::is_default(&self.metageneration) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("metageneration", &__With(&self.metageneration))?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.location_type.is_empty() {
            state.serialize_entry("locationType", &self.location_type)?;
        }
        if !self.storage_class.is_empty() {
            state.serialize_entry("storageClass", &self.storage_class)?;
        }
        if !self.rpo.is_empty() {
            state.serialize_entry("rpo", &self.rpo)?;
        }
        if !self.acl.is_empty() {
            state.serialize_entry("acl", &self.acl)?;
        }
        if !self.default_object_acl.is_empty() {
            state.serialize_entry("defaultObjectAcl", &self.default_object_acl)?;
        }
        if self.lifecycle.is_some() {
            state.serialize_entry("lifecycle", &self.lifecycle)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.cors.is_empty() {
            state.serialize_entry("cors", &self.cors)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.default_event_based_hold) {
            state.serialize_entry("defaultEventBasedHold", &self.default_event_based_hold)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.website.is_some() {
            state.serialize_entry("website", &self.website)?;
        }
        if self.versioning.is_some() {
            state.serialize_entry("versioning", &self.versioning)?;
        }
        if self.logging.is_some() {
            state.serialize_entry("logging", &self.logging)?;
        }
        if self.owner.is_some() {
            state.serialize_entry("owner", &self.owner)?;
        }
        if self.encryption.is_some() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if self.billing.is_some() {
            state.serialize_entry("billing", &self.billing)?;
        }
        if self.retention_policy.is_some() {
            state.serialize_entry("retentionPolicy", &self.retention_policy)?;
        }
        if self.iam_config.is_some() {
            state.serialize_entry("iamConfig", &self.iam_config)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.custom_placement_config.is_some() {
            state.serialize_entry("customPlacementConfig", &self.custom_placement_config)?;
        }
        if self.autoclass.is_some() {
            state.serialize_entry("autoclass", &self.autoclass)?;
        }
        if self.hierarchical_namespace.is_some() {
            state.serialize_entry("hierarchicalNamespace", &self.hierarchical_namespace)?;
        }
        if self.soft_delete_policy.is_some() {
            state.serialize_entry("softDeletePolicy", &self.soft_delete_policy)?;
        }
        if self.object_retention.is_some() {
            state.serialize_entry("objectRetention", &self.object_retention)?;
        }
        if self.ip_filter.is_some() {
            state.serialize_entry("ipFilter", &self.ip_filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Bucket].
pub mod bucket {
    #[allow(unused_imports)]
    use super::*;

    /// Billing properties of a bucket.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Billing {
        /// Optional. When set to true, Requester Pays is enabled for this bucket.
        pub requester_pays: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Billing {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [requester_pays][crate::model::bucket::Billing::requester_pays].
        pub fn set_requester_pays<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.requester_pays = v.into();
            self
        }
    }

    impl wkt::message::Message for Billing {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Billing"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Billing {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __requester_pays,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Billing")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "requesterPays" => Ok(__FieldTag::__requester_pays),
                                "requester_pays" => Ok(__FieldTag::__requester_pays),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Billing;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Billing")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__requester_pays => {
                                if !fields.insert(__FieldTag::__requester_pays) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for requester_pays",
                                    ));
                                }
                                result.requester_pays = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Billing {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.requester_pays) {
                state.serialize_entry("requesterPays", &self.requester_pays)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Cross-Origin Response sharing (CORS) properties for a bucket.
    /// For more on Cloud Storage and CORS, see
    /// <https://cloud.google.com/storage/docs/cross-origin>.
    /// For more on CORS in general, see <https://tools.ietf.org/html/rfc6454>.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Cors {
        /// Optional. The list of Origins eligible to receive CORS response headers.
        /// See [<https://tools.ietf.org/html/rfc6454>][RFC 6454] for more on origins.
        /// Note: "*" is permitted in the list of origins, and means "any Origin".
        pub origin: std::vec::Vec<std::string::String>,

        /// Optional. The list of HTTP methods on which to include CORS response
        /// headers,
        /// (`GET`, `OPTIONS`, `POST`, etc) Note: "*" is permitted in the list of
        /// methods, and means "any method".
        pub method: std::vec::Vec<std::string::String>,

        /// Optional. The list of HTTP headers other than the
        /// [<https://www.w3.org/TR/cors/#simple-response-header>][simple response
        /// headers] to give permission for the user-agent to share across domains.
        pub response_header: std::vec::Vec<std::string::String>,

        /// Optional. The value, in seconds, to return in the
        /// [<https://www.w3.org/TR/cors/#access-control-max-age-response-header>][Access-Control-Max-Age
        /// header] used in preflight responses.
        pub max_age_seconds: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Cors {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [origin][crate::model::bucket::Cors::origin].
        pub fn set_origin<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.origin = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [method][crate::model::bucket::Cors::method].
        pub fn set_method<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.method = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [response_header][crate::model::bucket::Cors::response_header].
        pub fn set_response_header<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.response_header = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [max_age_seconds][crate::model::bucket::Cors::max_age_seconds].
        pub fn set_max_age_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_age_seconds = v.into();
            self
        }
    }

    impl wkt::message::Message for Cors {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Cors"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Cors {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __origin,
                __method,
                __response_header,
                __max_age_seconds,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Cors")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "origin" => Ok(__FieldTag::__origin),
                                "method" => Ok(__FieldTag::__method),
                                "responseHeader" => Ok(__FieldTag::__response_header),
                                "response_header" => Ok(__FieldTag::__response_header),
                                "maxAgeSeconds" => Ok(__FieldTag::__max_age_seconds),
                                "max_age_seconds" => Ok(__FieldTag::__max_age_seconds),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Cors;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Cors")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__origin => {
                                if !fields.insert(__FieldTag::__origin) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for origin",
                                    ));
                                }
                                result.origin = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__method => {
                                if !fields.insert(__FieldTag::__method) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for method",
                                    ));
                                }
                                result.method = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__response_header => {
                                if !fields.insert(__FieldTag::__response_header) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for response_header",
                                    ));
                                }
                                result.response_header = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__max_age_seconds => {
                                if !fields.insert(__FieldTag::__max_age_seconds) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_age_seconds",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_age_seconds =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Cors {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.origin.is_empty() {
                state.serialize_entry("origin", &self.origin)?;
            }
            if !self.method.is_empty() {
                state.serialize_entry("method", &self.method)?;
            }
            if !self.response_header.is_empty() {
                state.serialize_entry("responseHeader", &self.response_header)?;
            }
            if !wkt::internal::is_default(&self.max_age_seconds) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxAgeSeconds", &__With(&self.max_age_seconds))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Encryption properties of a bucket.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Encryption {
        /// Optional. The name of the Cloud KMS key that will be used to encrypt
        /// objects inserted into this bucket, if no encryption method is specified.
        pub default_kms_key: std::string::String,

        /// Optional. If omitted, then new objects with GMEK encryption-type is
        /// allowed. If set, then new objects created in this bucket must comply with
        /// enforcement config. Changing this has no effect on existing objects; it
        /// applies to new objects only.
        pub google_managed_encryption_enforcement_config: std::option::Option<
            crate::model::bucket::encryption::GoogleManagedEncryptionEnforcementConfig,
        >,

        /// Optional. If omitted, then new objects with CMEK encryption-type is
        /// allowed. If set, then new objects created in this bucket must comply with
        /// enforcement config. Changing this has no effect on existing objects; it
        /// applies to new objects only.
        pub customer_managed_encryption_enforcement_config: std::option::Option<
            crate::model::bucket::encryption::CustomerManagedEncryptionEnforcementConfig,
        >,

        /// Optional. If omitted, then new objects with CSEK encryption-type is
        /// allowed. If set, then new objects created in this bucket must comply with
        /// enforcement config. Changing this has no effect on existing objects; it
        /// applies to new objects only.
        pub customer_supplied_encryption_enforcement_config: std::option::Option<
            crate::model::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Encryption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [default_kms_key][crate::model::bucket::Encryption::default_kms_key].
        pub fn set_default_kms_key<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.default_kms_key = v.into();
            self
        }

        /// Sets the value of [google_managed_encryption_enforcement_config][crate::model::bucket::Encryption::google_managed_encryption_enforcement_config].
        pub fn set_google_managed_encryption_enforcement_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::bucket::encryption::GoogleManagedEncryptionEnforcementConfig,
                >,
        {
            self.google_managed_encryption_enforcement_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [google_managed_encryption_enforcement_config][crate::model::bucket::Encryption::google_managed_encryption_enforcement_config].
        pub fn set_or_clear_google_managed_encryption_enforcement_config<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<
                    crate::model::bucket::encryption::GoogleManagedEncryptionEnforcementConfig,
                >,
        {
            self.google_managed_encryption_enforcement_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [customer_managed_encryption_enforcement_config][crate::model::bucket::Encryption::customer_managed_encryption_enforcement_config].
        pub fn set_customer_managed_encryption_enforcement_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::bucket::encryption::CustomerManagedEncryptionEnforcementConfig,
                >,
        {
            self.customer_managed_encryption_enforcement_config =
                std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [customer_managed_encryption_enforcement_config][crate::model::bucket::Encryption::customer_managed_encryption_enforcement_config].
        pub fn set_or_clear_customer_managed_encryption_enforcement_config<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<
                    crate::model::bucket::encryption::CustomerManagedEncryptionEnforcementConfig,
                >,
        {
            self.customer_managed_encryption_enforcement_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [customer_supplied_encryption_enforcement_config][crate::model::bucket::Encryption::customer_supplied_encryption_enforcement_config].
        pub fn set_customer_supplied_encryption_enforcement_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig,
                >,
        {
            self.customer_supplied_encryption_enforcement_config =
                std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [customer_supplied_encryption_enforcement_config][crate::model::bucket::Encryption::customer_supplied_encryption_enforcement_config].
        pub fn set_or_clear_customer_supplied_encryption_enforcement_config<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<
                    crate::model::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig,
                >,
        {
            self.customer_supplied_encryption_enforcement_config = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Encryption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Encryption"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Encryption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __default_kms_key,
                __google_managed_encryption_enforcement_config,
                __customer_managed_encryption_enforcement_config,
                __customer_supplied_encryption_enforcement_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Encryption")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "defaultKmsKey" => Ok(__FieldTag::__default_kms_key),
                                "default_kms_key" => Ok(__FieldTag::__default_kms_key),
                                "googleManagedEncryptionEnforcementConfig" => {
                                    Ok(__FieldTag::__google_managed_encryption_enforcement_config)
                                }
                                "google_managed_encryption_enforcement_config" => {
                                    Ok(__FieldTag::__google_managed_encryption_enforcement_config)
                                }
                                "customerManagedEncryptionEnforcementConfig" => {
                                    Ok(__FieldTag::__customer_managed_encryption_enforcement_config)
                                }
                                "customer_managed_encryption_enforcement_config" => {
                                    Ok(__FieldTag::__customer_managed_encryption_enforcement_config)
                                }
                                "customerSuppliedEncryptionEnforcementConfig" => Ok(
                                    __FieldTag::__customer_supplied_encryption_enforcement_config,
                                ),
                                "customer_supplied_encryption_enforcement_config" => Ok(
                                    __FieldTag::__customer_supplied_encryption_enforcement_config,
                                ),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Encryption;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Encryption")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__default_kms_key => {
                                if !fields.insert(__FieldTag::__default_kms_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for default_kms_key",
                                    ));
                                }
                                result.default_kms_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__google_managed_encryption_enforcement_config => {
                                if !fields.insert(
                                    __FieldTag::__google_managed_encryption_enforcement_config,
                                ) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for google_managed_encryption_enforcement_config",
                                    ));
                                }
                                result.google_managed_encryption_enforcement_config = map.next_value::<std::option::Option<crate::model::bucket::encryption::GoogleManagedEncryptionEnforcementConfig>>()?
                                    ;
                            }
                            __FieldTag::__customer_managed_encryption_enforcement_config => {
                                if !fields.insert(
                                    __FieldTag::__customer_managed_encryption_enforcement_config,
                                ) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for customer_managed_encryption_enforcement_config",
                                    ));
                                }
                                result.customer_managed_encryption_enforcement_config = map.next_value::<std::option::Option<crate::model::bucket::encryption::CustomerManagedEncryptionEnforcementConfig>>()?
                                    ;
                            }
                            __FieldTag::__customer_supplied_encryption_enforcement_config => {
                                if !fields.insert(
                                    __FieldTag::__customer_supplied_encryption_enforcement_config,
                                ) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for customer_supplied_encryption_enforcement_config",
                                    ));
                                }
                                result.customer_supplied_encryption_enforcement_config = map.next_value::<std::option::Option<crate::model::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Encryption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.default_kms_key.is_empty() {
                state.serialize_entry("defaultKmsKey", &self.default_kms_key)?;
            }
            if self.google_managed_encryption_enforcement_config.is_some() {
                state.serialize_entry(
                    "googleManagedEncryptionEnforcementConfig",
                    &self.google_managed_encryption_enforcement_config,
                )?;
            }
            if self
                .customer_managed_encryption_enforcement_config
                .is_some()
            {
                state.serialize_entry(
                    "customerManagedEncryptionEnforcementConfig",
                    &self.customer_managed_encryption_enforcement_config,
                )?;
            }
            if self
                .customer_supplied_encryption_enforcement_config
                .is_some()
            {
                state.serialize_entry(
                    "customerSuppliedEncryptionEnforcementConfig",
                    &self.customer_supplied_encryption_enforcement_config,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Encryption].
    pub mod encryption {
        #[allow(unused_imports)]
        use super::*;

        /// Google Managed Encryption (GMEK) enforcement config of a bucket.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct GoogleManagedEncryptionEnforcementConfig {
            /// Restriction mode for google-managed encryption for new objects within
            /// the bucket. Valid values are: "NotRestricted", "FullyRestricted".
            /// If `NotRestricted` or unset, creation of new objects with
            /// google-managed encryption is allowed.
            /// If `FullyRestricted`, new objects can't be created using google-managed
            /// encryption.
            pub restriction_mode: std::option::Option<std::string::String>,

            /// Time from which the config was effective. This is service-provided.
            pub effective_time: std::option::Option<wkt::Timestamp>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl GoogleManagedEncryptionEnforcementConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [restriction_mode][crate::model::bucket::encryption::GoogleManagedEncryptionEnforcementConfig::restriction_mode].
            pub fn set_restriction_mode<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.restriction_mode = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [restriction_mode][crate::model::bucket::encryption::GoogleManagedEncryptionEnforcementConfig::restriction_mode].
            pub fn set_or_clear_restriction_mode<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.restriction_mode = v.map(|x| x.into());
                self
            }

            /// Sets the value of [effective_time][crate::model::bucket::encryption::GoogleManagedEncryptionEnforcementConfig::effective_time].
            pub fn set_effective_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.effective_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [effective_time][crate::model::bucket::encryption::GoogleManagedEncryptionEnforcementConfig::effective_time].
            pub fn set_or_clear_effective_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.effective_time = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for GoogleManagedEncryptionEnforcementConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.storage.v2.Bucket.Encryption.GoogleManagedEncryptionEnforcementConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for GoogleManagedEncryptionEnforcementConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __restriction_mode,
                    __effective_time,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str(
                                    "a field name for GoogleManagedEncryptionEnforcementConfig",
                                )
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "restrictionMode" => Ok(__FieldTag::__restriction_mode),
                                    "restriction_mode" => Ok(__FieldTag::__restriction_mode),
                                    "effectiveTime" => Ok(__FieldTag::__effective_time),
                                    "effective_time" => Ok(__FieldTag::__effective_time),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = GoogleManagedEncryptionEnforcementConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct GoogleManagedEncryptionEnforcementConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__restriction_mode => {
                                    if !fields.insert(__FieldTag::__restriction_mode) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for restriction_mode",
                                            ),
                                        );
                                    }
                                    result.restriction_mode = map
                                        .next_value::<std::option::Option<std::string::String>>()?;
                                }
                                __FieldTag::__effective_time => {
                                    if !fields.insert(__FieldTag::__effective_time) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for effective_time",
                                            ),
                                        );
                                    }
                                    result.effective_time =
                                        map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for GoogleManagedEncryptionEnforcementConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.restriction_mode.is_some() {
                    state.serialize_entry("restrictionMode", &self.restriction_mode)?;
                }
                if self.effective_time.is_some() {
                    state.serialize_entry("effectiveTime", &self.effective_time)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Customer Managed Encryption (CMEK) enforcement config of a bucket.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CustomerManagedEncryptionEnforcementConfig {
            /// Restriction mode for customer-managed encryption for new objects within
            /// the bucket. Valid values are: "NotRestricted", "FullyRestricted".
            /// If `NotRestricted` or unset, creation of new objects with
            /// customer-managed encryption is allowed.
            /// If `FullyRestricted`, new objects can't be created using
            /// customer-managed encryption.
            pub restriction_mode: std::option::Option<std::string::String>,

            /// Time from which the config was effective. This is service-provided.
            pub effective_time: std::option::Option<wkt::Timestamp>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CustomerManagedEncryptionEnforcementConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [restriction_mode][crate::model::bucket::encryption::CustomerManagedEncryptionEnforcementConfig::restriction_mode].
            pub fn set_restriction_mode<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.restriction_mode = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [restriction_mode][crate::model::bucket::encryption::CustomerManagedEncryptionEnforcementConfig::restriction_mode].
            pub fn set_or_clear_restriction_mode<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.restriction_mode = v.map(|x| x.into());
                self
            }

            /// Sets the value of [effective_time][crate::model::bucket::encryption::CustomerManagedEncryptionEnforcementConfig::effective_time].
            pub fn set_effective_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.effective_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [effective_time][crate::model::bucket::encryption::CustomerManagedEncryptionEnforcementConfig::effective_time].
            pub fn set_or_clear_effective_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.effective_time = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for CustomerManagedEncryptionEnforcementConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.storage.v2.Bucket.Encryption.CustomerManagedEncryptionEnforcementConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CustomerManagedEncryptionEnforcementConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __restriction_mode,
                    __effective_time,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str(
                                    "a field name for CustomerManagedEncryptionEnforcementConfig",
                                )
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "restrictionMode" => Ok(__FieldTag::__restriction_mode),
                                    "restriction_mode" => Ok(__FieldTag::__restriction_mode),
                                    "effectiveTime" => Ok(__FieldTag::__effective_time),
                                    "effective_time" => Ok(__FieldTag::__effective_time),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CustomerManagedEncryptionEnforcementConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CustomerManagedEncryptionEnforcementConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__restriction_mode => {
                                    if !fields.insert(__FieldTag::__restriction_mode) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for restriction_mode",
                                            ),
                                        );
                                    }
                                    result.restriction_mode = map
                                        .next_value::<std::option::Option<std::string::String>>()?;
                                }
                                __FieldTag::__effective_time => {
                                    if !fields.insert(__FieldTag::__effective_time) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for effective_time",
                                            ),
                                        );
                                    }
                                    result.effective_time =
                                        map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for CustomerManagedEncryptionEnforcementConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.restriction_mode.is_some() {
                    state.serialize_entry("restrictionMode", &self.restriction_mode)?;
                }
                if self.effective_time.is_some() {
                    state.serialize_entry("effectiveTime", &self.effective_time)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Customer Supplied Encryption (CSEK) enforcement config of a bucket.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CustomerSuppliedEncryptionEnforcementConfig {
            /// Restriction mode for customer-supplied encryption for new objects
            /// within the bucket. Valid values are: "NotRestricted",
            /// "FullyRestricted".
            /// If `NotRestricted` or unset, creation of new objects with
            /// customer-supplied encryption is allowed.
            /// If `FullyRestricted`, new objects can't be created using
            /// customer-supplied encryption.
            pub restriction_mode: std::option::Option<std::string::String>,

            /// Time from which the config was effective. This is service-provided.
            pub effective_time: std::option::Option<wkt::Timestamp>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CustomerSuppliedEncryptionEnforcementConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [restriction_mode][crate::model::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig::restriction_mode].
            pub fn set_restriction_mode<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.restriction_mode = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [restriction_mode][crate::model::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig::restriction_mode].
            pub fn set_or_clear_restriction_mode<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.restriction_mode = v.map(|x| x.into());
                self
            }

            /// Sets the value of [effective_time][crate::model::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig::effective_time].
            pub fn set_effective_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.effective_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [effective_time][crate::model::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig::effective_time].
            pub fn set_or_clear_effective_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.effective_time = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for CustomerSuppliedEncryptionEnforcementConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.storage.v2.Bucket.Encryption.CustomerSuppliedEncryptionEnforcementConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CustomerSuppliedEncryptionEnforcementConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __restriction_mode,
                    __effective_time,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str(
                                    "a field name for CustomerSuppliedEncryptionEnforcementConfig",
                                )
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "restrictionMode" => Ok(__FieldTag::__restriction_mode),
                                    "restriction_mode" => Ok(__FieldTag::__restriction_mode),
                                    "effectiveTime" => Ok(__FieldTag::__effective_time),
                                    "effective_time" => Ok(__FieldTag::__effective_time),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CustomerSuppliedEncryptionEnforcementConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CustomerSuppliedEncryptionEnforcementConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__restriction_mode => {
                                    if !fields.insert(__FieldTag::__restriction_mode) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for restriction_mode",
                                            ),
                                        );
                                    }
                                    result.restriction_mode = map
                                        .next_value::<std::option::Option<std::string::String>>()?;
                                }
                                __FieldTag::__effective_time => {
                                    if !fields.insert(__FieldTag::__effective_time) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for effective_time",
                                            ),
                                        );
                                    }
                                    result.effective_time =
                                        map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for CustomerSuppliedEncryptionEnforcementConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.restriction_mode.is_some() {
                    state.serialize_entry("restrictionMode", &self.restriction_mode)?;
                }
                if self.effective_time.is_some() {
                    state.serialize_entry("effectiveTime", &self.effective_time)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Bucket restriction options.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IamConfig {
        /// Optional. Bucket restriction options currently enforced on the bucket.
        pub uniform_bucket_level_access:
            std::option::Option<crate::model::bucket::iam_config::UniformBucketLevelAccess>,

        /// Optional. Whether IAM will enforce public access prevention. Valid values
        /// are "enforced" or "inherited".
        pub public_access_prevention: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IamConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uniform_bucket_level_access][crate::model::bucket::IamConfig::uniform_bucket_level_access].
        pub fn set_uniform_bucket_level_access<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::bucket::iam_config::UniformBucketLevelAccess>,
        {
            self.uniform_bucket_level_access = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [uniform_bucket_level_access][crate::model::bucket::IamConfig::uniform_bucket_level_access].
        pub fn set_or_clear_uniform_bucket_level_access<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::bucket::iam_config::UniformBucketLevelAccess>,
        {
            self.uniform_bucket_level_access = v.map(|x| x.into());
            self
        }

        /// Sets the value of [public_access_prevention][crate::model::bucket::IamConfig::public_access_prevention].
        pub fn set_public_access_prevention<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.public_access_prevention = v.into();
            self
        }
    }

    impl wkt::message::Message for IamConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.IamConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IamConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uniform_bucket_level_access,
                __public_access_prevention,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IamConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uniformBucketLevelAccess" => {
                                    Ok(__FieldTag::__uniform_bucket_level_access)
                                }
                                "uniform_bucket_level_access" => {
                                    Ok(__FieldTag::__uniform_bucket_level_access)
                                }
                                "publicAccessPrevention" => {
                                    Ok(__FieldTag::__public_access_prevention)
                                }
                                "public_access_prevention" => {
                                    Ok(__FieldTag::__public_access_prevention)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IamConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IamConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uniform_bucket_level_access => {
                                if !fields.insert(__FieldTag::__uniform_bucket_level_access) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uniform_bucket_level_access",
                                    ));
                                }
                                result.uniform_bucket_level_access = map
                                    .next_value::<std::option::Option<
                                        crate::model::bucket::iam_config::UniformBucketLevelAccess,
                                    >>()?;
                            }
                            __FieldTag::__public_access_prevention => {
                                if !fields.insert(__FieldTag::__public_access_prevention) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for public_access_prevention",
                                    ));
                                }
                                result.public_access_prevention = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IamConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.uniform_bucket_level_access.is_some() {
                state.serialize_entry(
                    "uniformBucketLevelAccess",
                    &self.uniform_bucket_level_access,
                )?;
            }
            if !self.public_access_prevention.is_empty() {
                state.serialize_entry("publicAccessPrevention", &self.public_access_prevention)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [IamConfig].
    pub mod iam_config {
        #[allow(unused_imports)]
        use super::*;

        /// Settings for Uniform Bucket level access.
        /// See <https://cloud.google.com/storage/docs/uniform-bucket-level-access>.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct UniformBucketLevelAccess {
            /// Optional. If set, access checks only use bucket-level IAM policies or
            /// above.
            pub enabled: bool,

            /// Optional. The deadline time for changing
            /// `iam_config.uniform_bucket_level_access.enabled` from `true` to
            /// `false`. Mutable until the specified deadline is reached, but not
            /// afterward.
            pub lock_time: std::option::Option<wkt::Timestamp>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl UniformBucketLevelAccess {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [enabled][crate::model::bucket::iam_config::UniformBucketLevelAccess::enabled].
            pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.enabled = v.into();
                self
            }

            /// Sets the value of [lock_time][crate::model::bucket::iam_config::UniformBucketLevelAccess::lock_time].
            pub fn set_lock_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.lock_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [lock_time][crate::model::bucket::iam_config::UniformBucketLevelAccess::lock_time].
            pub fn set_or_clear_lock_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.lock_time = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for UniformBucketLevelAccess {
            fn typename() -> &'static str {
                "type.googleapis.com/google.storage.v2.Bucket.IamConfig.UniformBucketLevelAccess"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for UniformBucketLevelAccess {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __enabled,
                    __lock_time,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for UniformBucketLevelAccess")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "enabled" => Ok(__FieldTag::__enabled),
                                    "lockTime" => Ok(__FieldTag::__lock_time),
                                    "lock_time" => Ok(__FieldTag::__lock_time),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = UniformBucketLevelAccess;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct UniformBucketLevelAccess")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__enabled => {
                                    if !fields.insert(__FieldTag::__enabled) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for enabled",
                                            ),
                                        );
                                    }
                                    result.enabled = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__lock_time => {
                                    if !fields.insert(__FieldTag::__lock_time) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for lock_time",
                                            ),
                                        );
                                    }
                                    result.lock_time =
                                        map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for UniformBucketLevelAccess {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.enabled) {
                    state.serialize_entry("enabled", &self.enabled)?;
                }
                if self.lock_time.is_some() {
                    state.serialize_entry("lockTime", &self.lock_time)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Lifecycle properties of a bucket.
    /// For more information, see <https://cloud.google.com/storage/docs/lifecycle>.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Lifecycle {
        /// Optional. A lifecycle management rule, which is made of an action to take
        /// and the condition(s) under which the action will be taken.
        pub rule: std::vec::Vec<crate::model::bucket::lifecycle::Rule>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Lifecycle {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rule][crate::model::bucket::Lifecycle::rule].
        pub fn set_rule<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::bucket::lifecycle::Rule>,
        {
            use std::iter::Iterator;
            self.rule = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Lifecycle {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Lifecycle"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Lifecycle {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __rule,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Lifecycle")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "rule" => Ok(__FieldTag::__rule),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Lifecycle;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Lifecycle")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__rule => {
                                if !fields.insert(__FieldTag::__rule) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rule",
                                    ));
                                }
                                result.rule = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::bucket::lifecycle::Rule>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Lifecycle {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.rule.is_empty() {
                state.serialize_entry("rule", &self.rule)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Lifecycle].
    pub mod lifecycle {
        #[allow(unused_imports)]
        use super::*;

        /// A lifecycle Rule, combining an action to take on an object and a
        /// condition which will trigger that action.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Rule {
            /// Optional. The action to take.
            pub action: std::option::Option<crate::model::bucket::lifecycle::rule::Action>,

            /// Optional. The condition(s) under which the action will be taken.
            pub condition: std::option::Option<crate::model::bucket::lifecycle::rule::Condition>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Rule {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [action][crate::model::bucket::lifecycle::Rule::action].
            pub fn set_action<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::bucket::lifecycle::rule::Action>,
            {
                self.action = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [action][crate::model::bucket::lifecycle::Rule::action].
            pub fn set_or_clear_action<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::bucket::lifecycle::rule::Action>,
            {
                self.action = v.map(|x| x.into());
                self
            }

            /// Sets the value of [condition][crate::model::bucket::lifecycle::Rule::condition].
            pub fn set_condition<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::bucket::lifecycle::rule::Condition>,
            {
                self.condition = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [condition][crate::model::bucket::lifecycle::Rule::condition].
            pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::bucket::lifecycle::rule::Condition>,
            {
                self.condition = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Rule {
            fn typename() -> &'static str {
                "type.googleapis.com/google.storage.v2.Bucket.Lifecycle.Rule"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Rule {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __action,
                    __condition,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Rule")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "action" => Ok(__FieldTag::__action),
                                    "condition" => Ok(__FieldTag::__condition),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Rule;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Rule")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__action => {
                                    if !fields.insert(__FieldTag::__action) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for action"),
                                        );
                                    }
                                    result.action = map.next_value::<std::option::Option<
                                        crate::model::bucket::lifecycle::rule::Action,
                                    >>()?;
                                }
                                __FieldTag::__condition => {
                                    if !fields.insert(__FieldTag::__condition) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for condition",
                                            ),
                                        );
                                    }
                                    result.condition = map
                                        .next_value::<std::option::Option<
                                            crate::model::bucket::lifecycle::rule::Condition,
                                        >>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Rule {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.action.is_some() {
                    state.serialize_entry("action", &self.action)?;
                }
                if self.condition.is_some() {
                    state.serialize_entry("condition", &self.condition)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Rule].
        pub mod rule {
            #[allow(unused_imports)]
            use super::*;

            /// An action to take on an object.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Action {
                /// Optional. Type of the action. Currently, only `Delete`,
                /// `SetStorageClass`, and `AbortIncompleteMultipartUpload` are
                /// supported.
                pub r#type: std::string::String,

                /// Optional. Target storage class. Required iff the type of the action
                /// is SetStorageClass.
                pub storage_class: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Action {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [r#type][crate::model::bucket::lifecycle::rule::Action::type].
                pub fn set_type<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.r#type = v.into();
                    self
                }

                /// Sets the value of [storage_class][crate::model::bucket::lifecycle::rule::Action::storage_class].
                pub fn set_storage_class<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.storage_class = v.into();
                    self
                }
            }

            impl wkt::message::Message for Action {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.storage.v2.Bucket.Lifecycle.Rule.Action"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Action {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __type,
                        __storage_class,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Action")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "type" => Ok(__FieldTag::__type),
                                        "storageClass" => Ok(__FieldTag::__storage_class),
                                        "storage_class" => Ok(__FieldTag::__storage_class),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Action;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Action")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__type => {
                                        if !fields.insert(__FieldTag::__type) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for type",
                                                ),
                                            );
                                        }
                                        result.r#type = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__storage_class => {
                                        if !fields.insert(__FieldTag::__storage_class) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for storage_class",
                                                ),
                                            );
                                        }
                                        result.storage_class = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Action {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.r#type.is_empty() {
                        state.serialize_entry("type", &self.r#type)?;
                    }
                    if !self.storage_class.is_empty() {
                        state.serialize_entry("storageClass", &self.storage_class)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// A condition of an object which triggers some action.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Condition {
                /// Age of an object (in days). This condition is satisfied when an
                /// object reaches the specified age.
                /// A value of 0 indicates that all objects immediately match this
                /// condition.
                pub age_days: std::option::Option<i32>,

                /// Optional. This condition is satisfied when an object is created
                /// before midnight of the specified date in UTC.
                pub created_before: std::option::Option<gtype::model::Date>,

                /// Relevant only for versioned objects. If the value is
                /// `true`, this condition matches live objects; if the value
                /// is `false`, it matches archived objects.
                pub is_live: std::option::Option<bool>,

                /// Relevant only for versioned objects. If the value is N, this
                /// condition is satisfied when there are at least N versions (including
                /// the live version) newer than this version of the object.
                pub num_newer_versions: std::option::Option<i32>,

                /// Optional. Objects having any of the storage classes specified by this
                /// condition will be matched. Values include `MULTI_REGIONAL`,
                /// `REGIONAL`, `NEARLINE`, `COLDLINE`, `STANDARD`, and
                /// `DURABLE_REDUCED_AVAILABILITY`.
                pub matches_storage_class: std::vec::Vec<std::string::String>,

                /// Number of days that have elapsed since the custom timestamp set on an
                /// object.
                /// The value of the field must be a nonnegative integer.
                pub days_since_custom_time: std::option::Option<i32>,

                /// Optional. An object matches this condition if the custom timestamp
                /// set on the object is before the specified date in UTC.
                pub custom_time_before: std::option::Option<gtype::model::Date>,

                /// This condition is relevant only for versioned objects. An object
                /// version satisfies this condition only if these many days have been
                /// passed since it became noncurrent. The value of the field must be a
                /// nonnegative integer. If it's zero, the object version will become
                /// eligible for Lifecycle action as soon as it becomes noncurrent.
                pub days_since_noncurrent_time: std::option::Option<i32>,

                /// Optional. This condition is relevant only for versioned objects. An
                /// object version satisfies this condition only if it became noncurrent
                /// before the specified date in UTC.
                pub noncurrent_time_before: std::option::Option<gtype::model::Date>,

                /// Optional. List of object name prefixes. If any prefix exactly matches
                /// the beginning of the object name, the condition evaluates to true.
                pub matches_prefix: std::vec::Vec<std::string::String>,

                /// Optional. List of object name suffixes. If any suffix exactly matches
                /// the end of the object name, the condition evaluates to true.
                pub matches_suffix: std::vec::Vec<std::string::String>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Condition {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [age_days][crate::model::bucket::lifecycle::rule::Condition::age_days].
                pub fn set_age_days<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<i32>,
                {
                    self.age_days = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [age_days][crate::model::bucket::lifecycle::rule::Condition::age_days].
                pub fn set_or_clear_age_days<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<i32>,
                {
                    self.age_days = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [created_before][crate::model::bucket::lifecycle::rule::Condition::created_before].
                pub fn set_created_before<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<gtype::model::Date>,
                {
                    self.created_before = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [created_before][crate::model::bucket::lifecycle::rule::Condition::created_before].
                pub fn set_or_clear_created_before<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<gtype::model::Date>,
                {
                    self.created_before = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [is_live][crate::model::bucket::lifecycle::rule::Condition::is_live].
                pub fn set_is_live<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<bool>,
                {
                    self.is_live = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [is_live][crate::model::bucket::lifecycle::rule::Condition::is_live].
                pub fn set_or_clear_is_live<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<bool>,
                {
                    self.is_live = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [num_newer_versions][crate::model::bucket::lifecycle::rule::Condition::num_newer_versions].
                pub fn set_num_newer_versions<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<i32>,
                {
                    self.num_newer_versions = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [num_newer_versions][crate::model::bucket::lifecycle::rule::Condition::num_newer_versions].
                pub fn set_or_clear_num_newer_versions<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<i32>,
                {
                    self.num_newer_versions = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [matches_storage_class][crate::model::bucket::lifecycle::rule::Condition::matches_storage_class].
                pub fn set_matches_storage_class<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.matches_storage_class = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [days_since_custom_time][crate::model::bucket::lifecycle::rule::Condition::days_since_custom_time].
                pub fn set_days_since_custom_time<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<i32>,
                {
                    self.days_since_custom_time = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [days_since_custom_time][crate::model::bucket::lifecycle::rule::Condition::days_since_custom_time].
                pub fn set_or_clear_days_since_custom_time<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<i32>,
                {
                    self.days_since_custom_time = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [custom_time_before][crate::model::bucket::lifecycle::rule::Condition::custom_time_before].
                pub fn set_custom_time_before<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<gtype::model::Date>,
                {
                    self.custom_time_before = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [custom_time_before][crate::model::bucket::lifecycle::rule::Condition::custom_time_before].
                pub fn set_or_clear_custom_time_before<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<gtype::model::Date>,
                {
                    self.custom_time_before = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [days_since_noncurrent_time][crate::model::bucket::lifecycle::rule::Condition::days_since_noncurrent_time].
                pub fn set_days_since_noncurrent_time<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<i32>,
                {
                    self.days_since_noncurrent_time = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [days_since_noncurrent_time][crate::model::bucket::lifecycle::rule::Condition::days_since_noncurrent_time].
                pub fn set_or_clear_days_since_noncurrent_time<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<i32>,
                {
                    self.days_since_noncurrent_time = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [noncurrent_time_before][crate::model::bucket::lifecycle::rule::Condition::noncurrent_time_before].
                pub fn set_noncurrent_time_before<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<gtype::model::Date>,
                {
                    self.noncurrent_time_before = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [noncurrent_time_before][crate::model::bucket::lifecycle::rule::Condition::noncurrent_time_before].
                pub fn set_or_clear_noncurrent_time_before<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<gtype::model::Date>,
                {
                    self.noncurrent_time_before = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [matches_prefix][crate::model::bucket::lifecycle::rule::Condition::matches_prefix].
                pub fn set_matches_prefix<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.matches_prefix = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [matches_suffix][crate::model::bucket::lifecycle::rule::Condition::matches_suffix].
                pub fn set_matches_suffix<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.matches_suffix = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Condition {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.storage.v2.Bucket.Lifecycle.Rule.Condition"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Condition {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __age_days,
                        __created_before,
                        __is_live,
                        __num_newer_versions,
                        __matches_storage_class,
                        __days_since_custom_time,
                        __custom_time_before,
                        __days_since_noncurrent_time,
                        __noncurrent_time_before,
                        __matches_prefix,
                        __matches_suffix,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Condition")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "ageDays" => Ok(__FieldTag::__age_days),
                                        "age_days" => Ok(__FieldTag::__age_days),
                                        "createdBefore" => Ok(__FieldTag::__created_before),
                                        "created_before" => Ok(__FieldTag::__created_before),
                                        "isLive" => Ok(__FieldTag::__is_live),
                                        "is_live" => Ok(__FieldTag::__is_live),
                                        "numNewerVersions" => Ok(__FieldTag::__num_newer_versions),
                                        "num_newer_versions" => {
                                            Ok(__FieldTag::__num_newer_versions)
                                        }
                                        "matchesStorageClass" => {
                                            Ok(__FieldTag::__matches_storage_class)
                                        }
                                        "matches_storage_class" => {
                                            Ok(__FieldTag::__matches_storage_class)
                                        }
                                        "daysSinceCustomTime" => {
                                            Ok(__FieldTag::__days_since_custom_time)
                                        }
                                        "days_since_custom_time" => {
                                            Ok(__FieldTag::__days_since_custom_time)
                                        }
                                        "customTimeBefore" => Ok(__FieldTag::__custom_time_before),
                                        "custom_time_before" => {
                                            Ok(__FieldTag::__custom_time_before)
                                        }
                                        "daysSinceNoncurrentTime" => {
                                            Ok(__FieldTag::__days_since_noncurrent_time)
                                        }
                                        "days_since_noncurrent_time" => {
                                            Ok(__FieldTag::__days_since_noncurrent_time)
                                        }
                                        "noncurrentTimeBefore" => {
                                            Ok(__FieldTag::__noncurrent_time_before)
                                        }
                                        "noncurrent_time_before" => {
                                            Ok(__FieldTag::__noncurrent_time_before)
                                        }
                                        "matchesPrefix" => Ok(__FieldTag::__matches_prefix),
                                        "matches_prefix" => Ok(__FieldTag::__matches_prefix),
                                        "matchesSuffix" => Ok(__FieldTag::__matches_suffix),
                                        "matches_suffix" => Ok(__FieldTag::__matches_suffix),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Condition;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Condition")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__age_days => {
                                        if !fields.insert(__FieldTag::__age_days) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for age_days",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.age_days = map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__created_before => {
                                        if !fields.insert(__FieldTag::__created_before) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for created_before",
                                                ),
                                            );
                                        }
                                        result.created_before = map
                                            .next_value::<std::option::Option<gtype::model::Date>>(
                                            )?;
                                    }
                                    __FieldTag::__is_live => {
                                        if !fields.insert(__FieldTag::__is_live) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for is_live",
                                                ),
                                            );
                                        }
                                        result.is_live =
                                            map.next_value::<std::option::Option<bool>>()?;
                                    }
                                    __FieldTag::__num_newer_versions => {
                                        if !fields.insert(__FieldTag::__num_newer_versions) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for num_newer_versions",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.num_newer_versions = map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__matches_storage_class => {
                                        if !fields.insert(__FieldTag::__matches_storage_class) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for matches_storage_class",
                                                ),
                                            );
                                        }
                                        result.matches_storage_class =
                                            map.next_value::<std::option::Option<
                                                std::vec::Vec<std::string::String>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__days_since_custom_time => {
                                        if !fields.insert(__FieldTag::__days_since_custom_time) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for days_since_custom_time",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.days_since_custom_time =
                                            map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__custom_time_before => {
                                        if !fields.insert(__FieldTag::__custom_time_before) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for custom_time_before",
                                                ),
                                            );
                                        }
                                        result.custom_time_before = map
                                            .next_value::<std::option::Option<gtype::model::Date>>(
                                            )?;
                                    }
                                    __FieldTag::__days_since_noncurrent_time => {
                                        if !fields.insert(__FieldTag::__days_since_noncurrent_time)
                                        {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for days_since_noncurrent_time",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.days_since_noncurrent_time =
                                            map.next_value::<__With>()?.0;
                                    }
                                    __FieldTag::__noncurrent_time_before => {
                                        if !fields.insert(__FieldTag::__noncurrent_time_before) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for noncurrent_time_before",
                                                ),
                                            );
                                        }
                                        result.noncurrent_time_before = map
                                            .next_value::<std::option::Option<gtype::model::Date>>(
                                            )?;
                                    }
                                    __FieldTag::__matches_prefix => {
                                        if !fields.insert(__FieldTag::__matches_prefix) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for matches_prefix",
                                                ),
                                            );
                                        }
                                        result.matches_prefix =
                                            map.next_value::<std::option::Option<
                                                std::vec::Vec<std::string::String>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__matches_suffix => {
                                        if !fields.insert(__FieldTag::__matches_suffix) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for matches_suffix",
                                                ),
                                            );
                                        }
                                        result.matches_suffix =
                                            map.next_value::<std::option::Option<
                                                std::vec::Vec<std::string::String>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Condition {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.age_days.is_some() {
                        struct __With<'a>(&'a std::option::Option<i32>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry("ageDays", &__With(&self.age_days))?;
                    }
                    if self.created_before.is_some() {
                        state.serialize_entry("createdBefore", &self.created_before)?;
                    }
                    if self.is_live.is_some() {
                        state.serialize_entry("isLive", &self.is_live)?;
                    }
                    if self.num_newer_versions.is_some() {
                        struct __With<'a>(&'a std::option::Option<i32>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "numNewerVersions",
                            &__With(&self.num_newer_versions),
                        )?;
                    }
                    if !self.matches_storage_class.is_empty() {
                        state
                            .serialize_entry("matchesStorageClass", &self.matches_storage_class)?;
                    }
                    if self.days_since_custom_time.is_some() {
                        struct __With<'a>(&'a std::option::Option<i32>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "daysSinceCustomTime",
                            &__With(&self.days_since_custom_time),
                        )?;
                    }
                    if self.custom_time_before.is_some() {
                        state.serialize_entry("customTimeBefore", &self.custom_time_before)?;
                    }
                    if self.days_since_noncurrent_time.is_some() {
                        struct __With<'a>(&'a std::option::Option<i32>);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry(
                            "daysSinceNoncurrentTime",
                            &__With(&self.days_since_noncurrent_time),
                        )?;
                    }
                    if self.noncurrent_time_before.is_some() {
                        state.serialize_entry(
                            "noncurrentTimeBefore",
                            &self.noncurrent_time_before,
                        )?;
                    }
                    if !self.matches_prefix.is_empty() {
                        state.serialize_entry("matchesPrefix", &self.matches_prefix)?;
                    }
                    if !self.matches_suffix.is_empty() {
                        state.serialize_entry("matchesSuffix", &self.matches_suffix)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }
        }
    }

    /// Logging-related properties of a bucket.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Logging {
        /// Optional. The destination bucket where the current bucket's logs should
        /// be placed, using path format (like `projects/123456/buckets/foo`).
        pub log_bucket: std::string::String,

        /// Optional. A prefix for log object names.
        pub log_object_prefix: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Logging {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [log_bucket][crate::model::bucket::Logging::log_bucket].
        pub fn set_log_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.log_bucket = v.into();
            self
        }

        /// Sets the value of [log_object_prefix][crate::model::bucket::Logging::log_object_prefix].
        pub fn set_log_object_prefix<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.log_object_prefix = v.into();
            self
        }
    }

    impl wkt::message::Message for Logging {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Logging"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Logging {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __log_bucket,
                __log_object_prefix,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Logging")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "logBucket" => Ok(__FieldTag::__log_bucket),
                                "log_bucket" => Ok(__FieldTag::__log_bucket),
                                "logObjectPrefix" => Ok(__FieldTag::__log_object_prefix),
                                "log_object_prefix" => Ok(__FieldTag::__log_object_prefix),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Logging;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Logging")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__log_bucket => {
                                if !fields.insert(__FieldTag::__log_bucket) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for log_bucket",
                                    ));
                                }
                                result.log_bucket = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__log_object_prefix => {
                                if !fields.insert(__FieldTag::__log_object_prefix) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for log_object_prefix",
                                    ));
                                }
                                result.log_object_prefix = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Logging {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.log_bucket.is_empty() {
                state.serialize_entry("logBucket", &self.log_bucket)?;
            }
            if !self.log_object_prefix.is_empty() {
                state.serialize_entry("logObjectPrefix", &self.log_object_prefix)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Object Retention related properties of a bucket.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ObjectRetention {
        /// Optional. Output only. If true, object retention is enabled for the
        /// bucket.
        pub enabled: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ObjectRetention {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::bucket::ObjectRetention::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for ObjectRetention {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.ObjectRetention"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ObjectRetention {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enabled,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ObjectRetention")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enabled" => Ok(__FieldTag::__enabled),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ObjectRetention;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ObjectRetention")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enabled => {
                                if !fields.insert(__FieldTag::__enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enabled",
                                    ));
                                }
                                result.enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ObjectRetention {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enabled) {
                state.serialize_entry("enabled", &self.enabled)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Retention policy properties of a bucket.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RetentionPolicy {
        /// Optional. Server-determined value that indicates the time from which
        /// policy was enforced and effective.
        pub effective_time: std::option::Option<wkt::Timestamp>,

        /// Optional. Once locked, an object retention policy cannot be modified.
        pub is_locked: bool,

        /// Optional. The duration that objects need to be retained. Retention
        /// duration must be greater than zero and less than 100 years. Note that
        /// enforcement of retention periods less than a day is not guaranteed. Such
        /// periods should only be used for testing purposes. Any `nanos` value
        /// specified will be rounded down to the nearest second.
        pub retention_duration: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RetentionPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [effective_time][crate::model::bucket::RetentionPolicy::effective_time].
        pub fn set_effective_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.effective_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [effective_time][crate::model::bucket::RetentionPolicy::effective_time].
        pub fn set_or_clear_effective_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.effective_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [is_locked][crate::model::bucket::RetentionPolicy::is_locked].
        pub fn set_is_locked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.is_locked = v.into();
            self
        }

        /// Sets the value of [retention_duration][crate::model::bucket::RetentionPolicy::retention_duration].
        pub fn set_retention_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.retention_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [retention_duration][crate::model::bucket::RetentionPolicy::retention_duration].
        pub fn set_or_clear_retention_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.retention_duration = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for RetentionPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.RetentionPolicy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RetentionPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __effective_time,
                __is_locked,
                __retention_duration,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RetentionPolicy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "effectiveTime" => Ok(__FieldTag::__effective_time),
                                "effective_time" => Ok(__FieldTag::__effective_time),
                                "isLocked" => Ok(__FieldTag::__is_locked),
                                "is_locked" => Ok(__FieldTag::__is_locked),
                                "retentionDuration" => Ok(__FieldTag::__retention_duration),
                                "retention_duration" => Ok(__FieldTag::__retention_duration),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RetentionPolicy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RetentionPolicy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__effective_time => {
                                if !fields.insert(__FieldTag::__effective_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for effective_time",
                                    ));
                                }
                                result.effective_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__is_locked => {
                                if !fields.insert(__FieldTag::__is_locked) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for is_locked",
                                    ));
                                }
                                result.is_locked = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__retention_duration => {
                                if !fields.insert(__FieldTag::__retention_duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for retention_duration",
                                    ));
                                }
                                result.retention_duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RetentionPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.effective_time.is_some() {
                state.serialize_entry("effectiveTime", &self.effective_time)?;
            }
            if !wkt::internal::is_default(&self.is_locked) {
                state.serialize_entry("isLocked", &self.is_locked)?;
            }
            if self.retention_duration.is_some() {
                state.serialize_entry("retentionDuration", &self.retention_duration)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Soft delete policy properties of a bucket.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SoftDeletePolicy {
        /// The period of time that soft-deleted objects in the bucket must be
        /// retained and cannot be permanently deleted. The duration must be greater
        /// than or equal to 7 days and less than 1 year.
        pub retention_duration: std::option::Option<wkt::Duration>,

        /// Time from which the policy was effective. This is service-provided.
        pub effective_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SoftDeletePolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [retention_duration][crate::model::bucket::SoftDeletePolicy::retention_duration].
        pub fn set_retention_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.retention_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [retention_duration][crate::model::bucket::SoftDeletePolicy::retention_duration].
        pub fn set_or_clear_retention_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.retention_duration = v.map(|x| x.into());
            self
        }

        /// Sets the value of [effective_time][crate::model::bucket::SoftDeletePolicy::effective_time].
        pub fn set_effective_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.effective_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [effective_time][crate::model::bucket::SoftDeletePolicy::effective_time].
        pub fn set_or_clear_effective_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.effective_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SoftDeletePolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.SoftDeletePolicy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SoftDeletePolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __retention_duration,
                __effective_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SoftDeletePolicy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "retentionDuration" => Ok(__FieldTag::__retention_duration),
                                "retention_duration" => Ok(__FieldTag::__retention_duration),
                                "effectiveTime" => Ok(__FieldTag::__effective_time),
                                "effective_time" => Ok(__FieldTag::__effective_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SoftDeletePolicy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SoftDeletePolicy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__retention_duration => {
                                if !fields.insert(__FieldTag::__retention_duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for retention_duration",
                                    ));
                                }
                                result.retention_duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__effective_time => {
                                if !fields.insert(__FieldTag::__effective_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for effective_time",
                                    ));
                                }
                                result.effective_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SoftDeletePolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.retention_duration.is_some() {
                state.serialize_entry("retentionDuration", &self.retention_duration)?;
            }
            if self.effective_time.is_some() {
                state.serialize_entry("effectiveTime", &self.effective_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Properties of a bucket related to versioning.
    /// For more on Cloud Storage versioning, see
    /// <https://cloud.google.com/storage/docs/object-versioning>.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Versioning {
        /// Optional. While set to true, versioning is fully enabled for this bucket.
        pub enabled: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Versioning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::bucket::Versioning::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for Versioning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Versioning"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Versioning {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enabled,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Versioning")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enabled" => Ok(__FieldTag::__enabled),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Versioning;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Versioning")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enabled => {
                                if !fields.insert(__FieldTag::__enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enabled",
                                    ));
                                }
                                result.enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Versioning {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enabled) {
                state.serialize_entry("enabled", &self.enabled)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Properties of a bucket related to accessing the contents as a static
    /// website. For more on hosting a static website via Cloud Storage, see
    /// <https://cloud.google.com/storage/docs/hosting-static-website>.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Website {
        /// Optional. If the requested object path is missing, the service will
        /// ensure the path has a trailing '/', append this suffix, and attempt to
        /// retrieve the resulting object. This allows the creation of `index.html`
        /// objects to represent directory pages.
        pub main_page_suffix: std::string::String,

        /// Optional. If the requested object path is missing, and any
        /// `mainPageSuffix` object is missing, if applicable, the service
        /// will return the named object from this bucket as the content for a
        /// [<https://tools.ietf.org/html/rfc7231#section-6.5.4>][404 Not Found]
        /// result.
        pub not_found_page: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Website {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [main_page_suffix][crate::model::bucket::Website::main_page_suffix].
        pub fn set_main_page_suffix<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.main_page_suffix = v.into();
            self
        }

        /// Sets the value of [not_found_page][crate::model::bucket::Website::not_found_page].
        pub fn set_not_found_page<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.not_found_page = v.into();
            self
        }
    }

    impl wkt::message::Message for Website {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Website"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Website {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __main_page_suffix,
                __not_found_page,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Website")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "mainPageSuffix" => Ok(__FieldTag::__main_page_suffix),
                                "main_page_suffix" => Ok(__FieldTag::__main_page_suffix),
                                "notFoundPage" => Ok(__FieldTag::__not_found_page),
                                "not_found_page" => Ok(__FieldTag::__not_found_page),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Website;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Website")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__main_page_suffix => {
                                if !fields.insert(__FieldTag::__main_page_suffix) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for main_page_suffix",
                                    ));
                                }
                                result.main_page_suffix = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__not_found_page => {
                                if !fields.insert(__FieldTag::__not_found_page) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for not_found_page",
                                    ));
                                }
                                result.not_found_page = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Website {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.main_page_suffix.is_empty() {
                state.serialize_entry("mainPageSuffix", &self.main_page_suffix)?;
            }
            if !self.not_found_page.is_empty() {
                state.serialize_entry("notFoundPage", &self.not_found_page)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration for Custom Dual Regions.  It should specify precisely two
    /// eligible regions within the same Multiregion. More information on regions
    /// may be found [here](https://cloud.google.com/storage/docs/locations).
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CustomPlacementConfig {
        /// Optional. List of locations to use for data placement.
        pub data_locations: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CustomPlacementConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [data_locations][crate::model::bucket::CustomPlacementConfig::data_locations].
        pub fn set_data_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.data_locations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CustomPlacementConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.CustomPlacementConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CustomPlacementConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __data_locations,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CustomPlacementConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dataLocations" => Ok(__FieldTag::__data_locations),
                                "data_locations" => Ok(__FieldTag::__data_locations),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CustomPlacementConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CustomPlacementConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__data_locations => {
                                if !fields.insert(__FieldTag::__data_locations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for data_locations",
                                    ));
                                }
                                result.data_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CustomPlacementConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.data_locations.is_empty() {
                state.serialize_entry("dataLocations", &self.data_locations)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration for a bucket's Autoclass feature.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Autoclass {
        /// Optional. Enables Autoclass.
        pub enabled: bool,

        /// Output only. Latest instant at which the `enabled` field was set to true
        /// after being disabled/unconfigured or set to false after being enabled. If
        /// Autoclass is enabled when the bucket is created, the toggle_time is set
        /// to the bucket creation time.
        pub toggle_time: std::option::Option<wkt::Timestamp>,

        /// An object in an Autoclass bucket will eventually cool down to the
        /// terminal storage class if there is no access to the object.
        /// The only valid values are NEARLINE and ARCHIVE.
        pub terminal_storage_class: std::option::Option<std::string::String>,

        /// Output only. Latest instant at which the autoclass terminal storage class
        /// was updated.
        pub terminal_storage_class_update_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Autoclass {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::bucket::Autoclass::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [toggle_time][crate::model::bucket::Autoclass::toggle_time].
        pub fn set_toggle_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.toggle_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [toggle_time][crate::model::bucket::Autoclass::toggle_time].
        pub fn set_or_clear_toggle_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.toggle_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [terminal_storage_class][crate::model::bucket::Autoclass::terminal_storage_class].
        pub fn set_terminal_storage_class<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.terminal_storage_class = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [terminal_storage_class][crate::model::bucket::Autoclass::terminal_storage_class].
        pub fn set_or_clear_terminal_storage_class<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.terminal_storage_class = v.map(|x| x.into());
            self
        }

        /// Sets the value of [terminal_storage_class_update_time][crate::model::bucket::Autoclass::terminal_storage_class_update_time].
        pub fn set_terminal_storage_class_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.terminal_storage_class_update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [terminal_storage_class_update_time][crate::model::bucket::Autoclass::terminal_storage_class_update_time].
        pub fn set_or_clear_terminal_storage_class_update_time<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.terminal_storage_class_update_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Autoclass {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.Autoclass"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Autoclass {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enabled,
                __toggle_time,
                __terminal_storage_class,
                __terminal_storage_class_update_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Autoclass")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enabled" => Ok(__FieldTag::__enabled),
                                "toggleTime" => Ok(__FieldTag::__toggle_time),
                                "toggle_time" => Ok(__FieldTag::__toggle_time),
                                "terminalStorageClass" => Ok(__FieldTag::__terminal_storage_class),
                                "terminal_storage_class" => {
                                    Ok(__FieldTag::__terminal_storage_class)
                                }
                                "terminalStorageClassUpdateTime" => {
                                    Ok(__FieldTag::__terminal_storage_class_update_time)
                                }
                                "terminal_storage_class_update_time" => {
                                    Ok(__FieldTag::__terminal_storage_class_update_time)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Autoclass;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Autoclass")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enabled => {
                                if !fields.insert(__FieldTag::__enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enabled",
                                    ));
                                }
                                result.enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__toggle_time => {
                                if !fields.insert(__FieldTag::__toggle_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for toggle_time",
                                    ));
                                }
                                result.toggle_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__terminal_storage_class => {
                                if !fields.insert(__FieldTag::__terminal_storage_class) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for terminal_storage_class",
                                    ));
                                }
                                result.terminal_storage_class =
                                    map.next_value::<std::option::Option<std::string::String>>()?;
                            }
                            __FieldTag::__terminal_storage_class_update_time => {
                                if !fields.insert(__FieldTag::__terminal_storage_class_update_time)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for terminal_storage_class_update_time",
                                    ));
                                }
                                result.terminal_storage_class_update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Autoclass {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enabled) {
                state.serialize_entry("enabled", &self.enabled)?;
            }
            if self.toggle_time.is_some() {
                state.serialize_entry("toggleTime", &self.toggle_time)?;
            }
            if self.terminal_storage_class.is_some() {
                state.serialize_entry("terminalStorageClass", &self.terminal_storage_class)?;
            }
            if self.terminal_storage_class_update_time.is_some() {
                state.serialize_entry(
                    "terminalStorageClassUpdateTime",
                    &self.terminal_storage_class_update_time,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The [bucket IP
    /// filtering](https://cloud.google.com/storage/docs/ip-filtering-overview)
    /// configuration. Specifies the network sources that can access the bucket, as
    /// well as its underlying objects.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IpFilter {
        /// The state of the IP filter configuration. Valid values are `Enabled` and
        /// `Disabled`. When set to `Enabled`, IP filtering rules are applied to a
        /// bucket and all incoming requests to the bucket are evaluated against
        /// these rules. When set to `Disabled`, IP filtering rules are not applied
        /// to a bucket.".
        pub mode: std::option::Option<std::string::String>,

        /// Public IPs allowed to operate or access the bucket.
        pub public_network_source:
            std::option::Option<crate::model::bucket::ip_filter::PublicNetworkSource>,

        /// Optional. The list of network sources that are allowed to access
        /// operations on the bucket or the underlying objects.
        pub vpc_network_sources: std::vec::Vec<crate::model::bucket::ip_filter::VpcNetworkSource>,

        /// Optional. Whether or not to allow VPCs from orgs different than the
        /// bucket's parent org to access the bucket. When set to true, validations
        /// on the existence of the VPCs won't be performed. If set to false, each
        /// VPC network source will be checked to belong to the same org as the
        /// bucket as well as validated for existence.
        pub allow_cross_org_vpcs: bool,

        /// Whether or not to allow all P4SA access to the bucket. When set to true,
        /// IP filter config validation will not apply.
        pub allow_all_service_agent_access: std::option::Option<bool>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IpFilter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mode][crate::model::bucket::IpFilter::mode].
        pub fn set_mode<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.mode = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [mode][crate::model::bucket::IpFilter::mode].
        pub fn set_or_clear_mode<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.mode = v.map(|x| x.into());
            self
        }

        /// Sets the value of [public_network_source][crate::model::bucket::IpFilter::public_network_source].
        pub fn set_public_network_source<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::bucket::ip_filter::PublicNetworkSource>,
        {
            self.public_network_source = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [public_network_source][crate::model::bucket::IpFilter::public_network_source].
        pub fn set_or_clear_public_network_source<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::bucket::ip_filter::PublicNetworkSource>,
        {
            self.public_network_source = v.map(|x| x.into());
            self
        }

        /// Sets the value of [vpc_network_sources][crate::model::bucket::IpFilter::vpc_network_sources].
        pub fn set_vpc_network_sources<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::bucket::ip_filter::VpcNetworkSource>,
        {
            use std::iter::Iterator;
            self.vpc_network_sources = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [allow_cross_org_vpcs][crate::model::bucket::IpFilter::allow_cross_org_vpcs].
        pub fn set_allow_cross_org_vpcs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_cross_org_vpcs = v.into();
            self
        }

        /// Sets the value of [allow_all_service_agent_access][crate::model::bucket::IpFilter::allow_all_service_agent_access].
        pub fn set_allow_all_service_agent_access<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.allow_all_service_agent_access = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [allow_all_service_agent_access][crate::model::bucket::IpFilter::allow_all_service_agent_access].
        pub fn set_or_clear_allow_all_service_agent_access<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.allow_all_service_agent_access = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for IpFilter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.IpFilter"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IpFilter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __mode,
                __public_network_source,
                __vpc_network_sources,
                __allow_cross_org_vpcs,
                __allow_all_service_agent_access,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IpFilter")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "mode" => Ok(__FieldTag::__mode),
                                "publicNetworkSource" => Ok(__FieldTag::__public_network_source),
                                "public_network_source" => Ok(__FieldTag::__public_network_source),
                                "vpcNetworkSources" => Ok(__FieldTag::__vpc_network_sources),
                                "vpc_network_sources" => Ok(__FieldTag::__vpc_network_sources),
                                "allowCrossOrgVpcs" => Ok(__FieldTag::__allow_cross_org_vpcs),
                                "allow_cross_org_vpcs" => Ok(__FieldTag::__allow_cross_org_vpcs),
                                "allowAllServiceAgentAccess" => {
                                    Ok(__FieldTag::__allow_all_service_agent_access)
                                }
                                "allow_all_service_agent_access" => {
                                    Ok(__FieldTag::__allow_all_service_agent_access)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IpFilter;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IpFilter")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__mode => {
                                if !fields.insert(__FieldTag::__mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mode",
                                    ));
                                }
                                result.mode =
                                    map.next_value::<std::option::Option<std::string::String>>()?;
                            }
                            __FieldTag::__public_network_source => {
                                if !fields.insert(__FieldTag::__public_network_source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for public_network_source",
                                    ));
                                }
                                result.public_network_source = map
                                    .next_value::<std::option::Option<
                                        crate::model::bucket::ip_filter::PublicNetworkSource,
                                    >>()?;
                            }
                            __FieldTag::__vpc_network_sources => {
                                if !fields.insert(__FieldTag::__vpc_network_sources) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vpc_network_sources",
                                    ));
                                }
                                result.vpc_network_sources = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::bucket::ip_filter::VpcNetworkSource,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allow_cross_org_vpcs => {
                                if !fields.insert(__FieldTag::__allow_cross_org_vpcs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allow_cross_org_vpcs",
                                    ));
                                }
                                result.allow_cross_org_vpcs = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allow_all_service_agent_access => {
                                if !fields.insert(__FieldTag::__allow_all_service_agent_access) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allow_all_service_agent_access",
                                    ));
                                }
                                result.allow_all_service_agent_access =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IpFilter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.mode.is_some() {
                state.serialize_entry("mode", &self.mode)?;
            }
            if self.public_network_source.is_some() {
                state.serialize_entry("publicNetworkSource", &self.public_network_source)?;
            }
            if !self.vpc_network_sources.is_empty() {
                state.serialize_entry("vpcNetworkSources", &self.vpc_network_sources)?;
            }
            if !wkt::internal::is_default(&self.allow_cross_org_vpcs) {
                state.serialize_entry("allowCrossOrgVpcs", &self.allow_cross_org_vpcs)?;
            }
            if self.allow_all_service_agent_access.is_some() {
                state.serialize_entry(
                    "allowAllServiceAgentAccess",
                    &self.allow_all_service_agent_access,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [IpFilter].
    pub mod ip_filter {
        #[allow(unused_imports)]
        use super::*;

        /// The public network IP address ranges that can access the bucket and its
        /// data.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct PublicNetworkSource {
            /// Optional. The list of IPv4 and IPv6 cidr blocks that are allowed to
            /// operate or access the bucket and its underlying objects.
            pub allowed_ip_cidr_ranges: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PublicNetworkSource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [allowed_ip_cidr_ranges][crate::model::bucket::ip_filter::PublicNetworkSource::allowed_ip_cidr_ranges].
            pub fn set_allowed_ip_cidr_ranges<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.allowed_ip_cidr_ranges = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for PublicNetworkSource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.storage.v2.Bucket.IpFilter.PublicNetworkSource"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for PublicNetworkSource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __allowed_ip_cidr_ranges,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for PublicNetworkSource")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "allowedIpCidrRanges" => {
                                        Ok(__FieldTag::__allowed_ip_cidr_ranges)
                                    }
                                    "allowed_ip_cidr_ranges" => {
                                        Ok(__FieldTag::__allowed_ip_cidr_ranges)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = PublicNetworkSource;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct PublicNetworkSource")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__allowed_ip_cidr_ranges => {
                                    if !fields.insert(__FieldTag::__allowed_ip_cidr_ranges) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for allowed_ip_cidr_ranges",
                                            ),
                                        );
                                    }
                                    result.allowed_ip_cidr_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for PublicNetworkSource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.allowed_ip_cidr_ranges.is_empty() {
                    state.serialize_entry("allowedIpCidrRanges", &self.allowed_ip_cidr_ranges)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The list of VPC networks that can access the bucket.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct VpcNetworkSource {
            /// Name of the network.
            ///
            /// Format: `projects/PROJECT_ID/global/networks/NETWORK_NAME`
            pub network: std::option::Option<std::string::String>,

            /// Optional. The list of public or private IPv4 and IPv6 CIDR ranges that
            /// can access the bucket. In the CIDR IP address block, the specified IP
            /// address must be properly truncated, meaning all the host bits must be
            /// zero or else the input is considered malformed. For example,
            /// `192.0.2.0/24` is accepted but `192.0.2.1/24` is not. Similarly, for
            /// IPv6, `2001:db8::/32` is accepted whereas `2001:db8::1/32` is not.
            pub allowed_ip_cidr_ranges: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl VpcNetworkSource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [network][crate::model::bucket::ip_filter::VpcNetworkSource::network].
            pub fn set_network<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.network = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [network][crate::model::bucket::ip_filter::VpcNetworkSource::network].
            pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.network = v.map(|x| x.into());
                self
            }

            /// Sets the value of [allowed_ip_cidr_ranges][crate::model::bucket::ip_filter::VpcNetworkSource::allowed_ip_cidr_ranges].
            pub fn set_allowed_ip_cidr_ranges<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.allowed_ip_cidr_ranges = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for VpcNetworkSource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.storage.v2.Bucket.IpFilter.VpcNetworkSource"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for VpcNetworkSource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __network,
                    __allowed_ip_cidr_ranges,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for VpcNetworkSource")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "network" => Ok(__FieldTag::__network),
                                    "allowedIpCidrRanges" => {
                                        Ok(__FieldTag::__allowed_ip_cidr_ranges)
                                    }
                                    "allowed_ip_cidr_ranges" => {
                                        Ok(__FieldTag::__allowed_ip_cidr_ranges)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = VpcNetworkSource;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct VpcNetworkSource")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__network => {
                                    if !fields.insert(__FieldTag::__network) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for network",
                                            ),
                                        );
                                    }
                                    result.network = map
                                        .next_value::<std::option::Option<std::string::String>>()?;
                                }
                                __FieldTag::__allowed_ip_cidr_ranges => {
                                    if !fields.insert(__FieldTag::__allowed_ip_cidr_ranges) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for allowed_ip_cidr_ranges",
                                            ),
                                        );
                                    }
                                    result.allowed_ip_cidr_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for VpcNetworkSource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.network.is_some() {
                    state.serialize_entry("network", &self.network)?;
                }
                if !self.allowed_ip_cidr_ranges.is_empty() {
                    state.serialize_entry("allowedIpCidrRanges", &self.allowed_ip_cidr_ranges)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Configuration for a bucket's hierarchical namespace feature.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct HierarchicalNamespace {
        /// Optional. Enables the hierarchical namespace feature.
        pub enabled: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl HierarchicalNamespace {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::bucket::HierarchicalNamespace::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for HierarchicalNamespace {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Bucket.HierarchicalNamespace"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for HierarchicalNamespace {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enabled,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for HierarchicalNamespace")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enabled" => Ok(__FieldTag::__enabled),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = HierarchicalNamespace;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct HierarchicalNamespace")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enabled => {
                                if !fields.insert(__FieldTag::__enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enabled",
                                    ));
                                }
                                result.enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for HierarchicalNamespace {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enabled) {
                state.serialize_entry("enabled", &self.enabled)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// An access-control entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BucketAccessControl {
    /// Optional. The access permission for the entity.
    pub role: std::string::String,

    /// Optional. The ID of the access-control entry.
    pub id: std::string::String,

    /// Optional. The entity holding the permission, in one of the following forms:
    ///
    /// * `user-{userid}`
    /// * `user-{email}`
    /// * `group-{groupid}`
    /// * `group-{email}`
    /// * `domain-{domain}`
    /// * `project-{team}-{projectnumber}`
    /// * `project-{team}-{projectid}`
    /// * `allUsers`
    /// * `allAuthenticatedUsers`
    ///   Examples:
    /// * The user `liz@example.com` would be `user-liz@example.com`.
    /// * The group `example@googlegroups.com` would be
    ///   `group-example@googlegroups.com`
    /// * All members of the Google Apps for Business domain `example.com` would be
    ///   `domain-example.com`
    ///   For project entities, `project-{team}-{projectnumber}` format will be
    ///   returned on response.
    pub entity: std::string::String,

    /// Output only. The alternative entity format, if exists. For project
    /// entities, `project-{team}-{projectid}` format will be returned on response.
    pub entity_alt: std::string::String,

    /// Optional. The ID for the entity, if any.
    pub entity_id: std::string::String,

    /// Optional. The etag of the BucketAccessControl.
    /// If included in the metadata of an update or delete request message, the
    /// operation operation will only be performed if the etag matches that of the
    /// bucket's BucketAccessControl.
    pub etag: std::string::String,

    /// Optional. The email address associated with the entity, if any.
    pub email: std::string::String,

    /// Optional. The domain associated with the entity, if any.
    pub domain: std::string::String,

    /// Optional. The project team associated with the entity, if any.
    pub project_team: std::option::Option<crate::model::ProjectTeam>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BucketAccessControl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role][crate::model::BucketAccessControl::role].
    pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [id][crate::model::BucketAccessControl::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [entity][crate::model::BucketAccessControl::entity].
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity = v.into();
        self
    }

    /// Sets the value of [entity_alt][crate::model::BucketAccessControl::entity_alt].
    pub fn set_entity_alt<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_alt = v.into();
        self
    }

    /// Sets the value of [entity_id][crate::model::BucketAccessControl::entity_id].
    pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::BucketAccessControl::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [email][crate::model::BucketAccessControl::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::BucketAccessControl::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [project_team][crate::model::BucketAccessControl::project_team].
    pub fn set_project_team<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProjectTeam>,
    {
        self.project_team = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [project_team][crate::model::BucketAccessControl::project_team].
    pub fn set_or_clear_project_team<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProjectTeam>,
    {
        self.project_team = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BucketAccessControl {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.BucketAccessControl"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BucketAccessControl {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __role,
            __id,
            __entity,
            __entity_alt,
            __entity_id,
            __etag,
            __email,
            __domain,
            __project_team,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BucketAccessControl")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "role" => Ok(__FieldTag::__role),
                            "id" => Ok(__FieldTag::__id),
                            "entity" => Ok(__FieldTag::__entity),
                            "entityAlt" => Ok(__FieldTag::__entity_alt),
                            "entity_alt" => Ok(__FieldTag::__entity_alt),
                            "entityId" => Ok(__FieldTag::__entity_id),
                            "entity_id" => Ok(__FieldTag::__entity_id),
                            "etag" => Ok(__FieldTag::__etag),
                            "email" => Ok(__FieldTag::__email),
                            "domain" => Ok(__FieldTag::__domain),
                            "projectTeam" => Ok(__FieldTag::__project_team),
                            "project_team" => Ok(__FieldTag::__project_team),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BucketAccessControl;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BucketAccessControl")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity",
                                ));
                            }
                            result.entity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_alt => {
                            if !fields.insert(__FieldTag::__entity_alt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_alt",
                                ));
                            }
                            result.entity_alt = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_id => {
                            if !fields.insert(__FieldTag::__entity_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_id",
                                ));
                            }
                            result.entity_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_team => {
                            if !fields.insert(__FieldTag::__project_team) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_team",
                                ));
                            }
                            result.project_team =
                                map.next_value::<std::option::Option<crate::model::ProjectTeam>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BucketAccessControl {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.role.is_empty() {
            state.serialize_entry("role", &self.role)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.entity.is_empty() {
            state.serialize_entry("entity", &self.entity)?;
        }
        if !self.entity_alt.is_empty() {
            state.serialize_entry("entityAlt", &self.entity_alt)?;
        }
        if !self.entity_id.is_empty() {
            state.serialize_entry("entityId", &self.entity_id)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self.domain.is_empty() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if self.project_team.is_some() {
            state.serialize_entry("projectTeam", &self.project_team)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message used for storing full (not subrange) object checksums.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ObjectChecksums {
    /// CRC32C digest of the object data. Computed by the Cloud Storage service for
    /// all written objects.
    /// If set in a WriteObjectRequest, service will validate that the stored
    /// object matches this checksum.
    pub crc32c: std::option::Option<u32>,

    /// Optional. 128 bit MD5 hash of the object data.
    /// For more information about using the MD5 hash, see
    /// [<https://cloud.google.com/storage/docs/hashes-etags#json-api>][Hashes and
    /// ETags: Best Practices].
    /// Not all objects will provide an MD5 hash. For example, composite objects
    /// provide only crc32c hashes. This value is equivalent to running `cat
    /// object.txt | openssl md5 -binary`
    pub md5_hash: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectChecksums {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crc32c][crate::model::ObjectChecksums::crc32c].
    pub fn set_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u32>,
    {
        self.crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crc32c][crate::model::ObjectChecksums::crc32c].
    pub fn set_or_clear_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u32>,
    {
        self.crc32c = v.map(|x| x.into());
        self
    }

    /// Sets the value of [md5_hash][crate::model::ObjectChecksums::md5_hash].
    pub fn set_md5_hash<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.md5_hash = v.into();
        self
    }
}

impl wkt::message::Message for ObjectChecksums {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ObjectChecksums"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ObjectChecksums {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __crc32c,
            __md5_hash,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectChecksums")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "crc32c" => Ok(__FieldTag::__crc32c),
                            "md5Hash" => Ok(__FieldTag::__md5_hash),
                            "md5_hash" => Ok(__FieldTag::__md5_hash),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ObjectChecksums;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectChecksums")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__crc32c => {
                            if !fields.insert(__FieldTag::__crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crc32c",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__md5_hash => {
                            if !fields.insert(__FieldTag::__md5_hash) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for md5_hash",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.md5_hash = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ObjectChecksums {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("crc32c", &__With(&self.crc32c))?;
        }
        if !self.md5_hash.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("md5Hash", &__With(&self.md5_hash))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The payload of a single user-defined object context.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ObjectCustomContextPayload {
    /// Required. The value of the object context.
    pub value: std::string::String,

    /// Output only. The time at which the object context was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the object context was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectCustomContextPayload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::ObjectCustomContextPayload::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ObjectCustomContextPayload::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ObjectCustomContextPayload::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ObjectCustomContextPayload::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ObjectCustomContextPayload::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ObjectCustomContextPayload {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ObjectCustomContextPayload"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ObjectCustomContextPayload {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectCustomContextPayload")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ObjectCustomContextPayload;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectCustomContextPayload")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ObjectCustomContextPayload {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// All contexts of an object grouped by type.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ObjectContexts {
    /// Optional. User-defined object contexts.
    pub custom:
        std::collections::HashMap<std::string::String, crate::model::ObjectCustomContextPayload>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectContexts {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom][crate::model::ObjectContexts::custom].
    pub fn set_custom<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ObjectCustomContextPayload>,
    {
        use std::iter::Iterator;
        self.custom = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ObjectContexts {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ObjectContexts"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ObjectContexts {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __custom,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectContexts")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "custom" => Ok(__FieldTag::__custom),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ObjectContexts;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectContexts")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__custom => {
                            if !fields.insert(__FieldTag::__custom) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom",
                                ));
                            }
                            result.custom = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::ObjectCustomContextPayload,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ObjectContexts {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.custom.is_empty() {
            state.serialize_entry("custom", &self.custom)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes the Customer-Supplied Encryption Key mechanism used to store an
/// Object's data at rest.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomerEncryption {
    /// Optional. The encryption algorithm.
    pub encryption_algorithm: std::string::String,

    /// Optional. SHA256 hash value of the encryption key.
    /// In raw bytes format (not base64-encoded).
    pub key_sha256_bytes: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerEncryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_algorithm][crate::model::CustomerEncryption::encryption_algorithm].
    pub fn set_encryption_algorithm<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_algorithm = v.into();
        self
    }

    /// Sets the value of [key_sha256_bytes][crate::model::CustomerEncryption::key_sha256_bytes].
    pub fn set_key_sha256_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.key_sha256_bytes = v.into();
        self
    }
}

impl wkt::message::Message for CustomerEncryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.CustomerEncryption"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomerEncryption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encryption_algorithm,
            __key_sha256_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomerEncryption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encryptionAlgorithm" => Ok(__FieldTag::__encryption_algorithm),
                            "encryption_algorithm" => Ok(__FieldTag::__encryption_algorithm),
                            "keySha256Bytes" => Ok(__FieldTag::__key_sha256_bytes),
                            "key_sha256_bytes" => Ok(__FieldTag::__key_sha256_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomerEncryption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomerEncryption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encryption_algorithm => {
                            if !fields.insert(__FieldTag::__encryption_algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_algorithm",
                                ));
                            }
                            result.encryption_algorithm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_sha256_bytes => {
                            if !fields.insert(__FieldTag::__key_sha256_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_sha256_bytes",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.key_sha256_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomerEncryption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.encryption_algorithm.is_empty() {
            state.serialize_entry("encryptionAlgorithm", &self.encryption_algorithm)?;
        }
        if !self.key_sha256_bytes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("keySha256Bytes", &__With(&self.key_sha256_bytes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An object.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Object {
    /// Immutable. The name of this object. Nearly any sequence of unicode
    /// characters is valid. See
    /// [Guidelines](https://cloud.google.com/storage/docs/objects#naming).
    /// Example: `test.txt`
    /// The `name` field by itself does not uniquely identify a Cloud Storage
    /// object. A Cloud Storage object is uniquely identified by the tuple of
    /// (bucket, object, generation).
    pub name: std::string::String,

    /// Immutable. The name of the bucket containing this object.
    pub bucket: std::string::String,

    /// Optional. The etag of the object.
    /// If included in the metadata of an update or delete request message, the
    /// operation will only be performed if the etag matches that of the live
    /// object.
    pub etag: std::string::String,

    /// Immutable. The content generation of this object. Used for object
    /// versioning.
    pub generation: i64,

    /// Output only. Restore token used to differentiate deleted objects with the
    /// same name and generation. This field is output only, and only set for
    /// deleted objects in HNS buckets.
    pub restore_token: std::option::Option<std::string::String>,

    /// Output only. The version of the metadata for this generation of this
    /// object. Used for preconditions and for detecting changes in metadata. A
    /// metageneration number is only meaningful in the context of a particular
    /// generation of a particular object.
    pub metageneration: i64,

    /// Optional. Storage class of the object.
    pub storage_class: std::string::String,

    /// Output only. Content-Length of the object data in bytes, matching
    /// [<https://tools.ietf.org/html/rfc7230#section-3.3.2>][RFC 7230 3.3.2].
    pub size: i64,

    /// Optional. Content-Encoding of the object data, matching
    /// [<https://tools.ietf.org/html/rfc7231#section-3.1.2.2>][RFC 7231 3.1.2.2]
    pub content_encoding: std::string::String,

    /// Optional. Content-Disposition of the object data, matching
    /// [<https://tools.ietf.org/html/rfc6266>][RFC 6266].
    pub content_disposition: std::string::String,

    /// Optional. Cache-Control directive for the object data, matching
    /// [<https://tools.ietf.org/html/rfc7234#section-5.2>"][RFC 7234 5.2].
    /// If omitted, and the object is accessible to all anonymous users, the
    /// default will be `public, max-age=3600`.
    pub cache_control: std::string::String,

    /// Optional. Access controls on the object.
    /// If iam_config.uniform_bucket_level_access is enabled on the parent
    /// bucket, requests to set, read, or modify acl is an error.
    pub acl: std::vec::Vec<crate::model::ObjectAccessControl>,

    /// Optional. Content-Language of the object data, matching
    /// [<https://tools.ietf.org/html/rfc7231#section-3.1.3.2>][RFC 7231 3.1.3.2].
    pub content_language: std::string::String,

    /// Output only. If this object is noncurrent, this is the time when the object
    /// became noncurrent.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the object was finalized.
    pub finalize_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Content-Type of the object data, matching
    /// [<https://tools.ietf.org/html/rfc7231#section-3.1.1.5>][RFC 7231 3.1.1.5].
    /// If an object is stored without a Content-Type, it is served as
    /// `application/octet-stream`.
    pub content_type: std::string::String,

    /// Output only. The creation time of the object.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Number of underlying components that make up this object.
    /// Components are accumulated by compose operations.
    pub component_count: i32,

    /// Output only. Hashes for the data part of this object. This field is used
    /// for output only and will be silently ignored if provided in requests. The
    /// checksums of the complete object regardless of data range. If the object is
    /// downloaded in full, the client should compute one of these checksums over
    /// the downloaded object and compare it against the value provided here.
    pub checksums: std::option::Option<crate::model::ObjectChecksums>,

    /// Output only. The modification time of the object metadata.
    /// Set initially to object creation time and then updated whenever any
    /// metadata of the object changes. This includes changes made by a requester,
    /// such as modifying custom metadata, as well as changes made by Cloud Storage
    /// on behalf of a requester, such as changing the storage class based on an
    /// Object Lifecycle Configuration.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Cloud KMS Key used to encrypt this object, if the object is
    /// encrypted by such a key.
    pub kms_key: std::string::String,

    /// Output only. The time at which the object's storage class was last changed.
    /// When the object is initially created, it will be set to time_created.
    pub update_storage_class_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Whether an object is under temporary hold. While this flag is set
    /// to true, the object is protected against deletion and overwrites.  A common
    /// use case of this flag is regulatory investigations where objects need to be
    /// retained while the investigation is ongoing. Note that unlike event-based
    /// hold, temporary hold does not impact retention expiration time of an
    /// object.
    pub temporary_hold: bool,

    /// Optional. A server-determined value that specifies the earliest time that
    /// the object's retention period expires. Note 1: This field is not provided
    /// for objects with an active event-based hold, since retention expiration is
    /// unknown until the hold is removed. Note 2: This value can be provided even
    /// when temporary hold is set (so that the user can reason about policy
    /// without having to first unset the temporary hold).
    pub retention_expire_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User-provided metadata, in key/value pairs.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. User-defined or system-defined object contexts. Each object
    /// context is a key-payload pair, where the key provides the identification
    /// and the payload holds the associated value and additional metadata.
    pub contexts: std::option::Option<crate::model::ObjectContexts>,

    /// Whether an object is under event-based hold.
    /// An event-based hold is a way to force the retention of an object until
    /// after some event occurs. Once the hold is released by explicitly setting
    /// this field to false, the object will become subject to any bucket-level
    /// retention policy, except that the retention duration will be calculated
    /// from the time the event based hold was lifted, rather than the time the
    /// object was created.
    ///
    /// In a WriteObject request, not setting this field implies that the value
    /// should be taken from the parent bucket's "default_event_based_hold" field.
    /// In a response, this field will always be set to true or false.
    pub event_based_hold: std::option::Option<bool>,

    /// Output only. The owner of the object. This will always be the uploader of
    /// the object.
    pub owner: std::option::Option<crate::model::Owner>,

    /// Optional. Metadata of Customer-Supplied Encryption Key, if the object is
    /// encrypted by such a key.
    pub customer_encryption: std::option::Option<crate::model::CustomerEncryption>,

    /// Optional. A user-specified timestamp set on an object.
    pub custom_time: std::option::Option<wkt::Timestamp>,

    /// Output only. This is the time when the object became soft-deleted.
    ///
    /// Soft-deleted objects are only accessible if a soft_delete_policy is
    /// enabled. Also see hard_delete_time.
    pub soft_delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the object will be permanently deleted.
    ///
    /// Only set when an object becomes soft-deleted with a soft_delete_policy.
    /// Otherwise, the object will not be accessible.
    pub hard_delete_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Retention configuration of this object.
    /// May only be configured if the bucket has object retention enabled.
    pub retention: std::option::Option<crate::model::object::Retention>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Object {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Object::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [bucket][crate::model::Object::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Object::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::Object::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [restore_token][crate::model::Object::restore_token].
    pub fn set_restore_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.restore_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore_token][crate::model::Object::restore_token].
    pub fn set_or_clear_restore_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.restore_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metageneration][crate::model::Object::metageneration].
    pub fn set_metageneration<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.metageneration = v.into();
        self
    }

    /// Sets the value of [storage_class][crate::model::Object::storage_class].
    pub fn set_storage_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_class = v.into();
        self
    }

    /// Sets the value of [size][crate::model::Object::size].
    pub fn set_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size = v.into();
        self
    }

    /// Sets the value of [content_encoding][crate::model::Object::content_encoding].
    pub fn set_content_encoding<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.content_encoding = v.into();
        self
    }

    /// Sets the value of [content_disposition][crate::model::Object::content_disposition].
    pub fn set_content_disposition<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.content_disposition = v.into();
        self
    }

    /// Sets the value of [cache_control][crate::model::Object::cache_control].
    pub fn set_cache_control<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cache_control = v.into();
        self
    }

    /// Sets the value of [acl][crate::model::Object::acl].
    pub fn set_acl<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ObjectAccessControl>,
    {
        use std::iter::Iterator;
        self.acl = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [content_language][crate::model::Object::content_language].
    pub fn set_content_language<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.content_language = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Object::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Object::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finalize_time][crate::model::Object::finalize_time].
    pub fn set_finalize_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finalize_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finalize_time][crate::model::Object::finalize_time].
    pub fn set_or_clear_finalize_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finalize_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [content_type][crate::model::Object::content_type].
    pub fn set_content_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content_type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Object::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Object::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [component_count][crate::model::Object::component_count].
    pub fn set_component_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.component_count = v.into();
        self
    }

    /// Sets the value of [checksums][crate::model::Object::checksums].
    pub fn set_checksums<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ObjectChecksums>,
    {
        self.checksums = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [checksums][crate::model::Object::checksums].
    pub fn set_or_clear_checksums<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ObjectChecksums>,
    {
        self.checksums = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Object::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Object::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kms_key][crate::model::Object::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [update_storage_class_time][crate::model::Object::update_storage_class_time].
    pub fn set_update_storage_class_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_storage_class_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_storage_class_time][crate::model::Object::update_storage_class_time].
    pub fn set_or_clear_update_storage_class_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_storage_class_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [temporary_hold][crate::model::Object::temporary_hold].
    pub fn set_temporary_hold<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.temporary_hold = v.into();
        self
    }

    /// Sets the value of [retention_expire_time][crate::model::Object::retention_expire_time].
    pub fn set_retention_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.retention_expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retention_expire_time][crate::model::Object::retention_expire_time].
    pub fn set_or_clear_retention_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.retention_expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::Object::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [contexts][crate::model::Object::contexts].
    pub fn set_contexts<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ObjectContexts>,
    {
        self.contexts = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [contexts][crate::model::Object::contexts].
    pub fn set_or_clear_contexts<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ObjectContexts>,
    {
        self.contexts = v.map(|x| x.into());
        self
    }

    /// Sets the value of [event_based_hold][crate::model::Object::event_based_hold].
    pub fn set_event_based_hold<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.event_based_hold = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_based_hold][crate::model::Object::event_based_hold].
    pub fn set_or_clear_event_based_hold<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.event_based_hold = v.map(|x| x.into());
        self
    }

    /// Sets the value of [owner][crate::model::Object::owner].
    pub fn set_owner<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Owner>,
    {
        self.owner = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [owner][crate::model::Object::owner].
    pub fn set_or_clear_owner<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Owner>,
    {
        self.owner = v.map(|x| x.into());
        self
    }

    /// Sets the value of [customer_encryption][crate::model::Object::customer_encryption].
    pub fn set_customer_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryption>,
    {
        self.customer_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [customer_encryption][crate::model::Object::customer_encryption].
    pub fn set_or_clear_customer_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryption>,
    {
        self.customer_encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom_time][crate::model::Object::custom_time].
    pub fn set_custom_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.custom_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_time][crate::model::Object::custom_time].
    pub fn set_or_clear_custom_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.custom_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [soft_delete_time][crate::model::Object::soft_delete_time].
    pub fn set_soft_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.soft_delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [soft_delete_time][crate::model::Object::soft_delete_time].
    pub fn set_or_clear_soft_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.soft_delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [hard_delete_time][crate::model::Object::hard_delete_time].
    pub fn set_hard_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.hard_delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hard_delete_time][crate::model::Object::hard_delete_time].
    pub fn set_or_clear_hard_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.hard_delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [retention][crate::model::Object::retention].
    pub fn set_retention<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::object::Retention>,
    {
        self.retention = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retention][crate::model::Object::retention].
    pub fn set_or_clear_retention<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::object::Retention>,
    {
        self.retention = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Object {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.Object"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Object {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __bucket,
            __etag,
            __generation,
            __restore_token,
            __metageneration,
            __storage_class,
            __size,
            __content_encoding,
            __content_disposition,
            __cache_control,
            __acl,
            __content_language,
            __delete_time,
            __finalize_time,
            __content_type,
            __create_time,
            __component_count,
            __checksums,
            __update_time,
            __kms_key,
            __update_storage_class_time,
            __temporary_hold,
            __retention_expire_time,
            __metadata,
            __contexts,
            __event_based_hold,
            __owner,
            __customer_encryption,
            __custom_time,
            __soft_delete_time,
            __hard_delete_time,
            __retention,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Object")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "bucket" => Ok(__FieldTag::__bucket),
                            "etag" => Ok(__FieldTag::__etag),
                            "generation" => Ok(__FieldTag::__generation),
                            "restoreToken" => Ok(__FieldTag::__restore_token),
                            "restore_token" => Ok(__FieldTag::__restore_token),
                            "metageneration" => Ok(__FieldTag::__metageneration),
                            "storageClass" => Ok(__FieldTag::__storage_class),
                            "storage_class" => Ok(__FieldTag::__storage_class),
                            "size" => Ok(__FieldTag::__size),
                            "contentEncoding" => Ok(__FieldTag::__content_encoding),
                            "content_encoding" => Ok(__FieldTag::__content_encoding),
                            "contentDisposition" => Ok(__FieldTag::__content_disposition),
                            "content_disposition" => Ok(__FieldTag::__content_disposition),
                            "cacheControl" => Ok(__FieldTag::__cache_control),
                            "cache_control" => Ok(__FieldTag::__cache_control),
                            "acl" => Ok(__FieldTag::__acl),
                            "contentLanguage" => Ok(__FieldTag::__content_language),
                            "content_language" => Ok(__FieldTag::__content_language),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "finalizeTime" => Ok(__FieldTag::__finalize_time),
                            "finalize_time" => Ok(__FieldTag::__finalize_time),
                            "contentType" => Ok(__FieldTag::__content_type),
                            "content_type" => Ok(__FieldTag::__content_type),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "componentCount" => Ok(__FieldTag::__component_count),
                            "component_count" => Ok(__FieldTag::__component_count),
                            "checksums" => Ok(__FieldTag::__checksums),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            "updateStorageClassTime" => Ok(__FieldTag::__update_storage_class_time),
                            "update_storage_class_time" => {
                                Ok(__FieldTag::__update_storage_class_time)
                            }
                            "temporaryHold" => Ok(__FieldTag::__temporary_hold),
                            "temporary_hold" => Ok(__FieldTag::__temporary_hold),
                            "retentionExpireTime" => Ok(__FieldTag::__retention_expire_time),
                            "retention_expire_time" => Ok(__FieldTag::__retention_expire_time),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "contexts" => Ok(__FieldTag::__contexts),
                            "eventBasedHold" => Ok(__FieldTag::__event_based_hold),
                            "event_based_hold" => Ok(__FieldTag::__event_based_hold),
                            "owner" => Ok(__FieldTag::__owner),
                            "customerEncryption" => Ok(__FieldTag::__customer_encryption),
                            "customer_encryption" => Ok(__FieldTag::__customer_encryption),
                            "customTime" => Ok(__FieldTag::__custom_time),
                            "custom_time" => Ok(__FieldTag::__custom_time),
                            "softDeleteTime" => Ok(__FieldTag::__soft_delete_time),
                            "soft_delete_time" => Ok(__FieldTag::__soft_delete_time),
                            "hardDeleteTime" => Ok(__FieldTag::__hard_delete_time),
                            "hard_delete_time" => Ok(__FieldTag::__hard_delete_time),
                            "retention" => Ok(__FieldTag::__retention),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Object;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Object")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__restore_token => {
                            if !fields.insert(__FieldTag::__restore_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_token",
                                ));
                            }
                            result.restore_token =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__metageneration => {
                            if !fields.insert(__FieldTag::__metageneration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metageneration",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.metageneration =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__storage_class => {
                            if !fields.insert(__FieldTag::__storage_class) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_class",
                                ));
                            }
                            result.storage_class = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size => {
                            if !fields.insert(__FieldTag::__size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__content_encoding => {
                            if !fields.insert(__FieldTag::__content_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_encoding",
                                ));
                            }
                            result.content_encoding = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content_disposition => {
                            if !fields.insert(__FieldTag::__content_disposition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_disposition",
                                ));
                            }
                            result.content_disposition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cache_control => {
                            if !fields.insert(__FieldTag::__cache_control) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cache_control",
                                ));
                            }
                            result.cache_control = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__acl => {
                            if !fields.insert(__FieldTag::__acl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for acl",
                                ));
                            }
                            result.acl = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ObjectAccessControl>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content_language => {
                            if !fields.insert(__FieldTag::__content_language) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_language",
                                ));
                            }
                            result.content_language = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__finalize_time => {
                            if !fields.insert(__FieldTag::__finalize_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finalize_time",
                                ));
                            }
                            result.finalize_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__content_type => {
                            if !fields.insert(__FieldTag::__content_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_type",
                                ));
                            }
                            result.content_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__component_count => {
                            if !fields.insert(__FieldTag::__component_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for component_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.component_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__checksums => {
                            if !fields.insert(__FieldTag::__checksums) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for checksums",
                                ));
                            }
                            result.checksums = map
                                .next_value::<std::option::Option<crate::model::ObjectChecksums>>(
                                )?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_storage_class_time => {
                            if !fields.insert(__FieldTag::__update_storage_class_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_storage_class_time",
                                ));
                            }
                            result.update_storage_class_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__temporary_hold => {
                            if !fields.insert(__FieldTag::__temporary_hold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for temporary_hold",
                                ));
                            }
                            result.temporary_hold = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__retention_expire_time => {
                            if !fields.insert(__FieldTag::__retention_expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_expire_time",
                                ));
                            }
                            result.retention_expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__contexts => {
                            if !fields.insert(__FieldTag::__contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contexts",
                                ));
                            }
                            result.contexts = map
                                .next_value::<std::option::Option<crate::model::ObjectContexts>>(
                                )?;
                        }
                        __FieldTag::__event_based_hold => {
                            if !fields.insert(__FieldTag::__event_based_hold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_based_hold",
                                ));
                            }
                            result.event_based_hold =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__owner => {
                            if !fields.insert(__FieldTag::__owner) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for owner",
                                ));
                            }
                            result.owner =
                                map.next_value::<std::option::Option<crate::model::Owner>>()?;
                        }
                        __FieldTag::__customer_encryption => {
                            if !fields.insert(__FieldTag::__customer_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer_encryption",
                                ));
                            }
                            result.customer_encryption = map.next_value::<std::option::Option<crate::model::CustomerEncryption>>()?
                                ;
                        }
                        __FieldTag::__custom_time => {
                            if !fields.insert(__FieldTag::__custom_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_time",
                                ));
                            }
                            result.custom_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__soft_delete_time => {
                            if !fields.insert(__FieldTag::__soft_delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for soft_delete_time",
                                ));
                            }
                            result.soft_delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__hard_delete_time => {
                            if !fields.insert(__FieldTag::__hard_delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hard_delete_time",
                                ));
                            }
                            result.hard_delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__retention => {
                            if !fields.insert(__FieldTag::__retention) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention",
                                ));
                            }
                            result.retention = map
                                .next_value::<std::option::Option<crate::model::object::Retention>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Object {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if self.restore_token.is_some() {
            state.serialize_entry("restoreToken", &self.restore_token)?;
        }
        if !wkt::internal::is_default(&self.metageneration) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("metageneration", &__With(&self.metageneration))?;
        }
        if !self.storage_class.is_empty() {
            state.serialize_entry("storageClass", &self.storage_class)?;
        }
        if !wkt::internal::is_default(&self.size) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("size", &__With(&self.size))?;
        }
        if !self.content_encoding.is_empty() {
            state.serialize_entry("contentEncoding", &self.content_encoding)?;
        }
        if !self.content_disposition.is_empty() {
            state.serialize_entry("contentDisposition", &self.content_disposition)?;
        }
        if !self.cache_control.is_empty() {
            state.serialize_entry("cacheControl", &self.cache_control)?;
        }
        if !self.acl.is_empty() {
            state.serialize_entry("acl", &self.acl)?;
        }
        if !self.content_language.is_empty() {
            state.serialize_entry("contentLanguage", &self.content_language)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if self.finalize_time.is_some() {
            state.serialize_entry("finalizeTime", &self.finalize_time)?;
        }
        if !self.content_type.is_empty() {
            state.serialize_entry("contentType", &self.content_type)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.component_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("componentCount", &__With(&self.component_count))?;
        }
        if self.checksums.is_some() {
            state.serialize_entry("checksums", &self.checksums)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if self.update_storage_class_time.is_some() {
            state.serialize_entry("updateStorageClassTime", &self.update_storage_class_time)?;
        }
        if !wkt::internal::is_default(&self.temporary_hold) {
            state.serialize_entry("temporaryHold", &self.temporary_hold)?;
        }
        if self.retention_expire_time.is_some() {
            state.serialize_entry("retentionExpireTime", &self.retention_expire_time)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if self.contexts.is_some() {
            state.serialize_entry("contexts", &self.contexts)?;
        }
        if self.event_based_hold.is_some() {
            state.serialize_entry("eventBasedHold", &self.event_based_hold)?;
        }
        if self.owner.is_some() {
            state.serialize_entry("owner", &self.owner)?;
        }
        if self.customer_encryption.is_some() {
            state.serialize_entry("customerEncryption", &self.customer_encryption)?;
        }
        if self.custom_time.is_some() {
            state.serialize_entry("customTime", &self.custom_time)?;
        }
        if self.soft_delete_time.is_some() {
            state.serialize_entry("softDeleteTime", &self.soft_delete_time)?;
        }
        if self.hard_delete_time.is_some() {
            state.serialize_entry("hardDeleteTime", &self.hard_delete_time)?;
        }
        if self.retention.is_some() {
            state.serialize_entry("retention", &self.retention)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Object].
pub mod object {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies retention parameters of the object. Objects under retention
    /// cannot be deleted or overwritten until their retention expires.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Retention {
        /// Optional. The mode of the Retention.
        pub mode: crate::model::object::retention::Mode,

        /// Optional. The timestamp that the object needs to be retained until.
        /// Value cannot be set in the past or more than 100 years in the future.
        pub retain_until_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Retention {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mode][crate::model::object::Retention::mode].
        pub fn set_mode<T: std::convert::Into<crate::model::object::retention::Mode>>(
            mut self,
            v: T,
        ) -> Self {
            self.mode = v.into();
            self
        }

        /// Sets the value of [retain_until_time][crate::model::object::Retention::retain_until_time].
        pub fn set_retain_until_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.retain_until_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [retain_until_time][crate::model::object::Retention::retain_until_time].
        pub fn set_or_clear_retain_until_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.retain_until_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Retention {
        fn typename() -> &'static str {
            "type.googleapis.com/google.storage.v2.Object.Retention"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Retention {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __mode,
                __retain_until_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Retention")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "mode" => Ok(__FieldTag::__mode),
                                "retainUntilTime" => Ok(__FieldTag::__retain_until_time),
                                "retain_until_time" => Ok(__FieldTag::__retain_until_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Retention;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Retention")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__mode => {
                                if !fields.insert(__FieldTag::__mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mode",
                                    ));
                                }
                                result.mode = map.next_value::<std::option::Option<crate::model::object::retention::Mode>>()?.unwrap_or_default();
                            }
                            __FieldTag::__retain_until_time => {
                                if !fields.insert(__FieldTag::__retain_until_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for retain_until_time",
                                    ));
                                }
                                result.retain_until_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Retention {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.mode) {
                state.serialize_entry("mode", &self.mode)?;
            }
            if self.retain_until_time.is_some() {
                state.serialize_entry("retainUntilTime", &self.retain_until_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Retention].
    pub mod retention {
        #[allow(unused_imports)]
        use super::*;

        /// Retention mode values.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Mode {
            /// No specified mode. Object is not under retention.
            Unspecified,
            /// Retention period may be decreased or increased.
            /// The Retention configuration may be removed.
            /// The mode may be changed to locked.
            Unlocked,
            /// Retention period may be increased.
            /// The Retention configuration cannot be removed.
            /// The mode cannot be changed.
            Locked,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Mode::value] or
            /// [Mode::name].
            UnknownValue(mode::UnknownValue),
        }

        #[doc(hidden)]
        pub mod mode {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Mode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Unlocked => std::option::Option::Some(1),
                    Self::Locked => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                    Self::Unlocked => std::option::Option::Some("UNLOCKED"),
                    Self::Locked => std::option::Option::Some("LOCKED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Mode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Mode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Mode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Unlocked,
                    2 => Self::Locked,
                    _ => Self::UnknownValue(mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Mode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "MODE_UNSPECIFIED" => Self::Unspecified,
                    "UNLOCKED" => Self::Unlocked,
                    "LOCKED" => Self::Locked,
                    _ => Self::UnknownValue(mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Mode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Unlocked => serializer.serialize_i32(1),
                    Self::Locked => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Mode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                    ".google.storage.v2.Object.Retention.Mode",
                ))
            }
        }
    }
}

/// An access-control entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ObjectAccessControl {
    /// Optional. The access permission for the entity. One of the following
    /// values:
    ///
    /// * `READER`
    /// * `WRITER`
    /// * `OWNER`
    pub role: std::string::String,

    /// Optional. The ID of the access-control entry.
    pub id: std::string::String,

    /// Optional. The entity holding the permission, in one of the following forms:
    ///
    /// * `user-{userid}`
    /// * `user-{email}`
    /// * `group-{groupid}`
    /// * `group-{email}`
    /// * `domain-{domain}`
    /// * `project-{team}-{projectnumber}`
    /// * `project-{team}-{projectid}`
    /// * `allUsers`
    /// * `allAuthenticatedUsers`
    ///   Examples:
    /// * The user `liz@example.com` would be `user-liz@example.com`.
    /// * The group `example@googlegroups.com` would be
    ///   `group-example@googlegroups.com`.
    /// * All members of the Google Apps for Business domain `example.com` would be
    ///   `domain-example.com`.
    ///   For project entities, `project-{team}-{projectnumber}` format will be
    ///   returned on response.
    pub entity: std::string::String,

    /// Output only. The alternative entity format, if exists. For project
    /// entities, `project-{team}-{projectid}` format will be returned on response.
    pub entity_alt: std::string::String,

    /// Optional. The ID for the entity, if any.
    pub entity_id: std::string::String,

    /// Optional. The etag of the ObjectAccessControl.
    /// If included in the metadata of an update or delete request message, the
    /// operation will only be performed if the etag matches that of the live
    /// object's ObjectAccessControl.
    pub etag: std::string::String,

    /// Optional. The email address associated with the entity, if any.
    pub email: std::string::String,

    /// Optional. The domain associated with the entity, if any.
    pub domain: std::string::String,

    /// Optional. The project team associated with the entity, if any.
    pub project_team: std::option::Option<crate::model::ProjectTeam>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectAccessControl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role][crate::model::ObjectAccessControl::role].
    pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [id][crate::model::ObjectAccessControl::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [entity][crate::model::ObjectAccessControl::entity].
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity = v.into();
        self
    }

    /// Sets the value of [entity_alt][crate::model::ObjectAccessControl::entity_alt].
    pub fn set_entity_alt<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_alt = v.into();
        self
    }

    /// Sets the value of [entity_id][crate::model::ObjectAccessControl::entity_id].
    pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::ObjectAccessControl::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [email][crate::model::ObjectAccessControl::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::ObjectAccessControl::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [project_team][crate::model::ObjectAccessControl::project_team].
    pub fn set_project_team<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProjectTeam>,
    {
        self.project_team = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [project_team][crate::model::ObjectAccessControl::project_team].
    pub fn set_or_clear_project_team<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProjectTeam>,
    {
        self.project_team = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ObjectAccessControl {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ObjectAccessControl"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ObjectAccessControl {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __role,
            __id,
            __entity,
            __entity_alt,
            __entity_id,
            __etag,
            __email,
            __domain,
            __project_team,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectAccessControl")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "role" => Ok(__FieldTag::__role),
                            "id" => Ok(__FieldTag::__id),
                            "entity" => Ok(__FieldTag::__entity),
                            "entityAlt" => Ok(__FieldTag::__entity_alt),
                            "entity_alt" => Ok(__FieldTag::__entity_alt),
                            "entityId" => Ok(__FieldTag::__entity_id),
                            "entity_id" => Ok(__FieldTag::__entity_id),
                            "etag" => Ok(__FieldTag::__etag),
                            "email" => Ok(__FieldTag::__email),
                            "domain" => Ok(__FieldTag::__domain),
                            "projectTeam" => Ok(__FieldTag::__project_team),
                            "project_team" => Ok(__FieldTag::__project_team),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ObjectAccessControl;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectAccessControl")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity",
                                ));
                            }
                            result.entity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_alt => {
                            if !fields.insert(__FieldTag::__entity_alt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_alt",
                                ));
                            }
                            result.entity_alt = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_id => {
                            if !fields.insert(__FieldTag::__entity_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_id",
                                ));
                            }
                            result.entity_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_team => {
                            if !fields.insert(__FieldTag::__project_team) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_team",
                                ));
                            }
                            result.project_team =
                                map.next_value::<std::option::Option<crate::model::ProjectTeam>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ObjectAccessControl {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.role.is_empty() {
            state.serialize_entry("role", &self.role)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.entity.is_empty() {
            state.serialize_entry("entity", &self.entity)?;
        }
        if !self.entity_alt.is_empty() {
            state.serialize_entry("entityAlt", &self.entity_alt)?;
        }
        if !self.entity_id.is_empty() {
            state.serialize_entry("entityId", &self.entity_id)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self.domain.is_empty() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if self.project_team.is_some() {
            state.serialize_entry("projectTeam", &self.project_team)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The result of a call to Objects.ListObjects
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListObjectsResponse {
    /// The list of items.
    pub objects: std::vec::Vec<crate::model::Object>,

    /// The list of prefixes of objects matching-but-not-listed up to and including
    /// the requested delimiter.
    pub prefixes: std::vec::Vec<std::string::String>,

    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListObjectsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [objects][crate::model::ListObjectsResponse::objects].
    pub fn set_objects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Object>,
    {
        use std::iter::Iterator;
        self.objects = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [prefixes][crate::model::ListObjectsResponse::prefixes].
    pub fn set_prefixes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.prefixes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListObjectsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListObjectsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ListObjectsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListObjectsResponse {
    type PageItem = crate::model::Object;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.objects
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListObjectsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __objects,
            __prefixes,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListObjectsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "objects" => Ok(__FieldTag::__objects),
                            "prefixes" => Ok(__FieldTag::__prefixes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListObjectsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListObjectsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__objects => {
                            if !fields.insert(__FieldTag::__objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects",
                                ));
                            }
                            result.objects = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Object>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__prefixes => {
                            if !fields.insert(__FieldTag::__prefixes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prefixes",
                                ));
                            }
                            result.prefixes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListObjectsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.objects.is_empty() {
            state.serialize_entry("objects", &self.objects)?;
        }
        if !self.prefixes.is_empty() {
            state.serialize_entry("prefixes", &self.prefixes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the Viewers, Editors, or Owners of a given project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ProjectTeam {
    /// Optional. The project number.
    pub project_number: std::string::String,

    /// Optional. The team.
    pub team: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProjectTeam {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_number][crate::model::ProjectTeam::project_number].
    pub fn set_project_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_number = v.into();
        self
    }

    /// Sets the value of [team][crate::model::ProjectTeam::team].
    pub fn set_team<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.team = v.into();
        self
    }
}

impl wkt::message::Message for ProjectTeam {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.ProjectTeam"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProjectTeam {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_number,
            __team,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProjectTeam")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectNumber" => Ok(__FieldTag::__project_number),
                            "project_number" => Ok(__FieldTag::__project_number),
                            "team" => Ok(__FieldTag::__team),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProjectTeam;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProjectTeam")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_number => {
                            if !fields.insert(__FieldTag::__project_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_number",
                                ));
                            }
                            result.project_number = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__team => {
                            if !fields.insert(__FieldTag::__team) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for team",
                                ));
                            }
                            result.team = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProjectTeam {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_number.is_empty() {
            state.serialize_entry("projectNumber", &self.project_number)?;
        }
        if !self.team.is_empty() {
            state.serialize_entry("team", &self.team)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The owner of a specific resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Owner {
    /// Optional. The entity, in the form `user-`*userId*.
    pub entity: std::string::String,

    /// Optional. The ID for the entity.
    pub entity_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Owner {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity][crate::model::Owner::entity].
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity = v.into();
        self
    }

    /// Sets the value of [entity_id][crate::model::Owner::entity_id].
    pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_id = v.into();
        self
    }
}

impl wkt::message::Message for Owner {
    fn typename() -> &'static str {
        "type.googleapis.com/google.storage.v2.Owner"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Owner {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity,
            __entity_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Owner")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entity" => Ok(__FieldTag::__entity),
                            "entityId" => Ok(__FieldTag::__entity_id),
                            "entity_id" => Ok(__FieldTag::__entity_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Owner;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Owner")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity",
                                ));
                            }
                            result.entity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_id => {
                            if !fields.insert(__FieldTag::__entity_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_id",
                                ));
                            }
                            result.entity_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Owner {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity.is_empty() {
            state.serialize_entry("entity", &self.entity)?;
        }
        if !self.entity_id.is_empty() {
            state.serialize_entry("entityId", &self.entity_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
