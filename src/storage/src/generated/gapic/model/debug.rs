// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::DeleteBucketRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteBucketRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("if_metageneration_match", &self.if_metageneration_match);
        debug_struct.field("if_metageneration_not_match", &self.if_metageneration_not_match);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetBucketRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBucketRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("if_metageneration_match", &self.if_metageneration_match);
        debug_struct.field("if_metageneration_not_match", &self.if_metageneration_not_match);
        debug_struct.field("read_mask", &self.read_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateBucketRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateBucketRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("bucket_id", &self.bucket_id);
        debug_struct.field("predefined_acl", &self.predefined_acl);
        debug_struct.field("predefined_default_object_acl", &self.predefined_default_object_acl);
        debug_struct.field("enable_object_retention", &self.enable_object_retention);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBucketsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBucketsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("prefix", &self.prefix);
        debug_struct.field("read_mask", &self.read_mask);
        debug_struct.field("return_partial_success", &self.return_partial_success);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBucketsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBucketsResponse");
        debug_struct.field("buckets", &self.buckets);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LockBucketRetentionPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LockBucketRetentionPolicyRequest");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("if_metageneration_match", &self.if_metageneration_match);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateBucketRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateBucketRequest");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("if_metageneration_match", &self.if_metageneration_match);
        debug_struct.field("if_metageneration_not_match", &self.if_metageneration_not_match);
        debug_struct.field("predefined_acl", &self.predefined_acl);
        debug_struct.field("predefined_default_object_acl", &self.predefined_default_object_acl);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ComposeObjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComposeObjectRequest");
        debug_struct.field("destination", &self.destination);
        debug_struct.field("source_objects", &self.source_objects);
        debug_struct.field("destination_predefined_acl", &self.destination_predefined_acl);
        debug_struct.field("if_generation_match", &self.if_generation_match);
        debug_struct.field("if_metageneration_match", &self.if_metageneration_match);
        debug_struct.field("kms_key", &self.kms_key);
        debug_struct.field("common_object_request_params", &self.common_object_request_params);
        debug_struct.field("object_checksums", &self.object_checksums);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::compose_object_request::SourceObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceObject");
        debug_struct.field("name", &self.name);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("object_preconditions", &self.object_preconditions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::compose_object_request::source_object::ObjectPreconditions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ObjectPreconditions");
        debug_struct.field("if_generation_match", &self.if_generation_match);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteObjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteObjectRequest");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("object", &self.object);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("if_generation_match", &self.if_generation_match);
        debug_struct.field("if_generation_not_match", &self.if_generation_not_match);
        debug_struct.field("if_metageneration_match", &self.if_metageneration_match);
        debug_struct.field("if_metageneration_not_match", &self.if_metageneration_not_match);
        debug_struct.field("common_object_request_params", &self.common_object_request_params);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RestoreObjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RestoreObjectRequest");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("object", &self.object);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("restore_token", &self.restore_token);
        debug_struct.field("if_generation_match", &self.if_generation_match);
        debug_struct.field("if_generation_not_match", &self.if_generation_not_match);
        debug_struct.field("if_metageneration_match", &self.if_metageneration_match);
        debug_struct.field("if_metageneration_not_match", &self.if_metageneration_not_match);
        debug_struct.field("copy_source_acl", &self.copy_source_acl);
        debug_struct.field("common_object_request_params", &self.common_object_request_params);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReadObjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReadObjectRequest");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("object", &self.object);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("read_offset", &self.read_offset);
        debug_struct.field("read_limit", &self.read_limit);
        debug_struct.field("if_generation_match", &self.if_generation_match);
        debug_struct.field("if_generation_not_match", &self.if_generation_not_match);
        debug_struct.field("if_metageneration_match", &self.if_metageneration_match);
        debug_struct.field("if_metageneration_not_match", &self.if_metageneration_not_match);
        debug_struct.field("common_object_request_params", &self.common_object_request_params);
        debug_struct.field("read_mask", &self.read_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetObjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetObjectRequest");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("object", &self.object);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("soft_deleted", &self.soft_deleted);
        debug_struct.field("if_generation_match", &self.if_generation_match);
        debug_struct.field("if_generation_not_match", &self.if_generation_not_match);
        debug_struct.field("if_metageneration_match", &self.if_metageneration_match);
        debug_struct.field("if_metageneration_not_match", &self.if_metageneration_not_match);
        debug_struct.field("common_object_request_params", &self.common_object_request_params);
        debug_struct.field("read_mask", &self.read_mask);
        debug_struct.field("restore_token", &self.restore_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WriteObjectSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WriteObjectSpec");
        debug_struct.field("resource", &self.resource);
        debug_struct.field("predefined_acl", &self.predefined_acl);
        debug_struct.field("if_generation_match", &self.if_generation_match);
        debug_struct.field("if_generation_not_match", &self.if_generation_not_match);
        debug_struct.field("if_metageneration_match", &self.if_metageneration_match);
        debug_struct.field("if_metageneration_not_match", &self.if_metageneration_not_match);
        debug_struct.field("object_size", &self.object_size);
        debug_struct.field("appendable", &self.appendable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListObjectsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListObjectsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("delimiter", &self.delimiter);
        debug_struct.field("include_trailing_delimiter", &self.include_trailing_delimiter);
        debug_struct.field("prefix", &self.prefix);
        debug_struct.field("versions", &self.versions);
        debug_struct.field("read_mask", &self.read_mask);
        debug_struct.field("lexicographic_start", &self.lexicographic_start);
        debug_struct.field("lexicographic_end", &self.lexicographic_end);
        debug_struct.field("soft_deleted", &self.soft_deleted);
        debug_struct.field("include_folders_as_prefixes", &self.include_folders_as_prefixes);
        debug_struct.field("match_glob", &self.match_glob);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RewriteObjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RewriteObjectRequest");
        debug_struct.field("destination_name", &self.destination_name);
        debug_struct.field("destination_bucket", &self.destination_bucket);
        debug_struct.field("destination_kms_key", &self.destination_kms_key);
        debug_struct.field("destination", &self.destination);
        debug_struct.field("source_bucket", &self.source_bucket);
        debug_struct.field("source_object", &self.source_object);
        debug_struct.field("source_generation", &self.source_generation);
        debug_struct.field("rewrite_token", &self.rewrite_token);
        debug_struct.field("destination_predefined_acl", &self.destination_predefined_acl);
        debug_struct.field("if_generation_match", &self.if_generation_match);
        debug_struct.field("if_generation_not_match", &self.if_generation_not_match);
        debug_struct.field("if_metageneration_match", &self.if_metageneration_match);
        debug_struct.field("if_metageneration_not_match", &self.if_metageneration_not_match);
        debug_struct.field("if_source_generation_match", &self.if_source_generation_match);
        debug_struct.field("if_source_generation_not_match", &self.if_source_generation_not_match);
        debug_struct.field("if_source_metageneration_match", &self.if_source_metageneration_match);
        debug_struct.field("if_source_metageneration_not_match", &self.if_source_metageneration_not_match);
        debug_struct.field("max_bytes_rewritten_per_call", &self.max_bytes_rewritten_per_call);
        debug_struct.field("copy_source_encryption_algorithm", &self.copy_source_encryption_algorithm);
        debug_struct.field("copy_source_encryption_key_bytes", &self.copy_source_encryption_key_bytes);
        debug_struct.field("copy_source_encryption_key_sha256_bytes", &self.copy_source_encryption_key_sha256_bytes);
        debug_struct.field("common_object_request_params", &self.common_object_request_params);
        debug_struct.field("object_checksums", &self.object_checksums);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RewriteResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RewriteResponse");
        debug_struct.field("total_bytes_rewritten", &self.total_bytes_rewritten);
        debug_struct.field("object_size", &self.object_size);
        debug_struct.field("done", &self.done);
        debug_struct.field("rewrite_token", &self.rewrite_token);
        debug_struct.field("resource", &self.resource);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MoveObjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MoveObjectRequest");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("source_object", &self.source_object);
        debug_struct.field("destination_object", &self.destination_object);
        debug_struct.field("if_source_generation_match", &self.if_source_generation_match);
        debug_struct.field("if_source_generation_not_match", &self.if_source_generation_not_match);
        debug_struct.field("if_source_metageneration_match", &self.if_source_metageneration_match);
        debug_struct.field("if_source_metageneration_not_match", &self.if_source_metageneration_not_match);
        debug_struct.field("if_generation_match", &self.if_generation_match);
        debug_struct.field("if_generation_not_match", &self.if_generation_not_match);
        debug_struct.field("if_metageneration_match", &self.if_metageneration_match);
        debug_struct.field("if_metageneration_not_match", &self.if_metageneration_not_match);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateObjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateObjectRequest");
        debug_struct.field("object", &self.object);
        debug_struct.field("if_generation_match", &self.if_generation_match);
        debug_struct.field("if_generation_not_match", &self.if_generation_not_match);
        debug_struct.field("if_metageneration_match", &self.if_metageneration_match);
        debug_struct.field("if_metageneration_not_match", &self.if_metageneration_not_match);
        debug_struct.field("predefined_acl", &self.predefined_acl);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("common_object_request_params", &self.common_object_request_params);
        debug_struct.field("override_unlocked_retention", &self.override_unlocked_retention);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CommonObjectRequestParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CommonObjectRequestParams");
        debug_struct.field("encryption_algorithm", &self.encryption_algorithm);
        debug_struct.field("encryption_key_bytes", &self.encryption_key_bytes);
        debug_struct.field("encryption_key_sha256_bytes", &self.encryption_key_sha256_bytes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Bucket {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Bucket");
        debug_struct.field("name", &self.name);
        debug_struct.field("bucket_id", &self.bucket_id);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("project", &self.project);
        debug_struct.field("metageneration", &self.metageneration);
        debug_struct.field("location", &self.location);
        debug_struct.field("location_type", &self.location_type);
        debug_struct.field("storage_class", &self.storage_class);
        debug_struct.field("rpo", &self.rpo);
        debug_struct.field("acl", &self.acl);
        debug_struct.field("default_object_acl", &self.default_object_acl);
        debug_struct.field("lifecycle", &self.lifecycle);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("cors", &self.cors);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("default_event_based_hold", &self.default_event_based_hold);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("website", &self.website);
        debug_struct.field("versioning", &self.versioning);
        debug_struct.field("logging", &self.logging);
        debug_struct.field("owner", &self.owner);
        debug_struct.field("encryption", &self.encryption);
        debug_struct.field("billing", &self.billing);
        debug_struct.field("retention_policy", &self.retention_policy);
        debug_struct.field("iam_config", &self.iam_config);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("custom_placement_config", &self.custom_placement_config);
        debug_struct.field("autoclass", &self.autoclass);
        debug_struct.field("hierarchical_namespace", &self.hierarchical_namespace);
        debug_struct.field("soft_delete_policy", &self.soft_delete_policy);
        debug_struct.field("object_retention", &self.object_retention);
        debug_struct.field("ip_filter", &self.ip_filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::Billing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Billing");
        debug_struct.field("requester_pays", &self.requester_pays);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::Cors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Cors");
        debug_struct.field("origin", &self.origin);
        debug_struct.field("method", &self.method);
        debug_struct.field("response_header", &self.response_header);
        debug_struct.field("max_age_seconds", &self.max_age_seconds);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::Encryption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Encryption");
        debug_struct.field("default_kms_key", &self.default_kms_key);
        debug_struct.field("google_managed_encryption_enforcement_config", &self.google_managed_encryption_enforcement_config);
        debug_struct.field("customer_managed_encryption_enforcement_config", &self.customer_managed_encryption_enforcement_config);
        debug_struct.field("customer_supplied_encryption_enforcement_config", &self.customer_supplied_encryption_enforcement_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::encryption::GoogleManagedEncryptionEnforcementConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GoogleManagedEncryptionEnforcementConfig");
        debug_struct.field("restriction_mode", &self.restriction_mode);
        debug_struct.field("effective_time", &self.effective_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::encryption::CustomerManagedEncryptionEnforcementConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomerManagedEncryptionEnforcementConfig");
        debug_struct.field("restriction_mode", &self.restriction_mode);
        debug_struct.field("effective_time", &self.effective_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomerSuppliedEncryptionEnforcementConfig");
        debug_struct.field("restriction_mode", &self.restriction_mode);
        debug_struct.field("effective_time", &self.effective_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::IamConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IamConfig");
        debug_struct.field("uniform_bucket_level_access", &self.uniform_bucket_level_access);
        debug_struct.field("public_access_prevention", &self.public_access_prevention);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::iam_config::UniformBucketLevelAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UniformBucketLevelAccess");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("lock_time", &self.lock_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::Lifecycle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Lifecycle");
        debug_struct.field("rule", &self.rule);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::lifecycle::Rule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Rule");
        debug_struct.field("action", &self.action);
        debug_struct.field("condition", &self.condition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::lifecycle::rule::Action {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Action");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("storage_class", &self.storage_class);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::lifecycle::rule::Condition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Condition");
        debug_struct.field("age_days", &self.age_days);
        debug_struct.field("created_before", &self.created_before);
        debug_struct.field("is_live", &self.is_live);
        debug_struct.field("num_newer_versions", &self.num_newer_versions);
        debug_struct.field("matches_storage_class", &self.matches_storage_class);
        debug_struct.field("days_since_custom_time", &self.days_since_custom_time);
        debug_struct.field("custom_time_before", &self.custom_time_before);
        debug_struct.field("days_since_noncurrent_time", &self.days_since_noncurrent_time);
        debug_struct.field("noncurrent_time_before", &self.noncurrent_time_before);
        debug_struct.field("matches_prefix", &self.matches_prefix);
        debug_struct.field("matches_suffix", &self.matches_suffix);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::Logging {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Logging");
        debug_struct.field("log_bucket", &self.log_bucket);
        debug_struct.field("log_object_prefix", &self.log_object_prefix);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::ObjectRetention {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ObjectRetention");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::RetentionPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RetentionPolicy");
        debug_struct.field("effective_time", &self.effective_time);
        debug_struct.field("is_locked", &self.is_locked);
        debug_struct.field("retention_duration", &self.retention_duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::SoftDeletePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SoftDeletePolicy");
        debug_struct.field("retention_duration", &self.retention_duration);
        debug_struct.field("effective_time", &self.effective_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::Versioning {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Versioning");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::Website {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Website");
        debug_struct.field("main_page_suffix", &self.main_page_suffix);
        debug_struct.field("not_found_page", &self.not_found_page);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::CustomPlacementConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomPlacementConfig");
        debug_struct.field("data_locations", &self.data_locations);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::Autoclass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Autoclass");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("toggle_time", &self.toggle_time);
        debug_struct.field("terminal_storage_class", &self.terminal_storage_class);
        debug_struct.field("terminal_storage_class_update_time", &self.terminal_storage_class_update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::IpFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IpFilter");
        debug_struct.field("mode", &self.mode);
        debug_struct.field("public_network_source", &self.public_network_source);
        debug_struct.field("vpc_network_sources", &self.vpc_network_sources);
        debug_struct.field("allow_cross_org_vpcs", &self.allow_cross_org_vpcs);
        debug_struct.field("allow_all_service_agent_access", &self.allow_all_service_agent_access);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::ip_filter::PublicNetworkSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PublicNetworkSource");
        debug_struct.field("allowed_ip_cidr_ranges", &self.allowed_ip_cidr_ranges);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::ip_filter::VpcNetworkSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VpcNetworkSource");
        debug_struct.field("network", &self.network);
        debug_struct.field("allowed_ip_cidr_ranges", &self.allowed_ip_cidr_ranges);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::bucket::HierarchicalNamespace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HierarchicalNamespace");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}


impl std::fmt::Debug for super::BucketAccessControl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BucketAccessControl");
        debug_struct.field("role", &self.role);
        debug_struct.field("id", &self.id);
        debug_struct.field("entity", &self.entity);
        debug_struct.field("entity_alt", &self.entity_alt);
        debug_struct.field("entity_id", &self.entity_id);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("email", &self.email);
        debug_struct.field("domain", &self.domain);
        debug_struct.field("project_team", &self.project_team);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ObjectChecksums {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ObjectChecksums");
        debug_struct.field("crc32c", &self.crc32c);
        debug_struct.field("md5_hash", &self.md5_hash);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ObjectCustomContextPayload {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ObjectCustomContextPayload");
        debug_struct.field("value", &self.value);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ObjectContexts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ObjectContexts");
        debug_struct.field("custom", &self.custom);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CustomerEncryption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomerEncryption");
        debug_struct.field("encryption_algorithm", &self.encryption_algorithm);
        debug_struct.field("key_sha256_bytes", &self.key_sha256_bytes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Object {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Object");
        debug_struct.field("name", &self.name);
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("restore_token", &self.restore_token);
        debug_struct.field("metageneration", &self.metageneration);
        debug_struct.field("storage_class", &self.storage_class);
        debug_struct.field("size", &self.size);
        debug_struct.field("content_encoding", &self.content_encoding);
        debug_struct.field("content_disposition", &self.content_disposition);
        debug_struct.field("cache_control", &self.cache_control);
        debug_struct.field("acl", &self.acl);
        debug_struct.field("content_language", &self.content_language);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("finalize_time", &self.finalize_time);
        debug_struct.field("content_type", &self.content_type);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("component_count", &self.component_count);
        debug_struct.field("checksums", &self.checksums);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("kms_key", &self.kms_key);
        debug_struct.field("update_storage_class_time", &self.update_storage_class_time);
        debug_struct.field("temporary_hold", &self.temporary_hold);
        debug_struct.field("retention_expire_time", &self.retention_expire_time);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("contexts", &self.contexts);
        debug_struct.field("event_based_hold", &self.event_based_hold);
        debug_struct.field("owner", &self.owner);
        debug_struct.field("customer_encryption", &self.customer_encryption);
        debug_struct.field("custom_time", &self.custom_time);
        debug_struct.field("soft_delete_time", &self.soft_delete_time);
        debug_struct.field("hard_delete_time", &self.hard_delete_time);
        debug_struct.field("retention", &self.retention);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::object::Retention {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Retention");
        debug_struct.field("mode", &self.mode);
        debug_struct.field("retain_until_time", &self.retain_until_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}


impl std::fmt::Debug for super::ObjectAccessControl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ObjectAccessControl");
        debug_struct.field("role", &self.role);
        debug_struct.field("id", &self.id);
        debug_struct.field("entity", &self.entity);
        debug_struct.field("entity_alt", &self.entity_alt);
        debug_struct.field("entity_id", &self.entity_id);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("email", &self.email);
        debug_struct.field("domain", &self.domain);
        debug_struct.field("project_team", &self.project_team);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListObjectsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListObjectsResponse");
        debug_struct.field("objects", &self.objects);
        debug_struct.field("prefixes", &self.prefixes);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ProjectTeam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProjectTeam");
        debug_struct.field("project_number", &self.project_number);
        debug_struct.field("team", &self.team);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Owner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Owner");
        debug_struct.field("entity", &self.entity);
        debug_struct.field("entity_id", &self.entity_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
