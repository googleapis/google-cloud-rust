// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteBucketRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationMatch", &__With(&self.if_metageneration_match))?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationNotMatch", &__With(&self.if_metageneration_not_match))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GetBucketRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationMatch", &__With(&self.if_metageneration_match))?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationNotMatch", &__With(&self.if_metageneration_not_match))?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CreateBucketRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.bucket.is_some() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.bucket_id.is_empty() {
            state.serialize_entry("bucketId", &self.bucket_id)?;
        }
        if !self.predefined_acl.is_empty() {
            state.serialize_entry("predefinedAcl", &self.predefined_acl)?;
        }
        if !self.predefined_default_object_acl.is_empty() {
            state.serialize_entry("predefinedDefaultObjectAcl", &self.predefined_default_object_acl)?;
        }
        if !wkt::internal::is_default(&self.enable_object_retention) {
            state.serialize_entry("enableObjectRetention", &self.enable_object_retention)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListBucketsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.prefix.is_empty() {
            state.serialize_entry("prefix", &self.prefix)?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !wkt::internal::is_default(&self.return_partial_success) {
            state.serialize_entry("returnPartialSuccess", &self.return_partial_success)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListBucketsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.buckets.is_empty() {
            state.serialize_entry("buckets", &self.buckets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::LockBucketRetentionPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !wkt::internal::is_default(&self.if_metageneration_match) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationMatch", &__With(&self.if_metageneration_match))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateBucketRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bucket.is_some() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationMatch", &__With(&self.if_metageneration_match))?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationNotMatch", &__With(&self.if_metageneration_not_match))?;
        }
        if !self.predefined_acl.is_empty() {
            state.serialize_entry("predefinedAcl", &self.predefined_acl)?;
        }
        if !self.predefined_default_object_acl.is_empty() {
            state.serialize_entry("predefinedDefaultObjectAcl", &self.predefined_default_object_acl)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ComposeObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.destination.is_some() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if !self.source_objects.is_empty() {
            state.serialize_entry("sourceObjects", &self.source_objects)?;
        }
        if !self.destination_predefined_acl.is_empty() {
            state.serialize_entry("destinationPredefinedAcl", &self.destination_predefined_acl)?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationMatch", &__With(&self.if_metageneration_match))?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if self.common_object_request_params.is_some() {
            state.serialize_entry("commonObjectRequestParams", &self.common_object_request_params)?;
        }
        if self.object_checksums.is_some() {
            state.serialize_entry("objectChecksums", &self.object_checksums)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::compose_object_request::SourceObject {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if self.object_preconditions.is_some() {
            state.serialize_entry("objectPreconditions", &self.object_preconditions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::compose_object_request::source_object::ObjectPreconditions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.object.is_empty() {
            state.serialize_entry("object", &self.object)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationNotMatch", &__With(&self.if_generation_not_match))?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationMatch", &__With(&self.if_metageneration_match))?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationNotMatch", &__With(&self.if_metageneration_not_match))?;
        }
        if self.common_object_request_params.is_some() {
            state.serialize_entry("commonObjectRequestParams", &self.common_object_request_params)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RestoreObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.object.is_empty() {
            state.serialize_entry("object", &self.object)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if !self.restore_token.is_empty() {
            state.serialize_entry("restoreToken", &self.restore_token)?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationNotMatch", &__With(&self.if_generation_not_match))?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationMatch", &__With(&self.if_metageneration_match))?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationNotMatch", &__With(&self.if_metageneration_not_match))?;
        }
        if self.copy_source_acl.is_some() {
            state.serialize_entry("copySourceAcl", &self.copy_source_acl)?;
        }
        if self.common_object_request_params.is_some() {
            state.serialize_entry("commonObjectRequestParams", &self.common_object_request_params)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ReadObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.object.is_empty() {
            state.serialize_entry("object", &self.object)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if !wkt::internal::is_default(&self.read_offset) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("readOffset", &__With(&self.read_offset))?;
        }
        if !wkt::internal::is_default(&self.read_limit) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("readLimit", &__With(&self.read_limit))?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationNotMatch", &__With(&self.if_generation_not_match))?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationMatch", &__With(&self.if_metageneration_match))?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationNotMatch", &__With(&self.if_metageneration_not_match))?;
        }
        if self.common_object_request_params.is_some() {
            state.serialize_entry("commonObjectRequestParams", &self.common_object_request_params)?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GetObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.object.is_empty() {
            state.serialize_entry("object", &self.object)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if self.soft_deleted.is_some() {
            state.serialize_entry("softDeleted", &self.soft_deleted)?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationNotMatch", &__With(&self.if_generation_not_match))?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationMatch", &__With(&self.if_metageneration_match))?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationNotMatch", &__With(&self.if_metageneration_not_match))?;
        }
        if self.common_object_request_params.is_some() {
            state.serialize_entry("commonObjectRequestParams", &self.common_object_request_params)?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self.restore_token.is_empty() {
            state.serialize_entry("restoreToken", &self.restore_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::WriteObjectSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self.predefined_acl.is_empty() {
            state.serialize_entry("predefinedAcl", &self.predefined_acl)?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationNotMatch", &__With(&self.if_generation_not_match))?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationMatch", &__With(&self.if_metageneration_match))?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationNotMatch", &__With(&self.if_metageneration_not_match))?;
        }
        if self.object_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("objectSize", &__With(&self.object_size))?;
        }
        if self.appendable.is_some() {
            state.serialize_entry("appendable", &self.appendable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListObjectsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.delimiter.is_empty() {
            state.serialize_entry("delimiter", &self.delimiter)?;
        }
        if !wkt::internal::is_default(&self.include_trailing_delimiter) {
            state.serialize_entry("includeTrailingDelimiter", &self.include_trailing_delimiter)?;
        }
        if !self.prefix.is_empty() {
            state.serialize_entry("prefix", &self.prefix)?;
        }
        if !wkt::internal::is_default(&self.versions) {
            state.serialize_entry("versions", &self.versions)?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self.lexicographic_start.is_empty() {
            state.serialize_entry("lexicographicStart", &self.lexicographic_start)?;
        }
        if !self.lexicographic_end.is_empty() {
            state.serialize_entry("lexicographicEnd", &self.lexicographic_end)?;
        }
        if !wkt::internal::is_default(&self.soft_deleted) {
            state.serialize_entry("softDeleted", &self.soft_deleted)?;
        }
        if !wkt::internal::is_default(&self.include_folders_as_prefixes) {
            state.serialize_entry("includeFoldersAsPrefixes", &self.include_folders_as_prefixes)?;
        }
        if !self.match_glob.is_empty() {
            state.serialize_entry("matchGlob", &self.match_glob)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RewriteObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.destination_name.is_empty() {
            state.serialize_entry("destinationName", &self.destination_name)?;
        }
        if !self.destination_bucket.is_empty() {
            state.serialize_entry("destinationBucket", &self.destination_bucket)?;
        }
        if !self.destination_kms_key.is_empty() {
            state.serialize_entry("destinationKmsKey", &self.destination_kms_key)?;
        }
        if self.destination.is_some() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if !self.source_bucket.is_empty() {
            state.serialize_entry("sourceBucket", &self.source_bucket)?;
        }
        if !self.source_object.is_empty() {
            state.serialize_entry("sourceObject", &self.source_object)?;
        }
        if !wkt::internal::is_default(&self.source_generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sourceGeneration", &__With(&self.source_generation))?;
        }
        if !self.rewrite_token.is_empty() {
            state.serialize_entry("rewriteToken", &self.rewrite_token)?;
        }
        if !self.destination_predefined_acl.is_empty() {
            state.serialize_entry("destinationPredefinedAcl", &self.destination_predefined_acl)?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationNotMatch", &__With(&self.if_generation_not_match))?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationMatch", &__With(&self.if_metageneration_match))?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationNotMatch", &__With(&self.if_metageneration_not_match))?;
        }
        if self.if_source_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifSourceGenerationMatch", &__With(&self.if_source_generation_match))?;
        }
        if self.if_source_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifSourceGenerationNotMatch", &__With(&self.if_source_generation_not_match))?;
        }
        if self.if_source_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifSourceMetagenerationMatch", &__With(&self.if_source_metageneration_match))?;
        }
        if self.if_source_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifSourceMetagenerationNotMatch", &__With(&self.if_source_metageneration_not_match))?;
        }
        if !wkt::internal::is_default(&self.max_bytes_rewritten_per_call) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxBytesRewrittenPerCall", &__With(&self.max_bytes_rewritten_per_call))?;
        }
        if !self.copy_source_encryption_algorithm.is_empty() {
            state.serialize_entry("copySourceEncryptionAlgorithm", &self.copy_source_encryption_algorithm)?;
        }
        if !self.copy_source_encryption_key_bytes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("copySourceEncryptionKeyBytes", &__With(&self.copy_source_encryption_key_bytes))?;
        }
        if !self.copy_source_encryption_key_sha256_bytes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("copySourceEncryptionKeySha256Bytes", &__With(&self.copy_source_encryption_key_sha256_bytes))?;
        }
        if self.common_object_request_params.is_some() {
            state.serialize_entry("commonObjectRequestParams", &self.common_object_request_params)?;
        }
        if self.object_checksums.is_some() {
            state.serialize_entry("objectChecksums", &self.object_checksums)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RewriteResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.total_bytes_rewritten) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalBytesRewritten", &__With(&self.total_bytes_rewritten))?;
        }
        if !wkt::internal::is_default(&self.object_size) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("objectSize", &__With(&self.object_size))?;
        }
        if !wkt::internal::is_default(&self.done) {
            state.serialize_entry("done", &self.done)?;
        }
        if !self.rewrite_token.is_empty() {
            state.serialize_entry("rewriteToken", &self.rewrite_token)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::MoveObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.source_object.is_empty() {
            state.serialize_entry("sourceObject", &self.source_object)?;
        }
        if !self.destination_object.is_empty() {
            state.serialize_entry("destinationObject", &self.destination_object)?;
        }
        if self.if_source_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifSourceGenerationMatch", &__With(&self.if_source_generation_match))?;
        }
        if self.if_source_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifSourceGenerationNotMatch", &__With(&self.if_source_generation_not_match))?;
        }
        if self.if_source_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifSourceMetagenerationMatch", &__With(&self.if_source_metageneration_match))?;
        }
        if self.if_source_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifSourceMetagenerationNotMatch", &__With(&self.if_source_metageneration_not_match))?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationNotMatch", &__With(&self.if_generation_not_match))?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationMatch", &__With(&self.if_metageneration_match))?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationNotMatch", &__With(&self.if_metageneration_not_match))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateObjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.object.is_some() {
            state.serialize_entry("object", &self.object)?;
        }
        if self.if_generation_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationMatch", &__With(&self.if_generation_match))?;
        }
        if self.if_generation_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifGenerationNotMatch", &__With(&self.if_generation_not_match))?;
        }
        if self.if_metageneration_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationMatch", &__With(&self.if_metageneration_match))?;
        }
        if self.if_metageneration_not_match.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ifMetagenerationNotMatch", &__With(&self.if_metageneration_not_match))?;
        }
        if !self.predefined_acl.is_empty() {
            state.serialize_entry("predefinedAcl", &self.predefined_acl)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.common_object_request_params.is_some() {
            state.serialize_entry("commonObjectRequestParams", &self.common_object_request_params)?;
        }
        if !wkt::internal::is_default(&self.override_unlocked_retention) {
            state.serialize_entry("overrideUnlockedRetention", &self.override_unlocked_retention)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CommonObjectRequestParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.encryption_algorithm.is_empty() {
            state.serialize_entry("encryptionAlgorithm", &self.encryption_algorithm)?;
        }
        if !self.encryption_key_bytes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("encryptionKeyBytes", &__With(&self.encryption_key_bytes))?;
        }
        if !self.encryption_key_sha256_bytes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("encryptionKeySha256Bytes", &__With(&self.encryption_key_sha256_bytes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Bucket {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.bucket_id.is_empty() {
            state.serialize_entry("bucketId", &self.bucket_id)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !wkt::internal::is_default(&self.metageneration) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("metageneration", &__With(&self.metageneration))?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.location_type.is_empty() {
            state.serialize_entry("locationType", &self.location_type)?;
        }
        if !self.storage_class.is_empty() {
            state.serialize_entry("storageClass", &self.storage_class)?;
        }
        if !self.rpo.is_empty() {
            state.serialize_entry("rpo", &self.rpo)?;
        }
        if !self.acl.is_empty() {
            state.serialize_entry("acl", &self.acl)?;
        }
        if !self.default_object_acl.is_empty() {
            state.serialize_entry("defaultObjectAcl", &self.default_object_acl)?;
        }
        if self.lifecycle.is_some() {
            state.serialize_entry("lifecycle", &self.lifecycle)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.cors.is_empty() {
            state.serialize_entry("cors", &self.cors)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.default_event_based_hold) {
            state.serialize_entry("defaultEventBasedHold", &self.default_event_based_hold)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.website.is_some() {
            state.serialize_entry("website", &self.website)?;
        }
        if self.versioning.is_some() {
            state.serialize_entry("versioning", &self.versioning)?;
        }
        if self.logging.is_some() {
            state.serialize_entry("logging", &self.logging)?;
        }
        if self.owner.is_some() {
            state.serialize_entry("owner", &self.owner)?;
        }
        if self.encryption.is_some() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if self.billing.is_some() {
            state.serialize_entry("billing", &self.billing)?;
        }
        if self.retention_policy.is_some() {
            state.serialize_entry("retentionPolicy", &self.retention_policy)?;
        }
        if self.iam_config.is_some() {
            state.serialize_entry("iamConfig", &self.iam_config)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.custom_placement_config.is_some() {
            state.serialize_entry("customPlacementConfig", &self.custom_placement_config)?;
        }
        if self.autoclass.is_some() {
            state.serialize_entry("autoclass", &self.autoclass)?;
        }
        if self.hierarchical_namespace.is_some() {
            state.serialize_entry("hierarchicalNamespace", &self.hierarchical_namespace)?;
        }
        if self.soft_delete_policy.is_some() {
            state.serialize_entry("softDeletePolicy", &self.soft_delete_policy)?;
        }
        if self.object_retention.is_some() {
            state.serialize_entry("objectRetention", &self.object_retention)?;
        }
        if self.ip_filter.is_some() {
            state.serialize_entry("ipFilter", &self.ip_filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::Billing {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.requester_pays) {
            state.serialize_entry("requesterPays", &self.requester_pays)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::Cors {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.origin.is_empty() {
            state.serialize_entry("origin", &self.origin)?;
        }
        if !self.method.is_empty() {
            state.serialize_entry("method", &self.method)?;
        }
        if !self.response_header.is_empty() {
            state.serialize_entry("responseHeader", &self.response_header)?;
        }
        if !wkt::internal::is_default(&self.max_age_seconds) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxAgeSeconds", &__With(&self.max_age_seconds))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::Encryption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.default_kms_key.is_empty() {
            state.serialize_entry("defaultKmsKey", &self.default_kms_key)?;
        }
        if self.google_managed_encryption_enforcement_config.is_some() {
            state.serialize_entry("googleManagedEncryptionEnforcementConfig", &self.google_managed_encryption_enforcement_config)?;
        }
        if self.customer_managed_encryption_enforcement_config.is_some() {
            state.serialize_entry("customerManagedEncryptionEnforcementConfig", &self.customer_managed_encryption_enforcement_config)?;
        }
        if self.customer_supplied_encryption_enforcement_config.is_some() {
            state.serialize_entry("customerSuppliedEncryptionEnforcementConfig", &self.customer_supplied_encryption_enforcement_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::encryption::GoogleManagedEncryptionEnforcementConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.restriction_mode.is_some() {
            state.serialize_entry("restrictionMode", &self.restriction_mode)?;
        }
        if self.effective_time.is_some() {
            state.serialize_entry("effectiveTime", &self.effective_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::encryption::CustomerManagedEncryptionEnforcementConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.restriction_mode.is_some() {
            state.serialize_entry("restrictionMode", &self.restriction_mode)?;
        }
        if self.effective_time.is_some() {
            state.serialize_entry("effectiveTime", &self.effective_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.restriction_mode.is_some() {
            state.serialize_entry("restrictionMode", &self.restriction_mode)?;
        }
        if self.effective_time.is_some() {
            state.serialize_entry("effectiveTime", &self.effective_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::IamConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.uniform_bucket_level_access.is_some() {
            state.serialize_entry("uniformBucketLevelAccess", &self.uniform_bucket_level_access)?;
        }
        if !self.public_access_prevention.is_empty() {
            state.serialize_entry("publicAccessPrevention", &self.public_access_prevention)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::iam_config::UniformBucketLevelAccess {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.lock_time.is_some() {
            state.serialize_entry("lockTime", &self.lock_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::Lifecycle {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rule.is_empty() {
            state.serialize_entry("rule", &self.rule)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::lifecycle::Rule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.action.is_some() {
            state.serialize_entry("action", &self.action)?;
        }
        if self.condition.is_some() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::lifecycle::rule::Action {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.storage_class.is_empty() {
            state.serialize_entry("storageClass", &self.storage_class)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::lifecycle::rule::Condition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.age_days.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ageDays", &__With(&self.age_days))?;
        }
        if self.created_before.is_some() {
            state.serialize_entry("createdBefore", &self.created_before)?;
        }
        if self.is_live.is_some() {
            state.serialize_entry("isLive", &self.is_live)?;
        }
        if self.num_newer_versions.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("numNewerVersions", &__With(&self.num_newer_versions))?;
        }
        if !self.matches_storage_class.is_empty() {
            state.serialize_entry("matchesStorageClass", &self.matches_storage_class)?;
        }
        if self.days_since_custom_time.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("daysSinceCustomTime", &__With(&self.days_since_custom_time))?;
        }
        if self.custom_time_before.is_some() {
            state.serialize_entry("customTimeBefore", &self.custom_time_before)?;
        }
        if self.days_since_noncurrent_time.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("daysSinceNoncurrentTime", &__With(&self.days_since_noncurrent_time))?;
        }
        if self.noncurrent_time_before.is_some() {
            state.serialize_entry("noncurrentTimeBefore", &self.noncurrent_time_before)?;
        }
        if !self.matches_prefix.is_empty() {
            state.serialize_entry("matchesPrefix", &self.matches_prefix)?;
        }
        if !self.matches_suffix.is_empty() {
            state.serialize_entry("matchesSuffix", &self.matches_suffix)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::Logging {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.log_bucket.is_empty() {
            state.serialize_entry("logBucket", &self.log_bucket)?;
        }
        if !self.log_object_prefix.is_empty() {
            state.serialize_entry("logObjectPrefix", &self.log_object_prefix)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::ObjectRetention {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::RetentionPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.effective_time.is_some() {
            state.serialize_entry("effectiveTime", &self.effective_time)?;
        }
        if !wkt::internal::is_default(&self.is_locked) {
            state.serialize_entry("isLocked", &self.is_locked)?;
        }
        if self.retention_duration.is_some() {
            state.serialize_entry("retentionDuration", &self.retention_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::SoftDeletePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.retention_duration.is_some() {
            state.serialize_entry("retentionDuration", &self.retention_duration)?;
        }
        if self.effective_time.is_some() {
            state.serialize_entry("effectiveTime", &self.effective_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::Versioning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::Website {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.main_page_suffix.is_empty() {
            state.serialize_entry("mainPageSuffix", &self.main_page_suffix)?;
        }
        if !self.not_found_page.is_empty() {
            state.serialize_entry("notFoundPage", &self.not_found_page)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::CustomPlacementConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_locations.is_empty() {
            state.serialize_entry("dataLocations", &self.data_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::Autoclass {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.toggle_time.is_some() {
            state.serialize_entry("toggleTime", &self.toggle_time)?;
        }
        if self.terminal_storage_class.is_some() {
            state.serialize_entry("terminalStorageClass", &self.terminal_storage_class)?;
        }
        if self.terminal_storage_class_update_time.is_some() {
            state.serialize_entry("terminalStorageClassUpdateTime", &self.terminal_storage_class_update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::IpFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if self.public_network_source.is_some() {
            state.serialize_entry("publicNetworkSource", &self.public_network_source)?;
        }
        if !self.vpc_network_sources.is_empty() {
            state.serialize_entry("vpcNetworkSources", &self.vpc_network_sources)?;
        }
        if !wkt::internal::is_default(&self.allow_cross_org_vpcs) {
            state.serialize_entry("allowCrossOrgVpcs", &self.allow_cross_org_vpcs)?;
        }
        if self.allow_all_service_agent_access.is_some() {
            state.serialize_entry("allowAllServiceAgentAccess", &self.allow_all_service_agent_access)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::ip_filter::PublicNetworkSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.allowed_ip_cidr_ranges.is_empty() {
            state.serialize_entry("allowedIpCidrRanges", &self.allowed_ip_cidr_ranges)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::ip_filter::VpcNetworkSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.allowed_ip_cidr_ranges.is_empty() {
            state.serialize_entry("allowedIpCidrRanges", &self.allowed_ip_cidr_ranges)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::bucket::HierarchicalNamespace {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}


#[doc(hidden)]
impl serde::ser::Serialize for super::BucketAccessControl {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.role.is_empty() {
            state.serialize_entry("role", &self.role)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.entity.is_empty() {
            state.serialize_entry("entity", &self.entity)?;
        }
        if !self.entity_alt.is_empty() {
            state.serialize_entry("entityAlt", &self.entity_alt)?;
        }
        if !self.entity_id.is_empty() {
            state.serialize_entry("entityId", &self.entity_id)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self.domain.is_empty() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if self.project_team.is_some() {
            state.serialize_entry("projectTeam", &self.project_team)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ObjectChecksums {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::U32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("crc32c", &__With(&self.crc32c))?;
        }
        if !self.md5_hash.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("md5Hash", &__With(&self.md5_hash))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ObjectCustomContextPayload {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ObjectContexts {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.custom.is_empty() {
            state.serialize_entry("custom", &self.custom)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CustomerEncryption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.encryption_algorithm.is_empty() {
            state.serialize_entry("encryptionAlgorithm", &self.encryption_algorithm)?;
        }
        if !self.key_sha256_bytes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("keySha256Bytes", &__With(&self.key_sha256_bytes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Object {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if self.restore_token.is_some() {
            state.serialize_entry("restoreToken", &self.restore_token)?;
        }
        if !wkt::internal::is_default(&self.metageneration) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("metageneration", &__With(&self.metageneration))?;
        }
        if !self.storage_class.is_empty() {
            state.serialize_entry("storageClass", &self.storage_class)?;
        }
        if !wkt::internal::is_default(&self.size) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("size", &__With(&self.size))?;
        }
        if !self.content_encoding.is_empty() {
            state.serialize_entry("contentEncoding", &self.content_encoding)?;
        }
        if !self.content_disposition.is_empty() {
            state.serialize_entry("contentDisposition", &self.content_disposition)?;
        }
        if !self.cache_control.is_empty() {
            state.serialize_entry("cacheControl", &self.cache_control)?;
        }
        if !self.acl.is_empty() {
            state.serialize_entry("acl", &self.acl)?;
        }
        if !self.content_language.is_empty() {
            state.serialize_entry("contentLanguage", &self.content_language)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if self.finalize_time.is_some() {
            state.serialize_entry("finalizeTime", &self.finalize_time)?;
        }
        if !self.content_type.is_empty() {
            state.serialize_entry("contentType", &self.content_type)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.component_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("componentCount", &__With(&self.component_count))?;
        }
        if self.checksums.is_some() {
            state.serialize_entry("checksums", &self.checksums)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if self.update_storage_class_time.is_some() {
            state.serialize_entry("updateStorageClassTime", &self.update_storage_class_time)?;
        }
        if !wkt::internal::is_default(&self.temporary_hold) {
            state.serialize_entry("temporaryHold", &self.temporary_hold)?;
        }
        if self.retention_expire_time.is_some() {
            state.serialize_entry("retentionExpireTime", &self.retention_expire_time)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if self.contexts.is_some() {
            state.serialize_entry("contexts", &self.contexts)?;
        }
        if self.event_based_hold.is_some() {
            state.serialize_entry("eventBasedHold", &self.event_based_hold)?;
        }
        if self.owner.is_some() {
            state.serialize_entry("owner", &self.owner)?;
        }
        if self.customer_encryption.is_some() {
            state.serialize_entry("customerEncryption", &self.customer_encryption)?;
        }
        if self.custom_time.is_some() {
            state.serialize_entry("customTime", &self.custom_time)?;
        }
        if self.soft_delete_time.is_some() {
            state.serialize_entry("softDeleteTime", &self.soft_delete_time)?;
        }
        if self.hard_delete_time.is_some() {
            state.serialize_entry("hardDeleteTime", &self.hard_delete_time)?;
        }
        if self.retention.is_some() {
            state.serialize_entry("retention", &self.retention)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::object::Retention {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if self.retain_until_time.is_some() {
            state.serialize_entry("retainUntilTime", &self.retain_until_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}


#[doc(hidden)]
impl serde::ser::Serialize for super::ObjectAccessControl {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.role.is_empty() {
            state.serialize_entry("role", &self.role)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.entity.is_empty() {
            state.serialize_entry("entity", &self.entity)?;
        }
        if !self.entity_alt.is_empty() {
            state.serialize_entry("entityAlt", &self.entity_alt)?;
        }
        if !self.entity_id.is_empty() {
            state.serialize_entry("entityId", &self.entity_id)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self.domain.is_empty() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if self.project_team.is_some() {
            state.serialize_entry("projectTeam", &self.project_team)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListObjectsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.objects.is_empty() {
            state.serialize_entry("objects", &self.objects)?;
        }
        if !self.prefixes.is_empty() {
            state.serialize_entry("prefixes", &self.prefixes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ProjectTeam {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_number.is_empty() {
            state.serialize_entry("projectNumber", &self.project_number)?;
        }
        if !self.team.is_empty() {
            state.serialize_entry("team", &self.team)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Owner {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity.is_empty() {
            state.serialize_entry("entity", &self.entity)?;
        }
        if !self.entity_id.is_empty() {
            state.serialize_entry("entityId", &self.entity_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
