// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteBucketRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __if_metageneration_match,
            __if_metageneration_not_match,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBucketRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => Ok(__FieldTag::__if_metageneration_not_match),
                            "if_metageneration_not_match" => Ok(__FieldTag::__if_metageneration_not_match),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteBucketRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBucketRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetBucketRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __read_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBucketRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => Ok(__FieldTag::__if_metageneration_not_match),
                            "if_metageneration_not_match" => Ok(__FieldTag::__if_metageneration_not_match),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetBucketRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBucketRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for read_mask"));
                            }
                            result.read_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateBucketRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __bucket,
            __bucket_id,
            __predefined_acl,
            __predefined_default_object_acl,
            __enable_object_retention,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBucketRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "bucket" => Ok(__FieldTag::__bucket),
                            "bucketId" => Ok(__FieldTag::__bucket_id),
                            "bucket_id" => Ok(__FieldTag::__bucket_id),
                            "predefinedAcl" => Ok(__FieldTag::__predefined_acl),
                            "predefined_acl" => Ok(__FieldTag::__predefined_acl),
                            "predefinedDefaultObjectAcl" => Ok(__FieldTag::__predefined_default_object_acl),
                            "predefined_default_object_acl" => Ok(__FieldTag::__predefined_default_object_acl),
                            "enableObjectRetention" => Ok(__FieldTag::__enable_object_retention),
                            "enable_object_retention" => Ok(__FieldTag::__enable_object_retention),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateBucketRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBucketRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bucket"));
                            }
                            result.bucket = map.next_value::<std::option::Option<crate::model::Bucket>>()?
                                ;
                        },
                        __FieldTag::__bucket_id => {
                            if !fields.insert(__FieldTag::__bucket_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bucket_id"));
                            }
                            result.bucket_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__predefined_acl => {
                            if !fields.insert(__FieldTag::__predefined_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for predefined_acl"));
                            }
                            result.predefined_acl = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__predefined_default_object_acl => {
                            if !fields.insert(__FieldTag::__predefined_default_object_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for predefined_default_object_acl"));
                            }
                            result.predefined_default_object_acl = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__enable_object_retention => {
                            if !fields.insert(__FieldTag::__enable_object_retention) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enable_object_retention"));
                            }
                            result.enable_object_retention = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListBucketsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __prefix,
            __read_mask,
            __return_partial_success,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBucketsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "prefix" => Ok(__FieldTag::__prefix),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            "returnPartialSuccess" => Ok(__FieldTag::__return_partial_success),
                            "return_partial_success" => Ok(__FieldTag::__return_partial_success),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListBucketsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBucketsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__prefix => {
                            if !fields.insert(__FieldTag::__prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for prefix"));
                            }
                            result.prefix = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for read_mask"));
                            }
                            result.read_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::__return_partial_success => {
                            if !fields.insert(__FieldTag::__return_partial_success) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for return_partial_success"));
                            }
                            result.return_partial_success = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListBucketsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __buckets,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBucketsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "buckets" => Ok(__FieldTag::__buckets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListBucketsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBucketsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__buckets => {
                            if !fields.insert(__FieldTag::__buckets) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for buckets"));
                            }
                            result.buckets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Bucket>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for unreachable"));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LockBucketRetentionPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __if_metageneration_match,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LockBucketRetentionPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LockBucketRetentionPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LockBucketRetentionPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bucket"));
                            }
                            result.bucket = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateBucketRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __predefined_acl,
            __predefined_default_object_acl,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBucketRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => Ok(__FieldTag::__if_metageneration_not_match),
                            "if_metageneration_not_match" => Ok(__FieldTag::__if_metageneration_not_match),
                            "predefinedAcl" => Ok(__FieldTag::__predefined_acl),
                            "predefined_acl" => Ok(__FieldTag::__predefined_acl),
                            "predefinedDefaultObjectAcl" => Ok(__FieldTag::__predefined_default_object_acl),
                            "predefined_default_object_acl" => Ok(__FieldTag::__predefined_default_object_acl),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateBucketRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBucketRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bucket"));
                            }
                            result.bucket = map.next_value::<std::option::Option<crate::model::Bucket>>()?
                                ;
                        },
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__predefined_acl => {
                            if !fields.insert(__FieldTag::__predefined_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for predefined_acl"));
                            }
                            result.predefined_acl = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__predefined_default_object_acl => {
                            if !fields.insert(__FieldTag::__predefined_default_object_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for predefined_default_object_acl"));
                            }
                            result.predefined_default_object_acl = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ComposeObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __destination,
            __source_objects,
            __destination_predefined_acl,
            __if_generation_match,
            __if_metageneration_match,
            __kms_key,
            __common_object_request_params,
            __object_checksums,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComposeObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "destination" => Ok(__FieldTag::__destination),
                            "sourceObjects" => Ok(__FieldTag::__source_objects),
                            "source_objects" => Ok(__FieldTag::__source_objects),
                            "destinationPredefinedAcl" => Ok(__FieldTag::__destination_predefined_acl),
                            "destination_predefined_acl" => Ok(__FieldTag::__destination_predefined_acl),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            "commonObjectRequestParams" => Ok(__FieldTag::__common_object_request_params),
                            "common_object_request_params" => Ok(__FieldTag::__common_object_request_params),
                            "objectChecksums" => Ok(__FieldTag::__object_checksums),
                            "object_checksums" => Ok(__FieldTag::__object_checksums),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ComposeObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComposeObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination"));
                            }
                            result.destination = map.next_value::<std::option::Option<crate::model::Object>>()?
                                ;
                        },
                        __FieldTag::__source_objects => {
                            if !fields.insert(__FieldTag::__source_objects) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_objects"));
                            }
                            result.source_objects = map.next_value::<std::option::Option<std::vec::Vec<crate::model::compose_object_request::SourceObject>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__destination_predefined_acl => {
                            if !fields.insert(__FieldTag::__destination_predefined_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_predefined_acl"));
                            }
                            result.destination_predefined_acl = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for kms_key"));
                            }
                            result.kms_key = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__common_object_request_params => {
                            if !fields.insert(__FieldTag::__common_object_request_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for common_object_request_params"));
                            }
                            result.common_object_request_params = map.next_value::<std::option::Option<crate::model::CommonObjectRequestParams>>()?
                                ;
                        },
                        __FieldTag::__object_checksums => {
                            if !fields.insert(__FieldTag::__object_checksums) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for object_checksums"));
                            }
                            result.object_checksums = map.next_value::<std::option::Option<crate::model::ObjectChecksums>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::compose_object_request::SourceObject {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __generation,
            __object_preconditions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceObject")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "generation" => Ok(__FieldTag::__generation),
                            "objectPreconditions" => Ok(__FieldTag::__object_preconditions),
                            "object_preconditions" => Ok(__FieldTag::__object_preconditions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::compose_object_request::SourceObject;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceObject")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generation"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__object_preconditions => {
                            if !fields.insert(__FieldTag::__object_preconditions) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for object_preconditions"));
                            }
                            result.object_preconditions = map.next_value::<std::option::Option<crate::model::compose_object_request::source_object::ObjectPreconditions>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::compose_object_request::source_object::ObjectPreconditions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __if_generation_match,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectPreconditions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::compose_object_request::source_object::ObjectPreconditions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectPreconditions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __common_object_request_params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generation" => Ok(__FieldTag::__generation),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => Ok(__FieldTag::__if_metageneration_not_match),
                            "if_metageneration_not_match" => Ok(__FieldTag::__if_metageneration_not_match),
                            "commonObjectRequestParams" => Ok(__FieldTag::__common_object_request_params),
                            "common_object_request_params" => Ok(__FieldTag::__common_object_request_params),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bucket"));
                            }
                            result.bucket = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for object"));
                            }
                            result.object = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generation"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__common_object_request_params => {
                            if !fields.insert(__FieldTag::__common_object_request_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for common_object_request_params"));
                            }
                            result.common_object_request_params = map.next_value::<std::option::Option<crate::model::CommonObjectRequestParams>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RestoreObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation,
            __restore_token,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __copy_source_acl,
            __common_object_request_params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generation" => Ok(__FieldTag::__generation),
                            "restoreToken" => Ok(__FieldTag::__restore_token),
                            "restore_token" => Ok(__FieldTag::__restore_token),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => Ok(__FieldTag::__if_metageneration_not_match),
                            "if_metageneration_not_match" => Ok(__FieldTag::__if_metageneration_not_match),
                            "copySourceAcl" => Ok(__FieldTag::__copy_source_acl),
                            "copy_source_acl" => Ok(__FieldTag::__copy_source_acl),
                            "commonObjectRequestParams" => Ok(__FieldTag::__common_object_request_params),
                            "common_object_request_params" => Ok(__FieldTag::__common_object_request_params),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RestoreObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bucket"));
                            }
                            result.bucket = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for object"));
                            }
                            result.object = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generation"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__restore_token => {
                            if !fields.insert(__FieldTag::__restore_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for restore_token"));
                            }
                            result.restore_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__copy_source_acl => {
                            if !fields.insert(__FieldTag::__copy_source_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for copy_source_acl"));
                            }
                            result.copy_source_acl = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::__common_object_request_params => {
                            if !fields.insert(__FieldTag::__common_object_request_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for common_object_request_params"));
                            }
                            result.common_object_request_params = map.next_value::<std::option::Option<crate::model::CommonObjectRequestParams>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ReadObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation,
            __read_offset,
            __read_limit,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __common_object_request_params,
            __read_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReadObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generation" => Ok(__FieldTag::__generation),
                            "readOffset" => Ok(__FieldTag::__read_offset),
                            "read_offset" => Ok(__FieldTag::__read_offset),
                            "readLimit" => Ok(__FieldTag::__read_limit),
                            "read_limit" => Ok(__FieldTag::__read_limit),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => Ok(__FieldTag::__if_metageneration_not_match),
                            "if_metageneration_not_match" => Ok(__FieldTag::__if_metageneration_not_match),
                            "commonObjectRequestParams" => Ok(__FieldTag::__common_object_request_params),
                            "common_object_request_params" => Ok(__FieldTag::__common_object_request_params),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ReadObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReadObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bucket"));
                            }
                            result.bucket = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for object"));
                            }
                            result.object = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generation"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__read_offset => {
                            if !fields.insert(__FieldTag::__read_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for read_offset"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.read_offset = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__read_limit => {
                            if !fields.insert(__FieldTag::__read_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for read_limit"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.read_limit = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__common_object_request_params => {
                            if !fields.insert(__FieldTag::__common_object_request_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for common_object_request_params"));
                            }
                            result.common_object_request_params = map.next_value::<std::option::Option<crate::model::CommonObjectRequestParams>>()?
                                ;
                        },
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for read_mask"));
                            }
                            result.read_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation,
            __soft_deleted,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __common_object_request_params,
            __read_mask,
            __restore_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generation" => Ok(__FieldTag::__generation),
                            "softDeleted" => Ok(__FieldTag::__soft_deleted),
                            "soft_deleted" => Ok(__FieldTag::__soft_deleted),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => Ok(__FieldTag::__if_metageneration_not_match),
                            "if_metageneration_not_match" => Ok(__FieldTag::__if_metageneration_not_match),
                            "commonObjectRequestParams" => Ok(__FieldTag::__common_object_request_params),
                            "common_object_request_params" => Ok(__FieldTag::__common_object_request_params),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            "restoreToken" => Ok(__FieldTag::__restore_token),
                            "restore_token" => Ok(__FieldTag::__restore_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bucket"));
                            }
                            result.bucket = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for object"));
                            }
                            result.object = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generation"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__soft_deleted => {
                            if !fields.insert(__FieldTag::__soft_deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for soft_deleted"));
                            }
                            result.soft_deleted = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__common_object_request_params => {
                            if !fields.insert(__FieldTag::__common_object_request_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for common_object_request_params"));
                            }
                            result.common_object_request_params = map.next_value::<std::option::Option<crate::model::CommonObjectRequestParams>>()?
                                ;
                        },
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for read_mask"));
                            }
                            result.read_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::__restore_token => {
                            if !fields.insert(__FieldTag::__restore_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for restore_token"));
                            }
                            result.restore_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::WriteObjectSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource,
            __predefined_acl,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __object_size,
            __appendable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WriteObjectSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resource" => Ok(__FieldTag::__resource),
                            "predefinedAcl" => Ok(__FieldTag::__predefined_acl),
                            "predefined_acl" => Ok(__FieldTag::__predefined_acl),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => Ok(__FieldTag::__if_metageneration_not_match),
                            "if_metageneration_not_match" => Ok(__FieldTag::__if_metageneration_not_match),
                            "objectSize" => Ok(__FieldTag::__object_size),
                            "object_size" => Ok(__FieldTag::__object_size),
                            "appendable" => Ok(__FieldTag::__appendable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::WriteObjectSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WriteObjectSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for resource"));
                            }
                            result.resource = map.next_value::<std::option::Option<crate::model::Object>>()?
                                ;
                        },
                        __FieldTag::__predefined_acl => {
                            if !fields.insert(__FieldTag::__predefined_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for predefined_acl"));
                            }
                            result.predefined_acl = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__object_size => {
                            if !fields.insert(__FieldTag::__object_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for object_size"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.object_size = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__appendable => {
                            if !fields.insert(__FieldTag::__appendable) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for appendable"));
                            }
                            result.appendable = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListObjectsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __delimiter,
            __include_trailing_delimiter,
            __prefix,
            __versions,
            __read_mask,
            __lexicographic_start,
            __lexicographic_end,
            __soft_deleted,
            __include_folders_as_prefixes,
            __match_glob,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListObjectsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "delimiter" => Ok(__FieldTag::__delimiter),
                            "includeTrailingDelimiter" => Ok(__FieldTag::__include_trailing_delimiter),
                            "include_trailing_delimiter" => Ok(__FieldTag::__include_trailing_delimiter),
                            "prefix" => Ok(__FieldTag::__prefix),
                            "versions" => Ok(__FieldTag::__versions),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            "lexicographicStart" => Ok(__FieldTag::__lexicographic_start),
                            "lexicographic_start" => Ok(__FieldTag::__lexicographic_start),
                            "lexicographicEnd" => Ok(__FieldTag::__lexicographic_end),
                            "lexicographic_end" => Ok(__FieldTag::__lexicographic_end),
                            "softDeleted" => Ok(__FieldTag::__soft_deleted),
                            "soft_deleted" => Ok(__FieldTag::__soft_deleted),
                            "includeFoldersAsPrefixes" => Ok(__FieldTag::__include_folders_as_prefixes),
                            "include_folders_as_prefixes" => Ok(__FieldTag::__include_folders_as_prefixes),
                            "matchGlob" => Ok(__FieldTag::__match_glob),
                            "match_glob" => Ok(__FieldTag::__match_glob),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListObjectsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListObjectsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for parent"));
                            }
                            result.parent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_size"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for page_token"));
                            }
                            result.page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__delimiter => {
                            if !fields.insert(__FieldTag::__delimiter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for delimiter"));
                            }
                            result.delimiter = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__include_trailing_delimiter => {
                            if !fields.insert(__FieldTag::__include_trailing_delimiter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for include_trailing_delimiter"));
                            }
                            result.include_trailing_delimiter = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__prefix => {
                            if !fields.insert(__FieldTag::__prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for prefix"));
                            }
                            result.prefix = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for versions"));
                            }
                            result.versions = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for read_mask"));
                            }
                            result.read_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::__lexicographic_start => {
                            if !fields.insert(__FieldTag::__lexicographic_start) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for lexicographic_start"));
                            }
                            result.lexicographic_start = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__lexicographic_end => {
                            if !fields.insert(__FieldTag::__lexicographic_end) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for lexicographic_end"));
                            }
                            result.lexicographic_end = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__soft_deleted => {
                            if !fields.insert(__FieldTag::__soft_deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for soft_deleted"));
                            }
                            result.soft_deleted = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__include_folders_as_prefixes => {
                            if !fields.insert(__FieldTag::__include_folders_as_prefixes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for include_folders_as_prefixes"));
                            }
                            result.include_folders_as_prefixes = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__match_glob => {
                            if !fields.insert(__FieldTag::__match_glob) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for match_glob"));
                            }
                            result.match_glob = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for filter"));
                            }
                            result.filter = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RewriteObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __destination_name,
            __destination_bucket,
            __destination_kms_key,
            __destination,
            __source_bucket,
            __source_object,
            __source_generation,
            __rewrite_token,
            __destination_predefined_acl,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __if_source_generation_match,
            __if_source_generation_not_match,
            __if_source_metageneration_match,
            __if_source_metageneration_not_match,
            __max_bytes_rewritten_per_call,
            __copy_source_encryption_algorithm,
            __copy_source_encryption_key_bytes,
            __copy_source_encryption_key_sha256_bytes,
            __common_object_request_params,
            __object_checksums,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RewriteObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "destinationName" => Ok(__FieldTag::__destination_name),
                            "destination_name" => Ok(__FieldTag::__destination_name),
                            "destinationBucket" => Ok(__FieldTag::__destination_bucket),
                            "destination_bucket" => Ok(__FieldTag::__destination_bucket),
                            "destinationKmsKey" => Ok(__FieldTag::__destination_kms_key),
                            "destination_kms_key" => Ok(__FieldTag::__destination_kms_key),
                            "destination" => Ok(__FieldTag::__destination),
                            "sourceBucket" => Ok(__FieldTag::__source_bucket),
                            "source_bucket" => Ok(__FieldTag::__source_bucket),
                            "sourceObject" => Ok(__FieldTag::__source_object),
                            "source_object" => Ok(__FieldTag::__source_object),
                            "sourceGeneration" => Ok(__FieldTag::__source_generation),
                            "source_generation" => Ok(__FieldTag::__source_generation),
                            "rewriteToken" => Ok(__FieldTag::__rewrite_token),
                            "rewrite_token" => Ok(__FieldTag::__rewrite_token),
                            "destinationPredefinedAcl" => Ok(__FieldTag::__destination_predefined_acl),
                            "destination_predefined_acl" => Ok(__FieldTag::__destination_predefined_acl),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => Ok(__FieldTag::__if_metageneration_not_match),
                            "if_metageneration_not_match" => Ok(__FieldTag::__if_metageneration_not_match),
                            "ifSourceGenerationMatch" => Ok(__FieldTag::__if_source_generation_match),
                            "if_source_generation_match" => Ok(__FieldTag::__if_source_generation_match),
                            "ifSourceGenerationNotMatch" => Ok(__FieldTag::__if_source_generation_not_match),
                            "if_source_generation_not_match" => Ok(__FieldTag::__if_source_generation_not_match),
                            "ifSourceMetagenerationMatch" => Ok(__FieldTag::__if_source_metageneration_match),
                            "if_source_metageneration_match" => Ok(__FieldTag::__if_source_metageneration_match),
                            "ifSourceMetagenerationNotMatch" => Ok(__FieldTag::__if_source_metageneration_not_match),
                            "if_source_metageneration_not_match" => Ok(__FieldTag::__if_source_metageneration_not_match),
                            "maxBytesRewrittenPerCall" => Ok(__FieldTag::__max_bytes_rewritten_per_call),
                            "max_bytes_rewritten_per_call" => Ok(__FieldTag::__max_bytes_rewritten_per_call),
                            "copySourceEncryptionAlgorithm" => Ok(__FieldTag::__copy_source_encryption_algorithm),
                            "copy_source_encryption_algorithm" => Ok(__FieldTag::__copy_source_encryption_algorithm),
                            "copySourceEncryptionKeyBytes" => Ok(__FieldTag::__copy_source_encryption_key_bytes),
                            "copy_source_encryption_key_bytes" => Ok(__FieldTag::__copy_source_encryption_key_bytes),
                            "copySourceEncryptionKeySha256Bytes" => Ok(__FieldTag::__copy_source_encryption_key_sha256_bytes),
                            "copy_source_encryption_key_sha256_bytes" => Ok(__FieldTag::__copy_source_encryption_key_sha256_bytes),
                            "commonObjectRequestParams" => Ok(__FieldTag::__common_object_request_params),
                            "common_object_request_params" => Ok(__FieldTag::__common_object_request_params),
                            "objectChecksums" => Ok(__FieldTag::__object_checksums),
                            "object_checksums" => Ok(__FieldTag::__object_checksums),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RewriteObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RewriteObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__destination_name => {
                            if !fields.insert(__FieldTag::__destination_name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_name"));
                            }
                            result.destination_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__destination_bucket => {
                            if !fields.insert(__FieldTag::__destination_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_bucket"));
                            }
                            result.destination_bucket = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__destination_kms_key => {
                            if !fields.insert(__FieldTag::__destination_kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_kms_key"));
                            }
                            result.destination_kms_key = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination"));
                            }
                            result.destination = map.next_value::<std::option::Option<crate::model::Object>>()?
                                ;
                        },
                        __FieldTag::__source_bucket => {
                            if !fields.insert(__FieldTag::__source_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_bucket"));
                            }
                            result.source_bucket = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__source_object => {
                            if !fields.insert(__FieldTag::__source_object) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_object"));
                            }
                            result.source_object = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__source_generation => {
                            if !fields.insert(__FieldTag::__source_generation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_generation"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_generation = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__rewrite_token => {
                            if !fields.insert(__FieldTag::__rewrite_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for rewrite_token"));
                            }
                            result.rewrite_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__destination_predefined_acl => {
                            if !fields.insert(__FieldTag::__destination_predefined_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_predefined_acl"));
                            }
                            result.destination_predefined_acl = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_source_generation_match => {
                            if !fields.insert(__FieldTag::__if_source_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_source_generation_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_generation_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_source_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_source_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_source_generation_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_generation_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_source_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_source_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_source_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_metageneration_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_source_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_source_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_source_metageneration_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_metageneration_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__max_bytes_rewritten_per_call => {
                            if !fields.insert(__FieldTag::__max_bytes_rewritten_per_call) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for max_bytes_rewritten_per_call"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_bytes_rewritten_per_call = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__copy_source_encryption_algorithm => {
                            if !fields.insert(__FieldTag::__copy_source_encryption_algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for copy_source_encryption_algorithm"));
                            }
                            result.copy_source_encryption_algorithm = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__copy_source_encryption_key_bytes => {
                            if !fields.insert(__FieldTag::__copy_source_encryption_key_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for copy_source_encryption_key_bytes"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.copy_source_encryption_key_bytes = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__copy_source_encryption_key_sha256_bytes => {
                            if !fields.insert(__FieldTag::__copy_source_encryption_key_sha256_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for copy_source_encryption_key_sha256_bytes"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.copy_source_encryption_key_sha256_bytes = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__common_object_request_params => {
                            if !fields.insert(__FieldTag::__common_object_request_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for common_object_request_params"));
                            }
                            result.common_object_request_params = map.next_value::<std::option::Option<crate::model::CommonObjectRequestParams>>()?
                                ;
                        },
                        __FieldTag::__object_checksums => {
                            if !fields.insert(__FieldTag::__object_checksums) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for object_checksums"));
                            }
                            result.object_checksums = map.next_value::<std::option::Option<crate::model::ObjectChecksums>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RewriteResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __total_bytes_rewritten,
            __object_size,
            __done,
            __rewrite_token,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RewriteResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "totalBytesRewritten" => Ok(__FieldTag::__total_bytes_rewritten),
                            "total_bytes_rewritten" => Ok(__FieldTag::__total_bytes_rewritten),
                            "objectSize" => Ok(__FieldTag::__object_size),
                            "object_size" => Ok(__FieldTag::__object_size),
                            "done" => Ok(__FieldTag::__done),
                            "rewriteToken" => Ok(__FieldTag::__rewrite_token),
                            "rewrite_token" => Ok(__FieldTag::__rewrite_token),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RewriteResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RewriteResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__total_bytes_rewritten => {
                            if !fields.insert(__FieldTag::__total_bytes_rewritten) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for total_bytes_rewritten"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_bytes_rewritten = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__object_size => {
                            if !fields.insert(__FieldTag::__object_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for object_size"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.object_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__done => {
                            if !fields.insert(__FieldTag::__done) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for done"));
                            }
                            result.done = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__rewrite_token => {
                            if !fields.insert(__FieldTag::__rewrite_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for rewrite_token"));
                            }
                            result.rewrite_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for resource"));
                            }
                            result.resource = map.next_value::<std::option::Option<crate::model::Object>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MoveObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __source_object,
            __destination_object,
            __if_source_generation_match,
            __if_source_generation_not_match,
            __if_source_metageneration_match,
            __if_source_metageneration_not_match,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MoveObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "sourceObject" => Ok(__FieldTag::__source_object),
                            "source_object" => Ok(__FieldTag::__source_object),
                            "destinationObject" => Ok(__FieldTag::__destination_object),
                            "destination_object" => Ok(__FieldTag::__destination_object),
                            "ifSourceGenerationMatch" => Ok(__FieldTag::__if_source_generation_match),
                            "if_source_generation_match" => Ok(__FieldTag::__if_source_generation_match),
                            "ifSourceGenerationNotMatch" => Ok(__FieldTag::__if_source_generation_not_match),
                            "if_source_generation_not_match" => Ok(__FieldTag::__if_source_generation_not_match),
                            "ifSourceMetagenerationMatch" => Ok(__FieldTag::__if_source_metageneration_match),
                            "if_source_metageneration_match" => Ok(__FieldTag::__if_source_metageneration_match),
                            "ifSourceMetagenerationNotMatch" => Ok(__FieldTag::__if_source_metageneration_not_match),
                            "if_source_metageneration_not_match" => Ok(__FieldTag::__if_source_metageneration_not_match),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => Ok(__FieldTag::__if_metageneration_not_match),
                            "if_metageneration_not_match" => Ok(__FieldTag::__if_metageneration_not_match),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MoveObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MoveObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bucket"));
                            }
                            result.bucket = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__source_object => {
                            if !fields.insert(__FieldTag::__source_object) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for source_object"));
                            }
                            result.source_object = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__destination_object => {
                            if !fields.insert(__FieldTag::__destination_object) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for destination_object"));
                            }
                            result.destination_object = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__if_source_generation_match => {
                            if !fields.insert(__FieldTag::__if_source_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_source_generation_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_generation_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_source_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_source_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_source_generation_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_generation_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_source_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_source_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_source_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_metageneration_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_source_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_source_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_source_metageneration_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_source_metageneration_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateObjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __object,
            __if_generation_match,
            __if_generation_not_match,
            __if_metageneration_match,
            __if_metageneration_not_match,
            __predefined_acl,
            __update_mask,
            __common_object_request_params,
            __override_unlocked_retention,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateObjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "object" => Ok(__FieldTag::__object),
                            "ifGenerationMatch" => Ok(__FieldTag::__if_generation_match),
                            "if_generation_match" => Ok(__FieldTag::__if_generation_match),
                            "ifGenerationNotMatch" => Ok(__FieldTag::__if_generation_not_match),
                            "if_generation_not_match" => Ok(__FieldTag::__if_generation_not_match),
                            "ifMetagenerationMatch" => Ok(__FieldTag::__if_metageneration_match),
                            "if_metageneration_match" => Ok(__FieldTag::__if_metageneration_match),
                            "ifMetagenerationNotMatch" => Ok(__FieldTag::__if_metageneration_not_match),
                            "if_metageneration_not_match" => Ok(__FieldTag::__if_metageneration_not_match),
                            "predefinedAcl" => Ok(__FieldTag::__predefined_acl),
                            "predefined_acl" => Ok(__FieldTag::__predefined_acl),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "commonObjectRequestParams" => Ok(__FieldTag::__common_object_request_params),
                            "common_object_request_params" => Ok(__FieldTag::__common_object_request_params),
                            "overrideUnlockedRetention" => Ok(__FieldTag::__override_unlocked_retention),
                            "override_unlocked_retention" => Ok(__FieldTag::__override_unlocked_retention),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateObjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateObjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for object"));
                            }
                            result.object = map.next_value::<std::option::Option<crate::model::Object>>()?
                                ;
                        },
                        __FieldTag::__if_generation_match => {
                            if !fields.insert(__FieldTag::__if_generation_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_generation_not_match => {
                            if !fields.insert(__FieldTag::__if_generation_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_generation_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_generation_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__if_metageneration_not_match => {
                            if !fields.insert(__FieldTag::__if_metageneration_not_match) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for if_metageneration_not_match"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.if_metageneration_not_match = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__predefined_acl => {
                            if !fields.insert(__FieldTag::__predefined_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for predefined_acl"));
                            }
                            result.predefined_acl = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_mask"));
                            }
                            result.update_mask = map.next_value::<std::option::Option<wkt::FieldMask>>()?
                                ;
                        },
                        __FieldTag::__common_object_request_params => {
                            if !fields.insert(__FieldTag::__common_object_request_params) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for common_object_request_params"));
                            }
                            result.common_object_request_params = map.next_value::<std::option::Option<crate::model::CommonObjectRequestParams>>()?
                                ;
                        },
                        __FieldTag::__override_unlocked_retention => {
                            if !fields.insert(__FieldTag::__override_unlocked_retention) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for override_unlocked_retention"));
                            }
                            result.override_unlocked_retention = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CommonObjectRequestParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encryption_algorithm,
            __encryption_key_bytes,
            __encryption_key_sha256_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommonObjectRequestParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encryptionAlgorithm" => Ok(__FieldTag::__encryption_algorithm),
                            "encryption_algorithm" => Ok(__FieldTag::__encryption_algorithm),
                            "encryptionKeyBytes" => Ok(__FieldTag::__encryption_key_bytes),
                            "encryption_key_bytes" => Ok(__FieldTag::__encryption_key_bytes),
                            "encryptionKeySha256Bytes" => Ok(__FieldTag::__encryption_key_sha256_bytes),
                            "encryption_key_sha256_bytes" => Ok(__FieldTag::__encryption_key_sha256_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CommonObjectRequestParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommonObjectRequestParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encryption_algorithm => {
                            if !fields.insert(__FieldTag::__encryption_algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for encryption_algorithm"));
                            }
                            result.encryption_algorithm = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__encryption_key_bytes => {
                            if !fields.insert(__FieldTag::__encryption_key_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for encryption_key_bytes"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.encryption_key_bytes = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__encryption_key_sha256_bytes => {
                            if !fields.insert(__FieldTag::__encryption_key_sha256_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for encryption_key_sha256_bytes"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.encryption_key_sha256_bytes = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Bucket {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __bucket_id,
            __etag,
            __project,
            __metageneration,
            __location,
            __location_type,
            __storage_class,
            __rpo,
            __acl,
            __default_object_acl,
            __lifecycle,
            __create_time,
            __cors,
            __update_time,
            __default_event_based_hold,
            __labels,
            __website,
            __versioning,
            __logging,
            __owner,
            __encryption,
            __billing,
            __retention_policy,
            __iam_config,
            __satisfies_pzs,
            __custom_placement_config,
            __autoclass,
            __hierarchical_namespace,
            __soft_delete_policy,
            __object_retention,
            __ip_filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Bucket")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "bucketId" => Ok(__FieldTag::__bucket_id),
                            "bucket_id" => Ok(__FieldTag::__bucket_id),
                            "etag" => Ok(__FieldTag::__etag),
                            "project" => Ok(__FieldTag::__project),
                            "metageneration" => Ok(__FieldTag::__metageneration),
                            "location" => Ok(__FieldTag::__location),
                            "locationType" => Ok(__FieldTag::__location_type),
                            "location_type" => Ok(__FieldTag::__location_type),
                            "storageClass" => Ok(__FieldTag::__storage_class),
                            "storage_class" => Ok(__FieldTag::__storage_class),
                            "rpo" => Ok(__FieldTag::__rpo),
                            "acl" => Ok(__FieldTag::__acl),
                            "defaultObjectAcl" => Ok(__FieldTag::__default_object_acl),
                            "default_object_acl" => Ok(__FieldTag::__default_object_acl),
                            "lifecycle" => Ok(__FieldTag::__lifecycle),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "cors" => Ok(__FieldTag::__cors),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "defaultEventBasedHold" => Ok(__FieldTag::__default_event_based_hold),
                            "default_event_based_hold" => Ok(__FieldTag::__default_event_based_hold),
                            "labels" => Ok(__FieldTag::__labels),
                            "website" => Ok(__FieldTag::__website),
                            "versioning" => Ok(__FieldTag::__versioning),
                            "logging" => Ok(__FieldTag::__logging),
                            "owner" => Ok(__FieldTag::__owner),
                            "encryption" => Ok(__FieldTag::__encryption),
                            "billing" => Ok(__FieldTag::__billing),
                            "retentionPolicy" => Ok(__FieldTag::__retention_policy),
                            "retention_policy" => Ok(__FieldTag::__retention_policy),
                            "iamConfig" => Ok(__FieldTag::__iam_config),
                            "iam_config" => Ok(__FieldTag::__iam_config),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "customPlacementConfig" => Ok(__FieldTag::__custom_placement_config),
                            "custom_placement_config" => Ok(__FieldTag::__custom_placement_config),
                            "autoclass" => Ok(__FieldTag::__autoclass),
                            "hierarchicalNamespace" => Ok(__FieldTag::__hierarchical_namespace),
                            "hierarchical_namespace" => Ok(__FieldTag::__hierarchical_namespace),
                            "softDeletePolicy" => Ok(__FieldTag::__soft_delete_policy),
                            "soft_delete_policy" => Ok(__FieldTag::__soft_delete_policy),
                            "objectRetention" => Ok(__FieldTag::__object_retention),
                            "object_retention" => Ok(__FieldTag::__object_retention),
                            "ipFilter" => Ok(__FieldTag::__ip_filter),
                            "ip_filter" => Ok(__FieldTag::__ip_filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Bucket;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Bucket")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__bucket_id => {
                            if !fields.insert(__FieldTag::__bucket_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bucket_id"));
                            }
                            result.bucket_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for etag"));
                            }
                            result.etag = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for project"));
                            }
                            result.project = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__metageneration => {
                            if !fields.insert(__FieldTag::__metageneration) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metageneration"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.metageneration = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for location"));
                            }
                            result.location = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__location_type => {
                            if !fields.insert(__FieldTag::__location_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for location_type"));
                            }
                            result.location_type = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__storage_class => {
                            if !fields.insert(__FieldTag::__storage_class) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for storage_class"));
                            }
                            result.storage_class = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__rpo => {
                            if !fields.insert(__FieldTag::__rpo) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for rpo"));
                            }
                            result.rpo = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__acl => {
                            if !fields.insert(__FieldTag::__acl) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for acl"));
                            }
                            result.acl = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BucketAccessControl>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__default_object_acl => {
                            if !fields.insert(__FieldTag::__default_object_acl) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for default_object_acl"));
                            }
                            result.default_object_acl = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ObjectAccessControl>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__lifecycle => {
                            if !fields.insert(__FieldTag::__lifecycle) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for lifecycle"));
                            }
                            result.lifecycle = map.next_value::<std::option::Option<crate::model::bucket::Lifecycle>>()?
                                ;
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__cors => {
                            if !fields.insert(__FieldTag::__cors) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cors"));
                            }
                            result.cors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::bucket::Cors>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_time"));
                            }
                            result.update_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__default_event_based_hold => {
                            if !fields.insert(__FieldTag::__default_event_based_hold) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for default_event_based_hold"));
                            }
                            result.default_event_based_hold = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for labels"));
                            }
                            result.labels = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__website => {
                            if !fields.insert(__FieldTag::__website) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for website"));
                            }
                            result.website = map.next_value::<std::option::Option<crate::model::bucket::Website>>()?
                                ;
                        },
                        __FieldTag::__versioning => {
                            if !fields.insert(__FieldTag::__versioning) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for versioning"));
                            }
                            result.versioning = map.next_value::<std::option::Option<crate::model::bucket::Versioning>>()?
                                ;
                        },
                        __FieldTag::__logging => {
                            if !fields.insert(__FieldTag::__logging) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for logging"));
                            }
                            result.logging = map.next_value::<std::option::Option<crate::model::bucket::Logging>>()?
                                ;
                        },
                        __FieldTag::__owner => {
                            if !fields.insert(__FieldTag::__owner) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for owner"));
                            }
                            result.owner = map.next_value::<std::option::Option<crate::model::Owner>>()?
                                ;
                        },
                        __FieldTag::__encryption => {
                            if !fields.insert(__FieldTag::__encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for encryption"));
                            }
                            result.encryption = map.next_value::<std::option::Option<crate::model::bucket::Encryption>>()?
                                ;
                        },
                        __FieldTag::__billing => {
                            if !fields.insert(__FieldTag::__billing) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for billing"));
                            }
                            result.billing = map.next_value::<std::option::Option<crate::model::bucket::Billing>>()?
                                ;
                        },
                        __FieldTag::__retention_policy => {
                            if !fields.insert(__FieldTag::__retention_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for retention_policy"));
                            }
                            result.retention_policy = map.next_value::<std::option::Option<crate::model::bucket::RetentionPolicy>>()?
                                ;
                        },
                        __FieldTag::__iam_config => {
                            if !fields.insert(__FieldTag::__iam_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for iam_config"));
                            }
                            result.iam_config = map.next_value::<std::option::Option<crate::model::bucket::IamConfig>>()?
                                ;
                        },
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for satisfies_pzs"));
                            }
                            result.satisfies_pzs = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__custom_placement_config => {
                            if !fields.insert(__FieldTag::__custom_placement_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for custom_placement_config"));
                            }
                            result.custom_placement_config = map.next_value::<std::option::Option<crate::model::bucket::CustomPlacementConfig>>()?
                                ;
                        },
                        __FieldTag::__autoclass => {
                            if !fields.insert(__FieldTag::__autoclass) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for autoclass"));
                            }
                            result.autoclass = map.next_value::<std::option::Option<crate::model::bucket::Autoclass>>()?
                                ;
                        },
                        __FieldTag::__hierarchical_namespace => {
                            if !fields.insert(__FieldTag::__hierarchical_namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for hierarchical_namespace"));
                            }
                            result.hierarchical_namespace = map.next_value::<std::option::Option<crate::model::bucket::HierarchicalNamespace>>()?
                                ;
                        },
                        __FieldTag::__soft_delete_policy => {
                            if !fields.insert(__FieldTag::__soft_delete_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for soft_delete_policy"));
                            }
                            result.soft_delete_policy = map.next_value::<std::option::Option<crate::model::bucket::SoftDeletePolicy>>()?
                                ;
                        },
                        __FieldTag::__object_retention => {
                            if !fields.insert(__FieldTag::__object_retention) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for object_retention"));
                            }
                            result.object_retention = map.next_value::<std::option::Option<crate::model::bucket::ObjectRetention>>()?
                                ;
                        },
                        __FieldTag::__ip_filter => {
                            if !fields.insert(__FieldTag::__ip_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for ip_filter"));
                            }
                            result.ip_filter = map.next_value::<std::option::Option<crate::model::bucket::IpFilter>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::Billing {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __requester_pays,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Billing")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requesterPays" => Ok(__FieldTag::__requester_pays),
                            "requester_pays" => Ok(__FieldTag::__requester_pays),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::Billing;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Billing")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__requester_pays => {
                            if !fields.insert(__FieldTag::__requester_pays) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for requester_pays"));
                            }
                            result.requester_pays = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::Cors {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __origin,
            __method,
            __response_header,
            __max_age_seconds,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cors")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "origin" => Ok(__FieldTag::__origin),
                            "method" => Ok(__FieldTag::__method),
                            "responseHeader" => Ok(__FieldTag::__response_header),
                            "response_header" => Ok(__FieldTag::__response_header),
                            "maxAgeSeconds" => Ok(__FieldTag::__max_age_seconds),
                            "max_age_seconds" => Ok(__FieldTag::__max_age_seconds),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::Cors;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cors")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__origin => {
                            if !fields.insert(__FieldTag::__origin) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for origin"));
                            }
                            result.origin = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__method => {
                            if !fields.insert(__FieldTag::__method) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for method"));
                            }
                            result.method = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__response_header => {
                            if !fields.insert(__FieldTag::__response_header) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for response_header"));
                            }
                            result.response_header = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__max_age_seconds => {
                            if !fields.insert(__FieldTag::__max_age_seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for max_age_seconds"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_age_seconds = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::Encryption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __default_kms_key,
            __google_managed_encryption_enforcement_config,
            __customer_managed_encryption_enforcement_config,
            __customer_supplied_encryption_enforcement_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Encryption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "defaultKmsKey" => Ok(__FieldTag::__default_kms_key),
                            "default_kms_key" => Ok(__FieldTag::__default_kms_key),
                            "googleManagedEncryptionEnforcementConfig" => Ok(__FieldTag::__google_managed_encryption_enforcement_config),
                            "google_managed_encryption_enforcement_config" => Ok(__FieldTag::__google_managed_encryption_enforcement_config),
                            "customerManagedEncryptionEnforcementConfig" => Ok(__FieldTag::__customer_managed_encryption_enforcement_config),
                            "customer_managed_encryption_enforcement_config" => Ok(__FieldTag::__customer_managed_encryption_enforcement_config),
                            "customerSuppliedEncryptionEnforcementConfig" => Ok(__FieldTag::__customer_supplied_encryption_enforcement_config),
                            "customer_supplied_encryption_enforcement_config" => Ok(__FieldTag::__customer_supplied_encryption_enforcement_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::Encryption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Encryption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__default_kms_key => {
                            if !fields.insert(__FieldTag::__default_kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for default_kms_key"));
                            }
                            result.default_kms_key = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__google_managed_encryption_enforcement_config => {
                            if !fields.insert(__FieldTag::__google_managed_encryption_enforcement_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for google_managed_encryption_enforcement_config"));
                            }
                            result.google_managed_encryption_enforcement_config = map.next_value::<std::option::Option<crate::model::bucket::encryption::GoogleManagedEncryptionEnforcementConfig>>()?
                                ;
                        },
                        __FieldTag::__customer_managed_encryption_enforcement_config => {
                            if !fields.insert(__FieldTag::__customer_managed_encryption_enforcement_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for customer_managed_encryption_enforcement_config"));
                            }
                            result.customer_managed_encryption_enforcement_config = map.next_value::<std::option::Option<crate::model::bucket::encryption::CustomerManagedEncryptionEnforcementConfig>>()?
                                ;
                        },
                        __FieldTag::__customer_supplied_encryption_enforcement_config => {
                            if !fields.insert(__FieldTag::__customer_supplied_encryption_enforcement_config) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for customer_supplied_encryption_enforcement_config"));
                            }
                            result.customer_supplied_encryption_enforcement_config = map.next_value::<std::option::Option<crate::model::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::encryption::GoogleManagedEncryptionEnforcementConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __restriction_mode,
            __effective_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleManagedEncryptionEnforcementConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "restrictionMode" => Ok(__FieldTag::__restriction_mode),
                            "restriction_mode" => Ok(__FieldTag::__restriction_mode),
                            "effectiveTime" => Ok(__FieldTag::__effective_time),
                            "effective_time" => Ok(__FieldTag::__effective_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::encryption::GoogleManagedEncryptionEnforcementConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleManagedEncryptionEnforcementConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__restriction_mode => {
                            if !fields.insert(__FieldTag::__restriction_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for restriction_mode"));
                            }
                            result.restriction_mode = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__effective_time => {
                            if !fields.insert(__FieldTag::__effective_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for effective_time"));
                            }
                            result.effective_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::encryption::CustomerManagedEncryptionEnforcementConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __restriction_mode,
            __effective_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomerManagedEncryptionEnforcementConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "restrictionMode" => Ok(__FieldTag::__restriction_mode),
                            "restriction_mode" => Ok(__FieldTag::__restriction_mode),
                            "effectiveTime" => Ok(__FieldTag::__effective_time),
                            "effective_time" => Ok(__FieldTag::__effective_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::encryption::CustomerManagedEncryptionEnforcementConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomerManagedEncryptionEnforcementConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__restriction_mode => {
                            if !fields.insert(__FieldTag::__restriction_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for restriction_mode"));
                            }
                            result.restriction_mode = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__effective_time => {
                            if !fields.insert(__FieldTag::__effective_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for effective_time"));
                            }
                            result.effective_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __restriction_mode,
            __effective_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomerSuppliedEncryptionEnforcementConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "restrictionMode" => Ok(__FieldTag::__restriction_mode),
                            "restriction_mode" => Ok(__FieldTag::__restriction_mode),
                            "effectiveTime" => Ok(__FieldTag::__effective_time),
                            "effective_time" => Ok(__FieldTag::__effective_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomerSuppliedEncryptionEnforcementConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__restriction_mode => {
                            if !fields.insert(__FieldTag::__restriction_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for restriction_mode"));
                            }
                            result.restriction_mode = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__effective_time => {
                            if !fields.insert(__FieldTag::__effective_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for effective_time"));
                            }
                            result.effective_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::IamConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uniform_bucket_level_access,
            __public_access_prevention,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IamConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uniformBucketLevelAccess" => Ok(__FieldTag::__uniform_bucket_level_access),
                            "uniform_bucket_level_access" => Ok(__FieldTag::__uniform_bucket_level_access),
                            "publicAccessPrevention" => Ok(__FieldTag::__public_access_prevention),
                            "public_access_prevention" => Ok(__FieldTag::__public_access_prevention),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::IamConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IamConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uniform_bucket_level_access => {
                            if !fields.insert(__FieldTag::__uniform_bucket_level_access) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for uniform_bucket_level_access"));
                            }
                            result.uniform_bucket_level_access = map.next_value::<std::option::Option<crate::model::bucket::iam_config::UniformBucketLevelAccess>>()?
                                ;
                        },
                        __FieldTag::__public_access_prevention => {
                            if !fields.insert(__FieldTag::__public_access_prevention) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for public_access_prevention"));
                            }
                            result.public_access_prevention = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::iam_config::UniformBucketLevelAccess {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __lock_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UniformBucketLevelAccess")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "lockTime" => Ok(__FieldTag::__lock_time),
                            "lock_time" => Ok(__FieldTag::__lock_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::iam_config::UniformBucketLevelAccess;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UniformBucketLevelAccess")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enabled"));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__lock_time => {
                            if !fields.insert(__FieldTag::__lock_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for lock_time"));
                            }
                            result.lock_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::Lifecycle {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Lifecycle")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rule" => Ok(__FieldTag::__rule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::Lifecycle;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Lifecycle")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rule => {
                            if !fields.insert(__FieldTag::__rule) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for rule"));
                            }
                            result.rule = map.next_value::<std::option::Option<std::vec::Vec<crate::model::bucket::lifecycle::Rule>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::lifecycle::Rule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __action,
            __condition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Rule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "action" => Ok(__FieldTag::__action),
                            "condition" => Ok(__FieldTag::__condition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::lifecycle::Rule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Rule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for action"));
                            }
                            result.action = map.next_value::<std::option::Option<crate::model::bucket::lifecycle::rule::Action>>()?
                                ;
                        },
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for condition"));
                            }
                            result.condition = map.next_value::<std::option::Option<crate::model::bucket::lifecycle::rule::Condition>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::lifecycle::rule::Action {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __storage_class,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Action")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "storageClass" => Ok(__FieldTag::__storage_class),
                            "storage_class" => Ok(__FieldTag::__storage_class),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::lifecycle::rule::Action;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Action")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for type"));
                            }
                            result.r#type = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__storage_class => {
                            if !fields.insert(__FieldTag::__storage_class) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for storage_class"));
                            }
                            result.storage_class = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::lifecycle::rule::Condition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __age_days,
            __created_before,
            __is_live,
            __num_newer_versions,
            __matches_storage_class,
            __days_since_custom_time,
            __custom_time_before,
            __days_since_noncurrent_time,
            __noncurrent_time_before,
            __matches_prefix,
            __matches_suffix,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Condition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ageDays" => Ok(__FieldTag::__age_days),
                            "age_days" => Ok(__FieldTag::__age_days),
                            "createdBefore" => Ok(__FieldTag::__created_before),
                            "created_before" => Ok(__FieldTag::__created_before),
                            "isLive" => Ok(__FieldTag::__is_live),
                            "is_live" => Ok(__FieldTag::__is_live),
                            "numNewerVersions" => Ok(__FieldTag::__num_newer_versions),
                            "num_newer_versions" => Ok(__FieldTag::__num_newer_versions),
                            "matchesStorageClass" => Ok(__FieldTag::__matches_storage_class),
                            "matches_storage_class" => Ok(__FieldTag::__matches_storage_class),
                            "daysSinceCustomTime" => Ok(__FieldTag::__days_since_custom_time),
                            "days_since_custom_time" => Ok(__FieldTag::__days_since_custom_time),
                            "customTimeBefore" => Ok(__FieldTag::__custom_time_before),
                            "custom_time_before" => Ok(__FieldTag::__custom_time_before),
                            "daysSinceNoncurrentTime" => Ok(__FieldTag::__days_since_noncurrent_time),
                            "days_since_noncurrent_time" => Ok(__FieldTag::__days_since_noncurrent_time),
                            "noncurrentTimeBefore" => Ok(__FieldTag::__noncurrent_time_before),
                            "noncurrent_time_before" => Ok(__FieldTag::__noncurrent_time_before),
                            "matchesPrefix" => Ok(__FieldTag::__matches_prefix),
                            "matches_prefix" => Ok(__FieldTag::__matches_prefix),
                            "matchesSuffix" => Ok(__FieldTag::__matches_suffix),
                            "matches_suffix" => Ok(__FieldTag::__matches_suffix),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::lifecycle::rule::Condition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Condition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__age_days => {
                            if !fields.insert(__FieldTag::__age_days) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for age_days"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.age_days = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__created_before => {
                            if !fields.insert(__FieldTag::__created_before) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for created_before"));
                            }
                            result.created_before = map.next_value::<std::option::Option<gtype::model::Date>>()?
                                ;
                        },
                        __FieldTag::__is_live => {
                            if !fields.insert(__FieldTag::__is_live) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for is_live"));
                            }
                            result.is_live = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::__num_newer_versions => {
                            if !fields.insert(__FieldTag::__num_newer_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for num_newer_versions"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_newer_versions = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__matches_storage_class => {
                            if !fields.insert(__FieldTag::__matches_storage_class) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for matches_storage_class"));
                            }
                            result.matches_storage_class = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__days_since_custom_time => {
                            if !fields.insert(__FieldTag::__days_since_custom_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for days_since_custom_time"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.days_since_custom_time = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__custom_time_before => {
                            if !fields.insert(__FieldTag::__custom_time_before) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for custom_time_before"));
                            }
                            result.custom_time_before = map.next_value::<std::option::Option<gtype::model::Date>>()?
                                ;
                        },
                        __FieldTag::__days_since_noncurrent_time => {
                            if !fields.insert(__FieldTag::__days_since_noncurrent_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for days_since_noncurrent_time"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.days_since_noncurrent_time = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__noncurrent_time_before => {
                            if !fields.insert(__FieldTag::__noncurrent_time_before) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for noncurrent_time_before"));
                            }
                            result.noncurrent_time_before = map.next_value::<std::option::Option<gtype::model::Date>>()?
                                ;
                        },
                        __FieldTag::__matches_prefix => {
                            if !fields.insert(__FieldTag::__matches_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for matches_prefix"));
                            }
                            result.matches_prefix = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__matches_suffix => {
                            if !fields.insert(__FieldTag::__matches_suffix) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for matches_suffix"));
                            }
                            result.matches_suffix = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::Logging {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_bucket,
            __log_object_prefix,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Logging")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logBucket" => Ok(__FieldTag::__log_bucket),
                            "log_bucket" => Ok(__FieldTag::__log_bucket),
                            "logObjectPrefix" => Ok(__FieldTag::__log_object_prefix),
                            "log_object_prefix" => Ok(__FieldTag::__log_object_prefix),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::Logging;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Logging")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_bucket => {
                            if !fields.insert(__FieldTag::__log_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for log_bucket"));
                            }
                            result.log_bucket = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__log_object_prefix => {
                            if !fields.insert(__FieldTag::__log_object_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for log_object_prefix"));
                            }
                            result.log_object_prefix = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::ObjectRetention {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectRetention")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::ObjectRetention;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectRetention")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enabled"));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::RetentionPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __effective_time,
            __is_locked,
            __retention_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetentionPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "effectiveTime" => Ok(__FieldTag::__effective_time),
                            "effective_time" => Ok(__FieldTag::__effective_time),
                            "isLocked" => Ok(__FieldTag::__is_locked),
                            "is_locked" => Ok(__FieldTag::__is_locked),
                            "retentionDuration" => Ok(__FieldTag::__retention_duration),
                            "retention_duration" => Ok(__FieldTag::__retention_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::RetentionPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetentionPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__effective_time => {
                            if !fields.insert(__FieldTag::__effective_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for effective_time"));
                            }
                            result.effective_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__is_locked => {
                            if !fields.insert(__FieldTag::__is_locked) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for is_locked"));
                            }
                            result.is_locked = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__retention_duration => {
                            if !fields.insert(__FieldTag::__retention_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for retention_duration"));
                            }
                            result.retention_duration = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::SoftDeletePolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __retention_duration,
            __effective_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SoftDeletePolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "retentionDuration" => Ok(__FieldTag::__retention_duration),
                            "retention_duration" => Ok(__FieldTag::__retention_duration),
                            "effectiveTime" => Ok(__FieldTag::__effective_time),
                            "effective_time" => Ok(__FieldTag::__effective_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::SoftDeletePolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SoftDeletePolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__retention_duration => {
                            if !fields.insert(__FieldTag::__retention_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for retention_duration"));
                            }
                            result.retention_duration = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::__effective_time => {
                            if !fields.insert(__FieldTag::__effective_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for effective_time"));
                            }
                            result.effective_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::Versioning {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Versioning")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::Versioning;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Versioning")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enabled"));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::Website {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __main_page_suffix,
            __not_found_page,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Website")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mainPageSuffix" => Ok(__FieldTag::__main_page_suffix),
                            "main_page_suffix" => Ok(__FieldTag::__main_page_suffix),
                            "notFoundPage" => Ok(__FieldTag::__not_found_page),
                            "not_found_page" => Ok(__FieldTag::__not_found_page),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::Website;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Website")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__main_page_suffix => {
                            if !fields.insert(__FieldTag::__main_page_suffix) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for main_page_suffix"));
                            }
                            result.main_page_suffix = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__not_found_page => {
                            if !fields.insert(__FieldTag::__not_found_page) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for not_found_page"));
                            }
                            result.not_found_page = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::CustomPlacementConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_locations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomPlacementConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataLocations" => Ok(__FieldTag::__data_locations),
                            "data_locations" => Ok(__FieldTag::__data_locations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::CustomPlacementConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomPlacementConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_locations => {
                            if !fields.insert(__FieldTag::__data_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for data_locations"));
                            }
                            result.data_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::Autoclass {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __toggle_time,
            __terminal_storage_class,
            __terminal_storage_class_update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Autoclass")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "toggleTime" => Ok(__FieldTag::__toggle_time),
                            "toggle_time" => Ok(__FieldTag::__toggle_time),
                            "terminalStorageClass" => Ok(__FieldTag::__terminal_storage_class),
                            "terminal_storage_class" => Ok(__FieldTag::__terminal_storage_class),
                            "terminalStorageClassUpdateTime" => Ok(__FieldTag::__terminal_storage_class_update_time),
                            "terminal_storage_class_update_time" => Ok(__FieldTag::__terminal_storage_class_update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::Autoclass;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Autoclass")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enabled"));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__toggle_time => {
                            if !fields.insert(__FieldTag::__toggle_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for toggle_time"));
                            }
                            result.toggle_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__terminal_storage_class => {
                            if !fields.insert(__FieldTag::__terminal_storage_class) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for terminal_storage_class"));
                            }
                            result.terminal_storage_class = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__terminal_storage_class_update_time => {
                            if !fields.insert(__FieldTag::__terminal_storage_class_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for terminal_storage_class_update_time"));
                            }
                            result.terminal_storage_class_update_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::IpFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            __public_network_source,
            __vpc_network_sources,
            __allow_cross_org_vpcs,
            __allow_all_service_agent_access,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IpFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            "publicNetworkSource" => Ok(__FieldTag::__public_network_source),
                            "public_network_source" => Ok(__FieldTag::__public_network_source),
                            "vpcNetworkSources" => Ok(__FieldTag::__vpc_network_sources),
                            "vpc_network_sources" => Ok(__FieldTag::__vpc_network_sources),
                            "allowCrossOrgVpcs" => Ok(__FieldTag::__allow_cross_org_vpcs),
                            "allow_cross_org_vpcs" => Ok(__FieldTag::__allow_cross_org_vpcs),
                            "allowAllServiceAgentAccess" => Ok(__FieldTag::__allow_all_service_agent_access),
                            "allow_all_service_agent_access" => Ok(__FieldTag::__allow_all_service_agent_access),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::IpFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IpFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for mode"));
                            }
                            result.mode = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__public_network_source => {
                            if !fields.insert(__FieldTag::__public_network_source) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for public_network_source"));
                            }
                            result.public_network_source = map.next_value::<std::option::Option<crate::model::bucket::ip_filter::PublicNetworkSource>>()?
                                ;
                        },
                        __FieldTag::__vpc_network_sources => {
                            if !fields.insert(__FieldTag::__vpc_network_sources) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for vpc_network_sources"));
                            }
                            result.vpc_network_sources = map.next_value::<std::option::Option<std::vec::Vec<crate::model::bucket::ip_filter::VpcNetworkSource>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__allow_cross_org_vpcs => {
                            if !fields.insert(__FieldTag::__allow_cross_org_vpcs) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for allow_cross_org_vpcs"));
                            }
                            result.allow_cross_org_vpcs = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__allow_all_service_agent_access => {
                            if !fields.insert(__FieldTag::__allow_all_service_agent_access) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for allow_all_service_agent_access"));
                            }
                            result.allow_all_service_agent_access = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::ip_filter::PublicNetworkSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowed_ip_cidr_ranges,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PublicNetworkSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowedIpCidrRanges" => Ok(__FieldTag::__allowed_ip_cidr_ranges),
                            "allowed_ip_cidr_ranges" => Ok(__FieldTag::__allowed_ip_cidr_ranges),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::ip_filter::PublicNetworkSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PublicNetworkSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowed_ip_cidr_ranges => {
                            if !fields.insert(__FieldTag::__allowed_ip_cidr_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for allowed_ip_cidr_ranges"));
                            }
                            result.allowed_ip_cidr_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::ip_filter::VpcNetworkSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network,
            __allowed_ip_cidr_ranges,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpcNetworkSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "network" => Ok(__FieldTag::__network),
                            "allowedIpCidrRanges" => Ok(__FieldTag::__allowed_ip_cidr_ranges),
                            "allowed_ip_cidr_ranges" => Ok(__FieldTag::__allowed_ip_cidr_ranges),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::ip_filter::VpcNetworkSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpcNetworkSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for network"));
                            }
                            result.network = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__allowed_ip_cidr_ranges => {
                            if !fields.insert(__FieldTag::__allowed_ip_cidr_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for allowed_ip_cidr_ranges"));
                            }
                            result.allowed_ip_cidr_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::bucket::HierarchicalNamespace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HierarchicalNamespace")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::bucket::HierarchicalNamespace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HierarchicalNamespace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for enabled"));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}


#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BucketAccessControl {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __role,
            __id,
            __entity,
            __entity_alt,
            __entity_id,
            __etag,
            __email,
            __domain,
            __project_team,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BucketAccessControl")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "role" => Ok(__FieldTag::__role),
                            "id" => Ok(__FieldTag::__id),
                            "entity" => Ok(__FieldTag::__entity),
                            "entityAlt" => Ok(__FieldTag::__entity_alt),
                            "entity_alt" => Ok(__FieldTag::__entity_alt),
                            "entityId" => Ok(__FieldTag::__entity_id),
                            "entity_id" => Ok(__FieldTag::__entity_id),
                            "etag" => Ok(__FieldTag::__etag),
                            "email" => Ok(__FieldTag::__email),
                            "domain" => Ok(__FieldTag::__domain),
                            "projectTeam" => Ok(__FieldTag::__project_team),
                            "project_team" => Ok(__FieldTag::__project_team),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BucketAccessControl;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BucketAccessControl")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for role"));
                            }
                            result.role = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for id"));
                            }
                            result.id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity"));
                            }
                            result.entity = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity_alt => {
                            if !fields.insert(__FieldTag::__entity_alt) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_alt"));
                            }
                            result.entity_alt = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity_id => {
                            if !fields.insert(__FieldTag::__entity_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_id"));
                            }
                            result.entity_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for etag"));
                            }
                            result.etag = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for email"));
                            }
                            result.email = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for domain"));
                            }
                            result.domain = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__project_team => {
                            if !fields.insert(__FieldTag::__project_team) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for project_team"));
                            }
                            result.project_team = map.next_value::<std::option::Option<crate::model::ProjectTeam>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ObjectChecksums {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __crc32c,
            __md5_hash,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectChecksums")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "crc32c" => Ok(__FieldTag::__crc32c),
                            "md5Hash" => Ok(__FieldTag::__md5_hash),
                            "md5_hash" => Ok(__FieldTag::__md5_hash),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ObjectChecksums;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectChecksums")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__crc32c => {
                            if !fields.insert(__FieldTag::__crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for crc32c"));
                            }
                            struct __With( std::option::Option<u32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.crc32c = map.next_value::< __With >()?.0;
                        },
                        __FieldTag::__md5_hash => {
                            if !fields.insert(__FieldTag::__md5_hash) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for md5_hash"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.md5_hash = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ObjectCustomContextPayload {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectCustomContextPayload")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ObjectCustomContextPayload;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectCustomContextPayload")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for value"));
                            }
                            result.value = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_time"));
                            }
                            result.update_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ObjectContexts {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __custom,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectContexts")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "custom" => Ok(__FieldTag::__custom),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ObjectContexts;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectContexts")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__custom => {
                            if !fields.insert(__FieldTag::__custom) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for custom"));
                            }
                            result.custom = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::ObjectCustomContextPayload>>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CustomerEncryption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encryption_algorithm,
            __key_sha256_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomerEncryption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encryptionAlgorithm" => Ok(__FieldTag::__encryption_algorithm),
                            "encryption_algorithm" => Ok(__FieldTag::__encryption_algorithm),
                            "keySha256Bytes" => Ok(__FieldTag::__key_sha256_bytes),
                            "key_sha256_bytes" => Ok(__FieldTag::__key_sha256_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CustomerEncryption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomerEncryption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encryption_algorithm => {
                            if !fields.insert(__FieldTag::__encryption_algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for encryption_algorithm"));
                            }
                            result.encryption_algorithm = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__key_sha256_bytes => {
                            if !fields.insert(__FieldTag::__key_sha256_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for key_sha256_bytes"));
                            }
                            struct __With( std::option::Option<::bytes::Bytes> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.key_sha256_bytes = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Object {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __bucket,
            __etag,
            __generation,
            __restore_token,
            __metageneration,
            __storage_class,
            __size,
            __content_encoding,
            __content_disposition,
            __cache_control,
            __acl,
            __content_language,
            __delete_time,
            __finalize_time,
            __content_type,
            __create_time,
            __component_count,
            __checksums,
            __update_time,
            __kms_key,
            __update_storage_class_time,
            __temporary_hold,
            __retention_expire_time,
            __metadata,
            __contexts,
            __event_based_hold,
            __owner,
            __customer_encryption,
            __custom_time,
            __soft_delete_time,
            __hard_delete_time,
            __retention,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Object")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "bucket" => Ok(__FieldTag::__bucket),
                            "etag" => Ok(__FieldTag::__etag),
                            "generation" => Ok(__FieldTag::__generation),
                            "restoreToken" => Ok(__FieldTag::__restore_token),
                            "restore_token" => Ok(__FieldTag::__restore_token),
                            "metageneration" => Ok(__FieldTag::__metageneration),
                            "storageClass" => Ok(__FieldTag::__storage_class),
                            "storage_class" => Ok(__FieldTag::__storage_class),
                            "size" => Ok(__FieldTag::__size),
                            "contentEncoding" => Ok(__FieldTag::__content_encoding),
                            "content_encoding" => Ok(__FieldTag::__content_encoding),
                            "contentDisposition" => Ok(__FieldTag::__content_disposition),
                            "content_disposition" => Ok(__FieldTag::__content_disposition),
                            "cacheControl" => Ok(__FieldTag::__cache_control),
                            "cache_control" => Ok(__FieldTag::__cache_control),
                            "acl" => Ok(__FieldTag::__acl),
                            "contentLanguage" => Ok(__FieldTag::__content_language),
                            "content_language" => Ok(__FieldTag::__content_language),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "finalizeTime" => Ok(__FieldTag::__finalize_time),
                            "finalize_time" => Ok(__FieldTag::__finalize_time),
                            "contentType" => Ok(__FieldTag::__content_type),
                            "content_type" => Ok(__FieldTag::__content_type),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "componentCount" => Ok(__FieldTag::__component_count),
                            "component_count" => Ok(__FieldTag::__component_count),
                            "checksums" => Ok(__FieldTag::__checksums),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            "updateStorageClassTime" => Ok(__FieldTag::__update_storage_class_time),
                            "update_storage_class_time" => Ok(__FieldTag::__update_storage_class_time),
                            "temporaryHold" => Ok(__FieldTag::__temporary_hold),
                            "temporary_hold" => Ok(__FieldTag::__temporary_hold),
                            "retentionExpireTime" => Ok(__FieldTag::__retention_expire_time),
                            "retention_expire_time" => Ok(__FieldTag::__retention_expire_time),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "contexts" => Ok(__FieldTag::__contexts),
                            "eventBasedHold" => Ok(__FieldTag::__event_based_hold),
                            "event_based_hold" => Ok(__FieldTag::__event_based_hold),
                            "owner" => Ok(__FieldTag::__owner),
                            "customerEncryption" => Ok(__FieldTag::__customer_encryption),
                            "customer_encryption" => Ok(__FieldTag::__customer_encryption),
                            "customTime" => Ok(__FieldTag::__custom_time),
                            "custom_time" => Ok(__FieldTag::__custom_time),
                            "softDeleteTime" => Ok(__FieldTag::__soft_delete_time),
                            "soft_delete_time" => Ok(__FieldTag::__soft_delete_time),
                            "hardDeleteTime" => Ok(__FieldTag::__hard_delete_time),
                            "hard_delete_time" => Ok(__FieldTag::__hard_delete_time),
                            "retention" => Ok(__FieldTag::__retention),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Object;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Object")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for name"));
                            }
                            result.name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for bucket"));
                            }
                            result.bucket = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for etag"));
                            }
                            result.etag = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for generation"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__restore_token => {
                            if !fields.insert(__FieldTag::__restore_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for restore_token"));
                            }
                            result.restore_token = map.next_value::<std::option::Option<std::string::String>>()?
                                ;
                        },
                        __FieldTag::__metageneration => {
                            if !fields.insert(__FieldTag::__metageneration) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metageneration"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.metageneration = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__storage_class => {
                            if !fields.insert(__FieldTag::__storage_class) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for storage_class"));
                            }
                            result.storage_class = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__size => {
                            if !fields.insert(__FieldTag::__size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for size"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__content_encoding => {
                            if !fields.insert(__FieldTag::__content_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for content_encoding"));
                            }
                            result.content_encoding = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__content_disposition => {
                            if !fields.insert(__FieldTag::__content_disposition) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for content_disposition"));
                            }
                            result.content_disposition = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__cache_control => {
                            if !fields.insert(__FieldTag::__cache_control) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cache_control"));
                            }
                            result.cache_control = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__acl => {
                            if !fields.insert(__FieldTag::__acl) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for acl"));
                            }
                            result.acl = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ObjectAccessControl>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__content_language => {
                            if !fields.insert(__FieldTag::__content_language) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for content_language"));
                            }
                            result.content_language = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for delete_time"));
                            }
                            result.delete_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__finalize_time => {
                            if !fields.insert(__FieldTag::__finalize_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for finalize_time"));
                            }
                            result.finalize_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__content_type => {
                            if !fields.insert(__FieldTag::__content_type) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for content_type"));
                            }
                            result.content_type = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for create_time"));
                            }
                            result.create_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__component_count => {
                            if !fields.insert(__FieldTag::__component_count) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for component_count"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.component_count = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__checksums => {
                            if !fields.insert(__FieldTag::__checksums) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for checksums"));
                            }
                            result.checksums = map.next_value::<std::option::Option<crate::model::ObjectChecksums>>()?
                                ;
                        },
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_time"));
                            }
                            result.update_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for kms_key"));
                            }
                            result.kms_key = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__update_storage_class_time => {
                            if !fields.insert(__FieldTag::__update_storage_class_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for update_storage_class_time"));
                            }
                            result.update_storage_class_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__temporary_hold => {
                            if !fields.insert(__FieldTag::__temporary_hold) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for temporary_hold"));
                            }
                            result.temporary_hold = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__retention_expire_time => {
                            if !fields.insert(__FieldTag::__retention_expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for retention_expire_time"));
                            }
                            result.retention_expire_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for metadata"));
                            }
                            result.metadata = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__contexts => {
                            if !fields.insert(__FieldTag::__contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for contexts"));
                            }
                            result.contexts = map.next_value::<std::option::Option<crate::model::ObjectContexts>>()?
                                ;
                        },
                        __FieldTag::__event_based_hold => {
                            if !fields.insert(__FieldTag::__event_based_hold) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for event_based_hold"));
                            }
                            result.event_based_hold = map.next_value::<std::option::Option<bool>>()?
                                ;
                        },
                        __FieldTag::__owner => {
                            if !fields.insert(__FieldTag::__owner) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for owner"));
                            }
                            result.owner = map.next_value::<std::option::Option<crate::model::Owner>>()?
                                ;
                        },
                        __FieldTag::__customer_encryption => {
                            if !fields.insert(__FieldTag::__customer_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for customer_encryption"));
                            }
                            result.customer_encryption = map.next_value::<std::option::Option<crate::model::CustomerEncryption>>()?
                                ;
                        },
                        __FieldTag::__custom_time => {
                            if !fields.insert(__FieldTag::__custom_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for custom_time"));
                            }
                            result.custom_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__soft_delete_time => {
                            if !fields.insert(__FieldTag::__soft_delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for soft_delete_time"));
                            }
                            result.soft_delete_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__hard_delete_time => {
                            if !fields.insert(__FieldTag::__hard_delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for hard_delete_time"));
                            }
                            result.hard_delete_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::__retention => {
                            if !fields.insert(__FieldTag::__retention) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for retention"));
                            }
                            result.retention = map.next_value::<std::option::Option<crate::model::object::Retention>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::object::Retention {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            __retain_until_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Retention")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            "retainUntilTime" => Ok(__FieldTag::__retain_until_time),
                            "retain_until_time" => Ok(__FieldTag::__retain_until_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::object::Retention;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Retention")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for mode"));
                            }
                            result.mode = map.next_value::<std::option::Option<crate::model::object::retention::Mode>>()?.unwrap_or_default();
                        },
                        __FieldTag::__retain_until_time => {
                            if !fields.insert(__FieldTag::__retain_until_time) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for retain_until_time"));
                            }
                            result.retain_until_time = map.next_value::<std::option::Option<wkt::Timestamp>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}


#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ObjectAccessControl {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __role,
            __id,
            __entity,
            __entity_alt,
            __entity_id,
            __etag,
            __email,
            __domain,
            __project_team,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectAccessControl")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "role" => Ok(__FieldTag::__role),
                            "id" => Ok(__FieldTag::__id),
                            "entity" => Ok(__FieldTag::__entity),
                            "entityAlt" => Ok(__FieldTag::__entity_alt),
                            "entity_alt" => Ok(__FieldTag::__entity_alt),
                            "entityId" => Ok(__FieldTag::__entity_id),
                            "entity_id" => Ok(__FieldTag::__entity_id),
                            "etag" => Ok(__FieldTag::__etag),
                            "email" => Ok(__FieldTag::__email),
                            "domain" => Ok(__FieldTag::__domain),
                            "projectTeam" => Ok(__FieldTag::__project_team),
                            "project_team" => Ok(__FieldTag::__project_team),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ObjectAccessControl;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectAccessControl")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for role"));
                            }
                            result.role = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for id"));
                            }
                            result.id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity"));
                            }
                            result.entity = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity_alt => {
                            if !fields.insert(__FieldTag::__entity_alt) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_alt"));
                            }
                            result.entity_alt = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity_id => {
                            if !fields.insert(__FieldTag::__entity_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_id"));
                            }
                            result.entity_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for etag"));
                            }
                            result.etag = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for email"));
                            }
                            result.email = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for domain"));
                            }
                            result.domain = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__project_team => {
                            if !fields.insert(__FieldTag::__project_team) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for project_team"));
                            }
                            result.project_team = map.next_value::<std::option::Option<crate::model::ProjectTeam>>()?
                                ;
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListObjectsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __objects,
            __prefixes,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListObjectsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "objects" => Ok(__FieldTag::__objects),
                            "prefixes" => Ok(__FieldTag::__prefixes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListObjectsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListObjectsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__objects => {
                            if !fields.insert(__FieldTag::__objects) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for objects"));
                            }
                            result.objects = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Object>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__prefixes => {
                            if !fields.insert(__FieldTag::__prefixes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for prefixes"));
                            }
                            result.prefixes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        },
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for next_page_token"));
                            }
                            result.next_page_token = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ProjectTeam {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_number,
            __team,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProjectTeam")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectNumber" => Ok(__FieldTag::__project_number),
                            "project_number" => Ok(__FieldTag::__project_number),
                            "team" => Ok(__FieldTag::__team),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ProjectTeam;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProjectTeam")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_number => {
                            if !fields.insert(__FieldTag::__project_number) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for project_number"));
                            }
                            result.project_number = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__team => {
                            if !fields.insert(__FieldTag::__team) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for team"));
                            }
                            result.team = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Owner {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity,
            __entity_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Owner")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entity" => Ok(__FieldTag::__entity),
                            "entityId" => Ok(__FieldTag::__entity_id),
                            "entity_id" => Ok(__FieldTag::__entity_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Owner;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Owner")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity"));
                            }
                            result.entity = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__entity_id => {
                            if !fields.insert(__FieldTag::__entity_id) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for entity_id"));
                            }
                            result.entity_id = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
