// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

impl gaxi::prost::ToProto<DeleteBucketRequest> for crate::generated::gapic::model::DeleteBucketRequest {
    type Output = DeleteBucketRequest;
    fn to_proto(self) -> std::result::Result<DeleteBucketRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            name: self.name.to_proto()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::DeleteBucketRequest> for DeleteBucketRequest {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::DeleteBucketRequest, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::DeleteBucketRequest::new()
                .set_name(self.name)
                .set_or_clear_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<GetBucketRequest> for crate::generated::gapic::model::GetBucketRequest {
    type Output = GetBucketRequest;
    fn to_proto(self) -> std::result::Result<GetBucketRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            name: self.name.to_proto()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            read_mask: self.read_mask.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::GetBucketRequest> for GetBucketRequest {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::GetBucketRequest, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::GetBucketRequest::new()
                .set_name(self.name)
                .set_or_clear_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_read_mask(self.read_mask.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<CreateBucketRequest> for crate::generated::gapic::model::CreateBucketRequest {
    type Output = CreateBucketRequest;
    fn to_proto(self) -> std::result::Result<CreateBucketRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            parent: self.parent.to_proto()?,
            bucket: self.bucket.map(|v| v.to_proto()).transpose()?,
            bucket_id: self.bucket_id.to_proto()?,
            predefined_acl: self.predefined_acl.to_proto()?,
            predefined_default_object_acl: self.predefined_default_object_acl.to_proto()?,
            enable_object_retention: self.enable_object_retention.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::CreateBucketRequest> for CreateBucketRequest {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::CreateBucketRequest, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::CreateBucketRequest::new()
                .set_parent(self.parent)
                .set_or_clear_bucket(self.bucket.map(|v| v.cnv()).transpose()?)
                .set_bucket_id(self.bucket_id)
                .set_predefined_acl(self.predefined_acl)
                .set_predefined_default_object_acl(self.predefined_default_object_acl)
                .set_enable_object_retention(self.enable_object_retention)
        )
    }
}

impl gaxi::prost::ToProto<ListBucketsRequest> for crate::generated::gapic::model::ListBucketsRequest {
    type Output = ListBucketsRequest;
    fn to_proto(self) -> std::result::Result<ListBucketsRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            parent: self.parent.to_proto()?,
            page_size: self.page_size.to_proto()?,
            page_token: self.page_token.to_proto()?,
            prefix: self.prefix.to_proto()?,
            read_mask: self.read_mask.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ListBucketsRequest> for ListBucketsRequest {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::ListBucketsRequest, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::ListBucketsRequest::new()
                .set_parent(self.parent)
                .set_page_size(self.page_size)
                .set_page_token(self.page_token)
                .set_prefix(self.prefix)
                .set_or_clear_read_mask(self.read_mask.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<ListBucketsResponse> for crate::generated::gapic::model::ListBucketsResponse {
    type Output = ListBucketsResponse;
    fn to_proto(self) -> std::result::Result<ListBucketsResponse, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            buckets: self.buckets
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            next_page_token: self.next_page_token.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ListBucketsResponse> for ListBucketsResponse {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::ListBucketsResponse, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::ListBucketsResponse::new()
                .set_buckets(self.buckets.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_next_page_token(self.next_page_token)
        )
    }
}

impl gaxi::prost::ToProto<LockBucketRetentionPolicyRequest> for crate::generated::gapic::model::LockBucketRetentionPolicyRequest {
    type Output = LockBucketRetentionPolicyRequest;
    fn to_proto(self) -> std::result::Result<LockBucketRetentionPolicyRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            bucket: self.bucket.to_proto()?,
            if_metageneration_match: self.if_metageneration_match.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::LockBucketRetentionPolicyRequest> for LockBucketRetentionPolicyRequest {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::LockBucketRetentionPolicyRequest, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::LockBucketRetentionPolicyRequest::new()
                .set_bucket(self.bucket)
                .set_if_metageneration_match(self.if_metageneration_match)
        )
    }
}

impl gaxi::prost::ToProto<UpdateBucketRequest> for crate::generated::gapic::model::UpdateBucketRequest {
    type Output = UpdateBucketRequest;
    fn to_proto(self) -> std::result::Result<UpdateBucketRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            bucket: self.bucket.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            predefined_acl: self.predefined_acl.to_proto()?,
            predefined_default_object_acl: self.predefined_default_object_acl.to_proto()?,
            update_mask: self.update_mask.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::UpdateBucketRequest> for UpdateBucketRequest {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::UpdateBucketRequest, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::UpdateBucketRequest::new()
                .set_or_clear_bucket(self.bucket.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()).transpose()?)
                .set_predefined_acl(self.predefined_acl)
                .set_predefined_default_object_acl(self.predefined_default_object_acl)
                .set_or_clear_update_mask(self.update_mask.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<compose_object_request::source_object::ObjectPreconditions> for crate::generated::gapic::model::compose_object_request::source_object::ObjectPreconditions {
    type Output = compose_object_request::source_object::ObjectPreconditions;
    fn to_proto(self) -> std::result::Result<compose_object_request::source_object::ObjectPreconditions, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::compose_object_request::source_object::ObjectPreconditions> for compose_object_request::source_object::ObjectPreconditions {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::compose_object_request::source_object::ObjectPreconditions, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::compose_object_request::source_object::ObjectPreconditions::new()
                .set_or_clear_if_generation_match(self.if_generation_match.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<compose_object_request::SourceObject> for crate::generated::gapic::model::compose_object_request::SourceObject {
    type Output = compose_object_request::SourceObject;
    fn to_proto(self) -> std::result::Result<compose_object_request::SourceObject, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            name: self.name.to_proto()?,
            generation: self.generation.to_proto()?,
            object_preconditions: self.object_preconditions.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::compose_object_request::SourceObject> for compose_object_request::SourceObject {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::compose_object_request::SourceObject, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::compose_object_request::SourceObject::new()
                .set_name(self.name)
                .set_generation(self.generation)
                .set_or_clear_object_preconditions(self.object_preconditions.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<ComposeObjectRequest> for crate::generated::gapic::model::ComposeObjectRequest {
    type Output = ComposeObjectRequest;
    fn to_proto(self) -> std::result::Result<ComposeObjectRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            destination: self.destination.map(|v| v.to_proto()).transpose()?,
            source_objects: self.source_objects
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            destination_predefined_acl: self.destination_predefined_acl.to_proto()?,
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            kms_key: self.kms_key.to_proto()?,
            common_object_request_params: self.common_object_request_params.map(|v| v.to_proto()).transpose()?,
            object_checksums: self.object_checksums.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ComposeObjectRequest> for ComposeObjectRequest {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::ComposeObjectRequest, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::ComposeObjectRequest::new()
                .set_or_clear_destination(self.destination.map(|v| v.cnv()).transpose()?)
                .set_source_objects(self.source_objects.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_destination_predefined_acl(self.destination_predefined_acl)
                .set_or_clear_if_generation_match(self.if_generation_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()).transpose()?)
                .set_kms_key(self.kms_key)
                .set_or_clear_common_object_request_params(self.common_object_request_params.map(|v| v.cnv()).transpose()?)
                .set_or_clear_object_checksums(self.object_checksums.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<DeleteObjectRequest> for crate::generated::gapic::model::DeleteObjectRequest {
    type Output = DeleteObjectRequest;
    fn to_proto(self) -> std::result::Result<DeleteObjectRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            bucket: self.bucket.to_proto()?,
            object: self.object.to_proto()?,
            generation: self.generation.to_proto()?,
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
            if_generation_not_match: self.if_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            common_object_request_params: self.common_object_request_params.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::DeleteObjectRequest> for DeleteObjectRequest {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::DeleteObjectRequest, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::DeleteObjectRequest::new()
                .set_bucket(self.bucket)
                .set_object(self.object)
                .set_generation(self.generation)
                .set_or_clear_if_generation_match(self.if_generation_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_generation_not_match(self.if_generation_not_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_common_object_request_params(self.common_object_request_params.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<RestoreObjectRequest> for crate::generated::gapic::model::RestoreObjectRequest {
    type Output = RestoreObjectRequest;
    fn to_proto(self) -> std::result::Result<RestoreObjectRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            bucket: self.bucket.to_proto()?,
            object: self.object.to_proto()?,
            generation: self.generation.to_proto()?,
            restore_token: self.restore_token.to_proto()?,
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
            if_generation_not_match: self.if_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            copy_source_acl: self.copy_source_acl.map(|v| v.to_proto()).transpose()?,
            common_object_request_params: self.common_object_request_params.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::RestoreObjectRequest> for RestoreObjectRequest {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::RestoreObjectRequest, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::RestoreObjectRequest::new()
                .set_bucket(self.bucket)
                .set_object(self.object)
                .set_generation(self.generation)
                .set_restore_token(self.restore_token)
                .set_or_clear_if_generation_match(self.if_generation_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_generation_not_match(self.if_generation_not_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_copy_source_acl(self.copy_source_acl.map(|v| v.cnv()).transpose()?)
                .set_or_clear_common_object_request_params(self.common_object_request_params.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<GetObjectRequest> for crate::generated::gapic::model::GetObjectRequest {
    type Output = GetObjectRequest;
    fn to_proto(self) -> std::result::Result<GetObjectRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            bucket: self.bucket.to_proto()?,
            object: self.object.to_proto()?,
            generation: self.generation.to_proto()?,
            soft_deleted: self.soft_deleted.map(|v| v.to_proto()).transpose()?,
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
            if_generation_not_match: self.if_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            common_object_request_params: self.common_object_request_params.map(|v| v.to_proto()).transpose()?,
            read_mask: self.read_mask.map(|v| v.to_proto()).transpose()?,
            restore_token: self.restore_token.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::GetObjectRequest> for GetObjectRequest {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::GetObjectRequest, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::GetObjectRequest::new()
                .set_bucket(self.bucket)
                .set_object(self.object)
                .set_generation(self.generation)
                .set_or_clear_soft_deleted(self.soft_deleted.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_generation_match(self.if_generation_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_generation_not_match(self.if_generation_not_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_common_object_request_params(self.common_object_request_params.map(|v| v.cnv()).transpose()?)
                .set_or_clear_read_mask(self.read_mask.map(|v| v.cnv()).transpose()?)
                .set_restore_token(self.restore_token)
        )
    }
}

impl gaxi::prost::ToProto<ListObjectsRequest> for crate::generated::gapic::model::ListObjectsRequest {
    type Output = ListObjectsRequest;
    fn to_proto(self) -> std::result::Result<ListObjectsRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            parent: self.parent.to_proto()?,
            page_size: self.page_size.to_proto()?,
            page_token: self.page_token.to_proto()?,
            delimiter: self.delimiter.to_proto()?,
            include_trailing_delimiter: self.include_trailing_delimiter.to_proto()?,
            prefix: self.prefix.to_proto()?,
            versions: self.versions.to_proto()?,
            read_mask: self.read_mask.map(|v| v.to_proto()).transpose()?,
            lexicographic_start: self.lexicographic_start.to_proto()?,
            lexicographic_end: self.lexicographic_end.to_proto()?,
            soft_deleted: self.soft_deleted.to_proto()?,
            include_folders_as_prefixes: self.include_folders_as_prefixes.to_proto()?,
            match_glob: self.match_glob.to_proto()?,
            filter: self.filter.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ListObjectsRequest> for ListObjectsRequest {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::ListObjectsRequest, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::ListObjectsRequest::new()
                .set_parent(self.parent)
                .set_page_size(self.page_size)
                .set_page_token(self.page_token)
                .set_delimiter(self.delimiter)
                .set_include_trailing_delimiter(self.include_trailing_delimiter)
                .set_prefix(self.prefix)
                .set_versions(self.versions)
                .set_or_clear_read_mask(self.read_mask.map(|v| v.cnv()).transpose()?)
                .set_lexicographic_start(self.lexicographic_start)
                .set_lexicographic_end(self.lexicographic_end)
                .set_soft_deleted(self.soft_deleted)
                .set_include_folders_as_prefixes(self.include_folders_as_prefixes)
                .set_match_glob(self.match_glob)
                .set_filter(self.filter)
        )
    }
}

impl gaxi::prost::ToProto<RewriteObjectRequest> for crate::generated::gapic::model::RewriteObjectRequest {
    type Output = RewriteObjectRequest;
    fn to_proto(self) -> std::result::Result<RewriteObjectRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            destination_name: self.destination_name.to_proto()?,
            destination_bucket: self.destination_bucket.to_proto()?,
            destination_kms_key: self.destination_kms_key.to_proto()?,
            destination: self.destination.map(|v| v.to_proto()).transpose()?,
            source_bucket: self.source_bucket.to_proto()?,
            source_object: self.source_object.to_proto()?,
            source_generation: self.source_generation.to_proto()?,
            rewrite_token: self.rewrite_token.to_proto()?,
            destination_predefined_acl: self.destination_predefined_acl.to_proto()?,
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
            if_generation_not_match: self.if_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            if_source_generation_match: self.if_source_generation_match.map(|v| v.to_proto()).transpose()?,
            if_source_generation_not_match: self.if_source_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_source_metageneration_match: self.if_source_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_source_metageneration_not_match: self.if_source_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            max_bytes_rewritten_per_call: self.max_bytes_rewritten_per_call.to_proto()?,
            copy_source_encryption_algorithm: self.copy_source_encryption_algorithm.to_proto()?,
            copy_source_encryption_key_bytes: self.copy_source_encryption_key_bytes.to_proto()?,
            copy_source_encryption_key_sha256_bytes: self.copy_source_encryption_key_sha256_bytes.to_proto()?,
            common_object_request_params: self.common_object_request_params.map(|v| v.to_proto()).transpose()?,
            object_checksums: self.object_checksums.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::RewriteObjectRequest> for RewriteObjectRequest {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::RewriteObjectRequest, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::RewriteObjectRequest::new()
                .set_destination_name(self.destination_name)
                .set_destination_bucket(self.destination_bucket)
                .set_destination_kms_key(self.destination_kms_key)
                .set_or_clear_destination(self.destination.map(|v| v.cnv()).transpose()?)
                .set_source_bucket(self.source_bucket)
                .set_source_object(self.source_object)
                .set_source_generation(self.source_generation)
                .set_rewrite_token(self.rewrite_token)
                .set_destination_predefined_acl(self.destination_predefined_acl)
                .set_or_clear_if_generation_match(self.if_generation_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_generation_not_match(self.if_generation_not_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_source_generation_match(self.if_source_generation_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_source_generation_not_match(self.if_source_generation_not_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_source_metageneration_match(self.if_source_metageneration_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_source_metageneration_not_match(self.if_source_metageneration_not_match.map(|v| v.cnv()).transpose()?)
                .set_max_bytes_rewritten_per_call(self.max_bytes_rewritten_per_call)
                .set_copy_source_encryption_algorithm(self.copy_source_encryption_algorithm)
                .set_copy_source_encryption_key_bytes(self.copy_source_encryption_key_bytes)
                .set_copy_source_encryption_key_sha256_bytes(self.copy_source_encryption_key_sha256_bytes)
                .set_or_clear_common_object_request_params(self.common_object_request_params.map(|v| v.cnv()).transpose()?)
                .set_or_clear_object_checksums(self.object_checksums.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<RewriteResponse> for crate::generated::gapic::model::RewriteResponse {
    type Output = RewriteResponse;
    fn to_proto(self) -> std::result::Result<RewriteResponse, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            total_bytes_rewritten: self.total_bytes_rewritten.to_proto()?,
            object_size: self.object_size.to_proto()?,
            done: self.done.to_proto()?,
            rewrite_token: self.rewrite_token.to_proto()?,
            resource: self.resource.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::RewriteResponse> for RewriteResponse {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::RewriteResponse, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::RewriteResponse::new()
                .set_total_bytes_rewritten(self.total_bytes_rewritten)
                .set_object_size(self.object_size)
                .set_done(self.done)
                .set_rewrite_token(self.rewrite_token)
                .set_or_clear_resource(self.resource.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<MoveObjectRequest> for crate::generated::gapic::model::MoveObjectRequest {
    type Output = MoveObjectRequest;
    fn to_proto(self) -> std::result::Result<MoveObjectRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            bucket: self.bucket.to_proto()?,
            source_object: self.source_object.to_proto()?,
            destination_object: self.destination_object.to_proto()?,
            if_source_generation_match: self.if_source_generation_match.map(|v| v.to_proto()).transpose()?,
            if_source_generation_not_match: self.if_source_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_source_metageneration_match: self.if_source_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_source_metageneration_not_match: self.if_source_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
            if_generation_not_match: self.if_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::MoveObjectRequest> for MoveObjectRequest {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::MoveObjectRequest, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::MoveObjectRequest::new()
                .set_bucket(self.bucket)
                .set_source_object(self.source_object)
                .set_destination_object(self.destination_object)
                .set_or_clear_if_source_generation_match(self.if_source_generation_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_source_generation_not_match(self.if_source_generation_not_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_source_metageneration_match(self.if_source_metageneration_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_source_metageneration_not_match(self.if_source_metageneration_not_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_generation_match(self.if_generation_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_generation_not_match(self.if_generation_not_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<UpdateObjectRequest> for crate::generated::gapic::model::UpdateObjectRequest {
    type Output = UpdateObjectRequest;
    fn to_proto(self) -> std::result::Result<UpdateObjectRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            object: self.object.map(|v| v.to_proto()).transpose()?,
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
            if_generation_not_match: self.if_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            predefined_acl: self.predefined_acl.to_proto()?,
            update_mask: self.update_mask.map(|v| v.to_proto()).transpose()?,
            common_object_request_params: self.common_object_request_params.map(|v| v.to_proto()).transpose()?,
            override_unlocked_retention: self.override_unlocked_retention.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::UpdateObjectRequest> for UpdateObjectRequest {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::UpdateObjectRequest, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::UpdateObjectRequest::new()
                .set_or_clear_object(self.object.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_generation_match(self.if_generation_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_generation_not_match(self.if_generation_not_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()).transpose()?)
                .set_or_clear_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()).transpose()?)
                .set_predefined_acl(self.predefined_acl)
                .set_or_clear_update_mask(self.update_mask.map(|v| v.cnv()).transpose()?)
                .set_or_clear_common_object_request_params(self.common_object_request_params.map(|v| v.cnv()).transpose()?)
                .set_override_unlocked_retention(self.override_unlocked_retention)
        )
    }
}

impl gaxi::prost::ToProto<CommonObjectRequestParams> for crate::generated::gapic::model::CommonObjectRequestParams {
    type Output = CommonObjectRequestParams;
    fn to_proto(self) -> std::result::Result<CommonObjectRequestParams, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            encryption_algorithm: self.encryption_algorithm.to_proto()?,
            encryption_key_bytes: self.encryption_key_bytes.to_proto()?,
            encryption_key_sha256_bytes: self.encryption_key_sha256_bytes.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::CommonObjectRequestParams> for CommonObjectRequestParams {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::CommonObjectRequestParams, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::CommonObjectRequestParams::new()
                .set_encryption_algorithm(self.encryption_algorithm)
                .set_encryption_key_bytes(self.encryption_key_bytes)
                .set_encryption_key_sha256_bytes(self.encryption_key_sha256_bytes)
        )
    }
}

impl gaxi::prost::ToProto<bucket::Billing> for crate::generated::gapic::model::bucket::Billing {
    type Output = bucket::Billing;
    fn to_proto(self) -> std::result::Result<bucket::Billing, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            requester_pays: self.requester_pays.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Billing> for bucket::Billing {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::Billing, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::Billing::new()
                .set_requester_pays(self.requester_pays)
        )
    }
}

impl gaxi::prost::ToProto<bucket::Cors> for crate::generated::gapic::model::bucket::Cors {
    type Output = bucket::Cors;
    fn to_proto(self) -> std::result::Result<bucket::Cors, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            origin: self.origin
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            method: self.method
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            response_header: self.response_header
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            max_age_seconds: self.max_age_seconds.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Cors> for bucket::Cors {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::Cors, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::Cors::new()
                .set_origin(self.origin.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_method(self.method.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_response_header(self.response_header.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_max_age_seconds(self.max_age_seconds)
        )
    }
}

impl gaxi::prost::ToProto<bucket::encryption::GoogleManagedEncryptionEnforcementConfig> for crate::generated::gapic::model::bucket::encryption::GoogleManagedEncryptionEnforcementConfig {
    type Output = bucket::encryption::GoogleManagedEncryptionEnforcementConfig;
    fn to_proto(self) -> std::result::Result<bucket::encryption::GoogleManagedEncryptionEnforcementConfig, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            restriction_mode: self.restriction_mode.map(|v| v.to_proto()).transpose()?,
            effective_time: self.effective_time.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::encryption::GoogleManagedEncryptionEnforcementConfig> for bucket::encryption::GoogleManagedEncryptionEnforcementConfig {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::encryption::GoogleManagedEncryptionEnforcementConfig, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::encryption::GoogleManagedEncryptionEnforcementConfig::new()
                .set_or_clear_restriction_mode(self.restriction_mode.map(|v| v.cnv()).transpose()?)
                .set_or_clear_effective_time(self.effective_time.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::encryption::CustomerManagedEncryptionEnforcementConfig> for crate::generated::gapic::model::bucket::encryption::CustomerManagedEncryptionEnforcementConfig {
    type Output = bucket::encryption::CustomerManagedEncryptionEnforcementConfig;
    fn to_proto(self) -> std::result::Result<bucket::encryption::CustomerManagedEncryptionEnforcementConfig, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            restriction_mode: self.restriction_mode.map(|v| v.to_proto()).transpose()?,
            effective_time: self.effective_time.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::encryption::CustomerManagedEncryptionEnforcementConfig> for bucket::encryption::CustomerManagedEncryptionEnforcementConfig {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::encryption::CustomerManagedEncryptionEnforcementConfig, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::encryption::CustomerManagedEncryptionEnforcementConfig::new()
                .set_or_clear_restriction_mode(self.restriction_mode.map(|v| v.cnv()).transpose()?)
                .set_or_clear_effective_time(self.effective_time.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig> for crate::generated::gapic::model::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig {
    type Output = bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig;
    fn to_proto(self) -> std::result::Result<bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            restriction_mode: self.restriction_mode.map(|v| v.to_proto()).transpose()?,
            effective_time: self.effective_time.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig> for bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::encryption::CustomerSuppliedEncryptionEnforcementConfig::new()
                .set_or_clear_restriction_mode(self.restriction_mode.map(|v| v.cnv()).transpose()?)
                .set_or_clear_effective_time(self.effective_time.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::Encryption> for crate::generated::gapic::model::bucket::Encryption {
    type Output = bucket::Encryption;
    fn to_proto(self) -> std::result::Result<bucket::Encryption, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            default_kms_key: self.default_kms_key.to_proto()?,
            google_managed_encryption_enforcement_config: self.google_managed_encryption_enforcement_config.map(|v| v.to_proto()).transpose()?,
            customer_managed_encryption_enforcement_config: self.customer_managed_encryption_enforcement_config.map(|v| v.to_proto()).transpose()?,
            customer_supplied_encryption_enforcement_config: self.customer_supplied_encryption_enforcement_config.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Encryption> for bucket::Encryption {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::Encryption, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::Encryption::new()
                .set_default_kms_key(self.default_kms_key)
                .set_or_clear_google_managed_encryption_enforcement_config(self.google_managed_encryption_enforcement_config.map(|v| v.cnv()).transpose()?)
                .set_or_clear_customer_managed_encryption_enforcement_config(self.customer_managed_encryption_enforcement_config.map(|v| v.cnv()).transpose()?)
                .set_or_clear_customer_supplied_encryption_enforcement_config(self.customer_supplied_encryption_enforcement_config.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::iam_config::UniformBucketLevelAccess> for crate::generated::gapic::model::bucket::iam_config::UniformBucketLevelAccess {
    type Output = bucket::iam_config::UniformBucketLevelAccess;
    fn to_proto(self) -> std::result::Result<bucket::iam_config::UniformBucketLevelAccess, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            enabled: self.enabled.to_proto()?,
            lock_time: self.lock_time.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::iam_config::UniformBucketLevelAccess> for bucket::iam_config::UniformBucketLevelAccess {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::iam_config::UniformBucketLevelAccess, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::iam_config::UniformBucketLevelAccess::new()
                .set_enabled(self.enabled)
                .set_or_clear_lock_time(self.lock_time.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::IamConfig> for crate::generated::gapic::model::bucket::IamConfig {
    type Output = bucket::IamConfig;
    fn to_proto(self) -> std::result::Result<bucket::IamConfig, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            uniform_bucket_level_access: self.uniform_bucket_level_access.map(|v| v.to_proto()).transpose()?,
            public_access_prevention: self.public_access_prevention.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::IamConfig> for bucket::IamConfig {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::IamConfig, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::IamConfig::new()
                .set_or_clear_uniform_bucket_level_access(self.uniform_bucket_level_access.map(|v| v.cnv()).transpose()?)
                .set_public_access_prevention(self.public_access_prevention)
        )
    }
}

impl gaxi::prost::ToProto<bucket::lifecycle::rule::Action> for crate::generated::gapic::model::bucket::lifecycle::rule::Action {
    type Output = bucket::lifecycle::rule::Action;
    fn to_proto(self) -> std::result::Result<bucket::lifecycle::rule::Action, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            r#type: self.r#type.to_proto()?,
            storage_class: self.storage_class.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::lifecycle::rule::Action> for bucket::lifecycle::rule::Action {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::lifecycle::rule::Action, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::lifecycle::rule::Action::new()
                .set_type(self.r#type)
                .set_storage_class(self.storage_class)
        )
    }
}

impl gaxi::prost::ToProto<bucket::lifecycle::rule::Condition> for crate::generated::gapic::model::bucket::lifecycle::rule::Condition {
    type Output = bucket::lifecycle::rule::Condition;
    fn to_proto(self) -> std::result::Result<bucket::lifecycle::rule::Condition, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            age_days: self.age_days.map(|v| v.to_proto()).transpose()?,
            created_before: self.created_before.map(|v| v.to_proto()).transpose()?,
            is_live: self.is_live.map(|v| v.to_proto()).transpose()?,
            num_newer_versions: self.num_newer_versions.map(|v| v.to_proto()).transpose()?,
            matches_storage_class: self.matches_storage_class
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            days_since_custom_time: self.days_since_custom_time.map(|v| v.to_proto()).transpose()?,
            custom_time_before: self.custom_time_before.map(|v| v.to_proto()).transpose()?,
            days_since_noncurrent_time: self.days_since_noncurrent_time.map(|v| v.to_proto()).transpose()?,
            noncurrent_time_before: self.noncurrent_time_before.map(|v| v.to_proto()).transpose()?,
            matches_prefix: self.matches_prefix
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            matches_suffix: self.matches_suffix
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::lifecycle::rule::Condition> for bucket::lifecycle::rule::Condition {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::lifecycle::rule::Condition, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::lifecycle::rule::Condition::new()
                .set_or_clear_age_days(self.age_days.map(|v| v.cnv()).transpose()?)
                .set_or_clear_created_before(self.created_before.map(|v| v.cnv()).transpose()?)
                .set_or_clear_is_live(self.is_live.map(|v| v.cnv()).transpose()?)
                .set_or_clear_num_newer_versions(self.num_newer_versions.map(|v| v.cnv()).transpose()?)
                .set_matches_storage_class(self.matches_storage_class.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_or_clear_days_since_custom_time(self.days_since_custom_time.map(|v| v.cnv()).transpose()?)
                .set_or_clear_custom_time_before(self.custom_time_before.map(|v| v.cnv()).transpose()?)
                .set_or_clear_days_since_noncurrent_time(self.days_since_noncurrent_time.map(|v| v.cnv()).transpose()?)
                .set_or_clear_noncurrent_time_before(self.noncurrent_time_before.map(|v| v.cnv()).transpose()?)
                .set_matches_prefix(self.matches_prefix.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_matches_suffix(self.matches_suffix.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::lifecycle::Rule> for crate::generated::gapic::model::bucket::lifecycle::Rule {
    type Output = bucket::lifecycle::Rule;
    fn to_proto(self) -> std::result::Result<bucket::lifecycle::Rule, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            action: self.action.map(|v| v.to_proto()).transpose()?,
            condition: self.condition.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::lifecycle::Rule> for bucket::lifecycle::Rule {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::lifecycle::Rule, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::lifecycle::Rule::new()
                .set_or_clear_action(self.action.map(|v| v.cnv()).transpose()?)
                .set_or_clear_condition(self.condition.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::Lifecycle> for crate::generated::gapic::model::bucket::Lifecycle {
    type Output = bucket::Lifecycle;
    fn to_proto(self) -> std::result::Result<bucket::Lifecycle, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            rule: self.rule
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Lifecycle> for bucket::Lifecycle {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::Lifecycle, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::Lifecycle::new()
                .set_rule(self.rule.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::Logging> for crate::generated::gapic::model::bucket::Logging {
    type Output = bucket::Logging;
    fn to_proto(self) -> std::result::Result<bucket::Logging, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            log_bucket: self.log_bucket.to_proto()?,
            log_object_prefix: self.log_object_prefix.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Logging> for bucket::Logging {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::Logging, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::Logging::new()
                .set_log_bucket(self.log_bucket)
                .set_log_object_prefix(self.log_object_prefix)
        )
    }
}

impl gaxi::prost::ToProto<bucket::ObjectRetention> for crate::generated::gapic::model::bucket::ObjectRetention {
    type Output = bucket::ObjectRetention;
    fn to_proto(self) -> std::result::Result<bucket::ObjectRetention, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            enabled: self.enabled.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::ObjectRetention> for bucket::ObjectRetention {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::ObjectRetention, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::ObjectRetention::new()
                .set_enabled(self.enabled)
        )
    }
}

impl gaxi::prost::ToProto<bucket::RetentionPolicy> for crate::generated::gapic::model::bucket::RetentionPolicy {
    type Output = bucket::RetentionPolicy;
    fn to_proto(self) -> std::result::Result<bucket::RetentionPolicy, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            effective_time: self.effective_time.map(|v| v.to_proto()).transpose()?,
            is_locked: self.is_locked.to_proto()?,
            retention_duration: self.retention_duration.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::RetentionPolicy> for bucket::RetentionPolicy {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::RetentionPolicy, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::RetentionPolicy::new()
                .set_or_clear_effective_time(self.effective_time.map(|v| v.cnv()).transpose()?)
                .set_is_locked(self.is_locked)
                .set_or_clear_retention_duration(self.retention_duration.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::SoftDeletePolicy> for crate::generated::gapic::model::bucket::SoftDeletePolicy {
    type Output = bucket::SoftDeletePolicy;
    fn to_proto(self) -> std::result::Result<bucket::SoftDeletePolicy, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            retention_duration: self.retention_duration.map(|v| v.to_proto()).transpose()?,
            effective_time: self.effective_time.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::SoftDeletePolicy> for bucket::SoftDeletePolicy {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::SoftDeletePolicy, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::SoftDeletePolicy::new()
                .set_or_clear_retention_duration(self.retention_duration.map(|v| v.cnv()).transpose()?)
                .set_or_clear_effective_time(self.effective_time.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::Versioning> for crate::generated::gapic::model::bucket::Versioning {
    type Output = bucket::Versioning;
    fn to_proto(self) -> std::result::Result<bucket::Versioning, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            enabled: self.enabled.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Versioning> for bucket::Versioning {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::Versioning, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::Versioning::new()
                .set_enabled(self.enabled)
        )
    }
}

impl gaxi::prost::ToProto<bucket::Website> for crate::generated::gapic::model::bucket::Website {
    type Output = bucket::Website;
    fn to_proto(self) -> std::result::Result<bucket::Website, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            main_page_suffix: self.main_page_suffix.to_proto()?,
            not_found_page: self.not_found_page.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Website> for bucket::Website {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::Website, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::Website::new()
                .set_main_page_suffix(self.main_page_suffix)
                .set_not_found_page(self.not_found_page)
        )
    }
}

impl gaxi::prost::ToProto<bucket::CustomPlacementConfig> for crate::generated::gapic::model::bucket::CustomPlacementConfig {
    type Output = bucket::CustomPlacementConfig;
    fn to_proto(self) -> std::result::Result<bucket::CustomPlacementConfig, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            data_locations: self.data_locations
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::CustomPlacementConfig> for bucket::CustomPlacementConfig {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::CustomPlacementConfig, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::CustomPlacementConfig::new()
                .set_data_locations(self.data_locations.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::Autoclass> for crate::generated::gapic::model::bucket::Autoclass {
    type Output = bucket::Autoclass;
    fn to_proto(self) -> std::result::Result<bucket::Autoclass, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            enabled: self.enabled.to_proto()?,
            toggle_time: self.toggle_time.map(|v| v.to_proto()).transpose()?,
            terminal_storage_class: self.terminal_storage_class.map(|v| v.to_proto()).transpose()?,
            terminal_storage_class_update_time: self.terminal_storage_class_update_time.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Autoclass> for bucket::Autoclass {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::Autoclass, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::Autoclass::new()
                .set_enabled(self.enabled)
                .set_or_clear_toggle_time(self.toggle_time.map(|v| v.cnv()).transpose()?)
                .set_or_clear_terminal_storage_class(self.terminal_storage_class.map(|v| v.cnv()).transpose()?)
                .set_or_clear_terminal_storage_class_update_time(self.terminal_storage_class_update_time.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::ip_filter::PublicNetworkSource> for crate::generated::gapic::model::bucket::ip_filter::PublicNetworkSource {
    type Output = bucket::ip_filter::PublicNetworkSource;
    fn to_proto(self) -> std::result::Result<bucket::ip_filter::PublicNetworkSource, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            allowed_ip_cidr_ranges: self.allowed_ip_cidr_ranges
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::ip_filter::PublicNetworkSource> for bucket::ip_filter::PublicNetworkSource {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::ip_filter::PublicNetworkSource, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::ip_filter::PublicNetworkSource::new()
                .set_allowed_ip_cidr_ranges(self.allowed_ip_cidr_ranges.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::ip_filter::VpcNetworkSource> for crate::generated::gapic::model::bucket::ip_filter::VpcNetworkSource {
    type Output = bucket::ip_filter::VpcNetworkSource;
    fn to_proto(self) -> std::result::Result<bucket::ip_filter::VpcNetworkSource, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            network: self.network.map(|v| v.to_proto()).transpose()?,
            allowed_ip_cidr_ranges: self.allowed_ip_cidr_ranges
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::ip_filter::VpcNetworkSource> for bucket::ip_filter::VpcNetworkSource {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::ip_filter::VpcNetworkSource, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::ip_filter::VpcNetworkSource::new()
                .set_or_clear_network(self.network.map(|v| v.cnv()).transpose()?)
                .set_allowed_ip_cidr_ranges(self.allowed_ip_cidr_ranges.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::IpFilter> for crate::generated::gapic::model::bucket::IpFilter {
    type Output = bucket::IpFilter;
    fn to_proto(self) -> std::result::Result<bucket::IpFilter, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            mode: self.mode.map(|v| v.to_proto()).transpose()?,
            public_network_source: self.public_network_source.map(|v| v.to_proto()).transpose()?,
            vpc_network_sources: self.vpc_network_sources
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            allow_cross_org_vpcs: self.allow_cross_org_vpcs.to_proto()?,
            allow_all_service_agent_access: self.allow_all_service_agent_access.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::IpFilter> for bucket::IpFilter {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::IpFilter, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::IpFilter::new()
                .set_or_clear_mode(self.mode.map(|v| v.cnv()).transpose()?)
                .set_or_clear_public_network_source(self.public_network_source.map(|v| v.cnv()).transpose()?)
                .set_vpc_network_sources(self.vpc_network_sources.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_allow_cross_org_vpcs(self.allow_cross_org_vpcs)
                .set_or_clear_allow_all_service_agent_access(self.allow_all_service_agent_access.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<bucket::HierarchicalNamespace> for crate::generated::gapic::model::bucket::HierarchicalNamespace {
    type Output = bucket::HierarchicalNamespace;
    fn to_proto(self) -> std::result::Result<bucket::HierarchicalNamespace, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            enabled: self.enabled.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::HierarchicalNamespace> for bucket::HierarchicalNamespace {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::bucket::HierarchicalNamespace, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::bucket::HierarchicalNamespace::new()
                .set_enabled(self.enabled)
        )
    }
}

impl gaxi::prost::ToProto<Bucket> for crate::generated::gapic::model::Bucket {
    type Output = Bucket;
    fn to_proto(self) -> std::result::Result<Bucket, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            name: self.name.to_proto()?,
            bucket_id: self.bucket_id.to_proto()?,
            etag: self.etag.to_proto()?,
            project: self.project.to_proto()?,
            metageneration: self.metageneration.to_proto()?,
            location: self.location.to_proto()?,
            location_type: self.location_type.to_proto()?,
            storage_class: self.storage_class.to_proto()?,
            rpo: self.rpo.to_proto()?,
            acl: self.acl
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            default_object_acl: self.default_object_acl
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            lifecycle: self.lifecycle.map(|v| v.to_proto()).transpose()?,
            create_time: self.create_time.map(|v| v.to_proto()).transpose()?,
            cors: self.cors
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            update_time: self.update_time.map(|v| v.to_proto()).transpose()?,
            default_event_based_hold: self.default_event_based_hold.to_proto()?,
            labels: self.labels
                .into_iter()
                .map(|(k, v)| {
                    gaxi::prost::pair_transpose(k.to_proto(), v.to_proto())
                }).collect::<std::result::Result<std::collections::HashMap<_, _>, _>>()?,
            website: self.website.map(|v| v.to_proto()).transpose()?,
            versioning: self.versioning.map(|v| v.to_proto()).transpose()?,
            logging: self.logging.map(|v| v.to_proto()).transpose()?,
            owner: self.owner.map(|v| v.to_proto()).transpose()?,
            encryption: self.encryption.map(|v| v.to_proto()).transpose()?,
            billing: self.billing.map(|v| v.to_proto()).transpose()?,
            retention_policy: self.retention_policy.map(|v| v.to_proto()).transpose()?,
            iam_config: self.iam_config.map(|v| v.to_proto()).transpose()?,
            satisfies_pzs: self.satisfies_pzs.to_proto()?,
            custom_placement_config: self.custom_placement_config.map(|v| v.to_proto()).transpose()?,
            autoclass: self.autoclass.map(|v| v.to_proto()).transpose()?,
            hierarchical_namespace: self.hierarchical_namespace.map(|v| v.to_proto()).transpose()?,
            soft_delete_policy: self.soft_delete_policy.map(|v| v.to_proto()).transpose()?,
            object_retention: self.object_retention.map(|v| v.to_proto()).transpose()?,
            ip_filter: self.ip_filter.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::Bucket> for Bucket {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::Bucket, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::Bucket::new()
                .set_name(self.name)
                .set_bucket_id(self.bucket_id)
                .set_etag(self.etag)
                .set_project(self.project)
                .set_metageneration(self.metageneration)
                .set_location(self.location)
                .set_location_type(self.location_type)
                .set_storage_class(self.storage_class)
                .set_rpo(self.rpo)
                .set_acl(self.acl.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_default_object_acl(self.default_object_acl.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_or_clear_lifecycle(self.lifecycle.map(|v| v.cnv()).transpose()?)
                .set_or_clear_create_time(self.create_time.map(|v| v.cnv()).transpose()?)
                .set_cors(self.cors.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_or_clear_update_time(self.update_time.map(|v| v.cnv()).transpose()?)
                .set_default_event_based_hold(self.default_event_based_hold)
                .set_labels(self.labels.into_iter()
                    .map(|(k, v)| {
                        gaxi::prost::pair_transpose(k.cnv(), v.cnv())
                    }).collect::<std::result::Result<std::collections::HashMap<_, _>, _>>()?)
                .set_or_clear_website(self.website.map(|v| v.cnv()).transpose()?)
                .set_or_clear_versioning(self.versioning.map(|v| v.cnv()).transpose()?)
                .set_or_clear_logging(self.logging.map(|v| v.cnv()).transpose()?)
                .set_or_clear_owner(self.owner.map(|v| v.cnv()).transpose()?)
                .set_or_clear_encryption(self.encryption.map(|v| v.cnv()).transpose()?)
                .set_or_clear_billing(self.billing.map(|v| v.cnv()).transpose()?)
                .set_or_clear_retention_policy(self.retention_policy.map(|v| v.cnv()).transpose()?)
                .set_or_clear_iam_config(self.iam_config.map(|v| v.cnv()).transpose()?)
                .set_satisfies_pzs(self.satisfies_pzs)
                .set_or_clear_custom_placement_config(self.custom_placement_config.map(|v| v.cnv()).transpose()?)
                .set_or_clear_autoclass(self.autoclass.map(|v| v.cnv()).transpose()?)
                .set_or_clear_hierarchical_namespace(self.hierarchical_namespace.map(|v| v.cnv()).transpose()?)
                .set_or_clear_soft_delete_policy(self.soft_delete_policy.map(|v| v.cnv()).transpose()?)
                .set_or_clear_object_retention(self.object_retention.map(|v| v.cnv()).transpose()?)
                .set_or_clear_ip_filter(self.ip_filter.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<BucketAccessControl> for crate::generated::gapic::model::BucketAccessControl {
    type Output = BucketAccessControl;
    fn to_proto(self) -> std::result::Result<BucketAccessControl, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            role: self.role.to_proto()?,
            id: self.id.to_proto()?,
            entity: self.entity.to_proto()?,
            entity_alt: self.entity_alt.to_proto()?,
            entity_id: self.entity_id.to_proto()?,
            etag: self.etag.to_proto()?,
            email: self.email.to_proto()?,
            domain: self.domain.to_proto()?,
            project_team: self.project_team.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::BucketAccessControl> for BucketAccessControl {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::BucketAccessControl, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::BucketAccessControl::new()
                .set_role(self.role)
                .set_id(self.id)
                .set_entity(self.entity)
                .set_entity_alt(self.entity_alt)
                .set_entity_id(self.entity_id)
                .set_etag(self.etag)
                .set_email(self.email)
                .set_domain(self.domain)
                .set_or_clear_project_team(self.project_team.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<ObjectChecksums> for crate::generated::gapic::model::ObjectChecksums {
    type Output = ObjectChecksums;
    fn to_proto(self) -> std::result::Result<ObjectChecksums, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            crc32c: self.crc32c.map(|v| v.to_proto()).transpose()?,
            md5_hash: self.md5_hash.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ObjectChecksums> for ObjectChecksums {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::ObjectChecksums, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::ObjectChecksums::new()
                .set_or_clear_crc32c(self.crc32c.map(|v| v.cnv()).transpose()?)
                .set_md5_hash(self.md5_hash)
        )
    }
}

impl gaxi::prost::ToProto<ObjectCustomContextPayload> for crate::generated::gapic::model::ObjectCustomContextPayload {
    type Output = ObjectCustomContextPayload;
    fn to_proto(self) -> std::result::Result<ObjectCustomContextPayload, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            value: self.value.to_proto()?,
            create_time: self.create_time.map(|v| v.to_proto()).transpose()?,
            update_time: self.update_time.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ObjectCustomContextPayload> for ObjectCustomContextPayload {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::ObjectCustomContextPayload, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::ObjectCustomContextPayload::new()
                .set_value(self.value)
                .set_or_clear_create_time(self.create_time.map(|v| v.cnv()).transpose()?)
                .set_or_clear_update_time(self.update_time.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<ObjectContexts> for crate::generated::gapic::model::ObjectContexts {
    type Output = ObjectContexts;
    fn to_proto(self) -> std::result::Result<ObjectContexts, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            custom: self.custom
                .into_iter()
                .map(|(k, v)| {
                    gaxi::prost::pair_transpose(k.to_proto(), v.to_proto())
                }).collect::<std::result::Result<std::collections::HashMap<_, _>, _>>()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ObjectContexts> for ObjectContexts {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::ObjectContexts, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::ObjectContexts::new()
                .set_custom(self.custom.into_iter()
                    .map(|(k, v)| {
                        gaxi::prost::pair_transpose(k.cnv(), v.cnv())
                    }).collect::<std::result::Result<std::collections::HashMap<_, _>, _>>()?)
        )
    }
}

impl gaxi::prost::ToProto<CustomerEncryption> for crate::generated::gapic::model::CustomerEncryption {
    type Output = CustomerEncryption;
    fn to_proto(self) -> std::result::Result<CustomerEncryption, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            encryption_algorithm: self.encryption_algorithm.to_proto()?,
            key_sha256_bytes: self.key_sha256_bytes.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::CustomerEncryption> for CustomerEncryption {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::CustomerEncryption, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::CustomerEncryption::new()
                .set_encryption_algorithm(self.encryption_algorithm)
                .set_key_sha256_bytes(self.key_sha256_bytes)
        )
    }
}

impl gaxi::prost::ToProto<object::retention::Mode> for crate::generated::gapic::model::object::retention::Mode {
    type Output = i32;
    fn to_proto(self) -> std::result::Result<Self::Output, gaxi::prost::ConvertError> {
        self.value().ok_or(gaxi::prost::ConvertError::EnumNoIntegerValue("crate::generated::gapic::model::object::retention::Mode"))
    }
}

impl gaxi::prost::ToProto<object::Retention> for crate::generated::gapic::model::object::Retention {
    type Output = object::Retention;
    fn to_proto(self) -> std::result::Result<object::Retention, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            mode: self.mode.to_proto()?,
            retain_until_time: self.retain_until_time.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::object::Retention> for object::Retention {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::object::Retention, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::object::Retention::new()
                .set_mode(self.mode)
                .set_or_clear_retain_until_time(self.retain_until_time.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<Object> for crate::generated::gapic::model::Object {
    type Output = Object;
    fn to_proto(self) -> std::result::Result<Object, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            name: self.name.to_proto()?,
            bucket: self.bucket.to_proto()?,
            etag: self.etag.to_proto()?,
            generation: self.generation.to_proto()?,
            restore_token: self.restore_token.map(|v| v.to_proto()).transpose()?,
            metageneration: self.metageneration.to_proto()?,
            storage_class: self.storage_class.to_proto()?,
            size: self.size.to_proto()?,
            content_encoding: self.content_encoding.to_proto()?,
            content_disposition: self.content_disposition.to_proto()?,
            cache_control: self.cache_control.to_proto()?,
            acl: self.acl
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            content_language: self.content_language.to_proto()?,
            delete_time: self.delete_time.map(|v| v.to_proto()).transpose()?,
            finalize_time: self.finalize_time.map(|v| v.to_proto()).transpose()?,
            content_type: self.content_type.to_proto()?,
            create_time: self.create_time.map(|v| v.to_proto()).transpose()?,
            component_count: self.component_count.to_proto()?,
            checksums: self.checksums.map(|v| v.to_proto()).transpose()?,
            update_time: self.update_time.map(|v| v.to_proto()).transpose()?,
            kms_key: self.kms_key.to_proto()?,
            update_storage_class_time: self.update_storage_class_time.map(|v| v.to_proto()).transpose()?,
            temporary_hold: self.temporary_hold.to_proto()?,
            retention_expire_time: self.retention_expire_time.map(|v| v.to_proto()).transpose()?,
            metadata: self.metadata
                .into_iter()
                .map(|(k, v)| {
                    gaxi::prost::pair_transpose(k.to_proto(), v.to_proto())
                }).collect::<std::result::Result<std::collections::HashMap<_, _>, _>>()?,
            contexts: self.contexts.map(|v| v.to_proto()).transpose()?,
            event_based_hold: self.event_based_hold.map(|v| v.to_proto()).transpose()?,
            owner: self.owner.map(|v| v.to_proto()).transpose()?,
            customer_encryption: self.customer_encryption.map(|v| v.to_proto()).transpose()?,
            custom_time: self.custom_time.map(|v| v.to_proto()).transpose()?,
            soft_delete_time: self.soft_delete_time.map(|v| v.to_proto()).transpose()?,
            hard_delete_time: self.hard_delete_time.map(|v| v.to_proto()).transpose()?,
            retention: self.retention.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::Object> for Object {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::Object, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::Object::new()
                .set_name(self.name)
                .set_bucket(self.bucket)
                .set_etag(self.etag)
                .set_generation(self.generation)
                .set_or_clear_restore_token(self.restore_token.map(|v| v.cnv()).transpose()?)
                .set_metageneration(self.metageneration)
                .set_storage_class(self.storage_class)
                .set_size(self.size)
                .set_content_encoding(self.content_encoding)
                .set_content_disposition(self.content_disposition)
                .set_cache_control(self.cache_control)
                .set_acl(self.acl.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_content_language(self.content_language)
                .set_or_clear_delete_time(self.delete_time.map(|v| v.cnv()).transpose()?)
                .set_or_clear_finalize_time(self.finalize_time.map(|v| v.cnv()).transpose()?)
                .set_content_type(self.content_type)
                .set_or_clear_create_time(self.create_time.map(|v| v.cnv()).transpose()?)
                .set_component_count(self.component_count)
                .set_or_clear_checksums(self.checksums.map(|v| v.cnv()).transpose()?)
                .set_or_clear_update_time(self.update_time.map(|v| v.cnv()).transpose()?)
                .set_kms_key(self.kms_key)
                .set_or_clear_update_storage_class_time(self.update_storage_class_time.map(|v| v.cnv()).transpose()?)
                .set_temporary_hold(self.temporary_hold)
                .set_or_clear_retention_expire_time(self.retention_expire_time.map(|v| v.cnv()).transpose()?)
                .set_metadata(self.metadata.into_iter()
                    .map(|(k, v)| {
                        gaxi::prost::pair_transpose(k.cnv(), v.cnv())
                    }).collect::<std::result::Result<std::collections::HashMap<_, _>, _>>()?)
                .set_or_clear_contexts(self.contexts.map(|v| v.cnv()).transpose()?)
                .set_or_clear_event_based_hold(self.event_based_hold.map(|v| v.cnv()).transpose()?)
                .set_or_clear_owner(self.owner.map(|v| v.cnv()).transpose()?)
                .set_or_clear_customer_encryption(self.customer_encryption.map(|v| v.cnv()).transpose()?)
                .set_or_clear_custom_time(self.custom_time.map(|v| v.cnv()).transpose()?)
                .set_or_clear_soft_delete_time(self.soft_delete_time.map(|v| v.cnv()).transpose()?)
                .set_or_clear_hard_delete_time(self.hard_delete_time.map(|v| v.cnv()).transpose()?)
                .set_or_clear_retention(self.retention.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<ObjectAccessControl> for crate::generated::gapic::model::ObjectAccessControl {
    type Output = ObjectAccessControl;
    fn to_proto(self) -> std::result::Result<ObjectAccessControl, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            role: self.role.to_proto()?,
            id: self.id.to_proto()?,
            entity: self.entity.to_proto()?,
            entity_alt: self.entity_alt.to_proto()?,
            entity_id: self.entity_id.to_proto()?,
            etag: self.etag.to_proto()?,
            email: self.email.to_proto()?,
            domain: self.domain.to_proto()?,
            project_team: self.project_team.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ObjectAccessControl> for ObjectAccessControl {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::ObjectAccessControl, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::ObjectAccessControl::new()
                .set_role(self.role)
                .set_id(self.id)
                .set_entity(self.entity)
                .set_entity_alt(self.entity_alt)
                .set_entity_id(self.entity_id)
                .set_etag(self.etag)
                .set_email(self.email)
                .set_domain(self.domain)
                .set_or_clear_project_team(self.project_team.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<ListObjectsResponse> for crate::generated::gapic::model::ListObjectsResponse {
    type Output = ListObjectsResponse;
    fn to_proto(self) -> std::result::Result<ListObjectsResponse, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            objects: self.objects
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            prefixes: self.prefixes
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            next_page_token: self.next_page_token.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ListObjectsResponse> for ListObjectsResponse {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::ListObjectsResponse, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::ListObjectsResponse::new()
                .set_objects(self.objects.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_prefixes(self.prefixes.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_next_page_token(self.next_page_token)
        )
    }
}

impl gaxi::prost::ToProto<ProjectTeam> for crate::generated::gapic::model::ProjectTeam {
    type Output = ProjectTeam;
    fn to_proto(self) -> std::result::Result<ProjectTeam, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            project_number: self.project_number.to_proto()?,
            team: self.team.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ProjectTeam> for ProjectTeam {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::ProjectTeam, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::ProjectTeam::new()
                .set_project_number(self.project_number)
                .set_team(self.team)
        )
    }
}

impl gaxi::prost::ToProto<Owner> for crate::generated::gapic::model::Owner {
    type Output = Owner;
    fn to_proto(self) -> std::result::Result<Owner, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            entity: self.entity.to_proto()?,
            entity_id: self.entity_id.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::Owner> for Owner {
    fn cnv(self) -> std::result::Result<crate::generated::gapic::model::Owner, gaxi::prost::ConvertError> {
        Ok(
            crate::generated::gapic::model::Owner::new()
                .set_entity(self.entity)
                .set_entity_id(self.entity_id)
        )
    }
}
