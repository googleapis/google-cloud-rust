// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBucketRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, optional, tag = "2")]
    pub if_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub if_metageneration_not_match: ::core::option::Option<i64>,
}
impl ::prost::Name for DeleteBucketRequest {
    const NAME: &'static str = "DeleteBucketRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.DeleteBucketRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.DeleteBucketRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBucketRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, optional, tag = "2")]
    pub if_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub if_metageneration_not_match: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for GetBucketRequest {
    const NAME: &'static str = "GetBucketRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.GetBucketRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.GetBucketRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBucketRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub bucket: ::core::option::Option<Bucket>,
    #[prost(string, tag = "3")]
    pub bucket_id: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub predefined_acl: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub predefined_default_object_acl: ::prost::alloc::string::String,
    #[prost(bool, tag = "9")]
    pub enable_object_retention: bool,
}
impl ::prost::Name for CreateBucketRequest {
    const NAME: &'static str = "CreateBucketRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.CreateBucketRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.CreateBucketRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBucketsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub prefix: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListBucketsRequest {
    const NAME: &'static str = "ListBucketsRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ListBucketsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ListBucketsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBucketsResponse {
    #[prost(message, repeated, tag = "1")]
    pub buckets: ::prost::alloc::vec::Vec<Bucket>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListBucketsResponse {
    const NAME: &'static str = "ListBucketsResponse";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ListBucketsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ListBucketsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LockBucketRetentionPolicyRequest {
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub if_metageneration_match: i64,
}
impl ::prost::Name for LockBucketRetentionPolicyRequest {
    const NAME: &'static str = "LockBucketRetentionPolicyRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.LockBucketRetentionPolicyRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.LockBucketRetentionPolicyRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBucketRequest {
    #[prost(message, optional, tag = "1")]
    pub bucket: ::core::option::Option<Bucket>,
    #[prost(int64, optional, tag = "2")]
    pub if_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub if_metageneration_not_match: ::core::option::Option<i64>,
    #[prost(string, tag = "8")]
    pub predefined_acl: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub predefined_default_object_acl: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateBucketRequest {
    const NAME: &'static str = "UpdateBucketRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.UpdateBucketRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.UpdateBucketRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComposeObjectRequest {
    #[prost(message, optional, tag = "1")]
    pub destination: ::core::option::Option<Object>,
    #[prost(message, repeated, tag = "2")]
    pub source_objects: ::prost::alloc::vec::Vec<compose_object_request::SourceObject>,
    #[prost(string, tag = "9")]
    pub destination_predefined_acl: ::prost::alloc::string::String,
    #[prost(int64, optional, tag = "4")]
    pub if_generation_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub if_metageneration_match: ::core::option::Option<i64>,
    #[prost(string, tag = "6")]
    pub kms_key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub common_object_request_params: ::core::option::Option<CommonObjectRequestParams>,
    #[prost(message, optional, tag = "10")]
    pub object_checksums: ::core::option::Option<ObjectChecksums>,
}
/// Nested message and enum types in `ComposeObjectRequest`.
pub mod compose_object_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SourceObject {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub generation: i64,
        #[prost(message, optional, tag = "3")]
        pub object_preconditions: ::core::option::Option<
            source_object::ObjectPreconditions,
        >,
    }
    /// Nested message and enum types in `SourceObject`.
    pub mod source_object {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ObjectPreconditions {
            #[prost(int64, optional, tag = "1")]
            pub if_generation_match: ::core::option::Option<i64>,
        }
        impl ::prost::Name for ObjectPreconditions {
            const NAME: &'static str = "ObjectPreconditions";
            const PACKAGE: &'static str = "google.storage.v2";
            fn full_name() -> ::prost::alloc::string::String {
                "google.storage.v2.ComposeObjectRequest.SourceObject.ObjectPreconditions"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.storage.v2.ComposeObjectRequest.SourceObject.ObjectPreconditions"
                    .into()
            }
        }
    }
    impl ::prost::Name for SourceObject {
        const NAME: &'static str = "SourceObject";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.ComposeObjectRequest.SourceObject".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.ComposeObjectRequest.SourceObject"
                .into()
        }
    }
}
impl ::prost::Name for ComposeObjectRequest {
    const NAME: &'static str = "ComposeObjectRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ComposeObjectRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ComposeObjectRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteObjectRequest {
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub object: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub generation: i64,
    #[prost(int64, optional, tag = "5")]
    pub if_generation_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub if_generation_not_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub if_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "8")]
    pub if_metageneration_not_match: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "10")]
    pub common_object_request_params: ::core::option::Option<CommonObjectRequestParams>,
}
impl ::prost::Name for DeleteObjectRequest {
    const NAME: &'static str = "DeleteObjectRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.DeleteObjectRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.DeleteObjectRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreObjectRequest {
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub object: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub generation: i64,
    #[prost(string, tag = "11")]
    pub restore_token: ::prost::alloc::string::String,
    #[prost(int64, optional, tag = "4")]
    pub if_generation_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub if_generation_not_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub if_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub if_metageneration_not_match: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "9")]
    pub copy_source_acl: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "8")]
    pub common_object_request_params: ::core::option::Option<CommonObjectRequestParams>,
}
impl ::prost::Name for RestoreObjectRequest {
    const NAME: &'static str = "RestoreObjectRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.RestoreObjectRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.RestoreObjectRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelResumableWriteRequest {
    #[prost(string, tag = "1")]
    pub upload_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CancelResumableWriteRequest {
    const NAME: &'static str = "CancelResumableWriteRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.CancelResumableWriteRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.CancelResumableWriteRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancelResumableWriteResponse {}
impl ::prost::Name for CancelResumableWriteResponse {
    const NAME: &'static str = "CancelResumableWriteResponse";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.CancelResumableWriteResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.CancelResumableWriteResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadObjectRequest {
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub object: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub generation: i64,
    #[prost(int64, tag = "4")]
    pub read_offset: i64,
    #[prost(int64, tag = "5")]
    pub read_limit: i64,
    #[prost(int64, optional, tag = "6")]
    pub if_generation_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub if_generation_not_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "8")]
    pub if_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "9")]
    pub if_metageneration_not_match: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "10")]
    pub common_object_request_params: ::core::option::Option<CommonObjectRequestParams>,
    #[prost(message, optional, tag = "12")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ReadObjectRequest {
    const NAME: &'static str = "ReadObjectRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ReadObjectRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ReadObjectRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetObjectRequest {
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub object: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub generation: i64,
    #[prost(bool, optional, tag = "11")]
    pub soft_deleted: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "4")]
    pub if_generation_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub if_generation_not_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub if_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub if_metageneration_not_match: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "8")]
    pub common_object_request_params: ::core::option::Option<CommonObjectRequestParams>,
    #[prost(message, optional, tag = "10")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "12")]
    pub restore_token: ::prost::alloc::string::String,
}
impl ::prost::Name for GetObjectRequest {
    const NAME: &'static str = "GetObjectRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.GetObjectRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.GetObjectRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadObjectResponse {
    #[prost(message, optional, tag = "1")]
    pub checksummed_data: ::core::option::Option<ChecksummedData>,
    #[prost(message, optional, tag = "2")]
    pub object_checksums: ::core::option::Option<ObjectChecksums>,
    #[prost(message, optional, tag = "3")]
    pub content_range: ::core::option::Option<ContentRange>,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<Object>,
}
impl ::prost::Name for ReadObjectResponse {
    const NAME: &'static str = "ReadObjectResponse";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ReadObjectResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ReadObjectResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiReadObjectSpec {
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub object: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub generation: i64,
    #[prost(int64, optional, tag = "4")]
    pub if_generation_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub if_generation_not_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub if_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub if_metageneration_not_match: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "8")]
    pub common_object_request_params: ::core::option::Option<CommonObjectRequestParams>,
    #[deprecated]
    #[prost(message, optional, tag = "12")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "13")]
    pub read_handle: ::core::option::Option<BidiReadHandle>,
    #[prost(string, optional, tag = "14")]
    pub routing_token: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for BidiReadObjectSpec {
    const NAME: &'static str = "BidiReadObjectSpec";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.BidiReadObjectSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.BidiReadObjectSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiReadObjectRequest {
    #[prost(message, optional, tag = "1")]
    pub read_object_spec: ::core::option::Option<BidiReadObjectSpec>,
    #[prost(message, repeated, tag = "8")]
    pub read_ranges: ::prost::alloc::vec::Vec<ReadRange>,
}
impl ::prost::Name for BidiReadObjectRequest {
    const NAME: &'static str = "BidiReadObjectRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.BidiReadObjectRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.BidiReadObjectRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiReadObjectResponse {
    #[prost(message, repeated, tag = "6")]
    pub object_data_ranges: ::prost::alloc::vec::Vec<ObjectRangeData>,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<Object>,
    #[prost(message, optional, tag = "7")]
    pub read_handle: ::core::option::Option<BidiReadHandle>,
}
impl ::prost::Name for BidiReadObjectResponse {
    const NAME: &'static str = "BidiReadObjectResponse";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.BidiReadObjectResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.BidiReadObjectResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiReadObjectRedirectedError {
    #[prost(message, optional, tag = "1")]
    pub read_handle: ::core::option::Option<BidiReadHandle>,
    #[prost(string, optional, tag = "2")]
    pub routing_token: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for BidiReadObjectRedirectedError {
    const NAME: &'static str = "BidiReadObjectRedirectedError";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.BidiReadObjectRedirectedError".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.BidiReadObjectRedirectedError".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiWriteObjectRedirectedError {
    #[prost(string, optional, tag = "1")]
    pub routing_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub write_handle: ::core::option::Option<BidiWriteHandle>,
    #[prost(int64, optional, tag = "3")]
    pub generation: ::core::option::Option<i64>,
}
impl ::prost::Name for BidiWriteObjectRedirectedError {
    const NAME: &'static str = "BidiWriteObjectRedirectedError";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.BidiWriteObjectRedirectedError".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.BidiWriteObjectRedirectedError".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiReadObjectError {
    #[prost(message, repeated, tag = "1")]
    pub read_range_errors: ::prost::alloc::vec::Vec<ReadRangeError>,
}
impl ::prost::Name for BidiReadObjectError {
    const NAME: &'static str = "BidiReadObjectError";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.BidiReadObjectError".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.BidiReadObjectError".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadRangeError {
    #[prost(int64, tag = "1")]
    pub read_id: i64,
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<super::super::rpc::Status>,
}
impl ::prost::Name for ReadRangeError {
    const NAME: &'static str = "ReadRangeError";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ReadRangeError".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ReadRangeError".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadRange {
    #[prost(int64, tag = "1")]
    pub read_offset: i64,
    #[prost(int64, tag = "2")]
    pub read_length: i64,
    #[prost(int64, tag = "3")]
    pub read_id: i64,
}
impl ::prost::Name for ReadRange {
    const NAME: &'static str = "ReadRange";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ReadRange".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ReadRange".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectRangeData {
    #[prost(message, optional, tag = "1")]
    pub checksummed_data: ::core::option::Option<ChecksummedData>,
    #[prost(message, optional, tag = "2")]
    pub read_range: ::core::option::Option<ReadRange>,
    #[prost(bool, tag = "3")]
    pub range_end: bool,
}
impl ::prost::Name for ObjectRangeData {
    const NAME: &'static str = "ObjectRangeData";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ObjectRangeData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ObjectRangeData".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiReadHandle {
    #[prost(bytes = "bytes", tag = "1")]
    pub handle: ::prost::bytes::Bytes,
}
impl ::prost::Name for BidiReadHandle {
    const NAME: &'static str = "BidiReadHandle";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.BidiReadHandle".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.BidiReadHandle".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiWriteHandle {
    #[prost(bytes = "bytes", tag = "1")]
    pub handle: ::prost::bytes::Bytes,
}
impl ::prost::Name for BidiWriteHandle {
    const NAME: &'static str = "BidiWriteHandle";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.BidiWriteHandle".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.BidiWriteHandle".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteObjectSpec {
    #[prost(message, optional, tag = "1")]
    pub resource: ::core::option::Option<Object>,
    #[prost(string, tag = "7")]
    pub predefined_acl: ::prost::alloc::string::String,
    #[prost(int64, optional, tag = "3")]
    pub if_generation_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub if_generation_not_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub if_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub if_metageneration_not_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "8")]
    pub object_size: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "9")]
    pub appendable: ::core::option::Option<bool>,
}
impl ::prost::Name for WriteObjectSpec {
    const NAME: &'static str = "WriteObjectSpec";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.WriteObjectSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.WriteObjectSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteObjectRequest {
    #[prost(int64, tag = "3")]
    pub write_offset: i64,
    #[prost(message, optional, tag = "6")]
    pub object_checksums: ::core::option::Option<ObjectChecksums>,
    #[prost(bool, tag = "7")]
    pub finish_write: bool,
    #[prost(message, optional, tag = "8")]
    pub common_object_request_params: ::core::option::Option<CommonObjectRequestParams>,
    #[prost(oneof = "write_object_request::FirstMessage", tags = "1, 2")]
    pub first_message: ::core::option::Option<write_object_request::FirstMessage>,
    #[prost(oneof = "write_object_request::Data", tags = "4")]
    pub data: ::core::option::Option<write_object_request::Data>,
}
/// Nested message and enum types in `WriteObjectRequest`.
pub mod write_object_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum FirstMessage {
        #[prost(string, tag = "1")]
        UploadId(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        WriteObjectSpec(super::WriteObjectSpec),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "4")]
        ChecksummedData(super::ChecksummedData),
    }
}
impl ::prost::Name for WriteObjectRequest {
    const NAME: &'static str = "WriteObjectRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.WriteObjectRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.WriteObjectRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteObjectResponse {
    #[prost(oneof = "write_object_response::WriteStatus", tags = "1, 2")]
    pub write_status: ::core::option::Option<write_object_response::WriteStatus>,
}
/// Nested message and enum types in `WriteObjectResponse`.
pub mod write_object_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum WriteStatus {
        #[prost(int64, tag = "1")]
        PersistedSize(i64),
        #[prost(message, tag = "2")]
        Resource(super::Object),
    }
}
impl ::prost::Name for WriteObjectResponse {
    const NAME: &'static str = "WriteObjectResponse";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.WriteObjectResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.WriteObjectResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendObjectSpec {
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub object: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub generation: i64,
    #[prost(int64, optional, tag = "4")]
    pub if_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub if_metageneration_not_match: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "6")]
    pub routing_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "7")]
    pub write_handle: ::core::option::Option<BidiWriteHandle>,
}
impl ::prost::Name for AppendObjectSpec {
    const NAME: &'static str = "AppendObjectSpec";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.AppendObjectSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.AppendObjectSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiWriteObjectRequest {
    #[prost(int64, tag = "3")]
    pub write_offset: i64,
    #[prost(message, optional, tag = "6")]
    pub object_checksums: ::core::option::Option<ObjectChecksums>,
    #[prost(bool, tag = "7")]
    pub state_lookup: bool,
    #[prost(bool, tag = "8")]
    pub flush: bool,
    #[prost(bool, tag = "9")]
    pub finish_write: bool,
    #[prost(message, optional, tag = "10")]
    pub common_object_request_params: ::core::option::Option<CommonObjectRequestParams>,
    #[prost(oneof = "bidi_write_object_request::FirstMessage", tags = "1, 2, 11")]
    pub first_message: ::core::option::Option<bidi_write_object_request::FirstMessage>,
    #[prost(oneof = "bidi_write_object_request::Data", tags = "4")]
    pub data: ::core::option::Option<bidi_write_object_request::Data>,
}
/// Nested message and enum types in `BidiWriteObjectRequest`.
pub mod bidi_write_object_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum FirstMessage {
        #[prost(string, tag = "1")]
        UploadId(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        WriteObjectSpec(super::WriteObjectSpec),
        #[prost(message, tag = "11")]
        AppendObjectSpec(super::AppendObjectSpec),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "4")]
        ChecksummedData(super::ChecksummedData),
    }
}
impl ::prost::Name for BidiWriteObjectRequest {
    const NAME: &'static str = "BidiWriteObjectRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.BidiWriteObjectRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.BidiWriteObjectRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiWriteObjectResponse {
    #[prost(message, optional, tag = "3")]
    pub write_handle: ::core::option::Option<BidiWriteHandle>,
    #[prost(oneof = "bidi_write_object_response::WriteStatus", tags = "1, 2")]
    pub write_status: ::core::option::Option<bidi_write_object_response::WriteStatus>,
}
/// Nested message and enum types in `BidiWriteObjectResponse`.
pub mod bidi_write_object_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum WriteStatus {
        #[prost(int64, tag = "1")]
        PersistedSize(i64),
        #[prost(message, tag = "2")]
        Resource(super::Object),
    }
}
impl ::prost::Name for BidiWriteObjectResponse {
    const NAME: &'static str = "BidiWriteObjectResponse";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.BidiWriteObjectResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.BidiWriteObjectResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListObjectsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub delimiter: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub include_trailing_delimiter: bool,
    #[prost(string, tag = "6")]
    pub prefix: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub versions: bool,
    #[prost(message, optional, tag = "8")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "10")]
    pub lexicographic_start: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub lexicographic_end: ::prost::alloc::string::String,
    #[prost(bool, tag = "12")]
    pub soft_deleted: bool,
    #[prost(bool, tag = "13")]
    pub include_folders_as_prefixes: bool,
    #[prost(string, tag = "14")]
    pub match_glob: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub filter: ::prost::alloc::string::String,
}
impl ::prost::Name for ListObjectsRequest {
    const NAME: &'static str = "ListObjectsRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ListObjectsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ListObjectsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryWriteStatusRequest {
    #[prost(string, tag = "1")]
    pub upload_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub common_object_request_params: ::core::option::Option<CommonObjectRequestParams>,
}
impl ::prost::Name for QueryWriteStatusRequest {
    const NAME: &'static str = "QueryWriteStatusRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.QueryWriteStatusRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.QueryWriteStatusRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryWriteStatusResponse {
    #[prost(oneof = "query_write_status_response::WriteStatus", tags = "1, 2")]
    pub write_status: ::core::option::Option<query_write_status_response::WriteStatus>,
}
/// Nested message and enum types in `QueryWriteStatusResponse`.
pub mod query_write_status_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum WriteStatus {
        #[prost(int64, tag = "1")]
        PersistedSize(i64),
        #[prost(message, tag = "2")]
        Resource(super::Object),
    }
}
impl ::prost::Name for QueryWriteStatusResponse {
    const NAME: &'static str = "QueryWriteStatusResponse";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.QueryWriteStatusResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.QueryWriteStatusResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RewriteObjectRequest {
    #[prost(string, tag = "24")]
    pub destination_name: ::prost::alloc::string::String,
    #[prost(string, tag = "25")]
    pub destination_bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "27")]
    pub destination_kms_key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1")]
    pub destination: ::core::option::Option<Object>,
    #[prost(string, tag = "2")]
    pub source_bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub source_object: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub source_generation: i64,
    #[prost(string, tag = "5")]
    pub rewrite_token: ::prost::alloc::string::String,
    #[prost(string, tag = "28")]
    pub destination_predefined_acl: ::prost::alloc::string::String,
    #[prost(int64, optional, tag = "7")]
    pub if_generation_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "8")]
    pub if_generation_not_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "9")]
    pub if_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "10")]
    pub if_metageneration_not_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "11")]
    pub if_source_generation_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "12")]
    pub if_source_generation_not_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "13")]
    pub if_source_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "14")]
    pub if_source_metageneration_not_match: ::core::option::Option<i64>,
    #[prost(int64, tag = "15")]
    pub max_bytes_rewritten_per_call: i64,
    #[prost(string, tag = "16")]
    pub copy_source_encryption_algorithm: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "21")]
    pub copy_source_encryption_key_bytes: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "22")]
    pub copy_source_encryption_key_sha256_bytes: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "19")]
    pub common_object_request_params: ::core::option::Option<CommonObjectRequestParams>,
    #[prost(message, optional, tag = "29")]
    pub object_checksums: ::core::option::Option<ObjectChecksums>,
}
impl ::prost::Name for RewriteObjectRequest {
    const NAME: &'static str = "RewriteObjectRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.RewriteObjectRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.RewriteObjectRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RewriteResponse {
    #[prost(int64, tag = "1")]
    pub total_bytes_rewritten: i64,
    #[prost(int64, tag = "2")]
    pub object_size: i64,
    #[prost(bool, tag = "3")]
    pub done: bool,
    #[prost(string, tag = "4")]
    pub rewrite_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub resource: ::core::option::Option<Object>,
}
impl ::prost::Name for RewriteResponse {
    const NAME: &'static str = "RewriteResponse";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.RewriteResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.RewriteResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveObjectRequest {
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub source_object: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub destination_object: ::prost::alloc::string::String,
    #[prost(int64, optional, tag = "4")]
    pub if_source_generation_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub if_source_generation_not_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub if_source_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub if_source_metageneration_not_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "8")]
    pub if_generation_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "9")]
    pub if_generation_not_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "10")]
    pub if_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "11")]
    pub if_metageneration_not_match: ::core::option::Option<i64>,
}
impl ::prost::Name for MoveObjectRequest {
    const NAME: &'static str = "MoveObjectRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.MoveObjectRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.MoveObjectRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartResumableWriteRequest {
    #[prost(message, optional, tag = "1")]
    pub write_object_spec: ::core::option::Option<WriteObjectSpec>,
    #[prost(message, optional, tag = "3")]
    pub common_object_request_params: ::core::option::Option<CommonObjectRequestParams>,
    #[prost(message, optional, tag = "5")]
    pub object_checksums: ::core::option::Option<ObjectChecksums>,
}
impl ::prost::Name for StartResumableWriteRequest {
    const NAME: &'static str = "StartResumableWriteRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.StartResumableWriteRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.StartResumableWriteRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartResumableWriteResponse {
    #[prost(string, tag = "1")]
    pub upload_id: ::prost::alloc::string::String,
}
impl ::prost::Name for StartResumableWriteResponse {
    const NAME: &'static str = "StartResumableWriteResponse";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.StartResumableWriteResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.StartResumableWriteResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateObjectRequest {
    #[prost(message, optional, tag = "1")]
    pub object: ::core::option::Option<Object>,
    #[prost(int64, optional, tag = "2")]
    pub if_generation_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub if_generation_not_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub if_metageneration_match: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub if_metageneration_not_match: ::core::option::Option<i64>,
    #[prost(string, tag = "10")]
    pub predefined_acl: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "8")]
    pub common_object_request_params: ::core::option::Option<CommonObjectRequestParams>,
    #[prost(bool, tag = "11")]
    pub override_unlocked_retention: bool,
}
impl ::prost::Name for UpdateObjectRequest {
    const NAME: &'static str = "UpdateObjectRequest";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.UpdateObjectRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.UpdateObjectRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommonObjectRequestParams {
    #[prost(string, tag = "1")]
    pub encryption_algorithm: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "4")]
    pub encryption_key_bytes: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "5")]
    pub encryption_key_sha256_bytes: ::prost::bytes::Bytes,
}
impl ::prost::Name for CommonObjectRequestParams {
    const NAME: &'static str = "CommonObjectRequestParams";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.CommonObjectRequestParams".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.CommonObjectRequestParams".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServiceConstants {}
/// Nested message and enum types in `ServiceConstants`.
pub mod service_constants {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Values {
        Unspecified = 0,
        MaxReadChunkBytes = 2097152,
        MaxObjectSizeMb = 5242880,
        MaxCustomMetadataFieldNameBytes = 1024,
        MaxCustomMetadataFieldValueBytes = 4096,
        MaxCustomMetadataTotalSizeBytes = 8192,
        MaxBucketMetadataTotalSizeBytes = 20480,
        MaxNotificationConfigsPerBucket = 100,
        MaxNotificationCustomAttributes = 5,
        MaxNotificationCustomAttributeKeyLength = 256,
        MaxLabelsEntriesCount = 64,
        MaxLabelsKeyValueLength = 63,
        MaxLabelsKeyValueBytes = 128,
        MaxObjectIdsPerDeleteObjectsRequest = 1000,
        SplitTokenMaxValidDays = 14,
    }
    impl Values {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VALUES_UNSPECIFIED",
                Self::MaxReadChunkBytes => "MAX_READ_CHUNK_BYTES",
                Self::MaxObjectSizeMb => "MAX_OBJECT_SIZE_MB",
                Self::MaxCustomMetadataFieldNameBytes => {
                    "MAX_CUSTOM_METADATA_FIELD_NAME_BYTES"
                }
                Self::MaxCustomMetadataFieldValueBytes => {
                    "MAX_CUSTOM_METADATA_FIELD_VALUE_BYTES"
                }
                Self::MaxCustomMetadataTotalSizeBytes => {
                    "MAX_CUSTOM_METADATA_TOTAL_SIZE_BYTES"
                }
                Self::MaxBucketMetadataTotalSizeBytes => {
                    "MAX_BUCKET_METADATA_TOTAL_SIZE_BYTES"
                }
                Self::MaxNotificationConfigsPerBucket => {
                    "MAX_NOTIFICATION_CONFIGS_PER_BUCKET"
                }
                Self::MaxNotificationCustomAttributes => {
                    "MAX_NOTIFICATION_CUSTOM_ATTRIBUTES"
                }
                Self::MaxNotificationCustomAttributeKeyLength => {
                    "MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_KEY_LENGTH"
                }
                Self::MaxLabelsEntriesCount => "MAX_LABELS_ENTRIES_COUNT",
                Self::MaxLabelsKeyValueLength => "MAX_LABELS_KEY_VALUE_LENGTH",
                Self::MaxLabelsKeyValueBytes => "MAX_LABELS_KEY_VALUE_BYTES",
                Self::MaxObjectIdsPerDeleteObjectsRequest => {
                    "MAX_OBJECT_IDS_PER_DELETE_OBJECTS_REQUEST"
                }
                Self::SplitTokenMaxValidDays => "SPLIT_TOKEN_MAX_VALID_DAYS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VALUES_UNSPECIFIED" => Some(Self::Unspecified),
                "MAX_READ_CHUNK_BYTES" => Some(Self::MaxReadChunkBytes),
                "MAX_OBJECT_SIZE_MB" => Some(Self::MaxObjectSizeMb),
                "MAX_CUSTOM_METADATA_FIELD_NAME_BYTES" => {
                    Some(Self::MaxCustomMetadataFieldNameBytes)
                }
                "MAX_CUSTOM_METADATA_FIELD_VALUE_BYTES" => {
                    Some(Self::MaxCustomMetadataFieldValueBytes)
                }
                "MAX_CUSTOM_METADATA_TOTAL_SIZE_BYTES" => {
                    Some(Self::MaxCustomMetadataTotalSizeBytes)
                }
                "MAX_BUCKET_METADATA_TOTAL_SIZE_BYTES" => {
                    Some(Self::MaxBucketMetadataTotalSizeBytes)
                }
                "MAX_NOTIFICATION_CONFIGS_PER_BUCKET" => {
                    Some(Self::MaxNotificationConfigsPerBucket)
                }
                "MAX_NOTIFICATION_CUSTOM_ATTRIBUTES" => {
                    Some(Self::MaxNotificationCustomAttributes)
                }
                "MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_KEY_LENGTH" => {
                    Some(Self::MaxNotificationCustomAttributeKeyLength)
                }
                "MAX_LABELS_ENTRIES_COUNT" => Some(Self::MaxLabelsEntriesCount),
                "MAX_LABELS_KEY_VALUE_LENGTH" => Some(Self::MaxLabelsKeyValueLength),
                "MAX_LABELS_KEY_VALUE_BYTES" => Some(Self::MaxLabelsKeyValueBytes),
                "MAX_OBJECT_IDS_PER_DELETE_OBJECTS_REQUEST" => {
                    Some(Self::MaxObjectIdsPerDeleteObjectsRequest)
                }
                "SPLIT_TOKEN_MAX_VALID_DAYS" => Some(Self::SplitTokenMaxValidDays),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for ServiceConstants {
    const NAME: &'static str = "ServiceConstants";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ServiceConstants".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ServiceConstants".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bucket {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub bucket_id: ::prost::alloc::string::String,
    #[prost(string, tag = "29")]
    pub etag: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub metageneration: i64,
    #[prost(string, tag = "5")]
    pub location: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub location_type: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub storage_class: ::prost::alloc::string::String,
    #[prost(string, tag = "27")]
    pub rpo: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "8")]
    pub acl: ::prost::alloc::vec::Vec<BucketAccessControl>,
    #[prost(message, repeated, tag = "9")]
    pub default_object_acl: ::prost::alloc::vec::Vec<ObjectAccessControl>,
    #[prost(message, optional, tag = "10")]
    pub lifecycle: ::core::option::Option<bucket::Lifecycle>,
    #[prost(message, optional, tag = "11")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "12")]
    pub cors: ::prost::alloc::vec::Vec<bucket::Cors>,
    #[prost(message, optional, tag = "13")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "14")]
    pub default_event_based_hold: bool,
    #[prost(map = "string, string", tag = "15")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "16")]
    pub website: ::core::option::Option<bucket::Website>,
    #[prost(message, optional, tag = "17")]
    pub versioning: ::core::option::Option<bucket::Versioning>,
    #[prost(message, optional, tag = "18")]
    pub logging: ::core::option::Option<bucket::Logging>,
    #[prost(message, optional, tag = "19")]
    pub owner: ::core::option::Option<Owner>,
    #[prost(message, optional, tag = "20")]
    pub encryption: ::core::option::Option<bucket::Encryption>,
    #[prost(message, optional, tag = "21")]
    pub billing: ::core::option::Option<bucket::Billing>,
    #[prost(message, optional, tag = "22")]
    pub retention_policy: ::core::option::Option<bucket::RetentionPolicy>,
    #[prost(message, optional, tag = "23")]
    pub iam_config: ::core::option::Option<bucket::IamConfig>,
    #[prost(bool, tag = "25")]
    pub satisfies_pzs: bool,
    #[prost(message, optional, tag = "26")]
    pub custom_placement_config: ::core::option::Option<bucket::CustomPlacementConfig>,
    #[prost(message, optional, tag = "28")]
    pub autoclass: ::core::option::Option<bucket::Autoclass>,
    #[prost(message, optional, tag = "32")]
    pub hierarchical_namespace: ::core::option::Option<bucket::HierarchicalNamespace>,
    #[prost(message, optional, tag = "31")]
    pub soft_delete_policy: ::core::option::Option<bucket::SoftDeletePolicy>,
    #[prost(message, optional, tag = "33")]
    pub object_retention: ::core::option::Option<bucket::ObjectRetention>,
    #[prost(message, optional, tag = "38")]
    pub ip_filter: ::core::option::Option<bucket::IpFilter>,
}
/// Nested message and enum types in `Bucket`.
pub mod bucket {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Billing {
        #[prost(bool, tag = "1")]
        pub requester_pays: bool,
    }
    impl ::prost::Name for Billing {
        const NAME: &'static str = "Billing";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.Billing".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.Billing".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Cors {
        #[prost(string, repeated, tag = "1")]
        pub origin: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "2")]
        pub method: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub response_header: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(int32, tag = "4")]
        pub max_age_seconds: i32,
    }
    impl ::prost::Name for Cors {
        const NAME: &'static str = "Cors";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.Cors".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.Cors".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Encryption {
        #[prost(string, tag = "1")]
        pub default_kms_key: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub google_managed_encryption_enforcement_config: ::core::option::Option<
            encryption::GoogleManagedEncryptionEnforcementConfig,
        >,
        #[prost(message, optional, tag = "3")]
        pub customer_managed_encryption_enforcement_config: ::core::option::Option<
            encryption::CustomerManagedEncryptionEnforcementConfig,
        >,
        #[prost(message, optional, tag = "4")]
        pub customer_supplied_encryption_enforcement_config: ::core::option::Option<
            encryption::CustomerSuppliedEncryptionEnforcementConfig,
        >,
    }
    /// Nested message and enum types in `Encryption`.
    pub mod encryption {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct GoogleManagedEncryptionEnforcementConfig {
            #[prost(string, optional, tag = "3")]
            pub restriction_mode: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(message, optional, tag = "2")]
            pub effective_time: ::core::option::Option<::prost_types::Timestamp>,
        }
        impl ::prost::Name for GoogleManagedEncryptionEnforcementConfig {
            const NAME: &'static str = "GoogleManagedEncryptionEnforcementConfig";
            const PACKAGE: &'static str = "google.storage.v2";
            fn full_name() -> ::prost::alloc::string::String {
                "google.storage.v2.Bucket.Encryption.GoogleManagedEncryptionEnforcementConfig"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.storage.v2.Bucket.Encryption.GoogleManagedEncryptionEnforcementConfig"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CustomerManagedEncryptionEnforcementConfig {
            #[prost(string, optional, tag = "3")]
            pub restriction_mode: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(message, optional, tag = "2")]
            pub effective_time: ::core::option::Option<::prost_types::Timestamp>,
        }
        impl ::prost::Name for CustomerManagedEncryptionEnforcementConfig {
            const NAME: &'static str = "CustomerManagedEncryptionEnforcementConfig";
            const PACKAGE: &'static str = "google.storage.v2";
            fn full_name() -> ::prost::alloc::string::String {
                "google.storage.v2.Bucket.Encryption.CustomerManagedEncryptionEnforcementConfig"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.storage.v2.Bucket.Encryption.CustomerManagedEncryptionEnforcementConfig"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CustomerSuppliedEncryptionEnforcementConfig {
            #[prost(string, optional, tag = "3")]
            pub restriction_mode: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(message, optional, tag = "2")]
            pub effective_time: ::core::option::Option<::prost_types::Timestamp>,
        }
        impl ::prost::Name for CustomerSuppliedEncryptionEnforcementConfig {
            const NAME: &'static str = "CustomerSuppliedEncryptionEnforcementConfig";
            const PACKAGE: &'static str = "google.storage.v2";
            fn full_name() -> ::prost::alloc::string::String {
                "google.storage.v2.Bucket.Encryption.CustomerSuppliedEncryptionEnforcementConfig"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.storage.v2.Bucket.Encryption.CustomerSuppliedEncryptionEnforcementConfig"
                    .into()
            }
        }
    }
    impl ::prost::Name for Encryption {
        const NAME: &'static str = "Encryption";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.Encryption".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.Encryption".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IamConfig {
        #[prost(message, optional, tag = "1")]
        pub uniform_bucket_level_access: ::core::option::Option<
            iam_config::UniformBucketLevelAccess,
        >,
        #[prost(string, tag = "3")]
        pub public_access_prevention: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `IamConfig`.
    pub mod iam_config {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct UniformBucketLevelAccess {
            #[prost(bool, tag = "1")]
            pub enabled: bool,
            #[prost(message, optional, tag = "2")]
            pub lock_time: ::core::option::Option<::prost_types::Timestamp>,
        }
        impl ::prost::Name for UniformBucketLevelAccess {
            const NAME: &'static str = "UniformBucketLevelAccess";
            const PACKAGE: &'static str = "google.storage.v2";
            fn full_name() -> ::prost::alloc::string::String {
                "google.storage.v2.Bucket.IamConfig.UniformBucketLevelAccess".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.storage.v2.Bucket.IamConfig.UniformBucketLevelAccess"
                    .into()
            }
        }
    }
    impl ::prost::Name for IamConfig {
        const NAME: &'static str = "IamConfig";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.IamConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.IamConfig".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Lifecycle {
        #[prost(message, repeated, tag = "1")]
        pub rule: ::prost::alloc::vec::Vec<lifecycle::Rule>,
    }
    /// Nested message and enum types in `Lifecycle`.
    pub mod lifecycle {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Rule {
            #[prost(message, optional, tag = "1")]
            pub action: ::core::option::Option<rule::Action>,
            #[prost(message, optional, tag = "2")]
            pub condition: ::core::option::Option<rule::Condition>,
        }
        /// Nested message and enum types in `Rule`.
        pub mod rule {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Action {
                #[prost(string, tag = "1")]
                pub r#type: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub storage_class: ::prost::alloc::string::String,
            }
            impl ::prost::Name for Action {
                const NAME: &'static str = "Action";
                const PACKAGE: &'static str = "google.storage.v2";
                fn full_name() -> ::prost::alloc::string::String {
                    "google.storage.v2.Bucket.Lifecycle.Rule.Action".into()
                }
                fn type_url() -> ::prost::alloc::string::String {
                    "type.googleapis.com/google.storage.v2.Bucket.Lifecycle.Rule.Action"
                        .into()
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Condition {
                #[prost(int32, optional, tag = "1")]
                pub age_days: ::core::option::Option<i32>,
                #[prost(message, optional, tag = "2")]
                pub created_before: ::core::option::Option<
                    super::super::super::super::super::r#type::Date,
                >,
                #[prost(bool, optional, tag = "3")]
                pub is_live: ::core::option::Option<bool>,
                #[prost(int32, optional, tag = "4")]
                pub num_newer_versions: ::core::option::Option<i32>,
                #[prost(string, repeated, tag = "5")]
                pub matches_storage_class: ::prost::alloc::vec::Vec<
                    ::prost::alloc::string::String,
                >,
                #[prost(int32, optional, tag = "7")]
                pub days_since_custom_time: ::core::option::Option<i32>,
                #[prost(message, optional, tag = "8")]
                pub custom_time_before: ::core::option::Option<
                    super::super::super::super::super::r#type::Date,
                >,
                #[prost(int32, optional, tag = "9")]
                pub days_since_noncurrent_time: ::core::option::Option<i32>,
                #[prost(message, optional, tag = "10")]
                pub noncurrent_time_before: ::core::option::Option<
                    super::super::super::super::super::r#type::Date,
                >,
                #[prost(string, repeated, tag = "11")]
                pub matches_prefix: ::prost::alloc::vec::Vec<
                    ::prost::alloc::string::String,
                >,
                #[prost(string, repeated, tag = "12")]
                pub matches_suffix: ::prost::alloc::vec::Vec<
                    ::prost::alloc::string::String,
                >,
            }
            impl ::prost::Name for Condition {
                const NAME: &'static str = "Condition";
                const PACKAGE: &'static str = "google.storage.v2";
                fn full_name() -> ::prost::alloc::string::String {
                    "google.storage.v2.Bucket.Lifecycle.Rule.Condition".into()
                }
                fn type_url() -> ::prost::alloc::string::String {
                    "type.googleapis.com/google.storage.v2.Bucket.Lifecycle.Rule.Condition"
                        .into()
                }
            }
        }
        impl ::prost::Name for Rule {
            const NAME: &'static str = "Rule";
            const PACKAGE: &'static str = "google.storage.v2";
            fn full_name() -> ::prost::alloc::string::String {
                "google.storage.v2.Bucket.Lifecycle.Rule".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.storage.v2.Bucket.Lifecycle.Rule".into()
            }
        }
    }
    impl ::prost::Name for Lifecycle {
        const NAME: &'static str = "Lifecycle";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.Lifecycle".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.Lifecycle".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Logging {
        #[prost(string, tag = "1")]
        pub log_bucket: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub log_object_prefix: ::prost::alloc::string::String,
    }
    impl ::prost::Name for Logging {
        const NAME: &'static str = "Logging";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.Logging".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.Logging".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ObjectRetention {
        #[prost(bool, tag = "1")]
        pub enabled: bool,
    }
    impl ::prost::Name for ObjectRetention {
        const NAME: &'static str = "ObjectRetention";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.ObjectRetention".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.ObjectRetention".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RetentionPolicy {
        #[prost(message, optional, tag = "1")]
        pub effective_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(bool, tag = "2")]
        pub is_locked: bool,
        #[prost(message, optional, tag = "4")]
        pub retention_duration: ::core::option::Option<::prost_types::Duration>,
    }
    impl ::prost::Name for RetentionPolicy {
        const NAME: &'static str = "RetentionPolicy";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.RetentionPolicy".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.RetentionPolicy".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SoftDeletePolicy {
        #[prost(message, optional, tag = "1")]
        pub retention_duration: ::core::option::Option<::prost_types::Duration>,
        #[prost(message, optional, tag = "2")]
        pub effective_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    impl ::prost::Name for SoftDeletePolicy {
        const NAME: &'static str = "SoftDeletePolicy";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.SoftDeletePolicy".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.SoftDeletePolicy".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Versioning {
        #[prost(bool, tag = "1")]
        pub enabled: bool,
    }
    impl ::prost::Name for Versioning {
        const NAME: &'static str = "Versioning";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.Versioning".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.Versioning".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Website {
        #[prost(string, tag = "1")]
        pub main_page_suffix: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub not_found_page: ::prost::alloc::string::String,
    }
    impl ::prost::Name for Website {
        const NAME: &'static str = "Website";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.Website".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.Website".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CustomPlacementConfig {
        #[prost(string, repeated, tag = "1")]
        pub data_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for CustomPlacementConfig {
        const NAME: &'static str = "CustomPlacementConfig";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.CustomPlacementConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.CustomPlacementConfig".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Autoclass {
        #[prost(bool, tag = "1")]
        pub enabled: bool,
        #[prost(message, optional, tag = "2")]
        pub toggle_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(string, optional, tag = "3")]
        pub terminal_storage_class: ::core::option::Option<
            ::prost::alloc::string::String,
        >,
        #[prost(message, optional, tag = "4")]
        pub terminal_storage_class_update_time: ::core::option::Option<
            ::prost_types::Timestamp,
        >,
    }
    impl ::prost::Name for Autoclass {
        const NAME: &'static str = "Autoclass";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.Autoclass".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.Autoclass".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IpFilter {
        #[prost(string, optional, tag = "1")]
        pub mode: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag = "2")]
        pub public_network_source: ::core::option::Option<
            ip_filter::PublicNetworkSource,
        >,
        #[prost(message, repeated, tag = "3")]
        pub vpc_network_sources: ::prost::alloc::vec::Vec<ip_filter::VpcNetworkSource>,
        #[prost(bool, tag = "4")]
        pub allow_cross_org_vpcs: bool,
        #[prost(bool, optional, tag = "5")]
        pub allow_all_service_agent_access: ::core::option::Option<bool>,
    }
    /// Nested message and enum types in `IpFilter`.
    pub mod ip_filter {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PublicNetworkSource {
            #[prost(string, repeated, tag = "1")]
            pub allowed_ip_cidr_ranges: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
        }
        impl ::prost::Name for PublicNetworkSource {
            const NAME: &'static str = "PublicNetworkSource";
            const PACKAGE: &'static str = "google.storage.v2";
            fn full_name() -> ::prost::alloc::string::String {
                "google.storage.v2.Bucket.IpFilter.PublicNetworkSource".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.storage.v2.Bucket.IpFilter.PublicNetworkSource"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct VpcNetworkSource {
            #[prost(string, optional, tag = "1")]
            pub network: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, repeated, tag = "2")]
            pub allowed_ip_cidr_ranges: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
        }
        impl ::prost::Name for VpcNetworkSource {
            const NAME: &'static str = "VpcNetworkSource";
            const PACKAGE: &'static str = "google.storage.v2";
            fn full_name() -> ::prost::alloc::string::String {
                "google.storage.v2.Bucket.IpFilter.VpcNetworkSource".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.storage.v2.Bucket.IpFilter.VpcNetworkSource"
                    .into()
            }
        }
    }
    impl ::prost::Name for IpFilter {
        const NAME: &'static str = "IpFilter";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.IpFilter".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.IpFilter".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct HierarchicalNamespace {
        #[prost(bool, tag = "1")]
        pub enabled: bool,
    }
    impl ::prost::Name for HierarchicalNamespace {
        const NAME: &'static str = "HierarchicalNamespace";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Bucket.HierarchicalNamespace".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Bucket.HierarchicalNamespace".into()
        }
    }
}
impl ::prost::Name for Bucket {
    const NAME: &'static str = "Bucket";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.Bucket".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.Bucket".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BucketAccessControl {
    #[prost(string, tag = "1")]
    pub role: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub entity: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub entity_alt: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub project_team: ::core::option::Option<ProjectTeam>,
}
impl ::prost::Name for BucketAccessControl {
    const NAME: &'static str = "BucketAccessControl";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.BucketAccessControl".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.BucketAccessControl".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChecksummedData {
    #[prost(bytes = "bytes", tag = "1")]
    pub content: ::prost::bytes::Bytes,
    #[prost(fixed32, optional, tag = "2")]
    pub crc32c: ::core::option::Option<u32>,
}
impl ::prost::Name for ChecksummedData {
    const NAME: &'static str = "ChecksummedData";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ChecksummedData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ChecksummedData".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectChecksums {
    #[prost(fixed32, optional, tag = "1")]
    pub crc32c: ::core::option::Option<u32>,
    #[prost(bytes = "bytes", tag = "2")]
    pub md5_hash: ::prost::bytes::Bytes,
}
impl ::prost::Name for ObjectChecksums {
    const NAME: &'static str = "ObjectChecksums";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ObjectChecksums".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ObjectChecksums".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectCustomContextPayload {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
impl ::prost::Name for ObjectCustomContextPayload {
    const NAME: &'static str = "ObjectCustomContextPayload";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ObjectCustomContextPayload".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ObjectCustomContextPayload".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectContexts {
    #[prost(map = "string, message", tag = "1")]
    pub custom: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ObjectCustomContextPayload,
    >,
}
impl ::prost::Name for ObjectContexts {
    const NAME: &'static str = "ObjectContexts";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ObjectContexts".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ObjectContexts".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerEncryption {
    #[prost(string, tag = "1")]
    pub encryption_algorithm: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "3")]
    pub key_sha256_bytes: ::prost::bytes::Bytes,
}
impl ::prost::Name for CustomerEncryption {
    const NAME: &'static str = "CustomerEncryption";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.CustomerEncryption".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.CustomerEncryption".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Object {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "27")]
    pub etag: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub generation: i64,
    #[prost(string, optional, tag = "35")]
    pub restore_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, tag = "4")]
    pub metageneration: i64,
    #[prost(string, tag = "5")]
    pub storage_class: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub size: i64,
    #[prost(string, tag = "7")]
    pub content_encoding: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub content_disposition: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub cache_control: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "10")]
    pub acl: ::prost::alloc::vec::Vec<ObjectAccessControl>,
    #[prost(string, tag = "11")]
    pub content_language: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "12")]
    pub delete_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "36")]
    pub finalize_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "13")]
    pub content_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "14")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, tag = "15")]
    pub component_count: i32,
    #[prost(message, optional, tag = "16")]
    pub checksums: ::core::option::Option<ObjectChecksums>,
    #[prost(message, optional, tag = "17")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "18")]
    pub kms_key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "19")]
    pub update_storage_class_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "20")]
    pub temporary_hold: bool,
    #[prost(message, optional, tag = "21")]
    pub retention_expire_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "22")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "38")]
    pub contexts: ::core::option::Option<ObjectContexts>,
    #[prost(bool, optional, tag = "23")]
    pub event_based_hold: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "24")]
    pub owner: ::core::option::Option<Owner>,
    #[prost(message, optional, tag = "25")]
    pub customer_encryption: ::core::option::Option<CustomerEncryption>,
    #[prost(message, optional, tag = "26")]
    pub custom_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "28")]
    pub soft_delete_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "29")]
    pub hard_delete_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "30")]
    pub retention: ::core::option::Option<object::Retention>,
}
/// Nested message and enum types in `Object`.
pub mod object {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Retention {
        #[prost(enumeration = "retention::Mode", tag = "1")]
        pub mode: i32,
        #[prost(message, optional, tag = "2")]
        pub retain_until_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Nested message and enum types in `Retention`.
    pub mod retention {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Mode {
            Unspecified = 0,
            Unlocked = 1,
            Locked = 2,
        }
        impl Mode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "MODE_UNSPECIFIED",
                    Self::Unlocked => "UNLOCKED",
                    Self::Locked => "LOCKED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "UNLOCKED" => Some(Self::Unlocked),
                    "LOCKED" => Some(Self::Locked),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for Retention {
        const NAME: &'static str = "Retention";
        const PACKAGE: &'static str = "google.storage.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "google.storage.v2.Object.Retention".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.storage.v2.Object.Retention".into()
        }
    }
}
impl ::prost::Name for Object {
    const NAME: &'static str = "Object";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.Object".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.Object".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectAccessControl {
    #[prost(string, tag = "1")]
    pub role: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub entity: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub entity_alt: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub project_team: ::core::option::Option<ProjectTeam>,
}
impl ::prost::Name for ObjectAccessControl {
    const NAME: &'static str = "ObjectAccessControl";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ObjectAccessControl".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ObjectAccessControl".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListObjectsResponse {
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Object>,
    #[prost(string, repeated, tag = "2")]
    pub prefixes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListObjectsResponse {
    const NAME: &'static str = "ListObjectsResponse";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ListObjectsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ListObjectsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectTeam {
    #[prost(string, tag = "1")]
    pub project_number: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub team: ::prost::alloc::string::String,
}
impl ::prost::Name for ProjectTeam {
    const NAME: &'static str = "ProjectTeam";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ProjectTeam".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ProjectTeam".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Owner {
    #[prost(string, tag = "1")]
    pub entity: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub entity_id: ::prost::alloc::string::String,
}
impl ::prost::Name for Owner {
    const NAME: &'static str = "Owner";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.Owner".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.Owner".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ContentRange {
    #[prost(int64, tag = "1")]
    pub start: i64,
    #[prost(int64, tag = "2")]
    pub end: i64,
    #[prost(int64, tag = "3")]
    pub complete_length: i64,
}
impl ::prost::Name for ContentRange {
    const NAME: &'static str = "ContentRange";
    const PACKAGE: &'static str = "google.storage.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "google.storage.v2.ContentRange".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.storage.v2.ContentRange".into()
    }
}
