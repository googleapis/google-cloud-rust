// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

impl gaxi::prost::ToProto<DeleteBucketRequest> for crate::generated::gapic::model::DeleteBucketRequest {
    type Output = DeleteBucketRequest;
    fn to_proto(self) -> std::result::Result<DeleteBucketRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            name: self.name.to_proto()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::DeleteBucketRequest> for DeleteBucketRequest {
    fn cnv(self) -> crate::generated::gapic::model::DeleteBucketRequest {
        crate::generated::gapic::model::DeleteBucketRequest::new()
            .set_name(self.name)
            .set_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()))
            .set_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<GetBucketRequest> for crate::generated::gapic::model::GetBucketRequest {
    type Output = GetBucketRequest;
    fn to_proto(self) -> std::result::Result<GetBucketRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            name: self.name.to_proto()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            read_mask: self.read_mask.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::GetBucketRequest> for GetBucketRequest {
    fn cnv(self) -> crate::generated::gapic::model::GetBucketRequest {
        crate::generated::gapic::model::GetBucketRequest::new()
            .set_name(self.name)
            .set_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()))
            .set_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()))
            .set_read_mask(self.read_mask.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<CreateBucketRequest> for crate::generated::gapic::model::CreateBucketRequest {
    type Output = CreateBucketRequest;
    fn to_proto(self) -> std::result::Result<CreateBucketRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            parent: self.parent.to_proto()?,
            bucket: self.bucket.map(|v| v.to_proto()).transpose()?,
            bucket_id: self.bucket_id.to_proto()?,
            predefined_acl: self.predefined_acl.to_proto()?,
            predefined_default_object_acl: self.predefined_default_object_acl.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::CreateBucketRequest> for CreateBucketRequest {
    fn cnv(self) -> crate::generated::gapic::model::CreateBucketRequest {
        crate::generated::gapic::model::CreateBucketRequest::new()
            .set_parent(self.parent)
            .set_bucket(self.bucket.map(|v| v.cnv()))
            .set_bucket_id(self.bucket_id)
            .set_predefined_acl(self.predefined_acl)
            .set_predefined_default_object_acl(self.predefined_default_object_acl)
    }
}

impl gaxi::prost::ToProto<ListBucketsRequest> for crate::generated::gapic::model::ListBucketsRequest {
    type Output = ListBucketsRequest;
    fn to_proto(self) -> std::result::Result<ListBucketsRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            parent: self.parent.to_proto()?,
            page_size: self.page_size.to_proto()?,
            page_token: self.page_token.to_proto()?,
            prefix: self.prefix.to_proto()?,
            read_mask: self.read_mask.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ListBucketsRequest> for ListBucketsRequest {
    fn cnv(self) -> crate::generated::gapic::model::ListBucketsRequest {
        crate::generated::gapic::model::ListBucketsRequest::new()
            .set_parent(self.parent)
            .set_page_size(self.page_size)
            .set_page_token(self.page_token)
            .set_prefix(self.prefix)
            .set_read_mask(self.read_mask.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<ListBucketsResponse> for crate::generated::gapic::model::ListBucketsResponse {
    type Output = ListBucketsResponse;
    fn to_proto(self) -> std::result::Result<ListBucketsResponse, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            buckets: self.buckets
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            next_page_token: self.next_page_token.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ListBucketsResponse> for ListBucketsResponse {
    fn cnv(self) -> crate::generated::gapic::model::ListBucketsResponse {
        crate::generated::gapic::model::ListBucketsResponse::new()
            .set_buckets(self.buckets.into_iter().map(|v| v.cnv()))
            .set_next_page_token(self.next_page_token)
    }
}

impl gaxi::prost::ToProto<LockBucketRetentionPolicyRequest> for crate::generated::gapic::model::LockBucketRetentionPolicyRequest {
    type Output = LockBucketRetentionPolicyRequest;
    fn to_proto(self) -> std::result::Result<LockBucketRetentionPolicyRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            bucket: self.bucket.to_proto()?,
            if_metageneration_match: self.if_metageneration_match.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::LockBucketRetentionPolicyRequest> for LockBucketRetentionPolicyRequest {
    fn cnv(self) -> crate::generated::gapic::model::LockBucketRetentionPolicyRequest {
        crate::generated::gapic::model::LockBucketRetentionPolicyRequest::new()
            .set_bucket(self.bucket)
            .set_if_metageneration_match(self.if_metageneration_match)
    }
}

impl gaxi::prost::ToProto<UpdateBucketRequest> for crate::generated::gapic::model::UpdateBucketRequest {
    type Output = UpdateBucketRequest;
    fn to_proto(self) -> std::result::Result<UpdateBucketRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            bucket: self.bucket.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            predefined_acl: self.predefined_acl.to_proto()?,
            predefined_default_object_acl: self.predefined_default_object_acl.to_proto()?,
            update_mask: self.update_mask.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::UpdateBucketRequest> for UpdateBucketRequest {
    fn cnv(self) -> crate::generated::gapic::model::UpdateBucketRequest {
        crate::generated::gapic::model::UpdateBucketRequest::new()
            .set_bucket(self.bucket.map(|v| v.cnv()))
            .set_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()))
            .set_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()))
            .set_predefined_acl(self.predefined_acl)
            .set_predefined_default_object_acl(self.predefined_default_object_acl)
            .set_update_mask(self.update_mask.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<compose_object_request::source_object::ObjectPreconditions> for crate::generated::gapic::model::compose_object_request::source_object::ObjectPreconditions {
    type Output = compose_object_request::source_object::ObjectPreconditions;
    fn to_proto(self) -> std::result::Result<compose_object_request::source_object::ObjectPreconditions, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::compose_object_request::source_object::ObjectPreconditions> for compose_object_request::source_object::ObjectPreconditions {
    fn cnv(self) -> crate::generated::gapic::model::compose_object_request::source_object::ObjectPreconditions {
        crate::generated::gapic::model::compose_object_request::source_object::ObjectPreconditions::new()
            .set_if_generation_match(self.if_generation_match.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<compose_object_request::SourceObject> for crate::generated::gapic::model::compose_object_request::SourceObject {
    type Output = compose_object_request::SourceObject;
    fn to_proto(self) -> std::result::Result<compose_object_request::SourceObject, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            name: self.name.to_proto()?,
            generation: self.generation.to_proto()?,
            object_preconditions: self.object_preconditions.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::compose_object_request::SourceObject> for compose_object_request::SourceObject {
    fn cnv(self) -> crate::generated::gapic::model::compose_object_request::SourceObject {
        crate::generated::gapic::model::compose_object_request::SourceObject::new()
            .set_name(self.name)
            .set_generation(self.generation)
            .set_object_preconditions(self.object_preconditions.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<ComposeObjectRequest> for crate::generated::gapic::model::ComposeObjectRequest {
    type Output = ComposeObjectRequest;
    fn to_proto(self) -> std::result::Result<ComposeObjectRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            destination: self.destination.map(|v| v.to_proto()).transpose()?,
            source_objects: self.source_objects
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            destination_predefined_acl: self.destination_predefined_acl.to_proto()?,
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            kms_key: self.kms_key.to_proto()?,
            common_object_request_params: self.common_object_request_params.map(|v| v.to_proto()).transpose()?,
            object_checksums: self.object_checksums.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ComposeObjectRequest> for ComposeObjectRequest {
    fn cnv(self) -> crate::generated::gapic::model::ComposeObjectRequest {
        crate::generated::gapic::model::ComposeObjectRequest::new()
            .set_destination(self.destination.map(|v| v.cnv()))
            .set_source_objects(self.source_objects.into_iter().map(|v| v.cnv()))
            .set_destination_predefined_acl(self.destination_predefined_acl)
            .set_if_generation_match(self.if_generation_match.map(|v| v.cnv()))
            .set_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()))
            .set_kms_key(self.kms_key)
            .set_common_object_request_params(self.common_object_request_params.map(|v| v.cnv()))
            .set_object_checksums(self.object_checksums.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<DeleteObjectRequest> for crate::generated::gapic::model::DeleteObjectRequest {
    type Output = DeleteObjectRequest;
    fn to_proto(self) -> std::result::Result<DeleteObjectRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            bucket: self.bucket.to_proto()?,
            object: self.object.to_proto()?,
            generation: self.generation.to_proto()?,
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
            if_generation_not_match: self.if_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            common_object_request_params: self.common_object_request_params.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::DeleteObjectRequest> for DeleteObjectRequest {
    fn cnv(self) -> crate::generated::gapic::model::DeleteObjectRequest {
        crate::generated::gapic::model::DeleteObjectRequest::new()
            .set_bucket(self.bucket)
            .set_object(self.object)
            .set_generation(self.generation)
            .set_if_generation_match(self.if_generation_match.map(|v| v.cnv()))
            .set_if_generation_not_match(self.if_generation_not_match.map(|v| v.cnv()))
            .set_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()))
            .set_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()))
            .set_common_object_request_params(self.common_object_request_params.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<RestoreObjectRequest> for crate::generated::gapic::model::RestoreObjectRequest {
    type Output = RestoreObjectRequest;
    fn to_proto(self) -> std::result::Result<RestoreObjectRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            bucket: self.bucket.to_proto()?,
            object: self.object.to_proto()?,
            generation: self.generation.to_proto()?,
            restore_token: self.restore_token.to_proto()?,
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
            if_generation_not_match: self.if_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            copy_source_acl: self.copy_source_acl.map(|v| v.to_proto()).transpose()?,
            common_object_request_params: self.common_object_request_params.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::RestoreObjectRequest> for RestoreObjectRequest {
    fn cnv(self) -> crate::generated::gapic::model::RestoreObjectRequest {
        crate::generated::gapic::model::RestoreObjectRequest::new()
            .set_bucket(self.bucket)
            .set_object(self.object)
            .set_generation(self.generation)
            .set_restore_token(self.restore_token)
            .set_if_generation_match(self.if_generation_match.map(|v| v.cnv()))
            .set_if_generation_not_match(self.if_generation_not_match.map(|v| v.cnv()))
            .set_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()))
            .set_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()))
            .set_copy_source_acl(self.copy_source_acl.map(|v| v.cnv()))
            .set_common_object_request_params(self.common_object_request_params.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<GetObjectRequest> for crate::generated::gapic::model::GetObjectRequest {
    type Output = GetObjectRequest;
    fn to_proto(self) -> std::result::Result<GetObjectRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            bucket: self.bucket.to_proto()?,
            object: self.object.to_proto()?,
            generation: self.generation.to_proto()?,
            soft_deleted: self.soft_deleted.map(|v| v.to_proto()).transpose()?,
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
            if_generation_not_match: self.if_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            common_object_request_params: self.common_object_request_params.map(|v| v.to_proto()).transpose()?,
            read_mask: self.read_mask.map(|v| v.to_proto()).transpose()?,
            restore_token: self.restore_token.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::GetObjectRequest> for GetObjectRequest {
    fn cnv(self) -> crate::generated::gapic::model::GetObjectRequest {
        crate::generated::gapic::model::GetObjectRequest::new()
            .set_bucket(self.bucket)
            .set_object(self.object)
            .set_generation(self.generation)
            .set_soft_deleted(self.soft_deleted.map(|v| v.cnv()))
            .set_if_generation_match(self.if_generation_match.map(|v| v.cnv()))
            .set_if_generation_not_match(self.if_generation_not_match.map(|v| v.cnv()))
            .set_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()))
            .set_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()))
            .set_common_object_request_params(self.common_object_request_params.map(|v| v.cnv()))
            .set_read_mask(self.read_mask.map(|v| v.cnv()))
            .set_restore_token(self.restore_token)
    }
}

impl gaxi::prost::ToProto<ListObjectsRequest> for crate::generated::gapic::model::ListObjectsRequest {
    type Output = ListObjectsRequest;
    fn to_proto(self) -> std::result::Result<ListObjectsRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            parent: self.parent.to_proto()?,
            page_size: self.page_size.to_proto()?,
            page_token: self.page_token.to_proto()?,
            delimiter: self.delimiter.to_proto()?,
            include_trailing_delimiter: self.include_trailing_delimiter.to_proto()?,
            prefix: self.prefix.to_proto()?,
            versions: self.versions.to_proto()?,
            read_mask: self.read_mask.map(|v| v.to_proto()).transpose()?,
            lexicographic_start: self.lexicographic_start.to_proto()?,
            lexicographic_end: self.lexicographic_end.to_proto()?,
            soft_deleted: self.soft_deleted.to_proto()?,
            include_folders_as_prefixes: self.include_folders_as_prefixes.to_proto()?,
            match_glob: self.match_glob.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ListObjectsRequest> for ListObjectsRequest {
    fn cnv(self) -> crate::generated::gapic::model::ListObjectsRequest {
        crate::generated::gapic::model::ListObjectsRequest::new()
            .set_parent(self.parent)
            .set_page_size(self.page_size)
            .set_page_token(self.page_token)
            .set_delimiter(self.delimiter)
            .set_include_trailing_delimiter(self.include_trailing_delimiter)
            .set_prefix(self.prefix)
            .set_versions(self.versions)
            .set_read_mask(self.read_mask.map(|v| v.cnv()))
            .set_lexicographic_start(self.lexicographic_start)
            .set_lexicographic_end(self.lexicographic_end)
            .set_soft_deleted(self.soft_deleted)
            .set_include_folders_as_prefixes(self.include_folders_as_prefixes)
            .set_match_glob(self.match_glob)
    }
}

impl gaxi::prost::ToProto<RewriteObjectRequest> for crate::generated::gapic::model::RewriteObjectRequest {
    type Output = RewriteObjectRequest;
    fn to_proto(self) -> std::result::Result<RewriteObjectRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            destination_name: self.destination_name.to_proto()?,
            destination_bucket: self.destination_bucket.to_proto()?,
            destination_kms_key: self.destination_kms_key.to_proto()?,
            destination: self.destination.map(|v| v.to_proto()).transpose()?,
            source_bucket: self.source_bucket.to_proto()?,
            source_object: self.source_object.to_proto()?,
            source_generation: self.source_generation.to_proto()?,
            rewrite_token: self.rewrite_token.to_proto()?,
            destination_predefined_acl: self.destination_predefined_acl.to_proto()?,
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
            if_generation_not_match: self.if_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            if_source_generation_match: self.if_source_generation_match.map(|v| v.to_proto()).transpose()?,
            if_source_generation_not_match: self.if_source_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_source_metageneration_match: self.if_source_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_source_metageneration_not_match: self.if_source_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            max_bytes_rewritten_per_call: self.max_bytes_rewritten_per_call.to_proto()?,
            copy_source_encryption_algorithm: self.copy_source_encryption_algorithm.to_proto()?,
            copy_source_encryption_key_bytes: self.copy_source_encryption_key_bytes.to_proto()?,
            copy_source_encryption_key_sha256_bytes: self.copy_source_encryption_key_sha256_bytes.to_proto()?,
            common_object_request_params: self.common_object_request_params.map(|v| v.to_proto()).transpose()?,
            object_checksums: self.object_checksums.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::RewriteObjectRequest> for RewriteObjectRequest {
    fn cnv(self) -> crate::generated::gapic::model::RewriteObjectRequest {
        crate::generated::gapic::model::RewriteObjectRequest::new()
            .set_destination_name(self.destination_name)
            .set_destination_bucket(self.destination_bucket)
            .set_destination_kms_key(self.destination_kms_key)
            .set_destination(self.destination.map(|v| v.cnv()))
            .set_source_bucket(self.source_bucket)
            .set_source_object(self.source_object)
            .set_source_generation(self.source_generation)
            .set_rewrite_token(self.rewrite_token)
            .set_destination_predefined_acl(self.destination_predefined_acl)
            .set_if_generation_match(self.if_generation_match.map(|v| v.cnv()))
            .set_if_generation_not_match(self.if_generation_not_match.map(|v| v.cnv()))
            .set_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()))
            .set_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()))
            .set_if_source_generation_match(self.if_source_generation_match.map(|v| v.cnv()))
            .set_if_source_generation_not_match(self.if_source_generation_not_match.map(|v| v.cnv()))
            .set_if_source_metageneration_match(self.if_source_metageneration_match.map(|v| v.cnv()))
            .set_if_source_metageneration_not_match(self.if_source_metageneration_not_match.map(|v| v.cnv()))
            .set_max_bytes_rewritten_per_call(self.max_bytes_rewritten_per_call)
            .set_copy_source_encryption_algorithm(self.copy_source_encryption_algorithm)
            .set_copy_source_encryption_key_bytes(self.copy_source_encryption_key_bytes)
            .set_copy_source_encryption_key_sha256_bytes(self.copy_source_encryption_key_sha256_bytes)
            .set_common_object_request_params(self.common_object_request_params.map(|v| v.cnv()))
            .set_object_checksums(self.object_checksums.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<RewriteResponse> for crate::generated::gapic::model::RewriteResponse {
    type Output = RewriteResponse;
    fn to_proto(self) -> std::result::Result<RewriteResponse, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            total_bytes_rewritten: self.total_bytes_rewritten.to_proto()?,
            object_size: self.object_size.to_proto()?,
            done: self.done.to_proto()?,
            rewrite_token: self.rewrite_token.to_proto()?,
            resource: self.resource.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::RewriteResponse> for RewriteResponse {
    fn cnv(self) -> crate::generated::gapic::model::RewriteResponse {
        crate::generated::gapic::model::RewriteResponse::new()
            .set_total_bytes_rewritten(self.total_bytes_rewritten)
            .set_object_size(self.object_size)
            .set_done(self.done)
            .set_rewrite_token(self.rewrite_token)
            .set_resource(self.resource.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<MoveObjectRequest> for crate::generated::gapic::model::MoveObjectRequest {
    type Output = MoveObjectRequest;
    fn to_proto(self) -> std::result::Result<MoveObjectRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            bucket: self.bucket.to_proto()?,
            source_object: self.source_object.to_proto()?,
            destination_object: self.destination_object.to_proto()?,
            if_source_generation_match: self.if_source_generation_match.map(|v| v.to_proto()).transpose()?,
            if_source_generation_not_match: self.if_source_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_source_metageneration_match: self.if_source_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_source_metageneration_not_match: self.if_source_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
            if_generation_not_match: self.if_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::MoveObjectRequest> for MoveObjectRequest {
    fn cnv(self) -> crate::generated::gapic::model::MoveObjectRequest {
        crate::generated::gapic::model::MoveObjectRequest::new()
            .set_bucket(self.bucket)
            .set_source_object(self.source_object)
            .set_destination_object(self.destination_object)
            .set_if_source_generation_match(self.if_source_generation_match.map(|v| v.cnv()))
            .set_if_source_generation_not_match(self.if_source_generation_not_match.map(|v| v.cnv()))
            .set_if_source_metageneration_match(self.if_source_metageneration_match.map(|v| v.cnv()))
            .set_if_source_metageneration_not_match(self.if_source_metageneration_not_match.map(|v| v.cnv()))
            .set_if_generation_match(self.if_generation_match.map(|v| v.cnv()))
            .set_if_generation_not_match(self.if_generation_not_match.map(|v| v.cnv()))
            .set_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()))
            .set_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<UpdateObjectRequest> for crate::generated::gapic::model::UpdateObjectRequest {
    type Output = UpdateObjectRequest;
    fn to_proto(self) -> std::result::Result<UpdateObjectRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            object: self.object.map(|v| v.to_proto()).transpose()?,
            if_generation_match: self.if_generation_match.map(|v| v.to_proto()).transpose()?,
            if_generation_not_match: self.if_generation_not_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_match: self.if_metageneration_match.map(|v| v.to_proto()).transpose()?,
            if_metageneration_not_match: self.if_metageneration_not_match.map(|v| v.to_proto()).transpose()?,
            predefined_acl: self.predefined_acl.to_proto()?,
            update_mask: self.update_mask.map(|v| v.to_proto()).transpose()?,
            common_object_request_params: self.common_object_request_params.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::UpdateObjectRequest> for UpdateObjectRequest {
    fn cnv(self) -> crate::generated::gapic::model::UpdateObjectRequest {
        crate::generated::gapic::model::UpdateObjectRequest::new()
            .set_object(self.object.map(|v| v.cnv()))
            .set_if_generation_match(self.if_generation_match.map(|v| v.cnv()))
            .set_if_generation_not_match(self.if_generation_not_match.map(|v| v.cnv()))
            .set_if_metageneration_match(self.if_metageneration_match.map(|v| v.cnv()))
            .set_if_metageneration_not_match(self.if_metageneration_not_match.map(|v| v.cnv()))
            .set_predefined_acl(self.predefined_acl)
            .set_update_mask(self.update_mask.map(|v| v.cnv()))
            .set_common_object_request_params(self.common_object_request_params.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<CommonObjectRequestParams> for crate::generated::gapic::model::CommonObjectRequestParams {
    type Output = CommonObjectRequestParams;
    fn to_proto(self) -> std::result::Result<CommonObjectRequestParams, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            encryption_algorithm: self.encryption_algorithm.to_proto()?,
            encryption_key_bytes: self.encryption_key_bytes.to_proto()?,
            encryption_key_sha256_bytes: self.encryption_key_sha256_bytes.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::CommonObjectRequestParams> for CommonObjectRequestParams {
    fn cnv(self) -> crate::generated::gapic::model::CommonObjectRequestParams {
        crate::generated::gapic::model::CommonObjectRequestParams::new()
            .set_encryption_algorithm(self.encryption_algorithm)
            .set_encryption_key_bytes(self.encryption_key_bytes)
            .set_encryption_key_sha256_bytes(self.encryption_key_sha256_bytes)
    }
}

impl gaxi::prost::ToProto<service_constants::Values> for crate::generated::gapic::model::service_constants::Values {
    type Output = i32;
    fn to_proto(self) -> std::result::Result<Self::Output, gaxi::prost::ConvertError> {
        self.value().ok_or(gaxi::prost::ConvertError::EnumNoIntegerValue("crate::generated::gapic::model::service_constants::Values"))
    }
}

impl gaxi::prost::ToProto<ServiceConstants> for crate::generated::gapic::model::ServiceConstants {
    type Output = ServiceConstants;
    fn to_proto(self) -> std::result::Result<ServiceConstants, gaxi::prost::ConvertError> {
        Ok(Self::Output {
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ServiceConstants> for ServiceConstants {
    fn cnv(self) -> crate::generated::gapic::model::ServiceConstants {
        crate::generated::gapic::model::ServiceConstants::new()
    }
}

impl gaxi::prost::ToProto<bucket::Billing> for crate::generated::gapic::model::bucket::Billing {
    type Output = bucket::Billing;
    fn to_proto(self) -> std::result::Result<bucket::Billing, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            requester_pays: self.requester_pays.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Billing> for bucket::Billing {
    fn cnv(self) -> crate::generated::gapic::model::bucket::Billing {
        crate::generated::gapic::model::bucket::Billing::new()
            .set_requester_pays(self.requester_pays)
    }
}

impl gaxi::prost::ToProto<bucket::Cors> for crate::generated::gapic::model::bucket::Cors {
    type Output = bucket::Cors;
    fn to_proto(self) -> std::result::Result<bucket::Cors, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            origin: self.origin
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            method: self.method
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            response_header: self.response_header
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            max_age_seconds: self.max_age_seconds.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Cors> for bucket::Cors {
    fn cnv(self) -> crate::generated::gapic::model::bucket::Cors {
        crate::generated::gapic::model::bucket::Cors::new()
            .set_origin(self.origin.into_iter().map(|v| v.cnv()))
            .set_method(self.method.into_iter().map(|v| v.cnv()))
            .set_response_header(self.response_header.into_iter().map(|v| v.cnv()))
            .set_max_age_seconds(self.max_age_seconds)
    }
}

impl gaxi::prost::ToProto<bucket::Encryption> for crate::generated::gapic::model::bucket::Encryption {
    type Output = bucket::Encryption;
    fn to_proto(self) -> std::result::Result<bucket::Encryption, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            default_kms_key: self.default_kms_key.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Encryption> for bucket::Encryption {
    fn cnv(self) -> crate::generated::gapic::model::bucket::Encryption {
        crate::generated::gapic::model::bucket::Encryption::new()
            .set_default_kms_key(self.default_kms_key)
    }
}

impl gaxi::prost::ToProto<bucket::iam_config::UniformBucketLevelAccess> for crate::generated::gapic::model::bucket::iam_config::UniformBucketLevelAccess {
    type Output = bucket::iam_config::UniformBucketLevelAccess;
    fn to_proto(self) -> std::result::Result<bucket::iam_config::UniformBucketLevelAccess, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            enabled: self.enabled.to_proto()?,
            lock_time: self.lock_time.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::iam_config::UniformBucketLevelAccess> for bucket::iam_config::UniformBucketLevelAccess {
    fn cnv(self) -> crate::generated::gapic::model::bucket::iam_config::UniformBucketLevelAccess {
        crate::generated::gapic::model::bucket::iam_config::UniformBucketLevelAccess::new()
            .set_enabled(self.enabled)
            .set_lock_time(self.lock_time.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<bucket::IamConfig> for crate::generated::gapic::model::bucket::IamConfig {
    type Output = bucket::IamConfig;
    fn to_proto(self) -> std::result::Result<bucket::IamConfig, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            uniform_bucket_level_access: self.uniform_bucket_level_access.map(|v| v.to_proto()).transpose()?,
            public_access_prevention: self.public_access_prevention.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::IamConfig> for bucket::IamConfig {
    fn cnv(self) -> crate::generated::gapic::model::bucket::IamConfig {
        crate::generated::gapic::model::bucket::IamConfig::new()
            .set_uniform_bucket_level_access(self.uniform_bucket_level_access.map(|v| v.cnv()))
            .set_public_access_prevention(self.public_access_prevention)
    }
}

impl gaxi::prost::ToProto<bucket::lifecycle::rule::Action> for crate::generated::gapic::model::bucket::lifecycle::rule::Action {
    type Output = bucket::lifecycle::rule::Action;
    fn to_proto(self) -> std::result::Result<bucket::lifecycle::rule::Action, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            r#type: self.r#type.to_proto()?,
            storage_class: self.storage_class.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::lifecycle::rule::Action> for bucket::lifecycle::rule::Action {
    fn cnv(self) -> crate::generated::gapic::model::bucket::lifecycle::rule::Action {
        crate::generated::gapic::model::bucket::lifecycle::rule::Action::new()
            .set_type(self.r#type)
            .set_storage_class(self.storage_class)
    }
}

impl gaxi::prost::ToProto<bucket::lifecycle::rule::Condition> for crate::generated::gapic::model::bucket::lifecycle::rule::Condition {
    type Output = bucket::lifecycle::rule::Condition;
    fn to_proto(self) -> std::result::Result<bucket::lifecycle::rule::Condition, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            age_days: self.age_days.map(|v| v.to_proto()).transpose()?,
            created_before: self.created_before.map(|v| v.to_proto()).transpose()?,
            is_live: self.is_live.map(|v| v.to_proto()).transpose()?,
            num_newer_versions: self.num_newer_versions.map(|v| v.to_proto()).transpose()?,
            matches_storage_class: self.matches_storage_class
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            days_since_custom_time: self.days_since_custom_time.map(|v| v.to_proto()).transpose()?,
            custom_time_before: self.custom_time_before.map(|v| v.to_proto()).transpose()?,
            days_since_noncurrent_time: self.days_since_noncurrent_time.map(|v| v.to_proto()).transpose()?,
            noncurrent_time_before: self.noncurrent_time_before.map(|v| v.to_proto()).transpose()?,
            matches_prefix: self.matches_prefix
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            matches_suffix: self.matches_suffix
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::lifecycle::rule::Condition> for bucket::lifecycle::rule::Condition {
    fn cnv(self) -> crate::generated::gapic::model::bucket::lifecycle::rule::Condition {
        crate::generated::gapic::model::bucket::lifecycle::rule::Condition::new()
            .set_age_days(self.age_days.map(|v| v.cnv()))
            .set_created_before(self.created_before.map(|v| v.cnv()))
            .set_is_live(self.is_live.map(|v| v.cnv()))
            .set_num_newer_versions(self.num_newer_versions.map(|v| v.cnv()))
            .set_matches_storage_class(self.matches_storage_class.into_iter().map(|v| v.cnv()))
            .set_days_since_custom_time(self.days_since_custom_time.map(|v| v.cnv()))
            .set_custom_time_before(self.custom_time_before.map(|v| v.cnv()))
            .set_days_since_noncurrent_time(self.days_since_noncurrent_time.map(|v| v.cnv()))
            .set_noncurrent_time_before(self.noncurrent_time_before.map(|v| v.cnv()))
            .set_matches_prefix(self.matches_prefix.into_iter().map(|v| v.cnv()))
            .set_matches_suffix(self.matches_suffix.into_iter().map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<bucket::lifecycle::Rule> for crate::generated::gapic::model::bucket::lifecycle::Rule {
    type Output = bucket::lifecycle::Rule;
    fn to_proto(self) -> std::result::Result<bucket::lifecycle::Rule, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            action: self.action.map(|v| v.to_proto()).transpose()?,
            condition: self.condition.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::lifecycle::Rule> for bucket::lifecycle::Rule {
    fn cnv(self) -> crate::generated::gapic::model::bucket::lifecycle::Rule {
        crate::generated::gapic::model::bucket::lifecycle::Rule::new()
            .set_action(self.action.map(|v| v.cnv()))
            .set_condition(self.condition.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<bucket::Lifecycle> for crate::generated::gapic::model::bucket::Lifecycle {
    type Output = bucket::Lifecycle;
    fn to_proto(self) -> std::result::Result<bucket::Lifecycle, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            rule: self.rule
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Lifecycle> for bucket::Lifecycle {
    fn cnv(self) -> crate::generated::gapic::model::bucket::Lifecycle {
        crate::generated::gapic::model::bucket::Lifecycle::new()
            .set_rule(self.rule.into_iter().map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<bucket::Logging> for crate::generated::gapic::model::bucket::Logging {
    type Output = bucket::Logging;
    fn to_proto(self) -> std::result::Result<bucket::Logging, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            log_bucket: self.log_bucket.to_proto()?,
            log_object_prefix: self.log_object_prefix.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Logging> for bucket::Logging {
    fn cnv(self) -> crate::generated::gapic::model::bucket::Logging {
        crate::generated::gapic::model::bucket::Logging::new()
            .set_log_bucket(self.log_bucket)
            .set_log_object_prefix(self.log_object_prefix)
    }
}

impl gaxi::prost::ToProto<bucket::RetentionPolicy> for crate::generated::gapic::model::bucket::RetentionPolicy {
    type Output = bucket::RetentionPolicy;
    fn to_proto(self) -> std::result::Result<bucket::RetentionPolicy, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            effective_time: self.effective_time.map(|v| v.to_proto()).transpose()?,
            is_locked: self.is_locked.to_proto()?,
            retention_duration: self.retention_duration.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::RetentionPolicy> for bucket::RetentionPolicy {
    fn cnv(self) -> crate::generated::gapic::model::bucket::RetentionPolicy {
        crate::generated::gapic::model::bucket::RetentionPolicy::new()
            .set_effective_time(self.effective_time.map(|v| v.cnv()))
            .set_is_locked(self.is_locked)
            .set_retention_duration(self.retention_duration.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<bucket::SoftDeletePolicy> for crate::generated::gapic::model::bucket::SoftDeletePolicy {
    type Output = bucket::SoftDeletePolicy;
    fn to_proto(self) -> std::result::Result<bucket::SoftDeletePolicy, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            retention_duration: self.retention_duration.map(|v| v.to_proto()).transpose()?,
            effective_time: self.effective_time.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::SoftDeletePolicy> for bucket::SoftDeletePolicy {
    fn cnv(self) -> crate::generated::gapic::model::bucket::SoftDeletePolicy {
        crate::generated::gapic::model::bucket::SoftDeletePolicy::new()
            .set_retention_duration(self.retention_duration.map(|v| v.cnv()))
            .set_effective_time(self.effective_time.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<bucket::Versioning> for crate::generated::gapic::model::bucket::Versioning {
    type Output = bucket::Versioning;
    fn to_proto(self) -> std::result::Result<bucket::Versioning, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            enabled: self.enabled.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Versioning> for bucket::Versioning {
    fn cnv(self) -> crate::generated::gapic::model::bucket::Versioning {
        crate::generated::gapic::model::bucket::Versioning::new()
            .set_enabled(self.enabled)
    }
}

impl gaxi::prost::ToProto<bucket::Website> for crate::generated::gapic::model::bucket::Website {
    type Output = bucket::Website;
    fn to_proto(self) -> std::result::Result<bucket::Website, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            main_page_suffix: self.main_page_suffix.to_proto()?,
            not_found_page: self.not_found_page.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Website> for bucket::Website {
    fn cnv(self) -> crate::generated::gapic::model::bucket::Website {
        crate::generated::gapic::model::bucket::Website::new()
            .set_main_page_suffix(self.main_page_suffix)
            .set_not_found_page(self.not_found_page)
    }
}

impl gaxi::prost::ToProto<bucket::CustomPlacementConfig> for crate::generated::gapic::model::bucket::CustomPlacementConfig {
    type Output = bucket::CustomPlacementConfig;
    fn to_proto(self) -> std::result::Result<bucket::CustomPlacementConfig, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            data_locations: self.data_locations
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::CustomPlacementConfig> for bucket::CustomPlacementConfig {
    fn cnv(self) -> crate::generated::gapic::model::bucket::CustomPlacementConfig {
        crate::generated::gapic::model::bucket::CustomPlacementConfig::new()
            .set_data_locations(self.data_locations.into_iter().map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<bucket::Autoclass> for crate::generated::gapic::model::bucket::Autoclass {
    type Output = bucket::Autoclass;
    fn to_proto(self) -> std::result::Result<bucket::Autoclass, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            enabled: self.enabled.to_proto()?,
            toggle_time: self.toggle_time.map(|v| v.to_proto()).transpose()?,
            terminal_storage_class: self.terminal_storage_class.map(|v| v.to_proto()).transpose()?,
            terminal_storage_class_update_time: self.terminal_storage_class_update_time.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::Autoclass> for bucket::Autoclass {
    fn cnv(self) -> crate::generated::gapic::model::bucket::Autoclass {
        crate::generated::gapic::model::bucket::Autoclass::new()
            .set_enabled(self.enabled)
            .set_toggle_time(self.toggle_time.map(|v| v.cnv()))
            .set_terminal_storage_class(self.terminal_storage_class.map(|v| v.cnv()))
            .set_terminal_storage_class_update_time(self.terminal_storage_class_update_time.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<bucket::HierarchicalNamespace> for crate::generated::gapic::model::bucket::HierarchicalNamespace {
    type Output = bucket::HierarchicalNamespace;
    fn to_proto(self) -> std::result::Result<bucket::HierarchicalNamespace, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            enabled: self.enabled.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::bucket::HierarchicalNamespace> for bucket::HierarchicalNamespace {
    fn cnv(self) -> crate::generated::gapic::model::bucket::HierarchicalNamespace {
        crate::generated::gapic::model::bucket::HierarchicalNamespace::new()
            .set_enabled(self.enabled)
    }
}

impl gaxi::prost::ToProto<Bucket> for crate::generated::gapic::model::Bucket {
    type Output = Bucket;
    fn to_proto(self) -> std::result::Result<Bucket, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            name: self.name.to_proto()?,
            bucket_id: self.bucket_id.to_proto()?,
            etag: self.etag.to_proto()?,
            project: self.project.to_proto()?,
            metageneration: self.metageneration.to_proto()?,
            location: self.location.to_proto()?,
            location_type: self.location_type.to_proto()?,
            storage_class: self.storage_class.to_proto()?,
            rpo: self.rpo.to_proto()?,
            acl: self.acl
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            default_object_acl: self.default_object_acl
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            lifecycle: self.lifecycle.map(|v| v.to_proto()).transpose()?,
            create_time: self.create_time.map(|v| v.to_proto()).transpose()?,
            cors: self.cors
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            update_time: self.update_time.map(|v| v.to_proto()).transpose()?,
            default_event_based_hold: self.default_event_based_hold.to_proto()?,
            labels: self.labels
                .into_iter()
                .map(|(k, v)| {
                    gaxi::prost::pair_transpose(k.to_proto(), v.to_proto())
                }).collect::<std::result::Result<std::collections::HashMap<_, _>, _>>()?,
            website: self.website.map(|v| v.to_proto()).transpose()?,
            versioning: self.versioning.map(|v| v.to_proto()).transpose()?,
            logging: self.logging.map(|v| v.to_proto()).transpose()?,
            owner: self.owner.map(|v| v.to_proto()).transpose()?,
            encryption: self.encryption.map(|v| v.to_proto()).transpose()?,
            billing: self.billing.map(|v| v.to_proto()).transpose()?,
            retention_policy: self.retention_policy.map(|v| v.to_proto()).transpose()?,
            iam_config: self.iam_config.map(|v| v.to_proto()).transpose()?,
            satisfies_pzs: self.satisfies_pzs.to_proto()?,
            custom_placement_config: self.custom_placement_config.map(|v| v.to_proto()).transpose()?,
            autoclass: self.autoclass.map(|v| v.to_proto()).transpose()?,
            hierarchical_namespace: self.hierarchical_namespace.map(|v| v.to_proto()).transpose()?,
            soft_delete_policy: self.soft_delete_policy.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::Bucket> for Bucket {
    fn cnv(self) -> crate::generated::gapic::model::Bucket {
        crate::generated::gapic::model::Bucket::new()
            .set_name(self.name)
            .set_bucket_id(self.bucket_id)
            .set_etag(self.etag)
            .set_project(self.project)
            .set_metageneration(self.metageneration)
            .set_location(self.location)
            .set_location_type(self.location_type)
            .set_storage_class(self.storage_class)
            .set_rpo(self.rpo)
            .set_acl(self.acl.into_iter().map(|v| v.cnv()))
            .set_default_object_acl(self.default_object_acl.into_iter().map(|v| v.cnv()))
            .set_lifecycle(self.lifecycle.map(|v| v.cnv()))
            .set_create_time(self.create_time.map(|v| v.cnv()))
            .set_cors(self.cors.into_iter().map(|v| v.cnv()))
            .set_update_time(self.update_time.map(|v| v.cnv()))
            .set_default_event_based_hold(self.default_event_based_hold)
            .set_labels(self.labels.into_iter().map(|(k, v)| (k.cnv(), v.cnv())))
            .set_website(self.website.map(|v| v.cnv()))
            .set_versioning(self.versioning.map(|v| v.cnv()))
            .set_logging(self.logging.map(|v| v.cnv()))
            .set_owner(self.owner.map(|v| v.cnv()))
            .set_encryption(self.encryption.map(|v| v.cnv()))
            .set_billing(self.billing.map(|v| v.cnv()))
            .set_retention_policy(self.retention_policy.map(|v| v.cnv()))
            .set_iam_config(self.iam_config.map(|v| v.cnv()))
            .set_satisfies_pzs(self.satisfies_pzs)
            .set_custom_placement_config(self.custom_placement_config.map(|v| v.cnv()))
            .set_autoclass(self.autoclass.map(|v| v.cnv()))
            .set_hierarchical_namespace(self.hierarchical_namespace.map(|v| v.cnv()))
            .set_soft_delete_policy(self.soft_delete_policy.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<BucketAccessControl> for crate::generated::gapic::model::BucketAccessControl {
    type Output = BucketAccessControl;
    fn to_proto(self) -> std::result::Result<BucketAccessControl, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            role: self.role.to_proto()?,
            id: self.id.to_proto()?,
            entity: self.entity.to_proto()?,
            entity_alt: self.entity_alt.to_proto()?,
            entity_id: self.entity_id.to_proto()?,
            etag: self.etag.to_proto()?,
            email: self.email.to_proto()?,
            domain: self.domain.to_proto()?,
            project_team: self.project_team.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::BucketAccessControl> for BucketAccessControl {
    fn cnv(self) -> crate::generated::gapic::model::BucketAccessControl {
        crate::generated::gapic::model::BucketAccessControl::new()
            .set_role(self.role)
            .set_id(self.id)
            .set_entity(self.entity)
            .set_entity_alt(self.entity_alt)
            .set_entity_id(self.entity_id)
            .set_etag(self.etag)
            .set_email(self.email)
            .set_domain(self.domain)
            .set_project_team(self.project_team.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<ObjectChecksums> for crate::generated::gapic::model::ObjectChecksums {
    type Output = ObjectChecksums;
    fn to_proto(self) -> std::result::Result<ObjectChecksums, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            crc32c: self.crc32c.map(|v| v.to_proto()).transpose()?,
            md5_hash: self.md5_hash.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ObjectChecksums> for ObjectChecksums {
    fn cnv(self) -> crate::generated::gapic::model::ObjectChecksums {
        crate::generated::gapic::model::ObjectChecksums::new()
            .set_crc32c(self.crc32c.map(|v| v.cnv()))
            .set_md5_hash(self.md5_hash)
    }
}

impl gaxi::prost::ToProto<CustomerEncryption> for crate::generated::gapic::model::CustomerEncryption {
    type Output = CustomerEncryption;
    fn to_proto(self) -> std::result::Result<CustomerEncryption, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            encryption_algorithm: self.encryption_algorithm.to_proto()?,
            key_sha256_bytes: self.key_sha256_bytes.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::CustomerEncryption> for CustomerEncryption {
    fn cnv(self) -> crate::generated::gapic::model::CustomerEncryption {
        crate::generated::gapic::model::CustomerEncryption::new()
            .set_encryption_algorithm(self.encryption_algorithm)
            .set_key_sha256_bytes(self.key_sha256_bytes)
    }
}

impl gaxi::prost::ToProto<Object> for crate::generated::gapic::model::Object {
    type Output = Object;
    fn to_proto(self) -> std::result::Result<Object, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            name: self.name.to_proto()?,
            bucket: self.bucket.to_proto()?,
            etag: self.etag.to_proto()?,
            generation: self.generation.to_proto()?,
            restore_token: self.restore_token.map(|v| v.to_proto()).transpose()?,
            metageneration: self.metageneration.to_proto()?,
            storage_class: self.storage_class.to_proto()?,
            size: self.size.to_proto()?,
            content_encoding: self.content_encoding.to_proto()?,
            content_disposition: self.content_disposition.to_proto()?,
            cache_control: self.cache_control.to_proto()?,
            acl: self.acl
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            content_language: self.content_language.to_proto()?,
            delete_time: self.delete_time.map(|v| v.to_proto()).transpose()?,
            finalize_time: self.finalize_time.map(|v| v.to_proto()).transpose()?,
            content_type: self.content_type.to_proto()?,
            create_time: self.create_time.map(|v| v.to_proto()).transpose()?,
            component_count: self.component_count.to_proto()?,
            checksums: self.checksums.map(|v| v.to_proto()).transpose()?,
            update_time: self.update_time.map(|v| v.to_proto()).transpose()?,
            kms_key: self.kms_key.to_proto()?,
            update_storage_class_time: self.update_storage_class_time.map(|v| v.to_proto()).transpose()?,
            temporary_hold: self.temporary_hold.to_proto()?,
            retention_expire_time: self.retention_expire_time.map(|v| v.to_proto()).transpose()?,
            metadata: self.metadata
                .into_iter()
                .map(|(k, v)| {
                    gaxi::prost::pair_transpose(k.to_proto(), v.to_proto())
                }).collect::<std::result::Result<std::collections::HashMap<_, _>, _>>()?,
            event_based_hold: self.event_based_hold.map(|v| v.to_proto()).transpose()?,
            owner: self.owner.map(|v| v.to_proto()).transpose()?,
            customer_encryption: self.customer_encryption.map(|v| v.to_proto()).transpose()?,
            custom_time: self.custom_time.map(|v| v.to_proto()).transpose()?,
            soft_delete_time: self.soft_delete_time.map(|v| v.to_proto()).transpose()?,
            hard_delete_time: self.hard_delete_time.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::Object> for Object {
    fn cnv(self) -> crate::generated::gapic::model::Object {
        crate::generated::gapic::model::Object::new()
            .set_name(self.name)
            .set_bucket(self.bucket)
            .set_etag(self.etag)
            .set_generation(self.generation)
            .set_restore_token(self.restore_token.map(|v| v.cnv()))
            .set_metageneration(self.metageneration)
            .set_storage_class(self.storage_class)
            .set_size(self.size)
            .set_content_encoding(self.content_encoding)
            .set_content_disposition(self.content_disposition)
            .set_cache_control(self.cache_control)
            .set_acl(self.acl.into_iter().map(|v| v.cnv()))
            .set_content_language(self.content_language)
            .set_delete_time(self.delete_time.map(|v| v.cnv()))
            .set_finalize_time(self.finalize_time.map(|v| v.cnv()))
            .set_content_type(self.content_type)
            .set_create_time(self.create_time.map(|v| v.cnv()))
            .set_component_count(self.component_count)
            .set_checksums(self.checksums.map(|v| v.cnv()))
            .set_update_time(self.update_time.map(|v| v.cnv()))
            .set_kms_key(self.kms_key)
            .set_update_storage_class_time(self.update_storage_class_time.map(|v| v.cnv()))
            .set_temporary_hold(self.temporary_hold)
            .set_retention_expire_time(self.retention_expire_time.map(|v| v.cnv()))
            .set_metadata(self.metadata.into_iter().map(|(k, v)| (k.cnv(), v.cnv())))
            .set_event_based_hold(self.event_based_hold.map(|v| v.cnv()))
            .set_owner(self.owner.map(|v| v.cnv()))
            .set_customer_encryption(self.customer_encryption.map(|v| v.cnv()))
            .set_custom_time(self.custom_time.map(|v| v.cnv()))
            .set_soft_delete_time(self.soft_delete_time.map(|v| v.cnv()))
            .set_hard_delete_time(self.hard_delete_time.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<ObjectAccessControl> for crate::generated::gapic::model::ObjectAccessControl {
    type Output = ObjectAccessControl;
    fn to_proto(self) -> std::result::Result<ObjectAccessControl, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            role: self.role.to_proto()?,
            id: self.id.to_proto()?,
            entity: self.entity.to_proto()?,
            entity_alt: self.entity_alt.to_proto()?,
            entity_id: self.entity_id.to_proto()?,
            etag: self.etag.to_proto()?,
            email: self.email.to_proto()?,
            domain: self.domain.to_proto()?,
            project_team: self.project_team.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ObjectAccessControl> for ObjectAccessControl {
    fn cnv(self) -> crate::generated::gapic::model::ObjectAccessControl {
        crate::generated::gapic::model::ObjectAccessControl::new()
            .set_role(self.role)
            .set_id(self.id)
            .set_entity(self.entity)
            .set_entity_alt(self.entity_alt)
            .set_entity_id(self.entity_id)
            .set_etag(self.etag)
            .set_email(self.email)
            .set_domain(self.domain)
            .set_project_team(self.project_team.map(|v| v.cnv()))
    }
}

impl gaxi::prost::ToProto<ListObjectsResponse> for crate::generated::gapic::model::ListObjectsResponse {
    type Output = ListObjectsResponse;
    fn to_proto(self) -> std::result::Result<ListObjectsResponse, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            objects: self.objects
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            prefixes: self.prefixes
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            next_page_token: self.next_page_token.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ListObjectsResponse> for ListObjectsResponse {
    fn cnv(self) -> crate::generated::gapic::model::ListObjectsResponse {
        crate::generated::gapic::model::ListObjectsResponse::new()
            .set_objects(self.objects.into_iter().map(|v| v.cnv()))
            .set_prefixes(self.prefixes.into_iter().map(|v| v.cnv()))
            .set_next_page_token(self.next_page_token)
    }
}

impl gaxi::prost::ToProto<ProjectTeam> for crate::generated::gapic::model::ProjectTeam {
    type Output = ProjectTeam;
    fn to_proto(self) -> std::result::Result<ProjectTeam, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            project_number: self.project_number.to_proto()?,
            team: self.team.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ProjectTeam> for ProjectTeam {
    fn cnv(self) -> crate::generated::gapic::model::ProjectTeam {
        crate::generated::gapic::model::ProjectTeam::new()
            .set_project_number(self.project_number)
            .set_team(self.team)
    }
}

impl gaxi::prost::ToProto<Owner> for crate::generated::gapic::model::Owner {
    type Output = Owner;
    fn to_proto(self) -> std::result::Result<Owner, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            entity: self.entity.to_proto()?,
            entity_id: self.entity_id.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::Owner> for Owner {
    fn cnv(self) -> crate::generated::gapic::model::Owner {
        crate::generated::gapic::model::Owner::new()
            .set_entity(self.entity)
            .set_entity_id(self.entity_id)
    }
}

impl gaxi::prost::ToProto<ContentRange> for crate::generated::gapic::model::ContentRange {
    type Output = ContentRange;
    fn to_proto(self) -> std::result::Result<ContentRange, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            start: self.start.to_proto()?,
            end: self.end.to_proto()?,
            complete_length: self.complete_length.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<crate::generated::gapic::model::ContentRange> for ContentRange {
    fn cnv(self) -> crate::generated::gapic::model::ContentRange {
        crate::generated::gapic::model::ContentRange::new()
            .set_start(self.start)
            .set_end(self.end)
            .set_complete_length(self.complete_length)
    }
}
