// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate as gaxi;

impl gaxi::prost::ToProto<Code> for rpc::model::Code {
    type Output = i32;
    fn to_proto(self) -> std::result::Result<Self::Output, gaxi::prost::ConvertError> {
        self.value().ok_or(gaxi::prost::ConvertError::EnumNoIntegerValue("rpc::model::Code"))
    }
}

impl gaxi::prost::ToProto<ErrorInfo> for rpc::model::ErrorInfo {
    type Output = ErrorInfo;
    fn to_proto(self) -> std::result::Result<ErrorInfo, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            reason: self.reason.to_proto()?,
            domain: self.domain.to_proto()?,
            metadata: self.metadata
                .into_iter()
                .map(|(k, v)| {
                    gaxi::prost::pair_transpose(k.to_proto(), v.to_proto())
                }).collect::<std::result::Result<std::collections::HashMap<_, _>, _>>()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::ErrorInfo> for ErrorInfo {
    fn cnv(self) -> std::result::Result<rpc::model::ErrorInfo, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::ErrorInfo::new()
                .set_reason(self.reason)
                .set_domain(self.domain)
                .set_metadata(self.metadata.into_iter()
                    .map(|(k, v)| {
                        gaxi::prost::pair_transpose(k.cnv(), v.cnv())
                    }).collect::<std::result::Result<std::collections::HashMap<_, _>, _>>()?)
        )
    }
}

impl gaxi::prost::ToProto<RetryInfo> for rpc::model::RetryInfo {
    type Output = RetryInfo;
    fn to_proto(self) -> std::result::Result<RetryInfo, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            retry_delay: self.retry_delay.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::RetryInfo> for RetryInfo {
    fn cnv(self) -> std::result::Result<rpc::model::RetryInfo, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::RetryInfo::new()
                .set_or_clear_retry_delay(self.retry_delay.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<DebugInfo> for rpc::model::DebugInfo {
    type Output = DebugInfo;
    fn to_proto(self) -> std::result::Result<DebugInfo, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            stack_entries: self.stack_entries
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            detail: self.detail.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::DebugInfo> for DebugInfo {
    fn cnv(self) -> std::result::Result<rpc::model::DebugInfo, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::DebugInfo::new()
                .set_stack_entries(self.stack_entries.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_detail(self.detail)
        )
    }
}

impl gaxi::prost::ToProto<quota_failure::Violation> for rpc::model::quota_failure::Violation {
    type Output = quota_failure::Violation;
    fn to_proto(self) -> std::result::Result<quota_failure::Violation, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            subject: self.subject.to_proto()?,
            description: self.description.to_proto()?,
            api_service: self.api_service.to_proto()?,
            quota_metric: self.quota_metric.to_proto()?,
            quota_id: self.quota_id.to_proto()?,
            quota_dimensions: self.quota_dimensions
                .into_iter()
                .map(|(k, v)| {
                    gaxi::prost::pair_transpose(k.to_proto(), v.to_proto())
                }).collect::<std::result::Result<std::collections::HashMap<_, _>, _>>()?,
            quota_value: self.quota_value.to_proto()?,
            future_quota_value: self.future_quota_value.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::quota_failure::Violation> for quota_failure::Violation {
    fn cnv(self) -> std::result::Result<rpc::model::quota_failure::Violation, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::quota_failure::Violation::new()
                .set_subject(self.subject)
                .set_description(self.description)
                .set_api_service(self.api_service)
                .set_quota_metric(self.quota_metric)
                .set_quota_id(self.quota_id)
                .set_quota_dimensions(self.quota_dimensions.into_iter()
                    .map(|(k, v)| {
                        gaxi::prost::pair_transpose(k.cnv(), v.cnv())
                    }).collect::<std::result::Result<std::collections::HashMap<_, _>, _>>()?)
                .set_quota_value(self.quota_value)
                .set_or_clear_future_quota_value(self.future_quota_value.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<QuotaFailure> for rpc::model::QuotaFailure {
    type Output = QuotaFailure;
    fn to_proto(self) -> std::result::Result<QuotaFailure, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            violations: self.violations
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::QuotaFailure> for QuotaFailure {
    fn cnv(self) -> std::result::Result<rpc::model::QuotaFailure, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::QuotaFailure::new()
                .set_violations(self.violations.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
        )
    }
}

impl gaxi::prost::ToProto<precondition_failure::Violation> for rpc::model::precondition_failure::Violation {
    type Output = precondition_failure::Violation;
    fn to_proto(self) -> std::result::Result<precondition_failure::Violation, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            r#type: self.r#type.to_proto()?,
            subject: self.subject.to_proto()?,
            description: self.description.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::precondition_failure::Violation> for precondition_failure::Violation {
    fn cnv(self) -> std::result::Result<rpc::model::precondition_failure::Violation, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::precondition_failure::Violation::new()
                .set_type(self.r#type)
                .set_subject(self.subject)
                .set_description(self.description)
        )
    }
}

impl gaxi::prost::ToProto<PreconditionFailure> for rpc::model::PreconditionFailure {
    type Output = PreconditionFailure;
    fn to_proto(self) -> std::result::Result<PreconditionFailure, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            violations: self.violations
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::PreconditionFailure> for PreconditionFailure {
    fn cnv(self) -> std::result::Result<rpc::model::PreconditionFailure, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::PreconditionFailure::new()
                .set_violations(self.violations.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
        )
    }
}

impl gaxi::prost::ToProto<bad_request::FieldViolation> for rpc::model::bad_request::FieldViolation {
    type Output = bad_request::FieldViolation;
    fn to_proto(self) -> std::result::Result<bad_request::FieldViolation, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            field: self.field.to_proto()?,
            description: self.description.to_proto()?,
            reason: self.reason.to_proto()?,
            localized_message: self.localized_message.map(|v| v.to_proto()).transpose()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::bad_request::FieldViolation> for bad_request::FieldViolation {
    fn cnv(self) -> std::result::Result<rpc::model::bad_request::FieldViolation, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::bad_request::FieldViolation::new()
                .set_field(self.field)
                .set_description(self.description)
                .set_reason(self.reason)
                .set_or_clear_localized_message(self.localized_message.map(|v| v.cnv()).transpose()?)
        )
    }
}

impl gaxi::prost::ToProto<BadRequest> for rpc::model::BadRequest {
    type Output = BadRequest;
    fn to_proto(self) -> std::result::Result<BadRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            field_violations: self.field_violations
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::BadRequest> for BadRequest {
    fn cnv(self) -> std::result::Result<rpc::model::BadRequest, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::BadRequest::new()
                .set_field_violations(self.field_violations.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
        )
    }
}

impl gaxi::prost::ToProto<RequestInfo> for rpc::model::RequestInfo {
    type Output = RequestInfo;
    fn to_proto(self) -> std::result::Result<RequestInfo, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            request_id: self.request_id.to_proto()?,
            serving_data: self.serving_data.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::RequestInfo> for RequestInfo {
    fn cnv(self) -> std::result::Result<rpc::model::RequestInfo, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::RequestInfo::new()
                .set_request_id(self.request_id)
                .set_serving_data(self.serving_data)
        )
    }
}

impl gaxi::prost::ToProto<ResourceInfo> for rpc::model::ResourceInfo {
    type Output = ResourceInfo;
    fn to_proto(self) -> std::result::Result<ResourceInfo, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            resource_type: self.resource_type.to_proto()?,
            resource_name: self.resource_name.to_proto()?,
            owner: self.owner.to_proto()?,
            description: self.description.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::ResourceInfo> for ResourceInfo {
    fn cnv(self) -> std::result::Result<rpc::model::ResourceInfo, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::ResourceInfo::new()
                .set_resource_type(self.resource_type)
                .set_resource_name(self.resource_name)
                .set_owner(self.owner)
                .set_description(self.description)
        )
    }
}

impl gaxi::prost::ToProto<help::Link> for rpc::model::help::Link {
    type Output = help::Link;
    fn to_proto(self) -> std::result::Result<help::Link, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            description: self.description.to_proto()?,
            url: self.url.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::help::Link> for help::Link {
    fn cnv(self) -> std::result::Result<rpc::model::help::Link, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::help::Link::new()
                .set_description(self.description)
                .set_url(self.url)
        )
    }
}

impl gaxi::prost::ToProto<Help> for rpc::model::Help {
    type Output = Help;
    fn to_proto(self) -> std::result::Result<Help, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            links: self.links
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::Help> for Help {
    fn cnv(self) -> std::result::Result<rpc::model::Help, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::Help::new()
                .set_links(self.links.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
        )
    }
}

impl gaxi::prost::ToProto<LocalizedMessage> for rpc::model::LocalizedMessage {
    type Output = LocalizedMessage;
    fn to_proto(self) -> std::result::Result<LocalizedMessage, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            locale: self.locale.to_proto()?,
            message: self.message.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::LocalizedMessage> for LocalizedMessage {
    fn cnv(self) -> std::result::Result<rpc::model::LocalizedMessage, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::LocalizedMessage::new()
                .set_locale(self.locale)
                .set_message(self.message)
        )
    }
}

impl gaxi::prost::ToProto<HttpRequest> for rpc::model::HttpRequest {
    type Output = HttpRequest;
    fn to_proto(self) -> std::result::Result<HttpRequest, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            method: self.method.to_proto()?,
            uri: self.uri.to_proto()?,
            headers: self.headers
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            body: self.body.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::HttpRequest> for HttpRequest {
    fn cnv(self) -> std::result::Result<rpc::model::HttpRequest, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::HttpRequest::new()
                .set_method(self.method)
                .set_uri(self.uri)
                .set_headers(self.headers.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_body(self.body)
        )
    }
}

impl gaxi::prost::ToProto<HttpResponse> for rpc::model::HttpResponse {
    type Output = HttpResponse;
    fn to_proto(self) -> std::result::Result<HttpResponse, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            status: self.status.to_proto()?,
            reason: self.reason.to_proto()?,
            headers: self.headers
                .into_iter()
                .map(|v| v.to_proto())
                .collect::<std::result::Result<std::vec::Vec<_>, _>>()?,
            body: self.body.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::HttpResponse> for HttpResponse {
    fn cnv(self) -> std::result::Result<rpc::model::HttpResponse, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::HttpResponse::new()
                .set_status(self.status)
                .set_reason(self.reason)
                .set_headers(self.headers.into_iter().map(|v| v.cnv())
                    .collect::<std::result::Result<std::vec::Vec<_>, _>>()?)
                .set_body(self.body)
        )
    }
}

impl gaxi::prost::ToProto<HttpHeader> for rpc::model::HttpHeader {
    type Output = HttpHeader;
    fn to_proto(self) -> std::result::Result<HttpHeader, gaxi::prost::ConvertError> {
        Ok(Self::Output {
            key: self.key.to_proto()?,
            value: self.value.to_proto()?,
        })
    }
}

impl gaxi::prost::FromProto<rpc::model::HttpHeader> for HttpHeader {
    fn cnv(self) -> std::result::Result<rpc::model::HttpHeader, gaxi::prost::ConvertError> {
        Ok(
            rpc::model::HttpHeader::new()
                .set_key(self.key)
                .set_value(self.value)
        )
    }
}
