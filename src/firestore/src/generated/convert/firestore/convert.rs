// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

impl wkt::prost::Convert<AggregationResult> for crate::generated::model::AggregationResult {
    fn cnv(self) -> AggregationResult {
        AggregationResult {
            aggregate_fields: self.aggregate_fields.into_iter().map(|(k, v)| (k.cnv(), v.cnv())).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::AggregationResult> for AggregationResult {
    fn cnv(self) -> crate::generated::model::AggregationResult {
        crate::generated::model::AggregationResult::new()
            .set_aggregate_fields(self.aggregate_fields.into_iter().map(|(k, v)| (k.cnv(), v.cnv())))
    }
}

impl wkt::prost::Convert<BitSequence> for crate::generated::model::BitSequence {
    fn cnv(self) -> BitSequence {
        BitSequence {
            bitmap: self.bitmap.cnv(),
            padding: self.padding.cnv(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::BitSequence> for BitSequence {
    fn cnv(self) -> crate::generated::model::BitSequence {
        crate::generated::model::BitSequence::new()
            .set_bitmap(self.bitmap)
            .set_padding(self.padding)
    }
}

impl wkt::prost::Convert<BloomFilter> for crate::generated::model::BloomFilter {
    fn cnv(self) -> BloomFilter {
        BloomFilter {
            bits: self.bits.map(|v| v.cnv()),
            hash_count: self.hash_count.cnv(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::BloomFilter> for BloomFilter {
    fn cnv(self) -> crate::generated::model::BloomFilter {
        crate::generated::model::BloomFilter::new()
            .set_bits(self.bits.map(|v| v.cnv()))
            .set_hash_count(self.hash_count)
    }
}

impl wkt::prost::Convert<DocumentMask> for crate::generated::model::DocumentMask {
    fn cnv(self) -> DocumentMask {
        DocumentMask {
            field_paths: self.field_paths.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::DocumentMask> for DocumentMask {
    fn cnv(self) -> crate::generated::model::DocumentMask {
        crate::generated::model::DocumentMask::new()
            .set_field_paths(self.field_paths.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::precondition::ConditionType> for precondition::ConditionType {
    fn cnv(self) -> crate::generated::model::precondition::ConditionType {
        use crate::generated::model::precondition::ConditionType as T;
        match self {
            Self::Exists(v) => T::from_exists(v.cnv()),
            Self::UpdateTime(v) => T::from_update_time(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<precondition::ConditionType> for crate::generated::model::precondition::ConditionType {
    fn cnv(self) -> precondition::ConditionType {
        use precondition::ConditionType as T;
        match self {
            Self::Exists(v) => T::Exists(v.cnv()),
            Self::UpdateTime(v) => T::UpdateTime((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<Precondition> for crate::generated::model::Precondition {
    fn cnv(self) -> Precondition {
        Precondition {
            condition_type: self.condition_type.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::Precondition> for Precondition {
    fn cnv(self) -> crate::generated::model::Precondition {
        crate::generated::model::Precondition::new()
            .set_condition_type(self.condition_type.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<transaction_options::ReadWrite> for crate::generated::model::transaction_options::ReadWrite {
    fn cnv(self) -> transaction_options::ReadWrite {
        transaction_options::ReadWrite {
            retry_transaction: self.retry_transaction.cnv(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::transaction_options::ReadWrite> for transaction_options::ReadWrite {
    fn cnv(self) -> crate::generated::model::transaction_options::ReadWrite {
        crate::generated::model::transaction_options::ReadWrite::new()
            .set_retry_transaction(self.retry_transaction)
    }
}

impl wkt::prost::Convert<crate::generated::model::transaction_options::read_only::ConsistencySelector> for transaction_options::read_only::ConsistencySelector {
    fn cnv(self) -> crate::generated::model::transaction_options::read_only::ConsistencySelector {
        use crate::generated::model::transaction_options::read_only::ConsistencySelector as T;
        match self {
            Self::ReadTime(v) => T::from_read_time(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<transaction_options::read_only::ConsistencySelector> for crate::generated::model::transaction_options::read_only::ConsistencySelector {
    fn cnv(self) -> transaction_options::read_only::ConsistencySelector {
        use transaction_options::read_only::ConsistencySelector as T;
        match self {
            Self::ReadTime(v) => T::ReadTime((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<transaction_options::ReadOnly> for crate::generated::model::transaction_options::ReadOnly {
    fn cnv(self) -> transaction_options::ReadOnly {
        transaction_options::ReadOnly {
            consistency_selector: self.consistency_selector.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::transaction_options::ReadOnly> for transaction_options::ReadOnly {
    fn cnv(self) -> crate::generated::model::transaction_options::ReadOnly {
        crate::generated::model::transaction_options::ReadOnly::new()
            .set_consistency_selector(self.consistency_selector.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::transaction_options::Mode> for transaction_options::Mode {
    fn cnv(self) -> crate::generated::model::transaction_options::Mode {
        use crate::generated::model::transaction_options::Mode as T;
        match self {
            Self::ReadOnly(v) => T::from_read_only(v.cnv()),
            Self::ReadWrite(v) => T::from_read_write(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<transaction_options::Mode> for crate::generated::model::transaction_options::Mode {
    fn cnv(self) -> transaction_options::Mode {
        use transaction_options::Mode as T;
        match self {
            Self::ReadOnly(v) => T::ReadOnly((*v).cnv()),
            Self::ReadWrite(v) => T::ReadWrite((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<TransactionOptions> for crate::generated::model::TransactionOptions {
    fn cnv(self) -> TransactionOptions {
        TransactionOptions {
            mode: self.mode.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::TransactionOptions> for TransactionOptions {
    fn cnv(self) -> crate::generated::model::TransactionOptions {
        crate::generated::model::TransactionOptions::new()
            .set_mode(self.mode.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<Document> for crate::generated::model::Document {
    fn cnv(self) -> Document {
        Document {
            name: self.name.cnv(),
            create_time: self.create_time.map(|v| v.cnv()),
            update_time: self.update_time.map(|v| v.cnv()),
            fields: self.fields.into_iter().map(|(k, v)| (k.cnv(), v.cnv())).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::Document> for Document {
    fn cnv(self) -> crate::generated::model::Document {
        crate::generated::model::Document::new()
            .set_name(self.name)
            .set_create_time(self.create_time.map(|v| v.cnv()))
            .set_update_time(self.update_time.map(|v| v.cnv()))
            .set_fields(self.fields.into_iter().map(|(k, v)| (k.cnv(), v.cnv())))
    }
}

impl wkt::prost::Convert<crate::generated::model::value::ValueType> for value::ValueType {
    fn cnv(self) -> crate::generated::model::value::ValueType {
        use crate::generated::model::value::ValueType as T;
        match self {
            Self::NullValue(v) => T::from_null_value(v.cnv()),
            Self::BooleanValue(v) => T::from_boolean_value(v.cnv()),
            Self::IntegerValue(v) => T::from_integer_value(v.cnv()),
            Self::DoubleValue(v) => T::from_double_value(v.cnv()),
            Self::TimestampValue(v) => T::from_timestamp_value(v.cnv()),
            Self::StringValue(v) => T::from_string_value(v.cnv()),
            Self::BytesValue(v) => T::from_bytes_value(v.cnv()),
            Self::ReferenceValue(v) => T::from_reference_value(v.cnv()),
            Self::GeoPointValue(v) => T::from_geo_point_value(v.cnv()),
            Self::ArrayValue(v) => T::from_array_value(v.cnv()),
            Self::MapValue(v) => T::from_map_value(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<value::ValueType> for crate::generated::model::value::ValueType {
    fn cnv(self) -> value::ValueType {
        use value::ValueType as T;
        match self {
            Self::NullValue(v) => T::NullValue(v.value()),
            Self::BooleanValue(v) => T::BooleanValue(v.cnv()),
            Self::IntegerValue(v) => T::IntegerValue(v.cnv()),
            Self::DoubleValue(v) => T::DoubleValue(v.cnv()),
            Self::TimestampValue(v) => T::TimestampValue((*v).cnv()),
            Self::StringValue(v) => T::StringValue(v.cnv()),
            Self::BytesValue(v) => T::BytesValue(v.cnv()),
            Self::ReferenceValue(v) => T::ReferenceValue(v.cnv()),
            Self::GeoPointValue(v) => T::GeoPointValue((*v).cnv()),
            Self::ArrayValue(v) => T::ArrayValue((*v).cnv()),
            Self::MapValue(v) => T::MapValue((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<Value> for crate::generated::model::Value {
    fn cnv(self) -> Value {
        Value {
            value_type: self.value_type.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::Value> for Value {
    fn cnv(self) -> crate::generated::model::Value {
        crate::generated::model::Value::new()
            .set_value_type(self.value_type.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<ArrayValue> for crate::generated::model::ArrayValue {
    fn cnv(self) -> ArrayValue {
        ArrayValue {
            values: self.values.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::ArrayValue> for ArrayValue {
    fn cnv(self) -> crate::generated::model::ArrayValue {
        crate::generated::model::ArrayValue::new()
            .set_values(self.values.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<MapValue> for crate::generated::model::MapValue {
    fn cnv(self) -> MapValue {
        MapValue {
            fields: self.fields.into_iter().map(|(k, v)| (k.cnv(), v.cnv())).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::MapValue> for MapValue {
    fn cnv(self) -> crate::generated::model::MapValue {
        crate::generated::model::MapValue::new()
            .set_fields(self.fields.into_iter().map(|(k, v)| (k.cnv(), v.cnv())))
    }
}

impl wkt::prost::Convert<crate::generated::model::get_document_request::ConsistencySelector> for get_document_request::ConsistencySelector {
    fn cnv(self) -> crate::generated::model::get_document_request::ConsistencySelector {
        use crate::generated::model::get_document_request::ConsistencySelector as T;
        match self {
            Self::Transaction(v) => T::from_transaction(v.cnv()),
            Self::ReadTime(v) => T::from_read_time(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<get_document_request::ConsistencySelector> for crate::generated::model::get_document_request::ConsistencySelector {
    fn cnv(self) -> get_document_request::ConsistencySelector {
        use get_document_request::ConsistencySelector as T;
        match self {
            Self::Transaction(v) => T::Transaction(v.cnv()),
            Self::ReadTime(v) => T::ReadTime((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<GetDocumentRequest> for crate::generated::model::GetDocumentRequest {
    fn cnv(self) -> GetDocumentRequest {
        GetDocumentRequest {
            name: self.name.cnv(),
            mask: self.mask.map(|v| v.cnv()),
            consistency_selector: self.consistency_selector.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::GetDocumentRequest> for GetDocumentRequest {
    fn cnv(self) -> crate::generated::model::GetDocumentRequest {
        crate::generated::model::GetDocumentRequest::new()
            .set_name(self.name)
            .set_mask(self.mask.map(|v| v.cnv()))
            .set_consistency_selector(self.consistency_selector.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::list_documents_request::ConsistencySelector> for list_documents_request::ConsistencySelector {
    fn cnv(self) -> crate::generated::model::list_documents_request::ConsistencySelector {
        use crate::generated::model::list_documents_request::ConsistencySelector as T;
        match self {
            Self::Transaction(v) => T::from_transaction(v.cnv()),
            Self::ReadTime(v) => T::from_read_time(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<list_documents_request::ConsistencySelector> for crate::generated::model::list_documents_request::ConsistencySelector {
    fn cnv(self) -> list_documents_request::ConsistencySelector {
        use list_documents_request::ConsistencySelector as T;
        match self {
            Self::Transaction(v) => T::Transaction(v.cnv()),
            Self::ReadTime(v) => T::ReadTime((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<ListDocumentsRequest> for crate::generated::model::ListDocumentsRequest {
    fn cnv(self) -> ListDocumentsRequest {
        ListDocumentsRequest {
            parent: self.parent.cnv(),
            collection_id: self.collection_id.cnv(),
            page_size: self.page_size.cnv(),
            page_token: self.page_token.cnv(),
            order_by: self.order_by.cnv(),
            mask: self.mask.map(|v| v.cnv()),
            show_missing: self.show_missing.cnv(),
            consistency_selector: self.consistency_selector.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::ListDocumentsRequest> for ListDocumentsRequest {
    fn cnv(self) -> crate::generated::model::ListDocumentsRequest {
        crate::generated::model::ListDocumentsRequest::new()
            .set_parent(self.parent)
            .set_collection_id(self.collection_id)
            .set_page_size(self.page_size)
            .set_page_token(self.page_token)
            .set_order_by(self.order_by)
            .set_mask(self.mask.map(|v| v.cnv()))
            .set_show_missing(self.show_missing)
            .set_consistency_selector(self.consistency_selector.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<ListDocumentsResponse> for crate::generated::model::ListDocumentsResponse {
    fn cnv(self) -> ListDocumentsResponse {
        ListDocumentsResponse {
            next_page_token: self.next_page_token.cnv(),
            documents: self.documents.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::ListDocumentsResponse> for ListDocumentsResponse {
    fn cnv(self) -> crate::generated::model::ListDocumentsResponse {
        crate::generated::model::ListDocumentsResponse::new()
            .set_next_page_token(self.next_page_token)
            .set_documents(self.documents.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<CreateDocumentRequest> for crate::generated::model::CreateDocumentRequest {
    fn cnv(self) -> CreateDocumentRequest {
        CreateDocumentRequest {
            parent: self.parent.cnv(),
            collection_id: self.collection_id.cnv(),
            document_id: self.document_id.cnv(),
            document: self.document.map(|v| v.cnv()),
            mask: self.mask.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::CreateDocumentRequest> for CreateDocumentRequest {
    fn cnv(self) -> crate::generated::model::CreateDocumentRequest {
        crate::generated::model::CreateDocumentRequest::new()
            .set_parent(self.parent)
            .set_collection_id(self.collection_id)
            .set_document_id(self.document_id)
            .set_document(self.document.map(|v| v.cnv()))
            .set_mask(self.mask.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<UpdateDocumentRequest> for crate::generated::model::UpdateDocumentRequest {
    fn cnv(self) -> UpdateDocumentRequest {
        UpdateDocumentRequest {
            document: self.document.map(|v| v.cnv()),
            update_mask: self.update_mask.map(|v| v.cnv()),
            mask: self.mask.map(|v| v.cnv()),
            current_document: self.current_document.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::UpdateDocumentRequest> for UpdateDocumentRequest {
    fn cnv(self) -> crate::generated::model::UpdateDocumentRequest {
        crate::generated::model::UpdateDocumentRequest::new()
            .set_document(self.document.map(|v| v.cnv()))
            .set_update_mask(self.update_mask.map(|v| v.cnv()))
            .set_mask(self.mask.map(|v| v.cnv()))
            .set_current_document(self.current_document.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<DeleteDocumentRequest> for crate::generated::model::DeleteDocumentRequest {
    fn cnv(self) -> DeleteDocumentRequest {
        DeleteDocumentRequest {
            name: self.name.cnv(),
            current_document: self.current_document.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::DeleteDocumentRequest> for DeleteDocumentRequest {
    fn cnv(self) -> crate::generated::model::DeleteDocumentRequest {
        crate::generated::model::DeleteDocumentRequest::new()
            .set_name(self.name)
            .set_current_document(self.current_document.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::batch_get_documents_request::ConsistencySelector> for batch_get_documents_request::ConsistencySelector {
    fn cnv(self) -> crate::generated::model::batch_get_documents_request::ConsistencySelector {
        use crate::generated::model::batch_get_documents_request::ConsistencySelector as T;
        match self {
            Self::Transaction(v) => T::from_transaction(v.cnv()),
            Self::NewTransaction(v) => T::from_new_transaction(v.cnv()),
            Self::ReadTime(v) => T::from_read_time(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<batch_get_documents_request::ConsistencySelector> for crate::generated::model::batch_get_documents_request::ConsistencySelector {
    fn cnv(self) -> batch_get_documents_request::ConsistencySelector {
        use batch_get_documents_request::ConsistencySelector as T;
        match self {
            Self::Transaction(v) => T::Transaction(v.cnv()),
            Self::NewTransaction(v) => T::NewTransaction((*v).cnv()),
            Self::ReadTime(v) => T::ReadTime((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<BatchGetDocumentsRequest> for crate::generated::model::BatchGetDocumentsRequest {
    fn cnv(self) -> BatchGetDocumentsRequest {
        BatchGetDocumentsRequest {
            database: self.database.cnv(),
            mask: self.mask.map(|v| v.cnv()),
            documents: self.documents.into_iter().map(|v| v.cnv()).collect(),
            consistency_selector: self.consistency_selector.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::BatchGetDocumentsRequest> for BatchGetDocumentsRequest {
    fn cnv(self) -> crate::generated::model::BatchGetDocumentsRequest {
        crate::generated::model::BatchGetDocumentsRequest::new()
            .set_database(self.database)
            .set_mask(self.mask.map(|v| v.cnv()))
            .set_documents(self.documents.into_iter().map(|v| v.cnv()))
            .set_consistency_selector(self.consistency_selector.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::batch_get_documents_response::Result> for batch_get_documents_response::Result {
    fn cnv(self) -> crate::generated::model::batch_get_documents_response::Result {
        use crate::generated::model::batch_get_documents_response::Result as T;
        match self {
            Self::Found(v) => T::from_found(v.cnv()),
            Self::Missing(v) => T::from_missing(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<batch_get_documents_response::Result> for crate::generated::model::batch_get_documents_response::Result {
    fn cnv(self) -> batch_get_documents_response::Result {
        use batch_get_documents_response::Result as T;
        match self {
            Self::Found(v) => T::Found((*v).cnv()),
            Self::Missing(v) => T::Missing(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<BatchGetDocumentsResponse> for crate::generated::model::BatchGetDocumentsResponse {
    fn cnv(self) -> BatchGetDocumentsResponse {
        BatchGetDocumentsResponse {
            transaction: self.transaction.cnv(),
            read_time: self.read_time.map(|v| v.cnv()),
            result: self.result.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::BatchGetDocumentsResponse> for BatchGetDocumentsResponse {
    fn cnv(self) -> crate::generated::model::BatchGetDocumentsResponse {
        crate::generated::model::BatchGetDocumentsResponse::new()
            .set_transaction(self.transaction)
            .set_read_time(self.read_time.map(|v| v.cnv()))
            .set_result(self.result.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<BeginTransactionRequest> for crate::generated::model::BeginTransactionRequest {
    fn cnv(self) -> BeginTransactionRequest {
        BeginTransactionRequest {
            database: self.database.cnv(),
            options: self.options.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::BeginTransactionRequest> for BeginTransactionRequest {
    fn cnv(self) -> crate::generated::model::BeginTransactionRequest {
        crate::generated::model::BeginTransactionRequest::new()
            .set_database(self.database)
            .set_options(self.options.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<BeginTransactionResponse> for crate::generated::model::BeginTransactionResponse {
    fn cnv(self) -> BeginTransactionResponse {
        BeginTransactionResponse {
            transaction: self.transaction.cnv(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::BeginTransactionResponse> for BeginTransactionResponse {
    fn cnv(self) -> crate::generated::model::BeginTransactionResponse {
        crate::generated::model::BeginTransactionResponse::new()
            .set_transaction(self.transaction)
    }
}

impl wkt::prost::Convert<CommitRequest> for crate::generated::model::CommitRequest {
    fn cnv(self) -> CommitRequest {
        CommitRequest {
            database: self.database.cnv(),
            transaction: self.transaction.cnv(),
            writes: self.writes.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::CommitRequest> for CommitRequest {
    fn cnv(self) -> crate::generated::model::CommitRequest {
        crate::generated::model::CommitRequest::new()
            .set_database(self.database)
            .set_transaction(self.transaction)
            .set_writes(self.writes.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<CommitResponse> for crate::generated::model::CommitResponse {
    fn cnv(self) -> CommitResponse {
        CommitResponse {
            commit_time: self.commit_time.map(|v| v.cnv()),
            write_results: self.write_results.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::CommitResponse> for CommitResponse {
    fn cnv(self) -> crate::generated::model::CommitResponse {
        crate::generated::model::CommitResponse::new()
            .set_commit_time(self.commit_time.map(|v| v.cnv()))
            .set_write_results(self.write_results.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<RollbackRequest> for crate::generated::model::RollbackRequest {
    fn cnv(self) -> RollbackRequest {
        RollbackRequest {
            database: self.database.cnv(),
            transaction: self.transaction.cnv(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::RollbackRequest> for RollbackRequest {
    fn cnv(self) -> crate::generated::model::RollbackRequest {
        crate::generated::model::RollbackRequest::new()
            .set_database(self.database)
            .set_transaction(self.transaction)
    }
}

impl wkt::prost::Convert<crate::generated::model::run_query_request::QueryType> for run_query_request::QueryType {
    fn cnv(self) -> crate::generated::model::run_query_request::QueryType {
        use crate::generated::model::run_query_request::QueryType as T;
        match self {
            Self::StructuredQuery(v) => T::from_structured_query(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<run_query_request::QueryType> for crate::generated::model::run_query_request::QueryType {
    fn cnv(self) -> run_query_request::QueryType {
        use run_query_request::QueryType as T;
        match self {
            Self::StructuredQuery(v) => T::StructuredQuery((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::run_query_request::ConsistencySelector> for run_query_request::ConsistencySelector {
    fn cnv(self) -> crate::generated::model::run_query_request::ConsistencySelector {
        use crate::generated::model::run_query_request::ConsistencySelector as T;
        match self {
            Self::Transaction(v) => T::from_transaction(v.cnv()),
            Self::NewTransaction(v) => T::from_new_transaction(v.cnv()),
            Self::ReadTime(v) => T::from_read_time(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<run_query_request::ConsistencySelector> for crate::generated::model::run_query_request::ConsistencySelector {
    fn cnv(self) -> run_query_request::ConsistencySelector {
        use run_query_request::ConsistencySelector as T;
        match self {
            Self::Transaction(v) => T::Transaction(v.cnv()),
            Self::NewTransaction(v) => T::NewTransaction((*v).cnv()),
            Self::ReadTime(v) => T::ReadTime((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<RunQueryRequest> for crate::generated::model::RunQueryRequest {
    fn cnv(self) -> RunQueryRequest {
        RunQueryRequest {
            parent: self.parent.cnv(),
            explain_options: self.explain_options.map(|v| v.cnv()),
            query_type: self.query_type.map(|v| v.cnv()),
            consistency_selector: self.consistency_selector.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::RunQueryRequest> for RunQueryRequest {
    fn cnv(self) -> crate::generated::model::RunQueryRequest {
        crate::generated::model::RunQueryRequest::new()
            .set_parent(self.parent)
            .set_explain_options(self.explain_options.map(|v| v.cnv()))
            .set_query_type(self.query_type.map(|v| v.cnv()))
            .set_consistency_selector(self.consistency_selector.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::run_query_response::ContinuationSelector> for run_query_response::ContinuationSelector {
    fn cnv(self) -> crate::generated::model::run_query_response::ContinuationSelector {
        use crate::generated::model::run_query_response::ContinuationSelector as T;
        match self {
            Self::Done(v) => T::from_done(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<run_query_response::ContinuationSelector> for crate::generated::model::run_query_response::ContinuationSelector {
    fn cnv(self) -> run_query_response::ContinuationSelector {
        use run_query_response::ContinuationSelector as T;
        match self {
            Self::Done(v) => T::Done(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<RunQueryResponse> for crate::generated::model::RunQueryResponse {
    fn cnv(self) -> RunQueryResponse {
        RunQueryResponse {
            transaction: self.transaction.cnv(),
            document: self.document.map(|v| v.cnv()),
            read_time: self.read_time.map(|v| v.cnv()),
            skipped_results: self.skipped_results.cnv(),
            explain_metrics: self.explain_metrics.map(|v| v.cnv()),
            continuation_selector: self.continuation_selector.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::RunQueryResponse> for RunQueryResponse {
    fn cnv(self) -> crate::generated::model::RunQueryResponse {
        crate::generated::model::RunQueryResponse::new()
            .set_transaction(self.transaction)
            .set_document(self.document.map(|v| v.cnv()))
            .set_read_time(self.read_time.map(|v| v.cnv()))
            .set_skipped_results(self.skipped_results)
            .set_explain_metrics(self.explain_metrics.map(|v| v.cnv()))
            .set_continuation_selector(self.continuation_selector.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::run_aggregation_query_request::QueryType> for run_aggregation_query_request::QueryType {
    fn cnv(self) -> crate::generated::model::run_aggregation_query_request::QueryType {
        use crate::generated::model::run_aggregation_query_request::QueryType as T;
        match self {
            Self::StructuredAggregationQuery(v) => T::from_structured_aggregation_query(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<run_aggregation_query_request::QueryType> for crate::generated::model::run_aggregation_query_request::QueryType {
    fn cnv(self) -> run_aggregation_query_request::QueryType {
        use run_aggregation_query_request::QueryType as T;
        match self {
            Self::StructuredAggregationQuery(v) => T::StructuredAggregationQuery((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::run_aggregation_query_request::ConsistencySelector> for run_aggregation_query_request::ConsistencySelector {
    fn cnv(self) -> crate::generated::model::run_aggregation_query_request::ConsistencySelector {
        use crate::generated::model::run_aggregation_query_request::ConsistencySelector as T;
        match self {
            Self::Transaction(v) => T::from_transaction(v.cnv()),
            Self::NewTransaction(v) => T::from_new_transaction(v.cnv()),
            Self::ReadTime(v) => T::from_read_time(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<run_aggregation_query_request::ConsistencySelector> for crate::generated::model::run_aggregation_query_request::ConsistencySelector {
    fn cnv(self) -> run_aggregation_query_request::ConsistencySelector {
        use run_aggregation_query_request::ConsistencySelector as T;
        match self {
            Self::Transaction(v) => T::Transaction(v.cnv()),
            Self::NewTransaction(v) => T::NewTransaction((*v).cnv()),
            Self::ReadTime(v) => T::ReadTime((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<RunAggregationQueryRequest> for crate::generated::model::RunAggregationQueryRequest {
    fn cnv(self) -> RunAggregationQueryRequest {
        RunAggregationQueryRequest {
            parent: self.parent.cnv(),
            explain_options: self.explain_options.map(|v| v.cnv()),
            query_type: self.query_type.map(|v| v.cnv()),
            consistency_selector: self.consistency_selector.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::RunAggregationQueryRequest> for RunAggregationQueryRequest {
    fn cnv(self) -> crate::generated::model::RunAggregationQueryRequest {
        crate::generated::model::RunAggregationQueryRequest::new()
            .set_parent(self.parent)
            .set_explain_options(self.explain_options.map(|v| v.cnv()))
            .set_query_type(self.query_type.map(|v| v.cnv()))
            .set_consistency_selector(self.consistency_selector.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<RunAggregationQueryResponse> for crate::generated::model::RunAggregationQueryResponse {
    fn cnv(self) -> RunAggregationQueryResponse {
        RunAggregationQueryResponse {
            result: self.result.map(|v| v.cnv()),
            transaction: self.transaction.cnv(),
            read_time: self.read_time.map(|v| v.cnv()),
            explain_metrics: self.explain_metrics.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::RunAggregationQueryResponse> for RunAggregationQueryResponse {
    fn cnv(self) -> crate::generated::model::RunAggregationQueryResponse {
        crate::generated::model::RunAggregationQueryResponse::new()
            .set_result(self.result.map(|v| v.cnv()))
            .set_transaction(self.transaction)
            .set_read_time(self.read_time.map(|v| v.cnv()))
            .set_explain_metrics(self.explain_metrics.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::partition_query_request::QueryType> for partition_query_request::QueryType {
    fn cnv(self) -> crate::generated::model::partition_query_request::QueryType {
        use crate::generated::model::partition_query_request::QueryType as T;
        match self {
            Self::StructuredQuery(v) => T::from_structured_query(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<partition_query_request::QueryType> for crate::generated::model::partition_query_request::QueryType {
    fn cnv(self) -> partition_query_request::QueryType {
        use partition_query_request::QueryType as T;
        match self {
            Self::StructuredQuery(v) => T::StructuredQuery((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::partition_query_request::ConsistencySelector> for partition_query_request::ConsistencySelector {
    fn cnv(self) -> crate::generated::model::partition_query_request::ConsistencySelector {
        use crate::generated::model::partition_query_request::ConsistencySelector as T;
        match self {
            Self::ReadTime(v) => T::from_read_time(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<partition_query_request::ConsistencySelector> for crate::generated::model::partition_query_request::ConsistencySelector {
    fn cnv(self) -> partition_query_request::ConsistencySelector {
        use partition_query_request::ConsistencySelector as T;
        match self {
            Self::ReadTime(v) => T::ReadTime((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<PartitionQueryRequest> for crate::generated::model::PartitionQueryRequest {
    fn cnv(self) -> PartitionQueryRequest {
        PartitionQueryRequest {
            parent: self.parent.cnv(),
            partition_count: self.partition_count.cnv(),
            page_token: self.page_token.cnv(),
            page_size: self.page_size.cnv(),
            query_type: self.query_type.map(|v| v.cnv()),
            consistency_selector: self.consistency_selector.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::PartitionQueryRequest> for PartitionQueryRequest {
    fn cnv(self) -> crate::generated::model::PartitionQueryRequest {
        crate::generated::model::PartitionQueryRequest::new()
            .set_parent(self.parent)
            .set_partition_count(self.partition_count)
            .set_page_token(self.page_token)
            .set_page_size(self.page_size)
            .set_query_type(self.query_type.map(|v| v.cnv()))
            .set_consistency_selector(self.consistency_selector.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<PartitionQueryResponse> for crate::generated::model::PartitionQueryResponse {
    fn cnv(self) -> PartitionQueryResponse {
        PartitionQueryResponse {
            next_page_token: self.next_page_token.cnv(),
            partitions: self.partitions.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::PartitionQueryResponse> for PartitionQueryResponse {
    fn cnv(self) -> crate::generated::model::PartitionQueryResponse {
        crate::generated::model::PartitionQueryResponse::new()
            .set_next_page_token(self.next_page_token)
            .set_partitions(self.partitions.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<WriteRequest> for crate::generated::model::WriteRequest {
    fn cnv(self) -> WriteRequest {
        WriteRequest {
            database: self.database.cnv(),
            stream_id: self.stream_id.cnv(),
            stream_token: self.stream_token.cnv(),
            writes: self.writes.into_iter().map(|v| v.cnv()).collect(),
            labels: self.labels.into_iter().map(|(k, v)| (k.cnv(), v.cnv())).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::WriteRequest> for WriteRequest {
    fn cnv(self) -> crate::generated::model::WriteRequest {
        crate::generated::model::WriteRequest::new()
            .set_database(self.database)
            .set_stream_id(self.stream_id)
            .set_stream_token(self.stream_token)
            .set_writes(self.writes.into_iter().map(|v| v.cnv()))
            .set_labels(self.labels.into_iter().map(|(k, v)| (k.cnv(), v.cnv())))
    }
}

impl wkt::prost::Convert<WriteResponse> for crate::generated::model::WriteResponse {
    fn cnv(self) -> WriteResponse {
        WriteResponse {
            stream_id: self.stream_id.cnv(),
            stream_token: self.stream_token.cnv(),
            commit_time: self.commit_time.map(|v| v.cnv()),
            write_results: self.write_results.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::WriteResponse> for WriteResponse {
    fn cnv(self) -> crate::generated::model::WriteResponse {
        crate::generated::model::WriteResponse::new()
            .set_stream_id(self.stream_id)
            .set_stream_token(self.stream_token)
            .set_commit_time(self.commit_time.map(|v| v.cnv()))
            .set_write_results(self.write_results.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::listen_request::TargetChange> for listen_request::TargetChange {
    fn cnv(self) -> crate::generated::model::listen_request::TargetChange {
        use crate::generated::model::listen_request::TargetChange as T;
        match self {
            Self::AddTarget(v) => T::from_add_target(v.cnv()),
            Self::RemoveTarget(v) => T::from_remove_target(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<listen_request::TargetChange> for crate::generated::model::listen_request::TargetChange {
    fn cnv(self) -> listen_request::TargetChange {
        use listen_request::TargetChange as T;
        match self {
            Self::AddTarget(v) => T::AddTarget((*v).cnv()),
            Self::RemoveTarget(v) => T::RemoveTarget(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<ListenRequest> for crate::generated::model::ListenRequest {
    fn cnv(self) -> ListenRequest {
        ListenRequest {
            database: self.database.cnv(),
            labels: self.labels.into_iter().map(|(k, v)| (k.cnv(), v.cnv())).collect(),
            target_change: self.target_change.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::ListenRequest> for ListenRequest {
    fn cnv(self) -> crate::generated::model::ListenRequest {
        crate::generated::model::ListenRequest::new()
            .set_database(self.database)
            .set_labels(self.labels.into_iter().map(|(k, v)| (k.cnv(), v.cnv())))
            .set_target_change(self.target_change.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::listen_response::ResponseType> for listen_response::ResponseType {
    fn cnv(self) -> crate::generated::model::listen_response::ResponseType {
        use crate::generated::model::listen_response::ResponseType as T;
        match self {
            Self::TargetChange(v) => T::from_target_change(v.cnv()),
            Self::DocumentChange(v) => T::from_document_change(v.cnv()),
            Self::DocumentDelete(v) => T::from_document_delete(v.cnv()),
            Self::DocumentRemove(v) => T::from_document_remove(v.cnv()),
            Self::Filter(v) => T::from_filter(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<listen_response::ResponseType> for crate::generated::model::listen_response::ResponseType {
    fn cnv(self) -> listen_response::ResponseType {
        use listen_response::ResponseType as T;
        match self {
            Self::TargetChange(v) => T::TargetChange((*v).cnv()),
            Self::DocumentChange(v) => T::DocumentChange((*v).cnv()),
            Self::DocumentDelete(v) => T::DocumentDelete((*v).cnv()),
            Self::DocumentRemove(v) => T::DocumentRemove((*v).cnv()),
            Self::Filter(v) => T::Filter((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<ListenResponse> for crate::generated::model::ListenResponse {
    fn cnv(self) -> ListenResponse {
        ListenResponse {
            response_type: self.response_type.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::ListenResponse> for ListenResponse {
    fn cnv(self) -> crate::generated::model::ListenResponse {
        crate::generated::model::ListenResponse::new()
            .set_response_type(self.response_type.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<target::DocumentsTarget> for crate::generated::model::target::DocumentsTarget {
    fn cnv(self) -> target::DocumentsTarget {
        target::DocumentsTarget {
            documents: self.documents.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::target::DocumentsTarget> for target::DocumentsTarget {
    fn cnv(self) -> crate::generated::model::target::DocumentsTarget {
        crate::generated::model::target::DocumentsTarget::new()
            .set_documents(self.documents.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::target::query_target::QueryType> for target::query_target::QueryType {
    fn cnv(self) -> crate::generated::model::target::query_target::QueryType {
        use crate::generated::model::target::query_target::QueryType as T;
        match self {
            Self::StructuredQuery(v) => T::from_structured_query(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<target::query_target::QueryType> for crate::generated::model::target::query_target::QueryType {
    fn cnv(self) -> target::query_target::QueryType {
        use target::query_target::QueryType as T;
        match self {
            Self::StructuredQuery(v) => T::StructuredQuery((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<target::QueryTarget> for crate::generated::model::target::QueryTarget {
    fn cnv(self) -> target::QueryTarget {
        target::QueryTarget {
            parent: self.parent.cnv(),
            query_type: self.query_type.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::target::QueryTarget> for target::QueryTarget {
    fn cnv(self) -> crate::generated::model::target::QueryTarget {
        crate::generated::model::target::QueryTarget::new()
            .set_parent(self.parent)
            .set_query_type(self.query_type.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::target::TargetType> for target::TargetType {
    fn cnv(self) -> crate::generated::model::target::TargetType {
        use crate::generated::model::target::TargetType as T;
        match self {
            Self::Query(v) => T::from_query(v.cnv()),
            Self::Documents(v) => T::from_documents(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<target::TargetType> for crate::generated::model::target::TargetType {
    fn cnv(self) -> target::TargetType {
        use target::TargetType as T;
        match self {
            Self::Query(v) => T::Query((*v).cnv()),
            Self::Documents(v) => T::Documents((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::target::ResumeType> for target::ResumeType {
    fn cnv(self) -> crate::generated::model::target::ResumeType {
        use crate::generated::model::target::ResumeType as T;
        match self {
            Self::ResumeToken(v) => T::from_resume_token(v.cnv()),
            Self::ReadTime(v) => T::from_read_time(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<target::ResumeType> for crate::generated::model::target::ResumeType {
    fn cnv(self) -> target::ResumeType {
        use target::ResumeType as T;
        match self {
            Self::ResumeToken(v) => T::ResumeToken(v.cnv()),
            Self::ReadTime(v) => T::ReadTime((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<Target> for crate::generated::model::Target {
    fn cnv(self) -> Target {
        Target {
            target_id: self.target_id.cnv(),
            once: self.once.cnv(),
            expected_count: self.expected_count.map(|v| v.cnv()),
            target_type: self.target_type.map(|v| v.cnv()),
            resume_type: self.resume_type.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::Target> for Target {
    fn cnv(self) -> crate::generated::model::Target {
        crate::generated::model::Target::new()
            .set_target_id(self.target_id)
            .set_once(self.once)
            .set_expected_count(self.expected_count.map(|v| v.cnv()))
            .set_target_type(self.target_type.map(|v| v.cnv()))
            .set_resume_type(self.resume_type.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<TargetChange> for crate::generated::model::TargetChange {
    fn cnv(self) -> TargetChange {
        TargetChange {
            target_change_type: self.target_change_type.value(),
            cause: self.cause.map(|v| v.cnv()),
            resume_token: self.resume_token.cnv(),
            read_time: self.read_time.map(|v| v.cnv()),
            target_ids: self.target_ids.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::TargetChange> for TargetChange {
    fn cnv(self) -> crate::generated::model::TargetChange {
        crate::generated::model::TargetChange::new()
            .set_target_change_type(self.target_change_type)
            .set_cause(self.cause.map(|v| v.cnv()))
            .set_resume_token(self.resume_token)
            .set_read_time(self.read_time.map(|v| v.cnv()))
            .set_target_ids(self.target_ids.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::list_collection_ids_request::ConsistencySelector> for list_collection_ids_request::ConsistencySelector {
    fn cnv(self) -> crate::generated::model::list_collection_ids_request::ConsistencySelector {
        use crate::generated::model::list_collection_ids_request::ConsistencySelector as T;
        match self {
            Self::ReadTime(v) => T::from_read_time(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<list_collection_ids_request::ConsistencySelector> for crate::generated::model::list_collection_ids_request::ConsistencySelector {
    fn cnv(self) -> list_collection_ids_request::ConsistencySelector {
        use list_collection_ids_request::ConsistencySelector as T;
        match self {
            Self::ReadTime(v) => T::ReadTime((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<ListCollectionIdsRequest> for crate::generated::model::ListCollectionIdsRequest {
    fn cnv(self) -> ListCollectionIdsRequest {
        ListCollectionIdsRequest {
            parent: self.parent.cnv(),
            page_size: self.page_size.cnv(),
            page_token: self.page_token.cnv(),
            consistency_selector: self.consistency_selector.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::ListCollectionIdsRequest> for ListCollectionIdsRequest {
    fn cnv(self) -> crate::generated::model::ListCollectionIdsRequest {
        crate::generated::model::ListCollectionIdsRequest::new()
            .set_parent(self.parent)
            .set_page_size(self.page_size)
            .set_page_token(self.page_token)
            .set_consistency_selector(self.consistency_selector.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<ListCollectionIdsResponse> for crate::generated::model::ListCollectionIdsResponse {
    fn cnv(self) -> ListCollectionIdsResponse {
        ListCollectionIdsResponse {
            next_page_token: self.next_page_token.cnv(),
            collection_ids: self.collection_ids.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::ListCollectionIdsResponse> for ListCollectionIdsResponse {
    fn cnv(self) -> crate::generated::model::ListCollectionIdsResponse {
        crate::generated::model::ListCollectionIdsResponse::new()
            .set_next_page_token(self.next_page_token)
            .set_collection_ids(self.collection_ids.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<BatchWriteRequest> for crate::generated::model::BatchWriteRequest {
    fn cnv(self) -> BatchWriteRequest {
        BatchWriteRequest {
            database: self.database.cnv(),
            writes: self.writes.into_iter().map(|v| v.cnv()).collect(),
            labels: self.labels.into_iter().map(|(k, v)| (k.cnv(), v.cnv())).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::BatchWriteRequest> for BatchWriteRequest {
    fn cnv(self) -> crate::generated::model::BatchWriteRequest {
        crate::generated::model::BatchWriteRequest::new()
            .set_database(self.database)
            .set_writes(self.writes.into_iter().map(|v| v.cnv()))
            .set_labels(self.labels.into_iter().map(|(k, v)| (k.cnv(), v.cnv())))
    }
}

impl wkt::prost::Convert<BatchWriteResponse> for crate::generated::model::BatchWriteResponse {
    fn cnv(self) -> BatchWriteResponse {
        BatchWriteResponse {
            write_results: self.write_results.into_iter().map(|v| v.cnv()).collect(),
            status: self.status.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::BatchWriteResponse> for BatchWriteResponse {
    fn cnv(self) -> crate::generated::model::BatchWriteResponse {
        crate::generated::model::BatchWriteResponse::new()
            .set_write_results(self.write_results.into_iter().map(|v| v.cnv()))
            .set_status(self.status.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<structured_query::CollectionSelector> for crate::generated::model::structured_query::CollectionSelector {
    fn cnv(self) -> structured_query::CollectionSelector {
        structured_query::CollectionSelector {
            collection_id: self.collection_id.cnv(),
            all_descendants: self.all_descendants.cnv(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_query::CollectionSelector> for structured_query::CollectionSelector {
    fn cnv(self) -> crate::generated::model::structured_query::CollectionSelector {
        crate::generated::model::structured_query::CollectionSelector::new()
            .set_collection_id(self.collection_id)
            .set_all_descendants(self.all_descendants)
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_query::filter::FilterType> for structured_query::filter::FilterType {
    fn cnv(self) -> crate::generated::model::structured_query::filter::FilterType {
        use crate::generated::model::structured_query::filter::FilterType as T;
        match self {
            Self::CompositeFilter(v) => T::from_composite_filter(v.cnv()),
            Self::FieldFilter(v) => T::from_field_filter(v.cnv()),
            Self::UnaryFilter(v) => T::from_unary_filter(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<structured_query::filter::FilterType> for crate::generated::model::structured_query::filter::FilterType {
    fn cnv(self) -> structured_query::filter::FilterType {
        use structured_query::filter::FilterType as T;
        match self {
            Self::CompositeFilter(v) => T::CompositeFilter((*v).cnv()),
            Self::FieldFilter(v) => T::FieldFilter((*v).cnv()),
            Self::UnaryFilter(v) => T::UnaryFilter((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<structured_query::Filter> for crate::generated::model::structured_query::Filter {
    fn cnv(self) -> structured_query::Filter {
        structured_query::Filter {
            filter_type: self.filter_type.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_query::Filter> for structured_query::Filter {
    fn cnv(self) -> crate::generated::model::structured_query::Filter {
        crate::generated::model::structured_query::Filter::new()
            .set_filter_type(self.filter_type.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<structured_query::CompositeFilter> for crate::generated::model::structured_query::CompositeFilter {
    fn cnv(self) -> structured_query::CompositeFilter {
        structured_query::CompositeFilter {
            op: self.op.value(),
            filters: self.filters.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_query::CompositeFilter> for structured_query::CompositeFilter {
    fn cnv(self) -> crate::generated::model::structured_query::CompositeFilter {
        crate::generated::model::structured_query::CompositeFilter::new()
            .set_op(self.op)
            .set_filters(self.filters.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<structured_query::FieldFilter> for crate::generated::model::structured_query::FieldFilter {
    fn cnv(self) -> structured_query::FieldFilter {
        structured_query::FieldFilter {
            field: self.field.map(|v| v.cnv()),
            op: self.op.value(),
            value: self.value.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_query::FieldFilter> for structured_query::FieldFilter {
    fn cnv(self) -> crate::generated::model::structured_query::FieldFilter {
        crate::generated::model::structured_query::FieldFilter::new()
            .set_field(self.field.map(|v| v.cnv()))
            .set_op(self.op)
            .set_value(self.value.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_query::unary_filter::OperandType> for structured_query::unary_filter::OperandType {
    fn cnv(self) -> crate::generated::model::structured_query::unary_filter::OperandType {
        use crate::generated::model::structured_query::unary_filter::OperandType as T;
        match self {
            Self::Field(v) => T::from_field(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<structured_query::unary_filter::OperandType> for crate::generated::model::structured_query::unary_filter::OperandType {
    fn cnv(self) -> structured_query::unary_filter::OperandType {
        use structured_query::unary_filter::OperandType as T;
        match self {
            Self::Field(v) => T::Field((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<structured_query::UnaryFilter> for crate::generated::model::structured_query::UnaryFilter {
    fn cnv(self) -> structured_query::UnaryFilter {
        structured_query::UnaryFilter {
            op: self.op.value(),
            operand_type: self.operand_type.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_query::UnaryFilter> for structured_query::UnaryFilter {
    fn cnv(self) -> crate::generated::model::structured_query::UnaryFilter {
        crate::generated::model::structured_query::UnaryFilter::new()
            .set_op(self.op)
            .set_operand_type(self.operand_type.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<structured_query::Order> for crate::generated::model::structured_query::Order {
    fn cnv(self) -> structured_query::Order {
        structured_query::Order {
            field: self.field.map(|v| v.cnv()),
            direction: self.direction.value(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_query::Order> for structured_query::Order {
    fn cnv(self) -> crate::generated::model::structured_query::Order {
        crate::generated::model::structured_query::Order::new()
            .set_field(self.field.map(|v| v.cnv()))
            .set_direction(self.direction)
    }
}

impl wkt::prost::Convert<structured_query::FieldReference> for crate::generated::model::structured_query::FieldReference {
    fn cnv(self) -> structured_query::FieldReference {
        structured_query::FieldReference {
            field_path: self.field_path.cnv(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_query::FieldReference> for structured_query::FieldReference {
    fn cnv(self) -> crate::generated::model::structured_query::FieldReference {
        crate::generated::model::structured_query::FieldReference::new()
            .set_field_path(self.field_path)
    }
}

impl wkt::prost::Convert<structured_query::Projection> for crate::generated::model::structured_query::Projection {
    fn cnv(self) -> structured_query::Projection {
        structured_query::Projection {
            fields: self.fields.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_query::Projection> for structured_query::Projection {
    fn cnv(self) -> crate::generated::model::structured_query::Projection {
        crate::generated::model::structured_query::Projection::new()
            .set_fields(self.fields.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<structured_query::FindNearest> for crate::generated::model::structured_query::FindNearest {
    fn cnv(self) -> structured_query::FindNearest {
        structured_query::FindNearest {
            vector_field: self.vector_field.map(|v| v.cnv()),
            query_vector: self.query_vector.map(|v| v.cnv()),
            distance_measure: self.distance_measure.value(),
            limit: self.limit.map(|v| v.cnv()),
            distance_result_field: self.distance_result_field.cnv(),
            distance_threshold: self.distance_threshold.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_query::FindNearest> for structured_query::FindNearest {
    fn cnv(self) -> crate::generated::model::structured_query::FindNearest {
        crate::generated::model::structured_query::FindNearest::new()
            .set_vector_field(self.vector_field.map(|v| v.cnv()))
            .set_query_vector(self.query_vector.map(|v| v.cnv()))
            .set_distance_measure(self.distance_measure)
            .set_limit(self.limit.map(|v| v.cnv()))
            .set_distance_result_field(self.distance_result_field)
            .set_distance_threshold(self.distance_threshold.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<StructuredQuery> for crate::generated::model::StructuredQuery {
    fn cnv(self) -> StructuredQuery {
        StructuredQuery {
            select: self.select.map(|v| v.cnv()),
            r#where: self.r#where.map(|v| v.cnv()),
            start_at: self.start_at.map(|v| v.cnv()),
            end_at: self.end_at.map(|v| v.cnv()),
            offset: self.offset.cnv(),
            limit: self.limit.map(|v| v.cnv()),
            find_nearest: self.find_nearest.map(|v| v.cnv()),
            from: self.from.into_iter().map(|v| v.cnv()).collect(),
            order_by: self.order_by.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::StructuredQuery> for StructuredQuery {
    fn cnv(self) -> crate::generated::model::StructuredQuery {
        crate::generated::model::StructuredQuery::new()
            .set_select(self.select.map(|v| v.cnv()))
            .set_where(self.r#where.map(|v| v.cnv()))
            .set_start_at(self.start_at.map(|v| v.cnv()))
            .set_end_at(self.end_at.map(|v| v.cnv()))
            .set_offset(self.offset)
            .set_limit(self.limit.map(|v| v.cnv()))
            .set_find_nearest(self.find_nearest.map(|v| v.cnv()))
            .set_from(self.from.into_iter().map(|v| v.cnv()))
            .set_order_by(self.order_by.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<structured_aggregation_query::aggregation::Count> for crate::generated::model::structured_aggregation_query::aggregation::Count {
    fn cnv(self) -> structured_aggregation_query::aggregation::Count {
        structured_aggregation_query::aggregation::Count {
            up_to: self.up_to.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_aggregation_query::aggregation::Count> for structured_aggregation_query::aggregation::Count {
    fn cnv(self) -> crate::generated::model::structured_aggregation_query::aggregation::Count {
        crate::generated::model::structured_aggregation_query::aggregation::Count::new()
            .set_up_to(self.up_to.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<structured_aggregation_query::aggregation::Sum> for crate::generated::model::structured_aggregation_query::aggregation::Sum {
    fn cnv(self) -> structured_aggregation_query::aggregation::Sum {
        structured_aggregation_query::aggregation::Sum {
            field: self.field.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_aggregation_query::aggregation::Sum> for structured_aggregation_query::aggregation::Sum {
    fn cnv(self) -> crate::generated::model::structured_aggregation_query::aggregation::Sum {
        crate::generated::model::structured_aggregation_query::aggregation::Sum::new()
            .set_field(self.field.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<structured_aggregation_query::aggregation::Avg> for crate::generated::model::structured_aggregation_query::aggregation::Avg {
    fn cnv(self) -> structured_aggregation_query::aggregation::Avg {
        structured_aggregation_query::aggregation::Avg {
            field: self.field.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_aggregation_query::aggregation::Avg> for structured_aggregation_query::aggregation::Avg {
    fn cnv(self) -> crate::generated::model::structured_aggregation_query::aggregation::Avg {
        crate::generated::model::structured_aggregation_query::aggregation::Avg::new()
            .set_field(self.field.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_aggregation_query::aggregation::Operator> for structured_aggregation_query::aggregation::Operator {
    fn cnv(self) -> crate::generated::model::structured_aggregation_query::aggregation::Operator {
        use crate::generated::model::structured_aggregation_query::aggregation::Operator as T;
        match self {
            Self::Count(v) => T::from_count(v.cnv()),
            Self::Sum(v) => T::from_sum(v.cnv()),
            Self::Avg(v) => T::from_avg(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<structured_aggregation_query::aggregation::Operator> for crate::generated::model::structured_aggregation_query::aggregation::Operator {
    fn cnv(self) -> structured_aggregation_query::aggregation::Operator {
        use structured_aggregation_query::aggregation::Operator as T;
        match self {
            Self::Count(v) => T::Count((*v).cnv()),
            Self::Sum(v) => T::Sum((*v).cnv()),
            Self::Avg(v) => T::Avg((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<structured_aggregation_query::Aggregation> for crate::generated::model::structured_aggregation_query::Aggregation {
    fn cnv(self) -> structured_aggregation_query::Aggregation {
        structured_aggregation_query::Aggregation {
            alias: self.alias.cnv(),
            operator: self.operator.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_aggregation_query::Aggregation> for structured_aggregation_query::Aggregation {
    fn cnv(self) -> crate::generated::model::structured_aggregation_query::Aggregation {
        crate::generated::model::structured_aggregation_query::Aggregation::new()
            .set_alias(self.alias)
            .set_operator(self.operator.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::structured_aggregation_query::QueryType> for structured_aggregation_query::QueryType {
    fn cnv(self) -> crate::generated::model::structured_aggregation_query::QueryType {
        use crate::generated::model::structured_aggregation_query::QueryType as T;
        match self {
            Self::StructuredQuery(v) => T::from_structured_query(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<structured_aggregation_query::QueryType> for crate::generated::model::structured_aggregation_query::QueryType {
    fn cnv(self) -> structured_aggregation_query::QueryType {
        use structured_aggregation_query::QueryType as T;
        match self {
            Self::StructuredQuery(v) => T::StructuredQuery((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<StructuredAggregationQuery> for crate::generated::model::StructuredAggregationQuery {
    fn cnv(self) -> StructuredAggregationQuery {
        StructuredAggregationQuery {
            aggregations: self.aggregations.into_iter().map(|v| v.cnv()).collect(),
            query_type: self.query_type.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::StructuredAggregationQuery> for StructuredAggregationQuery {
    fn cnv(self) -> crate::generated::model::StructuredAggregationQuery {
        crate::generated::model::StructuredAggregationQuery::new()
            .set_aggregations(self.aggregations.into_iter().map(|v| v.cnv()))
            .set_query_type(self.query_type.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<Cursor> for crate::generated::model::Cursor {
    fn cnv(self) -> Cursor {
        Cursor {
            before: self.before.cnv(),
            values: self.values.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::Cursor> for Cursor {
    fn cnv(self) -> crate::generated::model::Cursor {
        crate::generated::model::Cursor::new()
            .set_before(self.before)
            .set_values(self.values.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<ExplainOptions> for crate::generated::model::ExplainOptions {
    fn cnv(self) -> ExplainOptions {
        ExplainOptions {
            analyze: self.analyze.cnv(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::ExplainOptions> for ExplainOptions {
    fn cnv(self) -> crate::generated::model::ExplainOptions {
        crate::generated::model::ExplainOptions::new()
            .set_analyze(self.analyze)
    }
}

impl wkt::prost::Convert<ExplainMetrics> for crate::generated::model::ExplainMetrics {
    fn cnv(self) -> ExplainMetrics {
        ExplainMetrics {
            plan_summary: self.plan_summary.map(|v| v.cnv()),
            execution_stats: self.execution_stats.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::ExplainMetrics> for ExplainMetrics {
    fn cnv(self) -> crate::generated::model::ExplainMetrics {
        crate::generated::model::ExplainMetrics::new()
            .set_plan_summary(self.plan_summary.map(|v| v.cnv()))
            .set_execution_stats(self.execution_stats.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<PlanSummary> for crate::generated::model::PlanSummary {
    fn cnv(self) -> PlanSummary {
        PlanSummary {
            indexes_used: self.indexes_used.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::PlanSummary> for PlanSummary {
    fn cnv(self) -> crate::generated::model::PlanSummary {
        crate::generated::model::PlanSummary::new()
            .set_indexes_used(self.indexes_used.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<ExecutionStats> for crate::generated::model::ExecutionStats {
    fn cnv(self) -> ExecutionStats {
        ExecutionStats {
            results_returned: self.results_returned.cnv(),
            execution_duration: self.execution_duration.map(|v| v.cnv()),
            read_operations: self.read_operations.cnv(),
            debug_stats: self.debug_stats.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::ExecutionStats> for ExecutionStats {
    fn cnv(self) -> crate::generated::model::ExecutionStats {
        crate::generated::model::ExecutionStats::new()
            .set_results_returned(self.results_returned)
            .set_execution_duration(self.execution_duration.map(|v| v.cnv()))
            .set_read_operations(self.read_operations)
            .set_debug_stats(self.debug_stats.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::write::Operation> for write::Operation {
    fn cnv(self) -> crate::generated::model::write::Operation {
        use crate::generated::model::write::Operation as T;
        match self {
            Self::Update(v) => T::from_update(v.cnv()),
            Self::Delete(v) => T::from_delete(v.cnv()),
            Self::Transform(v) => T::from_transform(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<write::Operation> for crate::generated::model::write::Operation {
    fn cnv(self) -> write::Operation {
        use write::Operation as T;
        match self {
            Self::Update(v) => T::Update((*v).cnv()),
            Self::Delete(v) => T::Delete(v.cnv()),
            Self::Transform(v) => T::Transform((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<Write> for crate::generated::model::Write {
    fn cnv(self) -> Write {
        Write {
            update_mask: self.update_mask.map(|v| v.cnv()),
            current_document: self.current_document.map(|v| v.cnv()),
            update_transforms: self.update_transforms.into_iter().map(|v| v.cnv()).collect(),
            operation: self.operation.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::Write> for Write {
    fn cnv(self) -> crate::generated::model::Write {
        crate::generated::model::Write::new()
            .set_update_mask(self.update_mask.map(|v| v.cnv()))
            .set_current_document(self.current_document.map(|v| v.cnv()))
            .set_update_transforms(self.update_transforms.into_iter().map(|v| v.cnv()))
            .set_operation(self.operation.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<crate::generated::model::document_transform::field_transform::TransformType> for document_transform::field_transform::TransformType {
    fn cnv(self) -> crate::generated::model::document_transform::field_transform::TransformType {
        use crate::generated::model::document_transform::field_transform::TransformType as T;
        match self {
            Self::SetToServerValue(v) => T::from_set_to_server_value(v.cnv()),
            Self::Increment(v) => T::from_increment(v.cnv()),
            Self::Maximum(v) => T::from_maximum(v.cnv()),
            Self::Minimum(v) => T::from_minimum(v.cnv()),
            Self::AppendMissingElements(v) => T::from_append_missing_elements(v.cnv()),
            Self::RemoveAllFromArray(v) => T::from_remove_all_from_array(v.cnv()),
        }
    }
}

impl wkt::prost::Convert<document_transform::field_transform::TransformType> for crate::generated::model::document_transform::field_transform::TransformType {
    fn cnv(self) -> document_transform::field_transform::TransformType {
        use document_transform::field_transform::TransformType as T;
        match self {
            Self::SetToServerValue(v) => T::SetToServerValue(v.value()),
            Self::Increment(v) => T::Increment((*v).cnv()),
            Self::Maximum(v) => T::Maximum((*v).cnv()),
            Self::Minimum(v) => T::Minimum((*v).cnv()),
            Self::AppendMissingElements(v) => T::AppendMissingElements((*v).cnv()),
            Self::RemoveAllFromArray(v) => T::RemoveAllFromArray((*v).cnv()),
        }
    }
}

impl wkt::prost::Convert<document_transform::FieldTransform> for crate::generated::model::document_transform::FieldTransform {
    fn cnv(self) -> document_transform::FieldTransform {
        document_transform::FieldTransform {
            field_path: self.field_path.cnv(),
            transform_type: self.transform_type.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::document_transform::FieldTransform> for document_transform::FieldTransform {
    fn cnv(self) -> crate::generated::model::document_transform::FieldTransform {
        crate::generated::model::document_transform::FieldTransform::new()
            .set_field_path(self.field_path)
            .set_transform_type(self.transform_type.map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<DocumentTransform> for crate::generated::model::DocumentTransform {
    fn cnv(self) -> DocumentTransform {
        DocumentTransform {
            document: self.document.cnv(),
            field_transforms: self.field_transforms.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::DocumentTransform> for DocumentTransform {
    fn cnv(self) -> crate::generated::model::DocumentTransform {
        crate::generated::model::DocumentTransform::new()
            .set_document(self.document)
            .set_field_transforms(self.field_transforms.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<WriteResult> for crate::generated::model::WriteResult {
    fn cnv(self) -> WriteResult {
        WriteResult {
            update_time: self.update_time.map(|v| v.cnv()),
            transform_results: self.transform_results.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::WriteResult> for WriteResult {
    fn cnv(self) -> crate::generated::model::WriteResult {
        crate::generated::model::WriteResult::new()
            .set_update_time(self.update_time.map(|v| v.cnv()))
            .set_transform_results(self.transform_results.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<DocumentChange> for crate::generated::model::DocumentChange {
    fn cnv(self) -> DocumentChange {
        DocumentChange {
            document: self.document.map(|v| v.cnv()),
            target_ids: self.target_ids.into_iter().map(|v| v.cnv()).collect(),
            removed_target_ids: self.removed_target_ids.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::DocumentChange> for DocumentChange {
    fn cnv(self) -> crate::generated::model::DocumentChange {
        crate::generated::model::DocumentChange::new()
            .set_document(self.document.map(|v| v.cnv()))
            .set_target_ids(self.target_ids.into_iter().map(|v| v.cnv()))
            .set_removed_target_ids(self.removed_target_ids.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<DocumentDelete> for crate::generated::model::DocumentDelete {
    fn cnv(self) -> DocumentDelete {
        DocumentDelete {
            document: self.document.cnv(),
            read_time: self.read_time.map(|v| v.cnv()),
            removed_target_ids: self.removed_target_ids.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::DocumentDelete> for DocumentDelete {
    fn cnv(self) -> crate::generated::model::DocumentDelete {
        crate::generated::model::DocumentDelete::new()
            .set_document(self.document)
            .set_read_time(self.read_time.map(|v| v.cnv()))
            .set_removed_target_ids(self.removed_target_ids.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<DocumentRemove> for crate::generated::model::DocumentRemove {
    fn cnv(self) -> DocumentRemove {
        DocumentRemove {
            document: self.document.cnv(),
            read_time: self.read_time.map(|v| v.cnv()),
            removed_target_ids: self.removed_target_ids.into_iter().map(|v| v.cnv()).collect(),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::DocumentRemove> for DocumentRemove {
    fn cnv(self) -> crate::generated::model::DocumentRemove {
        crate::generated::model::DocumentRemove::new()
            .set_document(self.document)
            .set_read_time(self.read_time.map(|v| v.cnv()))
            .set_removed_target_ids(self.removed_target_ids.into_iter().map(|v| v.cnv()))
    }
}

impl wkt::prost::Convert<ExistenceFilter> for crate::generated::model::ExistenceFilter {
    fn cnv(self) -> ExistenceFilter {
        ExistenceFilter {
            target_id: self.target_id.cnv(),
            count: self.count.cnv(),
            unchanged_names: self.unchanged_names.map(|v| v.cnv()),
        }
    }
}

impl wkt::prost::Convert<crate::generated::model::ExistenceFilter> for ExistenceFilter {
    fn cnv(self) -> crate::generated::model::ExistenceFilter {
        crate::generated::model::ExistenceFilter::new()
            .set_target_id(self.target_id)
            .set_count(self.count)
            .set_unchanged_names(self.unchanged_names.map(|v| v.cnv()))
    }
}
