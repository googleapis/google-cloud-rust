// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AggregationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aggregate_fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AggregationResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "aggregateFields" => Ok(__FieldTag::__aggregate_fields),
                            "aggregate_fields" => Ok(__FieldTag::__aggregate_fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AggregationResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AggregationResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aggregate_fields => {
                            if !fields.insert(__FieldTag::__aggregate_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregate_fields",
                                ));
                            }
                            result.aggregate_fields = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::Value,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BitSequence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bitmap,
            __padding,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BitSequence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bitmap" => Ok(__FieldTag::__bitmap),
                            "padding" => Ok(__FieldTag::__padding),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BitSequence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BitSequence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bitmap => {
                            if !fields.insert(__FieldTag::__bitmap) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bitmap",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bitmap = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__padding => {
                            if !fields.insert(__FieldTag::__padding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for padding",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.padding = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BloomFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bits,
            __hash_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BloomFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bits" => Ok(__FieldTag::__bits),
                            "hashCount" => Ok(__FieldTag::__hash_count),
                            "hash_count" => Ok(__FieldTag::__hash_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BloomFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BloomFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bits => {
                            if !fields.insert(__FieldTag::__bits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bits",
                                ));
                            }
                            result.bits =
                                map.next_value::<std::option::Option<crate::model::BitSequence>>()?;
                        }
                        __FieldTag::__hash_count => {
                            if !fields.insert(__FieldTag::__hash_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hash_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hash_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DocumentMask {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field_paths,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DocumentMask")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fieldPaths" => Ok(__FieldTag::__field_paths),
                            "field_paths" => Ok(__FieldTag::__field_paths),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DocumentMask;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DocumentMask")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field_paths => {
                            if !fields.insert(__FieldTag::__field_paths) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_paths",
                                ));
                            }
                            result.field_paths = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Precondition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __exists,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Precondition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "exists" => Ok(__FieldTag::__exists),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Precondition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Precondition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__exists => {
                            if !fields.insert(__FieldTag::__exists) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exists",
                                ));
                            }
                            if result.condition_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `condition_type`, a oneof with full ID .google.firestore.v1.Precondition.exists, latest field was exists",
                                ));
                            }
                            result.condition_type = std::option::Option::Some(
                                crate::model::precondition::ConditionType::Exists(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            if result.condition_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `condition_type`, a oneof with full ID .google.firestore.v1.Precondition.update_time, latest field was updateTime",
                                ));
                            }
                            result.condition_type = std::option::Option::Some(
                                crate::model::precondition::ConditionType::UpdateTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TransactionOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __read_only,
            __read_write,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransactionOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "readOnly" => Ok(__FieldTag::__read_only),
                            "read_only" => Ok(__FieldTag::__read_only),
                            "readWrite" => Ok(__FieldTag::__read_write),
                            "read_write" => Ok(__FieldTag::__read_write),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TransactionOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransactionOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__read_only => {
                            if !fields.insert(__FieldTag::__read_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_only",
                                ));
                            }
                            if result.mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mode`, a oneof with full ID .google.firestore.v1.TransactionOptions.read_only, latest field was readOnly",
                                ));
                            }
                            result.mode = std::option::Option::Some(
                                crate::model::transaction_options::Mode::ReadOnly(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::transaction_options::ReadOnly,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__read_write => {
                            if !fields.insert(__FieldTag::__read_write) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_write",
                                ));
                            }
                            if result.mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mode`, a oneof with full ID .google.firestore.v1.TransactionOptions.read_write, latest field was readWrite",
                                ));
                            }
                            result.mode = std::option::Option::Some(
                                crate::model::transaction_options::Mode::ReadWrite(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::transaction_options::ReadWrite,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::transaction_options::ReadWrite {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __retry_transaction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReadWrite")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "retryTransaction" => Ok(__FieldTag::__retry_transaction),
                            "retry_transaction" => Ok(__FieldTag::__retry_transaction),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::transaction_options::ReadWrite;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReadWrite")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__retry_transaction => {
                            if !fields.insert(__FieldTag::__retry_transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retry_transaction",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.retry_transaction =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::transaction_options::ReadOnly {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __read_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReadOnly")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::transaction_options::ReadOnly;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReadOnly")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.TransactionOptions.ReadOnly.read_time, latest field was readTime",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::transaction_options::read_only::ConsistencySelector::ReadTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Document {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __fields,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Document")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "fields" => Ok(__FieldTag::__fields),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Document;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Document")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::Value,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Value {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __null_value,
            __boolean_value,
            __integer_value,
            __double_value,
            __timestamp_value,
            __string_value,
            __bytes_value,
            __reference_value,
            __geo_point_value,
            __array_value,
            __map_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Value")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nullValue" => Ok(__FieldTag::__null_value),
                            "null_value" => Ok(__FieldTag::__null_value),
                            "booleanValue" => Ok(__FieldTag::__boolean_value),
                            "boolean_value" => Ok(__FieldTag::__boolean_value),
                            "integerValue" => Ok(__FieldTag::__integer_value),
                            "integer_value" => Ok(__FieldTag::__integer_value),
                            "doubleValue" => Ok(__FieldTag::__double_value),
                            "double_value" => Ok(__FieldTag::__double_value),
                            "timestampValue" => Ok(__FieldTag::__timestamp_value),
                            "timestamp_value" => Ok(__FieldTag::__timestamp_value),
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            "bytesValue" => Ok(__FieldTag::__bytes_value),
                            "bytes_value" => Ok(__FieldTag::__bytes_value),
                            "referenceValue" => Ok(__FieldTag::__reference_value),
                            "reference_value" => Ok(__FieldTag::__reference_value),
                            "geoPointValue" => Ok(__FieldTag::__geo_point_value),
                            "geo_point_value" => Ok(__FieldTag::__geo_point_value),
                            "arrayValue" => Ok(__FieldTag::__array_value),
                            "array_value" => Ok(__FieldTag::__array_value),
                            "mapValue" => Ok(__FieldTag::__map_value),
                            "map_value" => Ok(__FieldTag::__map_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Value;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Value")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__null_value => {
                            if !fields.insert(__FieldTag::__null_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for null_value",
                                ));
                            }
                            if result.value_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value_type`, a oneof with full ID .google.firestore.v1.Value.null_value, latest field was nullValue",
                                ));
                            }
                            result.value_type = std::option::Option::Some(
                                crate::model::value::ValueType::NullValue(
                                    map.next_value::<std::option::Option<wkt::NullValue>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__boolean_value => {
                            if !fields.insert(__FieldTag::__boolean_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boolean_value",
                                ));
                            }
                            if result.value_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value_type`, a oneof with full ID .google.firestore.v1.Value.boolean_value, latest field was booleanValue",
                                ));
                            }
                            result.value_type = std::option::Option::Some(
                                crate::model::value::ValueType::BooleanValue(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__integer_value => {
                            if !fields.insert(__FieldTag::__integer_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for integer_value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value_type`, a oneof with full ID .google.firestore.v1.Value.integer_value, latest field was integerValue",
                                ));
                            }
                            result.value_type = std::option::Option::Some(
                                crate::model::value::ValueType::IntegerValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__double_value => {
                            if !fields.insert(__FieldTag::__double_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for double_value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value_type`, a oneof with full ID .google.firestore.v1.Value.double_value, latest field was doubleValue",
                                ));
                            }
                            result.value_type = std::option::Option::Some(
                                crate::model::value::ValueType::DoubleValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__timestamp_value => {
                            if !fields.insert(__FieldTag::__timestamp_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp_value",
                                ));
                            }
                            if result.value_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value_type`, a oneof with full ID .google.firestore.v1.Value.timestamp_value, latest field was timestampValue",
                                ));
                            }
                            result.value_type = std::option::Option::Some(
                                crate::model::value::ValueType::TimestampValue(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.value_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value_type`, a oneof with full ID .google.firestore.v1.Value.string_value, latest field was stringValue",
                                ));
                            }
                            result.value_type = std::option::Option::Some(
                                crate::model::value::ValueType::StringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bytes_value => {
                            if !fields.insert(__FieldTag::__bytes_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_value",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value_type`, a oneof with full ID .google.firestore.v1.Value.bytes_value, latest field was bytesValue",
                                ));
                            }
                            result.value_type = std::option::Option::Some(
                                crate::model::value::ValueType::BytesValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__reference_value => {
                            if !fields.insert(__FieldTag::__reference_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reference_value",
                                ));
                            }
                            if result.value_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value_type`, a oneof with full ID .google.firestore.v1.Value.reference_value, latest field was referenceValue",
                                ));
                            }
                            result.value_type = std::option::Option::Some(
                                crate::model::value::ValueType::ReferenceValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__geo_point_value => {
                            if !fields.insert(__FieldTag::__geo_point_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for geo_point_value",
                                ));
                            }
                            if result.value_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value_type`, a oneof with full ID .google.firestore.v1.Value.geo_point_value, latest field was geoPointValue",
                                ));
                            }
                            result.value_type =
                                std::option::Option::Some(
                                    crate::model::value::ValueType::GeoPointValue(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<gtype::model::LatLng>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__array_value => {
                            if !fields.insert(__FieldTag::__array_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for array_value",
                                ));
                            }
                            if result.value_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value_type`, a oneof with full ID .google.firestore.v1.Value.array_value, latest field was arrayValue",
                                ));
                            }
                            result.value_type = std::option::Option::Some(
                                crate::model::value::ValueType::ArrayValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ArrayValue>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__map_value => {
                            if !fields.insert(__FieldTag::__map_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_value",
                                ));
                            }
                            if result.value_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value_type`, a oneof with full ID .google.firestore.v1.Value.map_value, latest field was mapValue",
                                ));
                            }
                            result.value_type = std::option::Option::Some(
                                crate::model::value::ValueType::MapValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MapValue>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ArrayValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArrayValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ArrayValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArrayValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Value>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MapValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MapValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fields" => Ok(__FieldTag::__fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MapValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MapValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::Value,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __mask,
            __transaction,
            __read_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "mask" => Ok(__FieldTag::__mask),
                            "transaction" => Ok(__FieldTag::__transaction),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mask => {
                            if !fields.insert(__FieldTag::__mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mask",
                                ));
                            }
                            result.mask = map
                                .next_value::<std::option::Option<crate::model::DocumentMask>>()?;
                        }
                        __FieldTag::__transaction => {
                            if !fields.insert(__FieldTag::__transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.GetDocumentRequest.transaction, latest field was transaction",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::get_document_request::ConsistencySelector::Transaction(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.GetDocumentRequest.read_time, latest field was readTime",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::get_document_request::ConsistencySelector::ReadTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDocumentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __collection_id,
            __page_size,
            __page_token,
            __order_by,
            __mask,
            __transaction,
            __read_time,
            __show_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDocumentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "collectionId" => Ok(__FieldTag::__collection_id),
                            "collection_id" => Ok(__FieldTag::__collection_id),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "mask" => Ok(__FieldTag::__mask),
                            "transaction" => Ok(__FieldTag::__transaction),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            "showMissing" => Ok(__FieldTag::__show_missing),
                            "show_missing" => Ok(__FieldTag::__show_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDocumentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDocumentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__collection_id => {
                            if !fields.insert(__FieldTag::__collection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection_id",
                                ));
                            }
                            result.collection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mask => {
                            if !fields.insert(__FieldTag::__mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mask",
                                ));
                            }
                            result.mask = map
                                .next_value::<std::option::Option<crate::model::DocumentMask>>()?;
                        }
                        __FieldTag::__transaction => {
                            if !fields.insert(__FieldTag::__transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.ListDocumentsRequest.transaction, latest field was transaction",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::list_documents_request::ConsistencySelector::Transaction(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.ListDocumentsRequest.read_time, latest field was readTime",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::list_documents_request::ConsistencySelector::ReadTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__show_missing => {
                            if !fields.insert(__FieldTag::__show_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for show_missing",
                                ));
                            }
                            result.show_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListDocumentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __documents,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDocumentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "documents" => Ok(__FieldTag::__documents),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListDocumentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDocumentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__documents => {
                            if !fields.insert(__FieldTag::__documents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documents",
                                ));
                            }
                            result.documents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Document>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __collection_id,
            __document_id,
            __document,
            __mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "collectionId" => Ok(__FieldTag::__collection_id),
                            "collection_id" => Ok(__FieldTag::__collection_id),
                            "documentId" => Ok(__FieldTag::__document_id),
                            "document_id" => Ok(__FieldTag::__document_id),
                            "document" => Ok(__FieldTag::__document),
                            "mask" => Ok(__FieldTag::__mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__collection_id => {
                            if !fields.insert(__FieldTag::__collection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection_id",
                                ));
                            }
                            result.collection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__document_id => {
                            if !fields.insert(__FieldTag::__document_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_id",
                                ));
                            }
                            result.document_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document =
                                map.next_value::<std::option::Option<crate::model::Document>>()?;
                        }
                        __FieldTag::__mask => {
                            if !fields.insert(__FieldTag::__mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mask",
                                ));
                            }
                            result.mask = map
                                .next_value::<std::option::Option<crate::model::DocumentMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document,
            __update_mask,
            __mask,
            __current_document,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "document" => Ok(__FieldTag::__document),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "mask" => Ok(__FieldTag::__mask),
                            "currentDocument" => Ok(__FieldTag::__current_document),
                            "current_document" => Ok(__FieldTag::__current_document),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document =
                                map.next_value::<std::option::Option<crate::model::Document>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask = map
                                .next_value::<std::option::Option<crate::model::DocumentMask>>()?;
                        }
                        __FieldTag::__mask => {
                            if !fields.insert(__FieldTag::__mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mask",
                                ));
                            }
                            result.mask = map
                                .next_value::<std::option::Option<crate::model::DocumentMask>>()?;
                        }
                        __FieldTag::__current_document => {
                            if !fields.insert(__FieldTag::__current_document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_document",
                                ));
                            }
                            result.current_document = map
                                .next_value::<std::option::Option<crate::model::Precondition>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __current_document,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "currentDocument" => Ok(__FieldTag::__current_document),
                            "current_document" => Ok(__FieldTag::__current_document),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__current_document => {
                            if !fields.insert(__FieldTag::__current_document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_document",
                                ));
                            }
                            result.current_document = map
                                .next_value::<std::option::Option<crate::model::Precondition>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchGetDocumentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __documents,
            __mask,
            __transaction,
            __new_transaction,
            __read_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchGetDocumentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "documents" => Ok(__FieldTag::__documents),
                            "mask" => Ok(__FieldTag::__mask),
                            "transaction" => Ok(__FieldTag::__transaction),
                            "newTransaction" => Ok(__FieldTag::__new_transaction),
                            "new_transaction" => Ok(__FieldTag::__new_transaction),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchGetDocumentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchGetDocumentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__documents => {
                            if !fields.insert(__FieldTag::__documents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documents",
                                ));
                            }
                            result.documents = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__mask => {
                            if !fields.insert(__FieldTag::__mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mask",
                                ));
                            }
                            result.mask = map
                                .next_value::<std::option::Option<crate::model::DocumentMask>>()?;
                        }
                        __FieldTag::__transaction => {
                            if !fields.insert(__FieldTag::__transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.BatchGetDocumentsRequest.transaction, latest field was transaction",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::batch_get_documents_request::ConsistencySelector::Transaction(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__new_transaction => {
                            if !fields.insert(__FieldTag::__new_transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_transaction",
                                ));
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.BatchGetDocumentsRequest.new_transaction, latest field was newTransaction",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::batch_get_documents_request::ConsistencySelector::NewTransaction(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TransactionOptions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.BatchGetDocumentsRequest.read_time, latest field was readTime",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::batch_get_documents_request::ConsistencySelector::ReadTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchGetDocumentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __found,
            __missing,
            __transaction,
            __read_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchGetDocumentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "found" => Ok(__FieldTag::__found),
                            "missing" => Ok(__FieldTag::__missing),
                            "transaction" => Ok(__FieldTag::__transaction),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchGetDocumentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchGetDocumentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__found => {
                            if !fields.insert(__FieldTag::__found) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for found",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.firestore.v1.BatchGetDocumentsResponse.found, latest field was found",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::batch_get_documents_response::Result::Found(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Document>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__missing => {
                            if !fields.insert(__FieldTag::__missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for missing",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.firestore.v1.BatchGetDocumentsResponse.missing, latest field was missing",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::batch_get_documents_response::Result::Missing(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__transaction => {
                            if !fields.insert(__FieldTag::__transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transaction = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            result.read_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BeginTransactionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BeginTransactionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "options" => Ok(__FieldTag::__options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BeginTransactionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BeginTransactionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__options => {
                            if !fields.insert(__FieldTag::__options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for options",
                                ));
                            }
                            result.options = map.next_value::<std::option::Option<crate::model::TransactionOptions>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BeginTransactionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transaction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BeginTransactionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transaction" => Ok(__FieldTag::__transaction),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BeginTransactionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BeginTransactionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transaction => {
                            if !fields.insert(__FieldTag::__transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transaction = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CommitRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __writes,
            __transaction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommitRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "writes" => Ok(__FieldTag::__writes),
                            "transaction" => Ok(__FieldTag::__transaction),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CommitRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommitRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__writes => {
                            if !fields.insert(__FieldTag::__writes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for writes",
                                ));
                            }
                            result.writes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Write>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__transaction => {
                            if !fields.insert(__FieldTag::__transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transaction = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CommitResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __write_results,
            __commit_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommitResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "writeResults" => Ok(__FieldTag::__write_results),
                            "write_results" => Ok(__FieldTag::__write_results),
                            "commitTime" => Ok(__FieldTag::__commit_time),
                            "commit_time" => Ok(__FieldTag::__commit_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CommitResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommitResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__write_results => {
                            if !fields.insert(__FieldTag::__write_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_results",
                                ));
                            }
                            result.write_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::WriteResult>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__commit_time => {
                            if !fields.insert(__FieldTag::__commit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_time",
                                ));
                            }
                            result.commit_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RollbackRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __transaction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RollbackRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "transaction" => Ok(__FieldTag::__transaction),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RollbackRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RollbackRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transaction => {
                            if !fields.insert(__FieldTag::__transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transaction = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RunQueryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __structured_query,
            __transaction,
            __new_transaction,
            __read_time,
            __explain_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunQueryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "structuredQuery" => Ok(__FieldTag::__structured_query),
                            "structured_query" => Ok(__FieldTag::__structured_query),
                            "transaction" => Ok(__FieldTag::__transaction),
                            "newTransaction" => Ok(__FieldTag::__new_transaction),
                            "new_transaction" => Ok(__FieldTag::__new_transaction),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            "explainOptions" => Ok(__FieldTag::__explain_options),
                            "explain_options" => Ok(__FieldTag::__explain_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RunQueryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunQueryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__structured_query => {
                            if !fields.insert(__FieldTag::__structured_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for structured_query",
                                ));
                            }
                            if result.query_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query_type`, a oneof with full ID .google.firestore.v1.RunQueryRequest.structured_query, latest field was structuredQuery",
                                ));
                            }
                            result.query_type = std::option::Option::Some(
                                crate::model::run_query_request::QueryType::StructuredQuery(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StructuredQuery>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__transaction => {
                            if !fields.insert(__FieldTag::__transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.RunQueryRequest.transaction, latest field was transaction",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::run_query_request::ConsistencySelector::Transaction(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__new_transaction => {
                            if !fields.insert(__FieldTag::__new_transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_transaction",
                                ));
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.RunQueryRequest.new_transaction, latest field was newTransaction",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::run_query_request::ConsistencySelector::NewTransaction(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TransactionOptions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.RunQueryRequest.read_time, latest field was readTime",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::run_query_request::ConsistencySelector::ReadTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__explain_options => {
                            if !fields.insert(__FieldTag::__explain_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for explain_options",
                                ));
                            }
                            result.explain_options = map
                                .next_value::<std::option::Option<crate::model::ExplainOptions>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RunQueryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transaction,
            __document,
            __read_time,
            __skipped_results,
            __done,
            __explain_metrics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunQueryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transaction" => Ok(__FieldTag::__transaction),
                            "document" => Ok(__FieldTag::__document),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            "skippedResults" => Ok(__FieldTag::__skipped_results),
                            "skipped_results" => Ok(__FieldTag::__skipped_results),
                            "done" => Ok(__FieldTag::__done),
                            "explainMetrics" => Ok(__FieldTag::__explain_metrics),
                            "explain_metrics" => Ok(__FieldTag::__explain_metrics),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RunQueryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunQueryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transaction => {
                            if !fields.insert(__FieldTag::__transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transaction = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document =
                                map.next_value::<std::option::Option<crate::model::Document>>()?;
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            result.read_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__skipped_results => {
                            if !fields.insert(__FieldTag::__skipped_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skipped_results",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.skipped_results =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__done => {
                            if !fields.insert(__FieldTag::__done) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for done",
                                ));
                            }
                            if result.continuation_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `continuation_selector`, a oneof with full ID .google.firestore.v1.RunQueryResponse.done, latest field was done",
                                ));
                            }
                            result.continuation_selector = std::option::Option::Some(
                                crate::model::run_query_response::ContinuationSelector::Done(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__explain_metrics => {
                            if !fields.insert(__FieldTag::__explain_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for explain_metrics",
                                ));
                            }
                            result.explain_metrics = map
                                .next_value::<std::option::Option<crate::model::ExplainMetrics>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RunAggregationQueryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __structured_aggregation_query,
            __transaction,
            __new_transaction,
            __read_time,
            __explain_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunAggregationQueryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "structuredAggregationQuery" => {
                                Ok(__FieldTag::__structured_aggregation_query)
                            }
                            "structured_aggregation_query" => {
                                Ok(__FieldTag::__structured_aggregation_query)
                            }
                            "transaction" => Ok(__FieldTag::__transaction),
                            "newTransaction" => Ok(__FieldTag::__new_transaction),
                            "new_transaction" => Ok(__FieldTag::__new_transaction),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            "explainOptions" => Ok(__FieldTag::__explain_options),
                            "explain_options" => Ok(__FieldTag::__explain_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RunAggregationQueryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunAggregationQueryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__structured_aggregation_query => {
                            if !fields.insert(__FieldTag::__structured_aggregation_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for structured_aggregation_query",
                                ));
                            }
                            if result.query_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query_type`, a oneof with full ID .google.firestore.v1.RunAggregationQueryRequest.structured_aggregation_query, latest field was structuredAggregationQuery",
                                ));
                            }
                            result.query_type = std::option::Option::Some(
                                crate::model::run_aggregation_query_request::QueryType::StructuredAggregationQuery(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StructuredAggregationQuery>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__transaction => {
                            if !fields.insert(__FieldTag::__transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.RunAggregationQueryRequest.transaction, latest field was transaction",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::run_aggregation_query_request::ConsistencySelector::Transaction(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__new_transaction => {
                            if !fields.insert(__FieldTag::__new_transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_transaction",
                                ));
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.RunAggregationQueryRequest.new_transaction, latest field was newTransaction",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::run_aggregation_query_request::ConsistencySelector::NewTransaction(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TransactionOptions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.RunAggregationQueryRequest.read_time, latest field was readTime",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::run_aggregation_query_request::ConsistencySelector::ReadTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__explain_options => {
                            if !fields.insert(__FieldTag::__explain_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for explain_options",
                                ));
                            }
                            result.explain_options = map
                                .next_value::<std::option::Option<crate::model::ExplainOptions>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RunAggregationQueryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __result,
            __transaction,
            __read_time,
            __explain_metrics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunAggregationQueryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "result" => Ok(__FieldTag::__result),
                            "transaction" => Ok(__FieldTag::__transaction),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            "explainMetrics" => Ok(__FieldTag::__explain_metrics),
                            "explain_metrics" => Ok(__FieldTag::__explain_metrics),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RunAggregationQueryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunAggregationQueryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result = map
                                .next_value::<std::option::Option<crate::model::AggregationResult>>(
                                )?;
                        }
                        __FieldTag::__transaction => {
                            if !fields.insert(__FieldTag::__transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transaction = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            result.read_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__explain_metrics => {
                            if !fields.insert(__FieldTag::__explain_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for explain_metrics",
                                ));
                            }
                            result.explain_metrics = map
                                .next_value::<std::option::Option<crate::model::ExplainMetrics>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PartitionQueryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __structured_query,
            __partition_count,
            __page_token,
            __page_size,
            __read_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PartitionQueryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "structuredQuery" => Ok(__FieldTag::__structured_query),
                            "structured_query" => Ok(__FieldTag::__structured_query),
                            "partitionCount" => Ok(__FieldTag::__partition_count),
                            "partition_count" => Ok(__FieldTag::__partition_count),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PartitionQueryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PartitionQueryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__structured_query => {
                            if !fields.insert(__FieldTag::__structured_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for structured_query",
                                ));
                            }
                            if result.query_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query_type`, a oneof with full ID .google.firestore.v1.PartitionQueryRequest.structured_query, latest field was structuredQuery",
                                ));
                            }
                            result.query_type = std::option::Option::Some(
                                crate::model::partition_query_request::QueryType::StructuredQuery(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StructuredQuery>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__partition_count => {
                            if !fields.insert(__FieldTag::__partition_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partition_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.partition_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.PartitionQueryRequest.read_time, latest field was readTime",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::partition_query_request::ConsistencySelector::ReadTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PartitionQueryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __partitions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PartitionQueryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "partitions" => Ok(__FieldTag::__partitions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PartitionQueryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PartitionQueryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__partitions => {
                            if !fields.insert(__FieldTag::__partitions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partitions",
                                ));
                            }
                            result.partitions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Cursor>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::WriteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __stream_id,
            __writes,
            __stream_token,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WriteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "streamId" => Ok(__FieldTag::__stream_id),
                            "stream_id" => Ok(__FieldTag::__stream_id),
                            "writes" => Ok(__FieldTag::__writes),
                            "streamToken" => Ok(__FieldTag::__stream_token),
                            "stream_token" => Ok(__FieldTag::__stream_token),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::WriteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WriteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stream_id => {
                            if !fields.insert(__FieldTag::__stream_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_id",
                                ));
                            }
                            result.stream_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__writes => {
                            if !fields.insert(__FieldTag::__writes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for writes",
                                ));
                            }
                            result.writes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Write>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__stream_token => {
                            if !fields.insert(__FieldTag::__stream_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_token",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stream_token = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::WriteResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stream_id,
            __stream_token,
            __write_results,
            __commit_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WriteResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "streamId" => Ok(__FieldTag::__stream_id),
                            "stream_id" => Ok(__FieldTag::__stream_id),
                            "streamToken" => Ok(__FieldTag::__stream_token),
                            "stream_token" => Ok(__FieldTag::__stream_token),
                            "writeResults" => Ok(__FieldTag::__write_results),
                            "write_results" => Ok(__FieldTag::__write_results),
                            "commitTime" => Ok(__FieldTag::__commit_time),
                            "commit_time" => Ok(__FieldTag::__commit_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::WriteResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WriteResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stream_id => {
                            if !fields.insert(__FieldTag::__stream_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_id",
                                ));
                            }
                            result.stream_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stream_token => {
                            if !fields.insert(__FieldTag::__stream_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_token",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stream_token = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__write_results => {
                            if !fields.insert(__FieldTag::__write_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_results",
                                ));
                            }
                            result.write_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::WriteResult>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__commit_time => {
                            if !fields.insert(__FieldTag::__commit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_time",
                                ));
                            }
                            result.commit_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListenRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __add_target,
            __remove_target,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListenRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "addTarget" => Ok(__FieldTag::__add_target),
                            "add_target" => Ok(__FieldTag::__add_target),
                            "removeTarget" => Ok(__FieldTag::__remove_target),
                            "remove_target" => Ok(__FieldTag::__remove_target),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListenRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListenRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__add_target => {
                            if !fields.insert(__FieldTag::__add_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for add_target",
                                ));
                            }
                            if result.target_change.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_change`, a oneof with full ID .google.firestore.v1.ListenRequest.add_target, latest field was addTarget",
                                ));
                            }
                            result.target_change =
                                std::option::Option::Some(
                                    crate::model::listen_request::TargetChange::AddTarget(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Target>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__remove_target => {
                            if !fields.insert(__FieldTag::__remove_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remove_target",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.target_change.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_change`, a oneof with full ID .google.firestore.v1.ListenRequest.remove_target, latest field was removeTarget",
                                ));
                            }
                            result.target_change = std::option::Option::Some(
                                crate::model::listen_request::TargetChange::RemoveTarget(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListenResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_change,
            __document_change,
            __document_delete,
            __document_remove,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListenResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetChange" => Ok(__FieldTag::__target_change),
                            "target_change" => Ok(__FieldTag::__target_change),
                            "documentChange" => Ok(__FieldTag::__document_change),
                            "document_change" => Ok(__FieldTag::__document_change),
                            "documentDelete" => Ok(__FieldTag::__document_delete),
                            "document_delete" => Ok(__FieldTag::__document_delete),
                            "documentRemove" => Ok(__FieldTag::__document_remove),
                            "document_remove" => Ok(__FieldTag::__document_remove),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListenResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListenResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_change => {
                            if !fields.insert(__FieldTag::__target_change) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_change",
                                ));
                            }
                            if result.response_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response_type`, a oneof with full ID .google.firestore.v1.ListenResponse.target_change, latest field was targetChange",
                                ));
                            }
                            result.response_type = std::option::Option::Some(
                                crate::model::listen_response::ResponseType::TargetChange(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TargetChange>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__document_change => {
                            if !fields.insert(__FieldTag::__document_change) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_change",
                                ));
                            }
                            if result.response_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response_type`, a oneof with full ID .google.firestore.v1.ListenResponse.document_change, latest field was documentChange",
                                ));
                            }
                            result.response_type = std::option::Option::Some(
                                crate::model::listen_response::ResponseType::DocumentChange(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DocumentChange>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__document_delete => {
                            if !fields.insert(__FieldTag::__document_delete) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_delete",
                                ));
                            }
                            if result.response_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response_type`, a oneof with full ID .google.firestore.v1.ListenResponse.document_delete, latest field was documentDelete",
                                ));
                            }
                            result.response_type = std::option::Option::Some(
                                crate::model::listen_response::ResponseType::DocumentDelete(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DocumentDelete>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__document_remove => {
                            if !fields.insert(__FieldTag::__document_remove) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_remove",
                                ));
                            }
                            if result.response_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response_type`, a oneof with full ID .google.firestore.v1.ListenResponse.document_remove, latest field was documentRemove",
                                ));
                            }
                            result.response_type = std::option::Option::Some(
                                crate::model::listen_response::ResponseType::DocumentRemove(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DocumentRemove>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            if result.response_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response_type`, a oneof with full ID .google.firestore.v1.ListenResponse.filter, latest field was filter",
                                ));
                            }
                            result.response_type = std::option::Option::Some(
                                crate::model::listen_response::ResponseType::Filter(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ExistenceFilter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Target {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query,
            __documents,
            __resume_token,
            __read_time,
            __target_id,
            __once,
            __expected_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Target")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "query" => Ok(__FieldTag::__query),
                            "documents" => Ok(__FieldTag::__documents),
                            "resumeToken" => Ok(__FieldTag::__resume_token),
                            "resume_token" => Ok(__FieldTag::__resume_token),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            "targetId" => Ok(__FieldTag::__target_id),
                            "target_id" => Ok(__FieldTag::__target_id),
                            "once" => Ok(__FieldTag::__once),
                            "expectedCount" => Ok(__FieldTag::__expected_count),
                            "expected_count" => Ok(__FieldTag::__expected_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Target;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Target")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            if result.target_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_type`, a oneof with full ID .google.firestore.v1.Target.query, latest field was query",
                                ));
                            }
                            result.target_type =
                                std::option::Option::Some(crate::model::target::TargetType::Query(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::target::QueryTarget>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__documents => {
                            if !fields.insert(__FieldTag::__documents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documents",
                                ));
                            }
                            if result.target_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_type`, a oneof with full ID .google.firestore.v1.Target.documents, latest field was documents",
                                ));
                            }
                            result.target_type = std::option::Option::Some(
                                crate::model::target::TargetType::Documents(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::target::DocumentsTarget>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__resume_token => {
                            if !fields.insert(__FieldTag::__resume_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resume_token",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.resume_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resume_type`, a oneof with full ID .google.firestore.v1.Target.resume_token, latest field was resumeToken",
                                ));
                            }
                            result.resume_type = std::option::Option::Some(
                                crate::model::target::ResumeType::ResumeToken(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            if result.resume_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resume_type`, a oneof with full ID .google.firestore.v1.Target.read_time, latest field was readTime",
                                ));
                            }
                            result.resume_type = std::option::Option::Some(
                                crate::model::target::ResumeType::ReadTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__target_id => {
                            if !fields.insert(__FieldTag::__target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_id",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__once => {
                            if !fields.insert(__FieldTag::__once) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for once",
                                ));
                            }
                            result.once = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expected_count => {
                            if !fields.insert(__FieldTag::__expected_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expected_count",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expected_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::target::DocumentsTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __documents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DocumentsTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "documents" => Ok(__FieldTag::__documents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::target::DocumentsTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DocumentsTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__documents => {
                            if !fields.insert(__FieldTag::__documents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documents",
                                ));
                            }
                            result.documents = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::target::QueryTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __structured_query,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "structuredQuery" => Ok(__FieldTag::__structured_query),
                            "structured_query" => Ok(__FieldTag::__structured_query),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::target::QueryTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__structured_query => {
                            if !fields.insert(__FieldTag::__structured_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for structured_query",
                                ));
                            }
                            if result.query_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query_type`, a oneof with full ID .google.firestore.v1.Target.QueryTarget.structured_query, latest field was structuredQuery",
                                ));
                            }
                            result.query_type = std::option::Option::Some(
                                crate::model::target::query_target::QueryType::StructuredQuery(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StructuredQuery>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TargetChange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_change_type,
            __target_ids,
            __cause,
            __resume_token,
            __read_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TargetChange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetChangeType" => Ok(__FieldTag::__target_change_type),
                            "target_change_type" => Ok(__FieldTag::__target_change_type),
                            "targetIds" => Ok(__FieldTag::__target_ids),
                            "target_ids" => Ok(__FieldTag::__target_ids),
                            "cause" => Ok(__FieldTag::__cause),
                            "resumeToken" => Ok(__FieldTag::__resume_token),
                            "resume_token" => Ok(__FieldTag::__resume_token),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TargetChange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TargetChange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_change_type => {
                            if !fields.insert(__FieldTag::__target_change_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_change_type",
                                ));
                            }
                            result.target_change_type =
                                map.next_value::<std::option::Option<
                                    crate::model::target_change::TargetChangeType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_ids => {
                            if !fields.insert(__FieldTag::__target_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_ids",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.target_ids = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cause => {
                            if !fields.insert(__FieldTag::__cause) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cause",
                                ));
                            }
                            result.cause =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__resume_token => {
                            if !fields.insert(__FieldTag::__resume_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resume_token",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.resume_token = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            result.read_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCollectionIdsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __read_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCollectionIdsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCollectionIdsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCollectionIdsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            if result.consistency_selector.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `consistency_selector`, a oneof with full ID .google.firestore.v1.ListCollectionIdsRequest.read_time, latest field was readTime",
                                ));
                            }
                            result.consistency_selector = std::option::Option::Some(
                                crate::model::list_collection_ids_request::ConsistencySelector::ReadTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCollectionIdsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __collection_ids,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCollectionIdsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "collectionIds" => Ok(__FieldTag::__collection_ids),
                            "collection_ids" => Ok(__FieldTag::__collection_ids),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCollectionIdsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCollectionIdsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__collection_ids => {
                            if !fields.insert(__FieldTag::__collection_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection_ids",
                                ));
                            }
                            result.collection_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchWriteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __writes,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchWriteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "writes" => Ok(__FieldTag::__writes),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchWriteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchWriteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__writes => {
                            if !fields.insert(__FieldTag::__writes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for writes",
                                ));
                            }
                            result.writes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Write>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchWriteResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __write_results,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchWriteResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "writeResults" => Ok(__FieldTag::__write_results),
                            "write_results" => Ok(__FieldTag::__write_results),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchWriteResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchWriteResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__write_results => {
                            if !fields.insert(__FieldTag::__write_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_results",
                                ));
                            }
                            result.write_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::WriteResult>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StructuredQuery {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __select,
            __from,
            __where,
            __order_by,
            __start_at,
            __end_at,
            __offset,
            __limit,
            __find_nearest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StructuredQuery")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "select" => Ok(__FieldTag::__select),
                            "from" => Ok(__FieldTag::__from),
                            "where" => Ok(__FieldTag::__where),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "startAt" => Ok(__FieldTag::__start_at),
                            "start_at" => Ok(__FieldTag::__start_at),
                            "endAt" => Ok(__FieldTag::__end_at),
                            "end_at" => Ok(__FieldTag::__end_at),
                            "offset" => Ok(__FieldTag::__offset),
                            "limit" => Ok(__FieldTag::__limit),
                            "findNearest" => Ok(__FieldTag::__find_nearest),
                            "find_nearest" => Ok(__FieldTag::__find_nearest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StructuredQuery;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StructuredQuery")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__select => {
                            if !fields.insert(__FieldTag::__select) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for select",
                                ));
                            }
                            result.select = map.next_value::<std::option::Option<crate::model::structured_query::Projection>>()?
                                ;
                        }
                        __FieldTag::__from => {
                            if !fields.insert(__FieldTag::__from) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for from",
                                ));
                            }
                            result.from = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::structured_query::CollectionSelector,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__where => {
                            if !fields.insert(__FieldTag::__where) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for where",
                                ));
                            }
                            result.r#where = map.next_value::<std::option::Option<crate::model::structured_query::Filter>>()?
                                ;
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::structured_query::Order>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_at => {
                            if !fields.insert(__FieldTag::__start_at) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_at",
                                ));
                            }
                            result.start_at =
                                map.next_value::<std::option::Option<crate::model::Cursor>>()?;
                        }
                        __FieldTag::__end_at => {
                            if !fields.insert(__FieldTag::__end_at) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_at",
                                ));
                            }
                            result.end_at =
                                map.next_value::<std::option::Option<crate::model::Cursor>>()?;
                        }
                        __FieldTag::__offset => {
                            if !fields.insert(__FieldTag::__offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for offset",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.offset = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__limit => {
                            if !fields.insert(__FieldTag::__limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for limit",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.limit = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__find_nearest => {
                            if !fields.insert(__FieldTag::__find_nearest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for find_nearest",
                                ));
                            }
                            result.find_nearest =
                                map.next_value::<std::option::Option<
                                    crate::model::structured_query::FindNearest,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::structured_query::CollectionSelector {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __collection_id,
            __all_descendants,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CollectionSelector")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "collectionId" => Ok(__FieldTag::__collection_id),
                            "collection_id" => Ok(__FieldTag::__collection_id),
                            "allDescendants" => Ok(__FieldTag::__all_descendants),
                            "all_descendants" => Ok(__FieldTag::__all_descendants),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::structured_query::CollectionSelector;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CollectionSelector")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__collection_id => {
                            if !fields.insert(__FieldTag::__collection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection_id",
                                ));
                            }
                            result.collection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__all_descendants => {
                            if !fields.insert(__FieldTag::__all_descendants) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all_descendants",
                                ));
                            }
                            result.all_descendants = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::structured_query::Filter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __composite_filter,
            __field_filter,
            __unary_filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Filter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "compositeFilter" => Ok(__FieldTag::__composite_filter),
                            "composite_filter" => Ok(__FieldTag::__composite_filter),
                            "fieldFilter" => Ok(__FieldTag::__field_filter),
                            "field_filter" => Ok(__FieldTag::__field_filter),
                            "unaryFilter" => Ok(__FieldTag::__unary_filter),
                            "unary_filter" => Ok(__FieldTag::__unary_filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::structured_query::Filter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Filter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__composite_filter => {
                            if !fields.insert(__FieldTag::__composite_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for composite_filter",
                                ));
                            }
                            if result.filter_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_type`, a oneof with full ID .google.firestore.v1.StructuredQuery.Filter.composite_filter, latest field was compositeFilter",
                                ));
                            }
                            result.filter_type = std::option::Option::Some(
                                crate::model::structured_query::filter::FilterType::CompositeFilter(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::structured_query::CompositeFilter,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__field_filter => {
                            if !fields.insert(__FieldTag::__field_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_filter",
                                ));
                            }
                            if result.filter_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_type`, a oneof with full ID .google.firestore.v1.StructuredQuery.Filter.field_filter, latest field was fieldFilter",
                                ));
                            }
                            result.filter_type = std::option::Option::Some(
                                crate::model::structured_query::filter::FilterType::FieldFilter(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::structured_query::FieldFilter,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__unary_filter => {
                            if !fields.insert(__FieldTag::__unary_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unary_filter",
                                ));
                            }
                            if result.filter_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter_type`, a oneof with full ID .google.firestore.v1.StructuredQuery.Filter.unary_filter, latest field was unaryFilter",
                                ));
                            }
                            result.filter_type = std::option::Option::Some(
                                crate::model::structured_query::filter::FilterType::UnaryFilter(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::structured_query::UnaryFilter,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::structured_query::CompositeFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __op,
            __filters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompositeFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "op" => Ok(__FieldTag::__op),
                            "filters" => Ok(__FieldTag::__filters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::structured_query::CompositeFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompositeFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__op => {
                            if !fields.insert(__FieldTag::__op) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for op",
                                ));
                            }
                            result.op = map
                                .next_value::<std::option::Option<
                                    crate::model::structured_query::composite_filter::Operator,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filters => {
                            if !fields.insert(__FieldTag::__filters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filters",
                                ));
                            }
                            result.filters = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::structured_query::Filter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::structured_query::FieldFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            __op,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FieldFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            "op" => Ok(__FieldTag::__op),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::structured_query::FieldFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FieldFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field = map.next_value::<std::option::Option<
                                crate::model::structured_query::FieldReference,
                            >>()?;
                        }
                        __FieldTag::__op => {
                            if !fields.insert(__FieldTag::__op) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for op",
                                ));
                            }
                            result.op = map
                                .next_value::<std::option::Option<
                                    crate::model::structured_query::field_filter::Operator,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value =
                                map.next_value::<std::option::Option<crate::model::Value>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::structured_query::UnaryFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __op,
            __field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UnaryFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "op" => Ok(__FieldTag::__op),
                            "field" => Ok(__FieldTag::__field),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::structured_query::UnaryFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UnaryFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__op => {
                            if !fields.insert(__FieldTag::__op) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for op",
                                ));
                            }
                            result.op = map
                                .next_value::<std::option::Option<
                                    crate::model::structured_query::unary_filter::Operator,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            if result.operand_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operand_type`, a oneof with full ID .google.firestore.v1.StructuredQuery.UnaryFilter.field, latest field was field",
                                ));
                            }
                            result.operand_type = std::option::Option::Some(
                                crate::model::structured_query::unary_filter::OperandType::Field(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::structured_query::FieldReference,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::structured_query::Order {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            __direction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Order")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            "direction" => Ok(__FieldTag::__direction),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::structured_query::Order;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Order")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field = map.next_value::<std::option::Option<
                                crate::model::structured_query::FieldReference,
                            >>()?;
                        }
                        __FieldTag::__direction => {
                            if !fields.insert(__FieldTag::__direction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for direction",
                                ));
                            }
                            result.direction = map.next_value::<std::option::Option<crate::model::structured_query::Direction>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::structured_query::FieldReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FieldReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fieldPath" => Ok(__FieldTag::__field_path),
                            "field_path" => Ok(__FieldTag::__field_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::structured_query::FieldReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FieldReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field_path => {
                            if !fields.insert(__FieldTag::__field_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_path",
                                ));
                            }
                            result.field_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::structured_query::Projection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Projection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fields" => Ok(__FieldTag::__fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::structured_query::Projection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Projection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::structured_query::FieldReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::structured_query::FindNearest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vector_field,
            __query_vector,
            __distance_measure,
            __limit,
            __distance_result_field,
            __distance_threshold,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FindNearest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vectorField" => Ok(__FieldTag::__vector_field),
                            "vector_field" => Ok(__FieldTag::__vector_field),
                            "queryVector" => Ok(__FieldTag::__query_vector),
                            "query_vector" => Ok(__FieldTag::__query_vector),
                            "distanceMeasure" => Ok(__FieldTag::__distance_measure),
                            "distance_measure" => Ok(__FieldTag::__distance_measure),
                            "limit" => Ok(__FieldTag::__limit),
                            "distanceResultField" => Ok(__FieldTag::__distance_result_field),
                            "distance_result_field" => Ok(__FieldTag::__distance_result_field),
                            "distanceThreshold" => Ok(__FieldTag::__distance_threshold),
                            "distance_threshold" => Ok(__FieldTag::__distance_threshold),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::structured_query::FindNearest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FindNearest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vector_field => {
                            if !fields.insert(__FieldTag::__vector_field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vector_field",
                                ));
                            }
                            result.vector_field = map.next_value::<std::option::Option<
                                crate::model::structured_query::FieldReference,
                            >>()?;
                        }
                        __FieldTag::__query_vector => {
                            if !fields.insert(__FieldTag::__query_vector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_vector",
                                ));
                            }
                            result.query_vector =
                                map.next_value::<std::option::Option<crate::model::Value>>()?;
                        }
                        __FieldTag::__distance_measure => {
                            if !fields.insert(__FieldTag::__distance_measure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distance_measure",
                                ));
                            }
                            result.distance_measure = map
                                .next_value::<std::option::Option<
                                    crate::model::structured_query::find_nearest::DistanceMeasure,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__limit => {
                            if !fields.insert(__FieldTag::__limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for limit",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.limit = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__distance_result_field => {
                            if !fields.insert(__FieldTag::__distance_result_field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distance_result_field",
                                ));
                            }
                            result.distance_result_field = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__distance_threshold => {
                            if !fields.insert(__FieldTag::__distance_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distance_threshold",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.distance_threshold = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StructuredAggregationQuery {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __structured_query,
            __aggregations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StructuredAggregationQuery")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "structuredQuery" => Ok(__FieldTag::__structured_query),
                            "structured_query" => Ok(__FieldTag::__structured_query),
                            "aggregations" => Ok(__FieldTag::__aggregations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StructuredAggregationQuery;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StructuredAggregationQuery")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__structured_query => {
                            if !fields.insert(__FieldTag::__structured_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for structured_query",
                                ));
                            }
                            if result.query_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query_type`, a oneof with full ID .google.firestore.v1.StructuredAggregationQuery.structured_query, latest field was structuredQuery",
                                ));
                            }
                            result.query_type = std::option::Option::Some(
                                crate::model::structured_aggregation_query::QueryType::StructuredQuery(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StructuredQuery>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__aggregations => {
                            if !fields.insert(__FieldTag::__aggregations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregations",
                                ));
                            }
                            result.aggregations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::structured_aggregation_query::Aggregation,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::structured_aggregation_query::Aggregation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __count,
            __sum,
            __avg,
            __alias,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Aggregation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "count" => Ok(__FieldTag::__count),
                            "sum" => Ok(__FieldTag::__sum),
                            "avg" => Ok(__FieldTag::__avg),
                            "alias" => Ok(__FieldTag::__alias),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::structured_aggregation_query::Aggregation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Aggregation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__count => {
                            if !fields.insert(__FieldTag::__count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for count",
                                ));
                            }
                            if result.operator.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operator`, a oneof with full ID .google.firestore.v1.StructuredAggregationQuery.Aggregation.count, latest field was count",
                                ));
                            }
                            result.operator = std::option::Option::Some(
                                crate::model::structured_aggregation_query::aggregation::Operator::Count(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::structured_aggregation_query::aggregation::Count>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__sum => {
                            if !fields.insert(__FieldTag::__sum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sum",
                                ));
                            }
                            if result.operator.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operator`, a oneof with full ID .google.firestore.v1.StructuredAggregationQuery.Aggregation.sum, latest field was sum",
                                ));
                            }
                            result.operator = std::option::Option::Some(
                                crate::model::structured_aggregation_query::aggregation::Operator::Sum(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::structured_aggregation_query::aggregation::Sum>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__avg => {
                            if !fields.insert(__FieldTag::__avg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for avg",
                                ));
                            }
                            if result.operator.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operator`, a oneof with full ID .google.firestore.v1.StructuredAggregationQuery.Aggregation.avg, latest field was avg",
                                ));
                            }
                            result.operator = std::option::Option::Some(
                                crate::model::structured_aggregation_query::aggregation::Operator::Avg(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::structured_aggregation_query::aggregation::Avg>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__alias => {
                            if !fields.insert(__FieldTag::__alias) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alias",
                                ));
                            }
                            result.alias = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::structured_aggregation_query::aggregation::Count {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __up_to,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Count")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "upTo" => Ok(__FieldTag::__up_to),
                            "up_to" => Ok(__FieldTag::__up_to),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::structured_aggregation_query::aggregation::Count;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Count")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__up_to => {
                            if !fields.insert(__FieldTag::__up_to) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for up_to",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.up_to = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::structured_aggregation_query::aggregation::Sum {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Sum")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::structured_aggregation_query::aggregation::Sum;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Sum")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field = map.next_value::<std::option::Option<
                                crate::model::structured_query::FieldReference,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::structured_aggregation_query::aggregation::Avg {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Avg")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "field" => Ok(__FieldTag::__field),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::structured_aggregation_query::aggregation::Avg;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Avg")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field => {
                            if !fields.insert(__FieldTag::__field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field",
                                ));
                            }
                            result.field = map.next_value::<std::option::Option<
                                crate::model::structured_query::FieldReference,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Cursor {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __values,
            __before,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cursor")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "values" => Ok(__FieldTag::__values),
                            "before" => Ok(__FieldTag::__before),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Cursor;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cursor")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Value>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__before => {
                            if !fields.insert(__FieldTag::__before) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for before",
                                ));
                            }
                            result.before = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExplainOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __analyze,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExplainOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "analyze" => Ok(__FieldTag::__analyze),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExplainOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExplainOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__analyze => {
                            if !fields.insert(__FieldTag::__analyze) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analyze",
                                ));
                            }
                            result.analyze = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExplainMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __plan_summary,
            __execution_stats,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExplainMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "planSummary" => Ok(__FieldTag::__plan_summary),
                            "plan_summary" => Ok(__FieldTag::__plan_summary),
                            "executionStats" => Ok(__FieldTag::__execution_stats),
                            "execution_stats" => Ok(__FieldTag::__execution_stats),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExplainMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExplainMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__plan_summary => {
                            if !fields.insert(__FieldTag::__plan_summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for plan_summary",
                                ));
                            }
                            result.plan_summary =
                                map.next_value::<std::option::Option<crate::model::PlanSummary>>()?;
                        }
                        __FieldTag::__execution_stats => {
                            if !fields.insert(__FieldTag::__execution_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_stats",
                                ));
                            }
                            result.execution_stats = map
                                .next_value::<std::option::Option<crate::model::ExecutionStats>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PlanSummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __indexes_used,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PlanSummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "indexesUsed" => Ok(__FieldTag::__indexes_used),
                            "indexes_used" => Ok(__FieldTag::__indexes_used),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PlanSummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PlanSummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__indexes_used => {
                            if !fields.insert(__FieldTag::__indexes_used) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for indexes_used",
                                ));
                            }
                            result.indexes_used = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Struct>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExecutionStats {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __results_returned,
            __execution_duration,
            __read_operations,
            __debug_stats,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecutionStats")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resultsReturned" => Ok(__FieldTag::__results_returned),
                            "results_returned" => Ok(__FieldTag::__results_returned),
                            "executionDuration" => Ok(__FieldTag::__execution_duration),
                            "execution_duration" => Ok(__FieldTag::__execution_duration),
                            "readOperations" => Ok(__FieldTag::__read_operations),
                            "read_operations" => Ok(__FieldTag::__read_operations),
                            "debugStats" => Ok(__FieldTag::__debug_stats),
                            "debug_stats" => Ok(__FieldTag::__debug_stats),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExecutionStats;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecutionStats")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__results_returned => {
                            if !fields.insert(__FieldTag::__results_returned) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results_returned",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.results_returned =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__execution_duration => {
                            if !fields.insert(__FieldTag::__execution_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_duration",
                                ));
                            }
                            result.execution_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__read_operations => {
                            if !fields.insert(__FieldTag::__read_operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_operations",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.read_operations =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__debug_stats => {
                            if !fields.insert(__FieldTag::__debug_stats) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for debug_stats",
                                ));
                            }
                            result.debug_stats =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Write {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update,
            __delete,
            __transform,
            __update_mask,
            __update_transforms,
            __current_document,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Write")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "update" => Ok(__FieldTag::__update),
                            "delete" => Ok(__FieldTag::__delete),
                            "transform" => Ok(__FieldTag::__transform),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "updateTransforms" => Ok(__FieldTag::__update_transforms),
                            "update_transforms" => Ok(__FieldTag::__update_transforms),
                            "currentDocument" => Ok(__FieldTag::__current_document),
                            "current_document" => Ok(__FieldTag::__current_document),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Write;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Write")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update => {
                            if !fields.insert(__FieldTag::__update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update",
                                ));
                            }
                            if result.operation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operation`, a oneof with full ID .google.firestore.v1.Write.update, latest field was update",
                                ));
                            }
                            result.operation =
                                std::option::Option::Some(crate::model::write::Operation::Update(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Document>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__delete => {
                            if !fields.insert(__FieldTag::__delete) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete",
                                ));
                            }
                            if result.operation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operation`, a oneof with full ID .google.firestore.v1.Write.delete, latest field was delete",
                                ));
                            }
                            result.operation =
                                std::option::Option::Some(crate::model::write::Operation::Delete(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__transform => {
                            if !fields.insert(__FieldTag::__transform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transform",
                                ));
                            }
                            if result.operation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operation`, a oneof with full ID .google.firestore.v1.Write.transform, latest field was transform",
                                ));
                            }
                            result.operation = std::option::Option::Some(
                                crate::model::write::Operation::Transform(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DocumentTransform>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask = map
                                .next_value::<std::option::Option<crate::model::DocumentMask>>()?;
                        }
                        __FieldTag::__update_transforms => {
                            if !fields.insert(__FieldTag::__update_transforms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_transforms",
                                ));
                            }
                            result.update_transforms = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::document_transform::FieldTransform>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__current_document => {
                            if !fields.insert(__FieldTag::__current_document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_document",
                                ));
                            }
                            result.current_document = map
                                .next_value::<std::option::Option<crate::model::Precondition>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DocumentTransform {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document,
            __field_transforms,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DocumentTransform")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "document" => Ok(__FieldTag::__document),
                            "fieldTransforms" => Ok(__FieldTag::__field_transforms),
                            "field_transforms" => Ok(__FieldTag::__field_transforms),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DocumentTransform;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DocumentTransform")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__field_transforms => {
                            if !fields.insert(__FieldTag::__field_transforms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_transforms",
                                ));
                            }
                            result.field_transforms = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::document_transform::FieldTransform>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::document_transform::FieldTransform {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field_path,
            __set_to_server_value,
            __increment,
            __maximum,
            __minimum,
            __append_missing_elements,
            __remove_all_from_array,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FieldTransform")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fieldPath" => Ok(__FieldTag::__field_path),
                            "field_path" => Ok(__FieldTag::__field_path),
                            "setToServerValue" => Ok(__FieldTag::__set_to_server_value),
                            "set_to_server_value" => Ok(__FieldTag::__set_to_server_value),
                            "increment" => Ok(__FieldTag::__increment),
                            "maximum" => Ok(__FieldTag::__maximum),
                            "minimum" => Ok(__FieldTag::__minimum),
                            "appendMissingElements" => Ok(__FieldTag::__append_missing_elements),
                            "append_missing_elements" => Ok(__FieldTag::__append_missing_elements),
                            "removeAllFromArray" => Ok(__FieldTag::__remove_all_from_array),
                            "remove_all_from_array" => Ok(__FieldTag::__remove_all_from_array),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::document_transform::FieldTransform;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FieldTransform")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field_path => {
                            if !fields.insert(__FieldTag::__field_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_path",
                                ));
                            }
                            result.field_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__set_to_server_value => {
                            if !fields.insert(__FieldTag::__set_to_server_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for set_to_server_value",
                                ));
                            }
                            if result.transform_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transform_type`, a oneof with full ID .google.firestore.v1.DocumentTransform.FieldTransform.set_to_server_value, latest field was setToServerValue",
                                ));
                            }
                            result.transform_type = std::option::Option::Some(
                                crate::model::document_transform::field_transform::TransformType::SetToServerValue(
                                    map.next_value::<std::option::Option<crate::model::document_transform::field_transform::ServerValue>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__increment => {
                            if !fields.insert(__FieldTag::__increment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for increment",
                                ));
                            }
                            if result.transform_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transform_type`, a oneof with full ID .google.firestore.v1.DocumentTransform.FieldTransform.increment, latest field was increment",
                                ));
                            }
                            result.transform_type = std::option::Option::Some(
                                crate::model::document_transform::field_transform::TransformType::Increment(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::Value>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__maximum => {
                            if !fields.insert(__FieldTag::__maximum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maximum",
                                ));
                            }
                            if result.transform_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transform_type`, a oneof with full ID .google.firestore.v1.DocumentTransform.FieldTransform.maximum, latest field was maximum",
                                ));
                            }
                            result.transform_type = std::option::Option::Some(
                                crate::model::document_transform::field_transform::TransformType::Maximum(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::Value>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__minimum => {
                            if !fields.insert(__FieldTag::__minimum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minimum",
                                ));
                            }
                            if result.transform_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transform_type`, a oneof with full ID .google.firestore.v1.DocumentTransform.FieldTransform.minimum, latest field was minimum",
                                ));
                            }
                            result.transform_type = std::option::Option::Some(
                                crate::model::document_transform::field_transform::TransformType::Minimum(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::Value>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__append_missing_elements => {
                            if !fields.insert(__FieldTag::__append_missing_elements) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for append_missing_elements",
                                ));
                            }
                            if result.transform_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transform_type`, a oneof with full ID .google.firestore.v1.DocumentTransform.FieldTransform.append_missing_elements, latest field was appendMissingElements",
                                ));
                            }
                            result.transform_type = std::option::Option::Some(
                                crate::model::document_transform::field_transform::TransformType::AppendMissingElements(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ArrayValue>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__remove_all_from_array => {
                            if !fields.insert(__FieldTag::__remove_all_from_array) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remove_all_from_array",
                                ));
                            }
                            if result.transform_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transform_type`, a oneof with full ID .google.firestore.v1.DocumentTransform.FieldTransform.remove_all_from_array, latest field was removeAllFromArray",
                                ));
                            }
                            result.transform_type = std::option::Option::Some(
                                crate::model::document_transform::field_transform::TransformType::RemoveAllFromArray(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ArrayValue>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::WriteResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_time,
            __transform_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WriteResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "transformResults" => Ok(__FieldTag::__transform_results),
                            "transform_results" => Ok(__FieldTag::__transform_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::WriteResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WriteResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__transform_results => {
                            if !fields.insert(__FieldTag::__transform_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transform_results",
                                ));
                            }
                            result.transform_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Value>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DocumentChange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document,
            __target_ids,
            __removed_target_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DocumentChange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "document" => Ok(__FieldTag::__document),
                            "targetIds" => Ok(__FieldTag::__target_ids),
                            "target_ids" => Ok(__FieldTag::__target_ids),
                            "removedTargetIds" => Ok(__FieldTag::__removed_target_ids),
                            "removed_target_ids" => Ok(__FieldTag::__removed_target_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DocumentChange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DocumentChange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document =
                                map.next_value::<std::option::Option<crate::model::Document>>()?;
                        }
                        __FieldTag::__target_ids => {
                            if !fields.insert(__FieldTag::__target_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_ids",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.target_ids = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__removed_target_ids => {
                            if !fields.insert(__FieldTag::__removed_target_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for removed_target_ids",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.removed_target_ids =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DocumentDelete {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document,
            __removed_target_ids,
            __read_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DocumentDelete")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "document" => Ok(__FieldTag::__document),
                            "removedTargetIds" => Ok(__FieldTag::__removed_target_ids),
                            "removed_target_ids" => Ok(__FieldTag::__removed_target_ids),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DocumentDelete;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DocumentDelete")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__removed_target_ids => {
                            if !fields.insert(__FieldTag::__removed_target_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for removed_target_ids",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.removed_target_ids =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            result.read_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DocumentRemove {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document,
            __removed_target_ids,
            __read_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DocumentRemove")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "document" => Ok(__FieldTag::__document),
                            "removedTargetIds" => Ok(__FieldTag::__removed_target_ids),
                            "removed_target_ids" => Ok(__FieldTag::__removed_target_ids),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DocumentRemove;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DocumentRemove")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__removed_target_ids => {
                            if !fields.insert(__FieldTag::__removed_target_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for removed_target_ids",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.removed_target_ids =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            result.read_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExistenceFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_id,
            __count,
            __unchanged_names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExistenceFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetId" => Ok(__FieldTag::__target_id),
                            "target_id" => Ok(__FieldTag::__target_id),
                            "count" => Ok(__FieldTag::__count),
                            "unchangedNames" => Ok(__FieldTag::__unchanged_names),
                            "unchanged_names" => Ok(__FieldTag::__unchanged_names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExistenceFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExistenceFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_id => {
                            if !fields.insert(__FieldTag::__target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_id",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__count => {
                            if !fields.insert(__FieldTag::__count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unchanged_names => {
                            if !fields.insert(__FieldTag::__unchanged_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unchanged_names",
                                ));
                            }
                            result.unchanged_names =
                                map.next_value::<std::option::Option<crate::model::BloomFilter>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
