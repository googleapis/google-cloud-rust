// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Document {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "2")]
    pub fields: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
impl ::prost::Name for Document {
    const NAME: &'static str = "Document";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.Document".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.Document".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(oneof = "value::ValueType", tags = "11, 1, 2, 3, 10, 17, 18, 5, 8, 9, 6")]
    pub value_type: ::core::option::Option<value::ValueType>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ValueType {
        #[prost(enumeration = "::prost_types::NullValue", tag = "11")]
        NullValue(i32),
        #[prost(bool, tag = "1")]
        BooleanValue(bool),
        #[prost(int64, tag = "2")]
        IntegerValue(i64),
        #[prost(double, tag = "3")]
        DoubleValue(f64),
        #[prost(message, tag = "10")]
        TimestampValue(::prost_types::Timestamp),
        #[prost(string, tag = "17")]
        StringValue(::prost::alloc::string::String),
        #[prost(bytes, tag = "18")]
        BytesValue(::prost::bytes::Bytes),
        #[prost(string, tag = "5")]
        ReferenceValue(::prost::alloc::string::String),
        #[prost(message, tag = "8")]
        GeoPointValue(super::super::super::r#type::LatLng),
        #[prost(message, tag = "9")]
        ArrayValue(super::ArrayValue),
        #[prost(message, tag = "6")]
        MapValue(super::MapValue),
    }
}
impl ::prost::Name for Value {
    const NAME: &'static str = "Value";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.Value".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.Value".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArrayValue {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<Value>,
}
impl ::prost::Name for ArrayValue {
    const NAME: &'static str = "ArrayValue";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.ArrayValue".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.ArrayValue".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapValue {
    #[prost(map = "string, message", tag = "1")]
    pub fields: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
}
impl ::prost::Name for MapValue {
    const NAME: &'static str = "MapValue";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.MapValue".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.MapValue".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregationResult {
    #[prost(map = "string, message", tag = "2")]
    pub aggregate_fields: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        Value,
    >,
}
impl ::prost::Name for AggregationResult {
    const NAME: &'static str = "AggregationResult";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.AggregationResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.AggregationResult".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BitSequence {
    #[prost(bytes = "bytes", tag = "1")]
    pub bitmap: ::prost::bytes::Bytes,
    #[prost(int32, tag = "2")]
    pub padding: i32,
}
impl ::prost::Name for BitSequence {
    const NAME: &'static str = "BitSequence";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.BitSequence".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.BitSequence".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BloomFilter {
    #[prost(message, optional, tag = "1")]
    pub bits: ::core::option::Option<BitSequence>,
    #[prost(int32, tag = "2")]
    pub hash_count: i32,
}
impl ::prost::Name for BloomFilter {
    const NAME: &'static str = "BloomFilter";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.BloomFilter".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.BloomFilter".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentMask {
    #[prost(string, repeated, tag = "1")]
    pub field_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for DocumentMask {
    const NAME: &'static str = "DocumentMask";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.DocumentMask".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.DocumentMask".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Precondition {
    #[prost(oneof = "precondition::ConditionType", tags = "1, 2")]
    pub condition_type: ::core::option::Option<precondition::ConditionType>,
}
/// Nested message and enum types in `Precondition`.
pub mod precondition {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ConditionType {
        #[prost(bool, tag = "1")]
        Exists(bool),
        #[prost(message, tag = "2")]
        UpdateTime(::prost_types::Timestamp),
    }
}
impl ::prost::Name for Precondition {
    const NAME: &'static str = "Precondition";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.Precondition".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.Precondition".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionOptions {
    #[prost(oneof = "transaction_options::Mode", tags = "2, 3")]
    pub mode: ::core::option::Option<transaction_options::Mode>,
}
/// Nested message and enum types in `TransactionOptions`.
pub mod transaction_options {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReadWrite {
        #[prost(bytes = "bytes", tag = "1")]
        pub retry_transaction: ::prost::bytes::Bytes,
    }
    impl ::prost::Name for ReadWrite {
        const NAME: &'static str = "ReadWrite";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.TransactionOptions.ReadWrite".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.TransactionOptions.ReadWrite".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ReadOnly {
        #[prost(oneof = "read_only::ConsistencySelector", tags = "2")]
        pub consistency_selector: ::core::option::Option<read_only::ConsistencySelector>,
    }
    /// Nested message and enum types in `ReadOnly`.
    pub mod read_only {
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum ConsistencySelector {
            #[prost(message, tag = "2")]
            ReadTime(::prost_types::Timestamp),
        }
    }
    impl ::prost::Name for ReadOnly {
        const NAME: &'static str = "ReadOnly";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.TransactionOptions.ReadOnly".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.TransactionOptions.ReadOnly".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Mode {
        #[prost(message, tag = "2")]
        ReadOnly(ReadOnly),
        #[prost(message, tag = "3")]
        ReadWrite(ReadWrite),
    }
}
impl ::prost::Name for TransactionOptions {
    const NAME: &'static str = "TransactionOptions";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.TransactionOptions".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.TransactionOptions".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructuredQuery {
    #[prost(message, optional, tag = "1")]
    pub select: ::core::option::Option<structured_query::Projection>,
    #[prost(message, repeated, tag = "2")]
    pub from: ::prost::alloc::vec::Vec<structured_query::CollectionSelector>,
    #[prost(message, optional, tag = "3")]
    pub r#where: ::core::option::Option<structured_query::Filter>,
    #[prost(message, repeated, tag = "4")]
    pub order_by: ::prost::alloc::vec::Vec<structured_query::Order>,
    #[prost(message, optional, tag = "7")]
    pub start_at: ::core::option::Option<Cursor>,
    #[prost(message, optional, tag = "8")]
    pub end_at: ::core::option::Option<Cursor>,
    #[prost(int32, tag = "6")]
    pub offset: i32,
    #[prost(message, optional, tag = "5")]
    pub limit: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "9")]
    pub find_nearest: ::core::option::Option<structured_query::FindNearest>,
}
/// Nested message and enum types in `StructuredQuery`.
pub mod structured_query {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CollectionSelector {
        #[prost(string, tag = "2")]
        pub collection_id: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub all_descendants: bool,
    }
    impl ::prost::Name for CollectionSelector {
        const NAME: &'static str = "CollectionSelector";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.StructuredQuery.CollectionSelector".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.StructuredQuery.CollectionSelector"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Filter {
        #[prost(oneof = "filter::FilterType", tags = "1, 2, 3")]
        pub filter_type: ::core::option::Option<filter::FilterType>,
    }
    /// Nested message and enum types in `Filter`.
    pub mod filter {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum FilterType {
            #[prost(message, tag = "1")]
            CompositeFilter(super::CompositeFilter),
            #[prost(message, tag = "2")]
            FieldFilter(super::FieldFilter),
            #[prost(message, tag = "3")]
            UnaryFilter(super::UnaryFilter),
        }
    }
    impl ::prost::Name for Filter {
        const NAME: &'static str = "Filter";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.StructuredQuery.Filter".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.StructuredQuery.Filter".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CompositeFilter {
        #[prost(enumeration = "composite_filter::Operator", tag = "1")]
        pub op: i32,
        #[prost(message, repeated, tag = "2")]
        pub filters: ::prost::alloc::vec::Vec<Filter>,
    }
    /// Nested message and enum types in `CompositeFilter`.
    pub mod composite_filter {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operator {
            Unspecified = 0,
            And = 1,
            Or = 2,
        }
        impl Operator {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "OPERATOR_UNSPECIFIED",
                    Self::And => "AND",
                    Self::Or => "OR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                    "AND" => Some(Self::And),
                    "OR" => Some(Self::Or),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for CompositeFilter {
        const NAME: &'static str = "CompositeFilter";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.StructuredQuery.CompositeFilter".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.StructuredQuery.CompositeFilter"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FieldFilter {
        #[prost(message, optional, tag = "1")]
        pub field: ::core::option::Option<FieldReference>,
        #[prost(enumeration = "field_filter::Operator", tag = "2")]
        pub op: i32,
        #[prost(message, optional, tag = "3")]
        pub value: ::core::option::Option<super::Value>,
    }
    /// Nested message and enum types in `FieldFilter`.
    pub mod field_filter {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operator {
            Unspecified = 0,
            LessThan = 1,
            LessThanOrEqual = 2,
            GreaterThan = 3,
            GreaterThanOrEqual = 4,
            Equal = 5,
            NotEqual = 6,
            ArrayContains = 7,
            In = 8,
            ArrayContainsAny = 9,
            NotIn = 10,
        }
        impl Operator {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "OPERATOR_UNSPECIFIED",
                    Self::LessThan => "LESS_THAN",
                    Self::LessThanOrEqual => "LESS_THAN_OR_EQUAL",
                    Self::GreaterThan => "GREATER_THAN",
                    Self::GreaterThanOrEqual => "GREATER_THAN_OR_EQUAL",
                    Self::Equal => "EQUAL",
                    Self::NotEqual => "NOT_EQUAL",
                    Self::ArrayContains => "ARRAY_CONTAINS",
                    Self::In => "IN",
                    Self::ArrayContainsAny => "ARRAY_CONTAINS_ANY",
                    Self::NotIn => "NOT_IN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                    "LESS_THAN" => Some(Self::LessThan),
                    "LESS_THAN_OR_EQUAL" => Some(Self::LessThanOrEqual),
                    "GREATER_THAN" => Some(Self::GreaterThan),
                    "GREATER_THAN_OR_EQUAL" => Some(Self::GreaterThanOrEqual),
                    "EQUAL" => Some(Self::Equal),
                    "NOT_EQUAL" => Some(Self::NotEqual),
                    "ARRAY_CONTAINS" => Some(Self::ArrayContains),
                    "IN" => Some(Self::In),
                    "ARRAY_CONTAINS_ANY" => Some(Self::ArrayContainsAny),
                    "NOT_IN" => Some(Self::NotIn),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for FieldFilter {
        const NAME: &'static str = "FieldFilter";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.StructuredQuery.FieldFilter".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.StructuredQuery.FieldFilter".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UnaryFilter {
        #[prost(enumeration = "unary_filter::Operator", tag = "1")]
        pub op: i32,
        #[prost(oneof = "unary_filter::OperandType", tags = "2")]
        pub operand_type: ::core::option::Option<unary_filter::OperandType>,
    }
    /// Nested message and enum types in `UnaryFilter`.
    pub mod unary_filter {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operator {
            Unspecified = 0,
            IsNan = 2,
            IsNull = 3,
            IsNotNan = 4,
            IsNotNull = 5,
        }
        impl Operator {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "OPERATOR_UNSPECIFIED",
                    Self::IsNan => "IS_NAN",
                    Self::IsNull => "IS_NULL",
                    Self::IsNotNan => "IS_NOT_NAN",
                    Self::IsNotNull => "IS_NOT_NULL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                    "IS_NAN" => Some(Self::IsNan),
                    "IS_NULL" => Some(Self::IsNull),
                    "IS_NOT_NAN" => Some(Self::IsNotNan),
                    "IS_NOT_NULL" => Some(Self::IsNotNull),
                    _ => None,
                }
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum OperandType {
            #[prost(message, tag = "2")]
            Field(super::FieldReference),
        }
    }
    impl ::prost::Name for UnaryFilter {
        const NAME: &'static str = "UnaryFilter";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.StructuredQuery.UnaryFilter".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.StructuredQuery.UnaryFilter".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Order {
        #[prost(message, optional, tag = "1")]
        pub field: ::core::option::Option<FieldReference>,
        #[prost(enumeration = "Direction", tag = "2")]
        pub direction: i32,
    }
    impl ::prost::Name for Order {
        const NAME: &'static str = "Order";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.StructuredQuery.Order".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.StructuredQuery.Order".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FieldReference {
        #[prost(string, tag = "2")]
        pub field_path: ::prost::alloc::string::String,
    }
    impl ::prost::Name for FieldReference {
        const NAME: &'static str = "FieldReference";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.StructuredQuery.FieldReference".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.StructuredQuery.FieldReference"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Projection {
        #[prost(message, repeated, tag = "2")]
        pub fields: ::prost::alloc::vec::Vec<FieldReference>,
    }
    impl ::prost::Name for Projection {
        const NAME: &'static str = "Projection";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.StructuredQuery.Projection".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.StructuredQuery.Projection".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FindNearest {
        #[prost(message, optional, tag = "1")]
        pub vector_field: ::core::option::Option<FieldReference>,
        #[prost(message, optional, tag = "2")]
        pub query_vector: ::core::option::Option<super::Value>,
        #[prost(enumeration = "find_nearest::DistanceMeasure", tag = "3")]
        pub distance_measure: i32,
        #[prost(message, optional, tag = "4")]
        pub limit: ::core::option::Option<i32>,
        #[prost(string, tag = "5")]
        pub distance_result_field: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "6")]
        pub distance_threshold: ::core::option::Option<f64>,
    }
    /// Nested message and enum types in `FindNearest`.
    pub mod find_nearest {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum DistanceMeasure {
            Unspecified = 0,
            Euclidean = 1,
            Cosine = 2,
            DotProduct = 3,
        }
        impl DistanceMeasure {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "DISTANCE_MEASURE_UNSPECIFIED",
                    Self::Euclidean => "EUCLIDEAN",
                    Self::Cosine => "COSINE",
                    Self::DotProduct => "DOT_PRODUCT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DISTANCE_MEASURE_UNSPECIFIED" => Some(Self::Unspecified),
                    "EUCLIDEAN" => Some(Self::Euclidean),
                    "COSINE" => Some(Self::Cosine),
                    "DOT_PRODUCT" => Some(Self::DotProduct),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for FindNearest {
        const NAME: &'static str = "FindNearest";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.StructuredQuery.FindNearest".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.StructuredQuery.FindNearest".into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        Unspecified = 0,
        Ascending = 1,
        Descending = 2,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DIRECTION_UNSPECIFIED",
                Self::Ascending => "ASCENDING",
                Self::Descending => "DESCENDING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
                "ASCENDING" => Some(Self::Ascending),
                "DESCENDING" => Some(Self::Descending),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for StructuredQuery {
    const NAME: &'static str = "StructuredQuery";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.StructuredQuery".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.StructuredQuery".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructuredAggregationQuery {
    #[prost(message, repeated, tag = "3")]
    pub aggregations: ::prost::alloc::vec::Vec<
        structured_aggregation_query::Aggregation,
    >,
    #[prost(oneof = "structured_aggregation_query::QueryType", tags = "1")]
    pub query_type: ::core::option::Option<structured_aggregation_query::QueryType>,
}
/// Nested message and enum types in `StructuredAggregationQuery`.
pub mod structured_aggregation_query {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Aggregation {
        #[prost(string, tag = "7")]
        pub alias: ::prost::alloc::string::String,
        #[prost(oneof = "aggregation::Operator", tags = "1, 2, 3")]
        pub operator: ::core::option::Option<aggregation::Operator>,
    }
    /// Nested message and enum types in `Aggregation`.
    pub mod aggregation {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Count {
            #[prost(message, optional, tag = "1")]
            pub up_to: ::core::option::Option<i64>,
        }
        impl ::prost::Name for Count {
            const NAME: &'static str = "Count";
            const PACKAGE: &'static str = "google.firestore.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.firestore.v1.StructuredAggregationQuery.Aggregation.Count".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.firestore.v1.StructuredAggregationQuery.Aggregation.Count"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Sum {
            #[prost(message, optional, tag = "1")]
            pub field: ::core::option::Option<
                super::super::structured_query::FieldReference,
            >,
        }
        impl ::prost::Name for Sum {
            const NAME: &'static str = "Sum";
            const PACKAGE: &'static str = "google.firestore.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.firestore.v1.StructuredAggregationQuery.Aggregation.Sum".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.firestore.v1.StructuredAggregationQuery.Aggregation.Sum"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Avg {
            #[prost(message, optional, tag = "1")]
            pub field: ::core::option::Option<
                super::super::structured_query::FieldReference,
            >,
        }
        impl ::prost::Name for Avg {
            const NAME: &'static str = "Avg";
            const PACKAGE: &'static str = "google.firestore.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.firestore.v1.StructuredAggregationQuery.Aggregation.Avg".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.firestore.v1.StructuredAggregationQuery.Aggregation.Avg"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Operator {
            #[prost(message, tag = "1")]
            Count(Count),
            #[prost(message, tag = "2")]
            Sum(Sum),
            #[prost(message, tag = "3")]
            Avg(Avg),
        }
    }
    impl ::prost::Name for Aggregation {
        const NAME: &'static str = "Aggregation";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.StructuredAggregationQuery.Aggregation".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.StructuredAggregationQuery.Aggregation"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum QueryType {
        #[prost(message, tag = "1")]
        StructuredQuery(super::StructuredQuery),
    }
}
impl ::prost::Name for StructuredAggregationQuery {
    const NAME: &'static str = "StructuredAggregationQuery";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.StructuredAggregationQuery".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.StructuredAggregationQuery".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cursor {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<Value>,
    #[prost(bool, tag = "2")]
    pub before: bool,
}
impl ::prost::Name for Cursor {
    const NAME: &'static str = "Cursor";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.Cursor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.Cursor".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExplainOptions {
    #[prost(bool, tag = "1")]
    pub analyze: bool,
}
impl ::prost::Name for ExplainOptions {
    const NAME: &'static str = "ExplainOptions";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.ExplainOptions".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.ExplainOptions".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplainMetrics {
    #[prost(message, optional, tag = "1")]
    pub plan_summary: ::core::option::Option<PlanSummary>,
    #[prost(message, optional, tag = "2")]
    pub execution_stats: ::core::option::Option<ExecutionStats>,
}
impl ::prost::Name for ExplainMetrics {
    const NAME: &'static str = "ExplainMetrics";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.ExplainMetrics".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.ExplainMetrics".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlanSummary {
    #[prost(message, repeated, tag = "1")]
    pub indexes_used: ::prost::alloc::vec::Vec<::prost_types::Struct>,
}
impl ::prost::Name for PlanSummary {
    const NAME: &'static str = "PlanSummary";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.PlanSummary".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.PlanSummary".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionStats {
    #[prost(int64, tag = "1")]
    pub results_returned: i64,
    #[prost(message, optional, tag = "3")]
    pub execution_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(int64, tag = "4")]
    pub read_operations: i64,
    #[prost(message, optional, tag = "5")]
    pub debug_stats: ::core::option::Option<::prost_types::Struct>,
}
impl ::prost::Name for ExecutionStats {
    const NAME: &'static str = "ExecutionStats";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.ExecutionStats".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.ExecutionStats".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Write {
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<DocumentMask>,
    #[prost(message, repeated, tag = "7")]
    pub update_transforms: ::prost::alloc::vec::Vec<document_transform::FieldTransform>,
    #[prost(message, optional, tag = "4")]
    pub current_document: ::core::option::Option<Precondition>,
    #[prost(oneof = "write::Operation", tags = "1, 2, 6")]
    pub operation: ::core::option::Option<write::Operation>,
}
/// Nested message and enum types in `Write`.
pub mod write {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        #[prost(message, tag = "1")]
        Update(super::Document),
        #[prost(string, tag = "2")]
        Delete(::prost::alloc::string::String),
        #[prost(message, tag = "6")]
        Transform(super::DocumentTransform),
    }
}
impl ::prost::Name for Write {
    const NAME: &'static str = "Write";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.Write".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.Write".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentTransform {
    #[prost(string, tag = "1")]
    pub document: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub field_transforms: ::prost::alloc::vec::Vec<document_transform::FieldTransform>,
}
/// Nested message and enum types in `DocumentTransform`.
pub mod document_transform {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FieldTransform {
        #[prost(string, tag = "1")]
        pub field_path: ::prost::alloc::string::String,
        #[prost(oneof = "field_transform::TransformType", tags = "2, 3, 4, 5, 6, 7")]
        pub transform_type: ::core::option::Option<field_transform::TransformType>,
    }
    /// Nested message and enum types in `FieldTransform`.
    pub mod field_transform {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ServerValue {
            Unspecified = 0,
            RequestTime = 1,
        }
        impl ServerValue {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SERVER_VALUE_UNSPECIFIED",
                    Self::RequestTime => "REQUEST_TIME",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SERVER_VALUE_UNSPECIFIED" => Some(Self::Unspecified),
                    "REQUEST_TIME" => Some(Self::RequestTime),
                    _ => None,
                }
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum TransformType {
            #[prost(enumeration = "ServerValue", tag = "2")]
            SetToServerValue(i32),
            #[prost(message, tag = "3")]
            Increment(super::super::Value),
            #[prost(message, tag = "4")]
            Maximum(super::super::Value),
            #[prost(message, tag = "5")]
            Minimum(super::super::Value),
            #[prost(message, tag = "6")]
            AppendMissingElements(super::super::ArrayValue),
            #[prost(message, tag = "7")]
            RemoveAllFromArray(super::super::ArrayValue),
        }
    }
    impl ::prost::Name for FieldTransform {
        const NAME: &'static str = "FieldTransform";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.DocumentTransform.FieldTransform".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.DocumentTransform.FieldTransform"
                .into()
        }
    }
}
impl ::prost::Name for DocumentTransform {
    const NAME: &'static str = "DocumentTransform";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.DocumentTransform".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.DocumentTransform".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteResult {
    #[prost(message, optional, tag = "1")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "2")]
    pub transform_results: ::prost::alloc::vec::Vec<Value>,
}
impl ::prost::Name for WriteResult {
    const NAME: &'static str = "WriteResult";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.WriteResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.WriteResult".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentChange {
    #[prost(message, optional, tag = "1")]
    pub document: ::core::option::Option<Document>,
    #[prost(int32, repeated, tag = "5")]
    pub target_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, tag = "6")]
    pub removed_target_ids: ::prost::alloc::vec::Vec<i32>,
}
impl ::prost::Name for DocumentChange {
    const NAME: &'static str = "DocumentChange";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.DocumentChange".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.DocumentChange".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentDelete {
    #[prost(string, tag = "1")]
    pub document: ::prost::alloc::string::String,
    #[prost(int32, repeated, tag = "6")]
    pub removed_target_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "4")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
}
impl ::prost::Name for DocumentDelete {
    const NAME: &'static str = "DocumentDelete";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.DocumentDelete".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.DocumentDelete".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentRemove {
    #[prost(string, tag = "1")]
    pub document: ::prost::alloc::string::String,
    #[prost(int32, repeated, tag = "2")]
    pub removed_target_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "4")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
}
impl ::prost::Name for DocumentRemove {
    const NAME: &'static str = "DocumentRemove";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.DocumentRemove".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.DocumentRemove".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExistenceFilter {
    #[prost(int32, tag = "1")]
    pub target_id: i32,
    #[prost(int32, tag = "2")]
    pub count: i32,
    #[prost(message, optional, tag = "3")]
    pub unchanged_names: ::core::option::Option<BloomFilter>,
}
impl ::prost::Name for ExistenceFilter {
    const NAME: &'static str = "ExistenceFilter";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.ExistenceFilter".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.ExistenceFilter".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDocumentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub mask: ::core::option::Option<DocumentMask>,
    #[prost(oneof = "get_document_request::ConsistencySelector", tags = "3, 5")]
    pub consistency_selector: ::core::option::Option<
        get_document_request::ConsistencySelector,
    >,
}
/// Nested message and enum types in `GetDocumentRequest`.
pub mod get_document_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConsistencySelector {
        #[prost(bytes, tag = "3")]
        Transaction(::prost::bytes::Bytes),
        #[prost(message, tag = "5")]
        ReadTime(::prost_types::Timestamp),
    }
}
impl ::prost::Name for GetDocumentRequest {
    const NAME: &'static str = "GetDocumentRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.GetDocumentRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.GetDocumentRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub mask: ::core::option::Option<DocumentMask>,
    #[prost(bool, tag = "12")]
    pub show_missing: bool,
    #[prost(oneof = "list_documents_request::ConsistencySelector", tags = "8, 10")]
    pub consistency_selector: ::core::option::Option<
        list_documents_request::ConsistencySelector,
    >,
}
/// Nested message and enum types in `ListDocumentsRequest`.
pub mod list_documents_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConsistencySelector {
        #[prost(bytes, tag = "8")]
        Transaction(::prost::bytes::Bytes),
        #[prost(message, tag = "10")]
        ReadTime(::prost_types::Timestamp),
    }
}
impl ::prost::Name for ListDocumentsRequest {
    const NAME: &'static str = "ListDocumentsRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.ListDocumentsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.ListDocumentsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub documents: ::prost::alloc::vec::Vec<Document>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListDocumentsResponse {
    const NAME: &'static str = "ListDocumentsResponse";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.ListDocumentsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.ListDocumentsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDocumentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub document_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub document: ::core::option::Option<Document>,
    #[prost(message, optional, tag = "5")]
    pub mask: ::core::option::Option<DocumentMask>,
}
impl ::prost::Name for CreateDocumentRequest {
    const NAME: &'static str = "CreateDocumentRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.CreateDocumentRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.CreateDocumentRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDocumentRequest {
    #[prost(message, optional, tag = "1")]
    pub document: ::core::option::Option<Document>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<DocumentMask>,
    #[prost(message, optional, tag = "3")]
    pub mask: ::core::option::Option<DocumentMask>,
    #[prost(message, optional, tag = "4")]
    pub current_document: ::core::option::Option<Precondition>,
}
impl ::prost::Name for UpdateDocumentRequest {
    const NAME: &'static str = "UpdateDocumentRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.UpdateDocumentRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.UpdateDocumentRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDocumentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub current_document: ::core::option::Option<Precondition>,
}
impl ::prost::Name for DeleteDocumentRequest {
    const NAME: &'static str = "DeleteDocumentRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.DeleteDocumentRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.DeleteDocumentRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetDocumentsRequest {
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub mask: ::core::option::Option<DocumentMask>,
    #[prost(
        oneof = "batch_get_documents_request::ConsistencySelector",
        tags = "4, 5, 7"
    )]
    pub consistency_selector: ::core::option::Option<
        batch_get_documents_request::ConsistencySelector,
    >,
}
/// Nested message and enum types in `BatchGetDocumentsRequest`.
pub mod batch_get_documents_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConsistencySelector {
        #[prost(bytes, tag = "4")]
        Transaction(::prost::bytes::Bytes),
        #[prost(message, tag = "5")]
        NewTransaction(super::TransactionOptions),
        #[prost(message, tag = "7")]
        ReadTime(::prost_types::Timestamp),
    }
}
impl ::prost::Name for BatchGetDocumentsRequest {
    const NAME: &'static str = "BatchGetDocumentsRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.BatchGetDocumentsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.BatchGetDocumentsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetDocumentsResponse {
    #[prost(bytes = "bytes", tag = "3")]
    pub transaction: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "4")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "batch_get_documents_response::Result", tags = "1, 2")]
    pub result: ::core::option::Option<batch_get_documents_response::Result>,
}
/// Nested message and enum types in `BatchGetDocumentsResponse`.
pub mod batch_get_documents_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        Found(super::Document),
        #[prost(string, tag = "2")]
        Missing(::prost::alloc::string::String),
    }
}
impl ::prost::Name for BatchGetDocumentsResponse {
    const NAME: &'static str = "BatchGetDocumentsResponse";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.BatchGetDocumentsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.BatchGetDocumentsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginTransactionRequest {
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub options: ::core::option::Option<TransactionOptions>,
}
impl ::prost::Name for BeginTransactionRequest {
    const NAME: &'static str = "BeginTransactionRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.BeginTransactionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.BeginTransactionRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginTransactionResponse {
    #[prost(bytes = "bytes", tag = "1")]
    pub transaction: ::prost::bytes::Bytes,
}
impl ::prost::Name for BeginTransactionResponse {
    const NAME: &'static str = "BeginTransactionResponse";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.BeginTransactionResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.BeginTransactionResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitRequest {
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub writes: ::prost::alloc::vec::Vec<Write>,
    #[prost(bytes = "bytes", tag = "3")]
    pub transaction: ::prost::bytes::Bytes,
}
impl ::prost::Name for CommitRequest {
    const NAME: &'static str = "CommitRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.CommitRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.CommitRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitResponse {
    #[prost(message, repeated, tag = "1")]
    pub write_results: ::prost::alloc::vec::Vec<WriteResult>,
    #[prost(message, optional, tag = "2")]
    pub commit_time: ::core::option::Option<::prost_types::Timestamp>,
}
impl ::prost::Name for CommitResponse {
    const NAME: &'static str = "CommitResponse";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.CommitResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.CommitResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackRequest {
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub transaction: ::prost::bytes::Bytes,
}
impl ::prost::Name for RollbackRequest {
    const NAME: &'static str = "RollbackRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.RollbackRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.RollbackRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunQueryRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub explain_options: ::core::option::Option<ExplainOptions>,
    #[prost(oneof = "run_query_request::QueryType", tags = "2")]
    pub query_type: ::core::option::Option<run_query_request::QueryType>,
    #[prost(oneof = "run_query_request::ConsistencySelector", tags = "5, 6, 7")]
    pub consistency_selector: ::core::option::Option<
        run_query_request::ConsistencySelector,
    >,
}
/// Nested message and enum types in `RunQueryRequest`.
pub mod run_query_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum QueryType {
        #[prost(message, tag = "2")]
        StructuredQuery(super::StructuredQuery),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConsistencySelector {
        #[prost(bytes, tag = "5")]
        Transaction(::prost::bytes::Bytes),
        #[prost(message, tag = "6")]
        NewTransaction(super::TransactionOptions),
        #[prost(message, tag = "7")]
        ReadTime(::prost_types::Timestamp),
    }
}
impl ::prost::Name for RunQueryRequest {
    const NAME: &'static str = "RunQueryRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.RunQueryRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.RunQueryRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunQueryResponse {
    #[prost(bytes = "bytes", tag = "2")]
    pub transaction: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "1")]
    pub document: ::core::option::Option<Document>,
    #[prost(message, optional, tag = "3")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, tag = "4")]
    pub skipped_results: i32,
    #[prost(message, optional, tag = "11")]
    pub explain_metrics: ::core::option::Option<ExplainMetrics>,
    #[prost(oneof = "run_query_response::ContinuationSelector", tags = "6")]
    pub continuation_selector: ::core::option::Option<
        run_query_response::ContinuationSelector,
    >,
}
/// Nested message and enum types in `RunQueryResponse`.
pub mod run_query_response {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ContinuationSelector {
        #[prost(bool, tag = "6")]
        Done(bool),
    }
}
impl ::prost::Name for RunQueryResponse {
    const NAME: &'static str = "RunQueryResponse";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.RunQueryResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.RunQueryResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunAggregationQueryRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub explain_options: ::core::option::Option<ExplainOptions>,
    #[prost(oneof = "run_aggregation_query_request::QueryType", tags = "2")]
    pub query_type: ::core::option::Option<run_aggregation_query_request::QueryType>,
    #[prost(
        oneof = "run_aggregation_query_request::ConsistencySelector",
        tags = "4, 5, 6"
    )]
    pub consistency_selector: ::core::option::Option<
        run_aggregation_query_request::ConsistencySelector,
    >,
}
/// Nested message and enum types in `RunAggregationQueryRequest`.
pub mod run_aggregation_query_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum QueryType {
        #[prost(message, tag = "2")]
        StructuredAggregationQuery(super::StructuredAggregationQuery),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConsistencySelector {
        #[prost(bytes, tag = "4")]
        Transaction(::prost::bytes::Bytes),
        #[prost(message, tag = "5")]
        NewTransaction(super::TransactionOptions),
        #[prost(message, tag = "6")]
        ReadTime(::prost_types::Timestamp),
    }
}
impl ::prost::Name for RunAggregationQueryRequest {
    const NAME: &'static str = "RunAggregationQueryRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.RunAggregationQueryRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.RunAggregationQueryRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunAggregationQueryResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<AggregationResult>,
    #[prost(bytes = "bytes", tag = "2")]
    pub transaction: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "3")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub explain_metrics: ::core::option::Option<ExplainMetrics>,
}
impl ::prost::Name for RunAggregationQueryResponse {
    const NAME: &'static str = "RunAggregationQueryResponse";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.RunAggregationQueryResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.RunAggregationQueryResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionQueryRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub partition_count: i64,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    #[prost(oneof = "partition_query_request::QueryType", tags = "2")]
    pub query_type: ::core::option::Option<partition_query_request::QueryType>,
    #[prost(oneof = "partition_query_request::ConsistencySelector", tags = "6")]
    pub consistency_selector: ::core::option::Option<
        partition_query_request::ConsistencySelector,
    >,
}
/// Nested message and enum types in `PartitionQueryRequest`.
pub mod partition_query_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum QueryType {
        #[prost(message, tag = "2")]
        StructuredQuery(super::StructuredQuery),
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ConsistencySelector {
        #[prost(message, tag = "6")]
        ReadTime(::prost_types::Timestamp),
    }
}
impl ::prost::Name for PartitionQueryRequest {
    const NAME: &'static str = "PartitionQueryRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.PartitionQueryRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.PartitionQueryRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionQueryResponse {
    #[prost(message, repeated, tag = "1")]
    pub partitions: ::prost::alloc::vec::Vec<Cursor>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for PartitionQueryResponse {
    const NAME: &'static str = "PartitionQueryResponse";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.PartitionQueryResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.PartitionQueryResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteRequest {
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub stream_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub writes: ::prost::alloc::vec::Vec<Write>,
    #[prost(bytes = "bytes", tag = "4")]
    pub stream_token: ::prost::bytes::Bytes,
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for WriteRequest {
    const NAME: &'static str = "WriteRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.WriteRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.WriteRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteResponse {
    #[prost(string, tag = "1")]
    pub stream_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub stream_token: ::prost::bytes::Bytes,
    #[prost(message, repeated, tag = "3")]
    pub write_results: ::prost::alloc::vec::Vec<WriteResult>,
    #[prost(message, optional, tag = "4")]
    pub commit_time: ::core::option::Option<::prost_types::Timestamp>,
}
impl ::prost::Name for WriteResponse {
    const NAME: &'static str = "WriteResponse";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.WriteResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.WriteResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListenRequest {
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(oneof = "listen_request::TargetChange", tags = "2, 3")]
    pub target_change: ::core::option::Option<listen_request::TargetChange>,
}
/// Nested message and enum types in `ListenRequest`.
pub mod listen_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TargetChange {
        #[prost(message, tag = "2")]
        AddTarget(super::Target),
        #[prost(int32, tag = "3")]
        RemoveTarget(i32),
    }
}
impl ::prost::Name for ListenRequest {
    const NAME: &'static str = "ListenRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.ListenRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.ListenRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListenResponse {
    #[prost(oneof = "listen_response::ResponseType", tags = "2, 3, 4, 6, 5")]
    pub response_type: ::core::option::Option<listen_response::ResponseType>,
}
/// Nested message and enum types in `ListenResponse`.
pub mod listen_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResponseType {
        #[prost(message, tag = "2")]
        TargetChange(super::TargetChange),
        #[prost(message, tag = "3")]
        DocumentChange(super::DocumentChange),
        #[prost(message, tag = "4")]
        DocumentDelete(super::DocumentDelete),
        #[prost(message, tag = "6")]
        DocumentRemove(super::DocumentRemove),
        #[prost(message, tag = "5")]
        Filter(super::ExistenceFilter),
    }
}
impl ::prost::Name for ListenResponse {
    const NAME: &'static str = "ListenResponse";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.ListenResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.ListenResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Target {
    #[prost(int32, tag = "5")]
    pub target_id: i32,
    #[prost(bool, tag = "6")]
    pub once: bool,
    #[prost(message, optional, tag = "12")]
    pub expected_count: ::core::option::Option<i32>,
    #[prost(oneof = "target::TargetType", tags = "2, 3")]
    pub target_type: ::core::option::Option<target::TargetType>,
    #[prost(oneof = "target::ResumeType", tags = "4, 11")]
    pub resume_type: ::core::option::Option<target::ResumeType>,
}
/// Nested message and enum types in `Target`.
pub mod target {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DocumentsTarget {
        #[prost(string, repeated, tag = "2")]
        pub documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for DocumentsTarget {
        const NAME: &'static str = "DocumentsTarget";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.Target.DocumentsTarget".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.Target.DocumentsTarget".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QueryTarget {
        #[prost(string, tag = "1")]
        pub parent: ::prost::alloc::string::String,
        #[prost(oneof = "query_target::QueryType", tags = "2")]
        pub query_type: ::core::option::Option<query_target::QueryType>,
    }
    /// Nested message and enum types in `QueryTarget`.
    pub mod query_target {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum QueryType {
            #[prost(message, tag = "2")]
            StructuredQuery(super::super::StructuredQuery),
        }
    }
    impl ::prost::Name for QueryTarget {
        const NAME: &'static str = "QueryTarget";
        const PACKAGE: &'static str = "google.firestore.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.firestore.v1.Target.QueryTarget".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.firestore.v1.Target.QueryTarget".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TargetType {
        #[prost(message, tag = "2")]
        Query(QueryTarget),
        #[prost(message, tag = "3")]
        Documents(DocumentsTarget),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResumeType {
        #[prost(bytes, tag = "4")]
        ResumeToken(::prost::bytes::Bytes),
        #[prost(message, tag = "11")]
        ReadTime(::prost_types::Timestamp),
    }
}
impl ::prost::Name for Target {
    const NAME: &'static str = "Target";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.Target".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.Target".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetChange {
    #[prost(enumeration = "target_change::TargetChangeType", tag = "1")]
    pub target_change_type: i32,
    #[prost(int32, repeated, tag = "2")]
    pub target_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "3")]
    pub cause: ::core::option::Option<super::super::rpc::Status>,
    #[prost(bytes = "bytes", tag = "4")]
    pub resume_token: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "6")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `TargetChange`.
pub mod target_change {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetChangeType {
        NoChange = 0,
        Add = 1,
        Remove = 2,
        Current = 3,
        Reset = 4,
    }
    impl TargetChangeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NoChange => "NO_CHANGE",
                Self::Add => "ADD",
                Self::Remove => "REMOVE",
                Self::Current => "CURRENT",
                Self::Reset => "RESET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NO_CHANGE" => Some(Self::NoChange),
                "ADD" => Some(Self::Add),
                "REMOVE" => Some(Self::Remove),
                "CURRENT" => Some(Self::Current),
                "RESET" => Some(Self::Reset),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for TargetChange {
    const NAME: &'static str = "TargetChange";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.TargetChange".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.TargetChange".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCollectionIdsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(oneof = "list_collection_ids_request::ConsistencySelector", tags = "4")]
    pub consistency_selector: ::core::option::Option<
        list_collection_ids_request::ConsistencySelector,
    >,
}
/// Nested message and enum types in `ListCollectionIdsRequest`.
pub mod list_collection_ids_request {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ConsistencySelector {
        #[prost(message, tag = "4")]
        ReadTime(::prost_types::Timestamp),
    }
}
impl ::prost::Name for ListCollectionIdsRequest {
    const NAME: &'static str = "ListCollectionIdsRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.ListCollectionIdsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.ListCollectionIdsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCollectionIdsResponse {
    #[prost(string, repeated, tag = "1")]
    pub collection_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListCollectionIdsResponse {
    const NAME: &'static str = "ListCollectionIdsResponse";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.ListCollectionIdsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.ListCollectionIdsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteRequest {
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub writes: ::prost::alloc::vec::Vec<Write>,
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for BatchWriteRequest {
    const NAME: &'static str = "BatchWriteRequest";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.BatchWriteRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.BatchWriteRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteResponse {
    #[prost(message, repeated, tag = "1")]
    pub write_results: ::prost::alloc::vec::Vec<WriteResult>,
    #[prost(message, repeated, tag = "2")]
    pub status: ::prost::alloc::vec::Vec<super::super::rpc::Status>,
}
impl ::prost::Name for BatchWriteResponse {
    const NAME: &'static str = "BatchWriteResponse";
    const PACKAGE: &'static str = "google.firestore.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.firestore.v1.BatchWriteResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.firestore.v1.BatchWriteResponse".into()
    }
}
