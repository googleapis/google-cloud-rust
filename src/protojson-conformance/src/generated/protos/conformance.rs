// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestStatus {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub failure_message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub matched_name: ::prost::alloc::string::String,
}
impl ::prost::Name for TestStatus {
    const NAME: &'static str = "TestStatus";
    const PACKAGE: &'static str = "conformance";
    fn full_name() -> ::prost::alloc::string::String {
        "conformance.TestStatus".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/conformance.TestStatus".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailureSet {
    #[prost(message, repeated, tag = "2")]
    pub test: ::prost::alloc::vec::Vec<TestStatus>,
}
impl ::prost::Name for FailureSet {
    const NAME: &'static str = "FailureSet";
    const PACKAGE: &'static str = "conformance";
    fn full_name() -> ::prost::alloc::string::String {
        "conformance.FailureSet".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/conformance.FailureSet".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConformanceRequest {
    #[prost(enumeration = "WireFormat", tag = "3")]
    pub requested_output_format: i32,
    #[prost(string, tag = "4")]
    pub message_type: ::prost::alloc::string::String,
    #[prost(enumeration = "TestCategory", tag = "5")]
    pub test_category: i32,
    #[prost(message, optional, tag = "6")]
    pub jspb_encoding_options: ::core::option::Option<JspbEncodingConfig>,
    #[prost(bool, tag = "9")]
    pub print_unknown_fields: bool,
    #[prost(oneof = "conformance_request::Payload", tags = "1, 2, 7, 8")]
    pub payload: ::core::option::Option<conformance_request::Payload>,
}
/// Nested message and enum types in `ConformanceRequest`.
pub mod conformance_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(bytes, tag = "1")]
        ProtobufPayload(::prost::bytes::Bytes),
        #[prost(string, tag = "2")]
        JsonPayload(::prost::alloc::string::String),
        #[prost(string, tag = "7")]
        JspbPayload(::prost::alloc::string::String),
        #[prost(string, tag = "8")]
        TextPayload(::prost::alloc::string::String),
    }
}
impl ::prost::Name for ConformanceRequest {
    const NAME: &'static str = "ConformanceRequest";
    const PACKAGE: &'static str = "conformance";
    fn full_name() -> ::prost::alloc::string::String {
        "conformance.ConformanceRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/conformance.ConformanceRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConformanceResponse {
    #[prost(oneof = "conformance_response::Result", tags = "1, 6, 9, 2, 3, 4, 5, 7, 8")]
    pub result: ::core::option::Option<conformance_response::Result>,
}
/// Nested message and enum types in `ConformanceResponse`.
pub mod conformance_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(string, tag = "1")]
        ParseError(::prost::alloc::string::String),
        #[prost(string, tag = "6")]
        SerializeError(::prost::alloc::string::String),
        #[prost(string, tag = "9")]
        TimeoutError(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        RuntimeError(::prost::alloc::string::String),
        #[prost(bytes, tag = "3")]
        ProtobufPayload(::prost::bytes::Bytes),
        #[prost(string, tag = "4")]
        JsonPayload(::prost::alloc::string::String),
        #[prost(string, tag = "5")]
        Skipped(::prost::alloc::string::String),
        #[prost(string, tag = "7")]
        JspbPayload(::prost::alloc::string::String),
        #[prost(string, tag = "8")]
        TextPayload(::prost::alloc::string::String),
    }
}
impl ::prost::Name for ConformanceResponse {
    const NAME: &'static str = "ConformanceResponse";
    const PACKAGE: &'static str = "conformance";
    fn full_name() -> ::prost::alloc::string::String {
        "conformance.ConformanceResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/conformance.ConformanceResponse".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JspbEncodingConfig {
    #[prost(bool, tag = "1")]
    pub use_jspb_array_any_format: bool,
}
impl ::prost::Name for JspbEncodingConfig {
    const NAME: &'static str = "JspbEncodingConfig";
    const PACKAGE: &'static str = "conformance";
    fn full_name() -> ::prost::alloc::string::String {
        "conformance.JspbEncodingConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/conformance.JspbEncodingConfig".into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WireFormat {
    Unspecified = 0,
    Protobuf = 1,
    Json = 2,
    Jspb = 3,
    TextFormat = 4,
}
impl WireFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UNSPECIFIED",
            Self::Protobuf => "PROTOBUF",
            Self::Json => "JSON",
            Self::Jspb => "JSPB",
            Self::TextFormat => "TEXT_FORMAT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED" => Some(Self::Unspecified),
            "PROTOBUF" => Some(Self::Protobuf),
            "JSON" => Some(Self::Json),
            "JSPB" => Some(Self::Jspb),
            "TEXT_FORMAT" => Some(Self::TextFormat),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TestCategory {
    UnspecifiedTest = 0,
    BinaryTest = 1,
    JsonTest = 2,
    JsonIgnoreUnknownParsingTest = 3,
    JspbTest = 4,
    TextFormatTest = 5,
}
impl TestCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedTest => "UNSPECIFIED_TEST",
            Self::BinaryTest => "BINARY_TEST",
            Self::JsonTest => "JSON_TEST",
            Self::JsonIgnoreUnknownParsingTest => "JSON_IGNORE_UNKNOWN_PARSING_TEST",
            Self::JspbTest => "JSPB_TEST",
            Self::TextFormatTest => "TEXT_FORMAT_TEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_TEST" => Some(Self::UnspecifiedTest),
            "BINARY_TEST" => Some(Self::BinaryTest),
            "JSON_TEST" => Some(Self::JsonTest),
            "JSON_IGNORE_UNKNOWN_PARSING_TEST" => {
                Some(Self::JsonIgnoreUnknownParsingTest)
            }
            "JSPB_TEST" => Some(Self::JspbTest),
            "TEXT_FORMAT_TEST" => Some(Self::TextFormatTest),
            _ => None,
        }
    }
}
