// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl serde::ser::Serialize for super::TestAllTypesProto3 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.optional_int32) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalInt32", &__With(&self.optional_int32))?;
        }
        if !wkt::internal::is_default(&self.optional_int64) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalInt64", &__With(&self.optional_int64))?;
        }
        if !wkt::internal::is_default(&self.optional_uint32) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalUint32", &__With(&self.optional_uint32))?;
        }
        if !wkt::internal::is_default(&self.optional_uint64) {
            struct __With<'a>(&'a u64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalUint64", &__With(&self.optional_uint64))?;
        }
        if !wkt::internal::is_default(&self.optional_sint32) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalSint32", &__With(&self.optional_sint32))?;
        }
        if !wkt::internal::is_default(&self.optional_sint64) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalSint64", &__With(&self.optional_sint64))?;
        }
        if !wkt::internal::is_default(&self.optional_fixed32) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalFixed32", &__With(&self.optional_fixed32))?;
        }
        if !wkt::internal::is_default(&self.optional_fixed64) {
            struct __With<'a>(&'a u64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalFixed64", &__With(&self.optional_fixed64))?;
        }
        if !wkt::internal::is_default(&self.optional_sfixed32) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalSfixed32", &__With(&self.optional_sfixed32))?;
        }
        if !wkt::internal::is_default(&self.optional_sfixed64) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalSfixed64", &__With(&self.optional_sfixed64))?;
        }
        if !wkt::internal::is_default(&self.optional_float) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalFloat", &__With(&self.optional_float))?;
        }
        if !wkt::internal::is_default(&self.optional_double) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalDouble", &__With(&self.optional_double))?;
        }
        if !wkt::internal::is_default(&self.optional_bool) {
            state.serialize_entry("optionalBool", &self.optional_bool)?;
        }
        if !self.optional_string.is_empty() {
            state.serialize_entry("optionalString", &self.optional_string)?;
        }
        if !self.optional_bytes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalBytes", &__With(&self.optional_bytes))?;
        }
        if self.optional_nested_message.is_some() {
            state.serialize_entry("optionalNestedMessage", &self.optional_nested_message)?;
        }
        if self.optional_foreign_message.is_some() {
            state.serialize_entry("optionalForeignMessage", &self.optional_foreign_message)?;
        }
        if !wkt::internal::is_default(&self.optional_nested_enum) {
            state.serialize_entry("optionalNestedEnum", &self.optional_nested_enum)?;
        }
        if !wkt::internal::is_default(&self.optional_foreign_enum) {
            state.serialize_entry("optionalForeignEnum", &self.optional_foreign_enum)?;
        }
        if !wkt::internal::is_default(&self.optional_aliased_enum) {
            state.serialize_entry("optionalAliasedEnum", &self.optional_aliased_enum)?;
        }
        if !self.optional_string_piece.is_empty() {
            state.serialize_entry("optionalStringPiece", &self.optional_string_piece)?;
        }
        if !self.optional_cord.is_empty() {
            state.serialize_entry("optionalCord", &self.optional_cord)?;
        }
        if self.recursive_message.is_some() {
            state.serialize_entry("recursiveMessage", &self.recursive_message)?;
        }
        if !self.repeated_int32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedInt32", &__With(&self.repeated_int32))?;
        }
        if !self.repeated_int64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedInt64", &__With(&self.repeated_int64))?;
        }
        if !self.repeated_uint32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedUint32", &__With(&self.repeated_uint32))?;
        }
        if !self.repeated_uint64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedUint64", &__With(&self.repeated_uint64))?;
        }
        if !self.repeated_sint32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedSint32", &__With(&self.repeated_sint32))?;
        }
        if !self.repeated_sint64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedSint64", &__With(&self.repeated_sint64))?;
        }
        if !self.repeated_fixed32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedFixed32", &__With(&self.repeated_fixed32))?;
        }
        if !self.repeated_fixed64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedFixed64", &__With(&self.repeated_fixed64))?;
        }
        if !self.repeated_sfixed32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedSfixed32", &__With(&self.repeated_sfixed32))?;
        }
        if !self.repeated_sfixed64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedSfixed64", &__With(&self.repeated_sfixed64))?;
        }
        if !self.repeated_float.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedFloat", &__With(&self.repeated_float))?;
        }
        if !self.repeated_double.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedDouble", &__With(&self.repeated_double))?;
        }
        if !self.repeated_bool.is_empty() {
            state.serialize_entry("repeatedBool", &self.repeated_bool)?;
        }
        if !self.repeated_string.is_empty() {
            state.serialize_entry("repeatedString", &self.repeated_string)?;
        }
        if !self.repeated_bytes.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<serde_with::base64::Base64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedBytes", &__With(&self.repeated_bytes))?;
        }
        if !self.repeated_nested_message.is_empty() {
            state.serialize_entry("repeatedNestedMessage", &self.repeated_nested_message)?;
        }
        if !self.repeated_foreign_message.is_empty() {
            state.serialize_entry("repeatedForeignMessage", &self.repeated_foreign_message)?;
        }
        if !self.repeated_nested_enum.is_empty() {
            state.serialize_entry("repeatedNestedEnum", &self.repeated_nested_enum)?;
        }
        if !self.repeated_foreign_enum.is_empty() {
            state.serialize_entry("repeatedForeignEnum", &self.repeated_foreign_enum)?;
        }
        if !self.repeated_string_piece.is_empty() {
            state.serialize_entry("repeatedStringPiece", &self.repeated_string_piece)?;
        }
        if !self.repeated_cord.is_empty() {
            state.serialize_entry("repeatedCord", &self.repeated_cord)?;
        }
        if !self.packed_int32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedInt32", &__With(&self.packed_int32))?;
        }
        if !self.packed_int64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedInt64", &__With(&self.packed_int64))?;
        }
        if !self.packed_uint32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedUint32", &__With(&self.packed_uint32))?;
        }
        if !self.packed_uint64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedUint64", &__With(&self.packed_uint64))?;
        }
        if !self.packed_sint32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedSint32", &__With(&self.packed_sint32))?;
        }
        if !self.packed_sint64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedSint64", &__With(&self.packed_sint64))?;
        }
        if !self.packed_fixed32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedFixed32", &__With(&self.packed_fixed32))?;
        }
        if !self.packed_fixed64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedFixed64", &__With(&self.packed_fixed64))?;
        }
        if !self.packed_sfixed32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedSfixed32", &__With(&self.packed_sfixed32))?;
        }
        if !self.packed_sfixed64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedSfixed64", &__With(&self.packed_sfixed64))?;
        }
        if !self.packed_float.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedFloat", &__With(&self.packed_float))?;
        }
        if !self.packed_double.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedDouble", &__With(&self.packed_double))?;
        }
        if !self.packed_bool.is_empty() {
            state.serialize_entry("packedBool", &self.packed_bool)?;
        }
        if !self.packed_nested_enum.is_empty() {
            state.serialize_entry("packedNestedEnum", &self.packed_nested_enum)?;
        }
        if !self.unpacked_int32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedInt32", &__With(&self.unpacked_int32))?;
        }
        if !self.unpacked_int64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedInt64", &__With(&self.unpacked_int64))?;
        }
        if !self.unpacked_uint32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedUint32", &__With(&self.unpacked_uint32))?;
        }
        if !self.unpacked_uint64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedUint64", &__With(&self.unpacked_uint64))?;
        }
        if !self.unpacked_sint32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedSint32", &__With(&self.unpacked_sint32))?;
        }
        if !self.unpacked_sint64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedSint64", &__With(&self.unpacked_sint64))?;
        }
        if !self.unpacked_fixed32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedFixed32", &__With(&self.unpacked_fixed32))?;
        }
        if !self.unpacked_fixed64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedFixed64", &__With(&self.unpacked_fixed64))?;
        }
        if !self.unpacked_sfixed32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedSfixed32", &__With(&self.unpacked_sfixed32))?;
        }
        if !self.unpacked_sfixed64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedSfixed64", &__With(&self.unpacked_sfixed64))?;
        }
        if !self.unpacked_float.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedFloat", &__With(&self.unpacked_float))?;
        }
        if !self.unpacked_double.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedDouble", &__With(&self.unpacked_double))?;
        }
        if !self.unpacked_bool.is_empty() {
            state.serialize_entry("unpackedBool", &self.unpacked_bool)?;
        }
        if !self.unpacked_nested_enum.is_empty() {
            state.serialize_entry("unpackedNestedEnum", &self.unpacked_nested_enum)?;
        }
        if !self.map_int32_int32.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i32, i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I32, wkt::internal::I32>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapInt32Int32", &__With(&self.map_int32_int32))?;
        }
        if !self.map_int64_int64.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i64, i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I64, wkt::internal::I64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapInt64Int64", &__With(&self.map_int64_int64))?;
        }
        if !self.map_uint32_uint32.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<u32, u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::U32, wkt::internal::U32>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapUint32Uint32", &__With(&self.map_uint32_uint32))?;
        }
        if !self.map_uint64_uint64.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<u64, u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::U64, wkt::internal::U64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapUint64Uint64", &__With(&self.map_uint64_uint64))?;
        }
        if !self.map_sint32_sint32.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i32, i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I32, wkt::internal::I32>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapSint32Sint32", &__With(&self.map_sint32_sint32))?;
        }
        if !self.map_sint64_sint64.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i64, i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I64, wkt::internal::I64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapSint64Sint64", &__With(&self.map_sint64_sint64))?;
        }
        if !self.map_fixed32_fixed32.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<u32, u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::U32, wkt::internal::U32>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapFixed32Fixed32", &__With(&self.map_fixed32_fixed32))?;
        }
        if !self.map_fixed64_fixed64.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<u64, u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::U64, wkt::internal::U64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapFixed64Fixed64", &__With(&self.map_fixed64_fixed64))?;
        }
        if !self.map_sfixed32_sfixed32.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i32, i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I32, wkt::internal::I32>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapSfixed32Sfixed32", &__With(&self.map_sfixed32_sfixed32))?;
        }
        if !self.map_sfixed64_sfixed64.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i64, i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I64, wkt::internal::I64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapSfixed64Sfixed64", &__With(&self.map_sfixed64_sfixed64))?;
        }
        if !self.map_int32_float.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i32, f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I32, wkt::internal::F32>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapInt32Float", &__With(&self.map_int32_float))?;
        }
        if !self.map_int32_double.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i32, f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I32, wkt::internal::F64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapInt32Double", &__With(&self.map_int32_double))?;
        }
        if !self.map_bool_bool.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<bool, bool>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<serde_with::DisplayFromStr, serde_with::Same>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapBoolBool", &__With(&self.map_bool_bool))?;
        }
        if !self.map_string_string.is_empty() {
            state.serialize_entry("mapStringString", &self.map_string_string)?;
        }
        if !self.map_string_bytes.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, ::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<serde_with::Same, serde_with::base64::Base64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapStringBytes", &__With(&self.map_string_bytes))?;
        }
        if !self.map_string_nested_message.is_empty() {
            state.serialize_entry("mapStringNestedMessage", &self.map_string_nested_message)?;
        }
        if !self.map_string_foreign_message.is_empty() {
            state.serialize_entry("mapStringForeignMessage", &self.map_string_foreign_message)?;
        }
        if !self.map_string_nested_enum.is_empty() {
            state.serialize_entry("mapStringNestedEnum", &self.map_string_nested_enum)?;
        }
        if !self.map_string_foreign_enum.is_empty() {
            state.serialize_entry("mapStringForeignEnum", &self.map_string_foreign_enum)?;
        }
        if let Some(value) = self.oneof_uint32() {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oneofUint32", &__With(value))?;
        }
        if let Some(value) = self.oneof_nested_message() {
            state.serialize_entry("oneofNestedMessage", value)?;
        }
        if let Some(value) = self.oneof_string() {
            state.serialize_entry("oneofString", value)?;
        }
        if let Some(value) = self.oneof_bytes() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oneofBytes", &__With(value))?;
        }
        if let Some(value) = self.oneof_bool() {
            state.serialize_entry("oneofBool", value)?;
        }
        if let Some(value) = self.oneof_uint64() {
            struct __With<'a>(&'a u64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oneofUint64", &__With(value))?;
        }
        if let Some(value) = self.oneof_float() {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oneofFloat", &__With(value))?;
        }
        if let Some(value) = self.oneof_double() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oneofDouble", &__With(value))?;
        }
        if let Some(value) = self.oneof_enum() {
            state.serialize_entry("oneofEnum", value)?;
        }
        if let Some(value) = self.oneof_null_value() {
            state.serialize_entry("oneofNullValue", value)?;
        }
        if self.optional_bool_wrapper.is_some() {
            state.serialize_entry("optionalBoolWrapper", &self.optional_bool_wrapper)?;
        }
        if self.optional_int32_wrapper.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "optionalInt32Wrapper",
                &__With(&self.optional_int32_wrapper),
            )?;
        }
        if self.optional_int64_wrapper.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "optionalInt64Wrapper",
                &__With(&self.optional_int64_wrapper),
            )?;
        }
        if self.optional_uint32_wrapper.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::UInt32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "optionalUint32Wrapper",
                &__With(&self.optional_uint32_wrapper),
            )?;
        }
        if self.optional_uint64_wrapper.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::UInt64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "optionalUint64Wrapper",
                &__With(&self.optional_uint64_wrapper),
            )?;
        }
        if self.optional_float_wrapper.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::FloatValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "optionalFloatWrapper",
                &__With(&self.optional_float_wrapper),
            )?;
        }
        if self.optional_double_wrapper.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "optionalDoubleWrapper",
                &__With(&self.optional_double_wrapper),
            )?;
        }
        if self.optional_string_wrapper.is_some() {
            state.serialize_entry("optionalStringWrapper", &self.optional_string_wrapper)?;
        }
        if self.optional_bytes_wrapper.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::BytesValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<serde_with::base64::Base64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "optionalBytesWrapper",
                &__With(&self.optional_bytes_wrapper),
            )?;
        }
        if !self.repeated_bool_wrapper.is_empty() {
            state.serialize_entry("repeatedBoolWrapper", &self.repeated_bool_wrapper)?;
        }
        if !self.repeated_int32_wrapper.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "repeatedInt32Wrapper",
                &__With(&self.repeated_int32_wrapper),
            )?;
        }
        if !self.repeated_int64_wrapper.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "repeatedInt64Wrapper",
                &__With(&self.repeated_int64_wrapper),
            )?;
        }
        if !self.repeated_uint32_wrapper.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<wkt::UInt32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "repeatedUint32Wrapper",
                &__With(&self.repeated_uint32_wrapper),
            )?;
        }
        if !self.repeated_uint64_wrapper.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<wkt::UInt64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "repeatedUint64Wrapper",
                &__With(&self.repeated_uint64_wrapper),
            )?;
        }
        if !self.repeated_float_wrapper.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<wkt::FloatValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "repeatedFloatWrapper",
                &__With(&self.repeated_float_wrapper),
            )?;
        }
        if !self.repeated_double_wrapper.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<wkt::DoubleValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "repeatedDoubleWrapper",
                &__With(&self.repeated_double_wrapper),
            )?;
        }
        if !self.repeated_string_wrapper.is_empty() {
            state.serialize_entry("repeatedStringWrapper", &self.repeated_string_wrapper)?;
        }
        if !self.repeated_bytes_wrapper.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<wkt::BytesValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<serde_with::base64::Base64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "repeatedBytesWrapper",
                &__With(&self.repeated_bytes_wrapper),
            )?;
        }
        if self.optional_duration.is_some() {
            state.serialize_entry("optionalDuration", &self.optional_duration)?;
        }
        if self.optional_timestamp.is_some() {
            state.serialize_entry("optionalTimestamp", &self.optional_timestamp)?;
        }
        if self.optional_field_mask.is_some() {
            state.serialize_entry("optionalFieldMask", &self.optional_field_mask)?;
        }
        if self.optional_struct.is_some() {
            state.serialize_entry("optionalStruct", &self.optional_struct)?;
        }
        if self.optional_any.is_some() {
            state.serialize_entry("optionalAny", &self.optional_any)?;
        }
        if self.optional_value.is_some() {
            state.serialize_entry("optionalValue", &self.optional_value)?;
        }
        if !wkt::internal::is_default(&self.optional_null_value) {
            state.serialize_entry("optionalNullValue", &self.optional_null_value)?;
        }
        if !self.repeated_duration.is_empty() {
            state.serialize_entry("repeatedDuration", &self.repeated_duration)?;
        }
        if !self.repeated_timestamp.is_empty() {
            state.serialize_entry("repeatedTimestamp", &self.repeated_timestamp)?;
        }
        if !self.repeated_fieldmask.is_empty() {
            state.serialize_entry("repeatedFieldmask", &self.repeated_fieldmask)?;
        }
        if !self.repeated_struct.is_empty() {
            state.serialize_entry("repeatedStruct", &self.repeated_struct)?;
        }
        if !self.repeated_any.is_empty() {
            state.serialize_entry("repeatedAny", &self.repeated_any)?;
        }
        if !self.repeated_value.is_empty() {
            state.serialize_entry("repeatedValue", &self.repeated_value)?;
        }
        if !self.repeated_list_value.is_empty() {
            state.serialize_entry("repeatedListValue", &self.repeated_list_value)?;
        }
        if !wkt::internal::is_default(&self.fieldname1) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldname1", &__With(&self.fieldname1))?;
        }
        if !wkt::internal::is_default(&self.field_name2) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldName2", &__With(&self.field_name2))?;
        }
        if !wkt::internal::is_default(&self._field_name3) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FieldName3", &__With(&self._field_name3))?;
        }
        if !wkt::internal::is_default(&self.field__name4_) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldName4", &__With(&self.field__name4_))?;
        }
        if !wkt::internal::is_default(&self.field0name5) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("field0name5", &__With(&self.field0name5))?;
        }
        if !wkt::internal::is_default(&self.field_0_name6) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("field0Name6", &__With(&self.field_0_name6))?;
        }
        if !wkt::internal::is_default(&self.field_name_7) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldName7", &__With(&self.field_name_7))?;
        }
        if !wkt::internal::is_default(&self.field_name_8) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FieldName8", &__With(&self.field_name_8))?;
        }
        if !wkt::internal::is_default(&self.field_name_9) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldName9", &__With(&self.field_name_9))?;
        }
        if !wkt::internal::is_default(&self.field_name_10) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FieldName10", &__With(&self.field_name_10))?;
        }
        if !wkt::internal::is_default(&self.field_name_11) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FIELDNAME11", &__With(&self.field_name_11))?;
        }
        if !wkt::internal::is_default(&self.field_name_12) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FIELDName12", &__With(&self.field_name_12))?;
        }
        if !wkt::internal::is_default(&self.__field_name13) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FieldName13", &__With(&self.__field_name13))?;
        }
        if !wkt::internal::is_default(&self.__field_name_14) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FieldName14", &__With(&self.__field_name_14))?;
        }
        if !wkt::internal::is_default(&self.field__name15) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldName15", &__With(&self.field__name15))?;
        }
        if !wkt::internal::is_default(&self.field__name_16) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldName16", &__With(&self.field__name_16))?;
        }
        if !wkt::internal::is_default(&self.field_name17__) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldName17", &__With(&self.field_name17__))?;
        }
        if !wkt::internal::is_default(&self.field_name_18__) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FieldName18", &__With(&self.field_name_18__))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::test_all_types_proto_3::NestedMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.a) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("a", &__With(&self.a))?;
        }
        if self.corecursive.is_some() {
            state.serialize_entry("corecursive", &self.corecursive)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ForeignMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.c) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("c", &__With(&self.c))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NullHypothesisProto3 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::EnumOnlyProto3 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
