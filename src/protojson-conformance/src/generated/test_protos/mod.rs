// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]

/// This proto includes every type of field in both singular and repeated
/// forms.
///
/// Also, crucially, all messages and enums in this file are eventually
/// submessages of this message.  So for example, a fuzz test of TestAllTypes
/// could trigger bugs that occur in any message type in this file.  We verify
/// this stays true in a unit test.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TestAllTypesProto3 {
    /// Singular
    pub optional_int32: i32,

    pub optional_int64: i64,

    pub optional_uint32: u32,

    pub optional_uint64: u64,

    pub optional_sint32: i32,

    pub optional_sint64: i64,

    pub optional_fixed32: u32,

    pub optional_fixed64: u64,

    pub optional_sfixed32: i32,

    pub optional_sfixed64: i64,

    pub optional_float: f32,

    pub optional_double: f64,

    pub optional_bool: bool,

    pub optional_string: std::string::String,

    pub optional_bytes: ::bytes::Bytes,

    pub optional_nested_message: std::option::Option<
        std::boxed::Box<crate::generated::test_protos::test_all_types_proto_3::NestedMessage>,
    >,

    pub optional_foreign_message:
        std::option::Option<crate::generated::test_protos::ForeignMessage>,

    pub optional_nested_enum: crate::generated::test_protos::test_all_types_proto_3::NestedEnum,

    pub optional_foreign_enum: crate::generated::test_protos::ForeignEnum,

    pub optional_aliased_enum: crate::generated::test_protos::test_all_types_proto_3::AliasedEnum,

    pub optional_string_piece: std::string::String,

    pub optional_cord: std::string::String,

    pub recursive_message:
        std::option::Option<std::boxed::Box<crate::generated::test_protos::TestAllTypesProto3>>,

    /// Repeated
    pub repeated_int32: std::vec::Vec<i32>,

    pub repeated_int64: std::vec::Vec<i64>,

    pub repeated_uint32: std::vec::Vec<u32>,

    pub repeated_uint64: std::vec::Vec<u64>,

    pub repeated_sint32: std::vec::Vec<i32>,

    pub repeated_sint64: std::vec::Vec<i64>,

    pub repeated_fixed32: std::vec::Vec<u32>,

    pub repeated_fixed64: std::vec::Vec<u64>,

    pub repeated_sfixed32: std::vec::Vec<i32>,

    pub repeated_sfixed64: std::vec::Vec<i64>,

    pub repeated_float: std::vec::Vec<f32>,

    pub repeated_double: std::vec::Vec<f64>,

    pub repeated_bool: std::vec::Vec<bool>,

    pub repeated_string: std::vec::Vec<std::string::String>,

    pub repeated_bytes: std::vec::Vec<::bytes::Bytes>,

    pub repeated_nested_message:
        std::vec::Vec<crate::generated::test_protos::test_all_types_proto_3::NestedMessage>,

    pub repeated_foreign_message: std::vec::Vec<crate::generated::test_protos::ForeignMessage>,

    pub repeated_nested_enum:
        std::vec::Vec<crate::generated::test_protos::test_all_types_proto_3::NestedEnum>,

    pub repeated_foreign_enum: std::vec::Vec<crate::generated::test_protos::ForeignEnum>,

    pub repeated_string_piece: std::vec::Vec<std::string::String>,

    pub repeated_cord: std::vec::Vec<std::string::String>,

    /// Packed
    pub packed_int32: std::vec::Vec<i32>,

    pub packed_int64: std::vec::Vec<i64>,

    pub packed_uint32: std::vec::Vec<u32>,

    pub packed_uint64: std::vec::Vec<u64>,

    pub packed_sint32: std::vec::Vec<i32>,

    pub packed_sint64: std::vec::Vec<i64>,

    pub packed_fixed32: std::vec::Vec<u32>,

    pub packed_fixed64: std::vec::Vec<u64>,

    pub packed_sfixed32: std::vec::Vec<i32>,

    pub packed_sfixed64: std::vec::Vec<i64>,

    pub packed_float: std::vec::Vec<f32>,

    pub packed_double: std::vec::Vec<f64>,

    pub packed_bool: std::vec::Vec<bool>,

    pub packed_nested_enum:
        std::vec::Vec<crate::generated::test_protos::test_all_types_proto_3::NestedEnum>,

    /// Unpacked
    pub unpacked_int32: std::vec::Vec<i32>,

    pub unpacked_int64: std::vec::Vec<i64>,

    pub unpacked_uint32: std::vec::Vec<u32>,

    pub unpacked_uint64: std::vec::Vec<u64>,

    pub unpacked_sint32: std::vec::Vec<i32>,

    pub unpacked_sint64: std::vec::Vec<i64>,

    pub unpacked_fixed32: std::vec::Vec<u32>,

    pub unpacked_fixed64: std::vec::Vec<u64>,

    pub unpacked_sfixed32: std::vec::Vec<i32>,

    pub unpacked_sfixed64: std::vec::Vec<i64>,

    pub unpacked_float: std::vec::Vec<f32>,

    pub unpacked_double: std::vec::Vec<f64>,

    pub unpacked_bool: std::vec::Vec<bool>,

    pub unpacked_nested_enum:
        std::vec::Vec<crate::generated::test_protos::test_all_types_proto_3::NestedEnum>,

    /// Map
    pub map_int32_int32: std::collections::HashMap<i32, i32>,

    pub map_int64_int64: std::collections::HashMap<i64, i64>,

    pub map_uint32_uint32: std::collections::HashMap<u32, u32>,

    pub map_uint64_uint64: std::collections::HashMap<u64, u64>,

    pub map_sint32_sint32: std::collections::HashMap<i32, i32>,

    pub map_sint64_sint64: std::collections::HashMap<i64, i64>,

    pub map_fixed32_fixed32: std::collections::HashMap<u32, u32>,

    pub map_fixed64_fixed64: std::collections::HashMap<u64, u64>,

    pub map_sfixed32_sfixed32: std::collections::HashMap<i32, i32>,

    pub map_sfixed64_sfixed64: std::collections::HashMap<i64, i64>,

    pub map_int32_float: std::collections::HashMap<i32, f32>,

    pub map_int32_double: std::collections::HashMap<i32, f64>,

    pub map_bool_bool: std::collections::HashMap<bool, bool>,

    pub map_string_string: std::collections::HashMap<std::string::String, std::string::String>,

    pub map_string_bytes: std::collections::HashMap<std::string::String, ::bytes::Bytes>,

    pub map_string_nested_message: std::collections::HashMap<
        std::string::String,
        crate::generated::test_protos::test_all_types_proto_3::NestedMessage,
    >,

    pub map_string_foreign_message: std::collections::HashMap<
        std::string::String,
        crate::generated::test_protos::ForeignMessage,
    >,

    pub map_string_nested_enum: std::collections::HashMap<
        std::string::String,
        crate::generated::test_protos::test_all_types_proto_3::NestedEnum,
    >,

    pub map_string_foreign_enum:
        std::collections::HashMap<std::string::String, crate::generated::test_protos::ForeignEnum>,

    /// Well-known types
    pub optional_bool_wrapper: std::option::Option<wkt::BoolValue>,

    pub optional_int32_wrapper: std::option::Option<wkt::Int32Value>,

    pub optional_int64_wrapper: std::option::Option<wkt::Int64Value>,

    pub optional_uint32_wrapper: std::option::Option<wkt::UInt32Value>,

    pub optional_uint64_wrapper: std::option::Option<wkt::UInt64Value>,

    pub optional_float_wrapper: std::option::Option<wkt::FloatValue>,

    pub optional_double_wrapper: std::option::Option<wkt::DoubleValue>,

    pub optional_string_wrapper: std::option::Option<wkt::StringValue>,

    pub optional_bytes_wrapper: std::option::Option<wkt::BytesValue>,

    pub repeated_bool_wrapper: std::vec::Vec<wkt::BoolValue>,

    pub repeated_int32_wrapper: std::vec::Vec<wkt::Int32Value>,

    pub repeated_int64_wrapper: std::vec::Vec<wkt::Int64Value>,

    pub repeated_uint32_wrapper: std::vec::Vec<wkt::UInt32Value>,

    pub repeated_uint64_wrapper: std::vec::Vec<wkt::UInt64Value>,

    pub repeated_float_wrapper: std::vec::Vec<wkt::FloatValue>,

    pub repeated_double_wrapper: std::vec::Vec<wkt::DoubleValue>,

    pub repeated_string_wrapper: std::vec::Vec<wkt::StringValue>,

    pub repeated_bytes_wrapper: std::vec::Vec<wkt::BytesValue>,

    pub optional_duration: std::option::Option<wkt::Duration>,

    pub optional_timestamp: std::option::Option<wkt::Timestamp>,

    pub optional_field_mask: std::option::Option<wkt::FieldMask>,

    pub optional_struct: std::option::Option<wkt::Struct>,

    pub optional_any: std::option::Option<wkt::Any>,

    pub optional_value: std::option::Option<wkt::Value>,

    pub optional_null_value: wkt::NullValue,

    pub repeated_duration: std::vec::Vec<wkt::Duration>,

    pub repeated_timestamp: std::vec::Vec<wkt::Timestamp>,

    pub repeated_fieldmask: std::vec::Vec<wkt::FieldMask>,

    pub repeated_struct: std::vec::Vec<wkt::Struct>,

    pub repeated_any: std::vec::Vec<wkt::Any>,

    pub repeated_value: std::vec::Vec<wkt::Value>,

    pub repeated_list_value: std::vec::Vec<wkt::ListValue>,

    /// Test field-name-to-JSON-name convention.
    /// (protobuf says names can be any valid C/C++ identifier.)
    pub fieldname1: i32,

    pub field_name2: i32,

    pub _field_name3: i32,

    pub field__name4_: i32,

    pub field0name5: i32,

    pub field_0_name6: i32,

    pub field_name_7: i32,

    pub field_name_8: i32,

    pub field_name_9: i32,

    pub field_name_10: i32,

    pub field_name_11: i32,

    pub field_name_12: i32,

    pub __field_name13: i32,

    pub __field_name_14: i32,

    pub field__name15: i32,

    pub field__name_16: i32,

    pub field_name17__: i32,

    pub field_name_18__: i32,

    pub oneof_field:
        std::option::Option<crate::generated::test_protos::test_all_types_proto_3::OneofField>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TestAllTypesProto3 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [optional_int32][crate::generated::test_protos::TestAllTypesProto3::optional_int32].
    pub fn set_optional_int32<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.optional_int32 = v.into();
        self
    }

    /// Sets the value of [optional_int64][crate::generated::test_protos::TestAllTypesProto3::optional_int64].
    pub fn set_optional_int64<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.optional_int64 = v.into();
        self
    }

    /// Sets the value of [optional_uint32][crate::generated::test_protos::TestAllTypesProto3::optional_uint32].
    pub fn set_optional_uint32<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.optional_uint32 = v.into();
        self
    }

    /// Sets the value of [optional_uint64][crate::generated::test_protos::TestAllTypesProto3::optional_uint64].
    pub fn set_optional_uint64<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.optional_uint64 = v.into();
        self
    }

    /// Sets the value of [optional_sint32][crate::generated::test_protos::TestAllTypesProto3::optional_sint32].
    pub fn set_optional_sint32<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.optional_sint32 = v.into();
        self
    }

    /// Sets the value of [optional_sint64][crate::generated::test_protos::TestAllTypesProto3::optional_sint64].
    pub fn set_optional_sint64<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.optional_sint64 = v.into();
        self
    }

    /// Sets the value of [optional_fixed32][crate::generated::test_protos::TestAllTypesProto3::optional_fixed32].
    pub fn set_optional_fixed32<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.optional_fixed32 = v.into();
        self
    }

    /// Sets the value of [optional_fixed64][crate::generated::test_protos::TestAllTypesProto3::optional_fixed64].
    pub fn set_optional_fixed64<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.optional_fixed64 = v.into();
        self
    }

    /// Sets the value of [optional_sfixed32][crate::generated::test_protos::TestAllTypesProto3::optional_sfixed32].
    pub fn set_optional_sfixed32<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.optional_sfixed32 = v.into();
        self
    }

    /// Sets the value of [optional_sfixed64][crate::generated::test_protos::TestAllTypesProto3::optional_sfixed64].
    pub fn set_optional_sfixed64<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.optional_sfixed64 = v.into();
        self
    }

    /// Sets the value of [optional_float][crate::generated::test_protos::TestAllTypesProto3::optional_float].
    pub fn set_optional_float<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.optional_float = v.into();
        self
    }

    /// Sets the value of [optional_double][crate::generated::test_protos::TestAllTypesProto3::optional_double].
    pub fn set_optional_double<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.optional_double = v.into();
        self
    }

    /// Sets the value of [optional_bool][crate::generated::test_protos::TestAllTypesProto3::optional_bool].
    pub fn set_optional_bool<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.optional_bool = v.into();
        self
    }

    /// Sets the value of [optional_string][crate::generated::test_protos::TestAllTypesProto3::optional_string].
    pub fn set_optional_string<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.optional_string = v.into();
        self
    }

    /// Sets the value of [optional_bytes][crate::generated::test_protos::TestAllTypesProto3::optional_bytes].
    pub fn set_optional_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.optional_bytes = v.into();
        self
    }

    /// Sets the value of [optional_nested_message][crate::generated::test_protos::TestAllTypesProto3::optional_nested_message].
    pub fn set_optional_nested_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::generated::test_protos::test_all_types_proto_3::NestedMessage>,
    {
        self.optional_nested_message = std::option::Option::Some(std::boxed::Box::new(v.into()));
        self
    }

    /// Sets or clears the value of [optional_nested_message][crate::generated::test_protos::TestAllTypesProto3::optional_nested_message].
    pub fn set_or_clear_optional_nested_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::generated::test_protos::test_all_types_proto_3::NestedMessage>,
    {
        self.optional_nested_message = v.map(|x| std::boxed::Box::new(x.into()));
        self
    }

    /// Sets the value of [optional_foreign_message][crate::generated::test_protos::TestAllTypesProto3::optional_foreign_message].
    pub fn set_optional_foreign_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::generated::test_protos::ForeignMessage>,
    {
        self.optional_foreign_message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_foreign_message][crate::generated::test_protos::TestAllTypesProto3::optional_foreign_message].
    pub fn set_or_clear_optional_foreign_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::generated::test_protos::ForeignMessage>,
    {
        self.optional_foreign_message = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_nested_enum][crate::generated::test_protos::TestAllTypesProto3::optional_nested_enum].
    pub fn set_optional_nested_enum<
        T: std::convert::Into<crate::generated::test_protos::test_all_types_proto_3::NestedEnum>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.optional_nested_enum = v.into();
        self
    }

    /// Sets the value of [optional_foreign_enum][crate::generated::test_protos::TestAllTypesProto3::optional_foreign_enum].
    pub fn set_optional_foreign_enum<
        T: std::convert::Into<crate::generated::test_protos::ForeignEnum>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.optional_foreign_enum = v.into();
        self
    }

    /// Sets the value of [optional_aliased_enum][crate::generated::test_protos::TestAllTypesProto3::optional_aliased_enum].
    pub fn set_optional_aliased_enum<
        T: std::convert::Into<crate::generated::test_protos::test_all_types_proto_3::AliasedEnum>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.optional_aliased_enum = v.into();
        self
    }

    /// Sets the value of [optional_string_piece][crate::generated::test_protos::TestAllTypesProto3::optional_string_piece].
    pub fn set_optional_string_piece<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.optional_string_piece = v.into();
        self
    }

    /// Sets the value of [optional_cord][crate::generated::test_protos::TestAllTypesProto3::optional_cord].
    pub fn set_optional_cord<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.optional_cord = v.into();
        self
    }

    /// Sets the value of [recursive_message][crate::generated::test_protos::TestAllTypesProto3::recursive_message].
    pub fn set_recursive_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::generated::test_protos::TestAllTypesProto3>,
    {
        self.recursive_message = std::option::Option::Some(std::boxed::Box::new(v.into()));
        self
    }

    /// Sets or clears the value of [recursive_message][crate::generated::test_protos::TestAllTypesProto3::recursive_message].
    pub fn set_or_clear_recursive_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::generated::test_protos::TestAllTypesProto3>,
    {
        self.recursive_message = v.map(|x| std::boxed::Box::new(x.into()));
        self
    }

    /// Sets the value of [repeated_int32][crate::generated::test_protos::TestAllTypesProto3::repeated_int32].
    pub fn set_repeated_int32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.repeated_int32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_int64][crate::generated::test_protos::TestAllTypesProto3::repeated_int64].
    pub fn set_repeated_int64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.repeated_int64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_uint32][crate::generated::test_protos::TestAllTypesProto3::repeated_uint32].
    pub fn set_repeated_uint32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u32>,
    {
        use std::iter::Iterator;
        self.repeated_uint32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_uint64][crate::generated::test_protos::TestAllTypesProto3::repeated_uint64].
    pub fn set_repeated_uint64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u64>,
    {
        use std::iter::Iterator;
        self.repeated_uint64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_sint32][crate::generated::test_protos::TestAllTypesProto3::repeated_sint32].
    pub fn set_repeated_sint32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.repeated_sint32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_sint64][crate::generated::test_protos::TestAllTypesProto3::repeated_sint64].
    pub fn set_repeated_sint64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.repeated_sint64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_fixed32][crate::generated::test_protos::TestAllTypesProto3::repeated_fixed32].
    pub fn set_repeated_fixed32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u32>,
    {
        use std::iter::Iterator;
        self.repeated_fixed32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_fixed64][crate::generated::test_protos::TestAllTypesProto3::repeated_fixed64].
    pub fn set_repeated_fixed64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u64>,
    {
        use std::iter::Iterator;
        self.repeated_fixed64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_sfixed32][crate::generated::test_protos::TestAllTypesProto3::repeated_sfixed32].
    pub fn set_repeated_sfixed32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.repeated_sfixed32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_sfixed64][crate::generated::test_protos::TestAllTypesProto3::repeated_sfixed64].
    pub fn set_repeated_sfixed64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.repeated_sfixed64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_float][crate::generated::test_protos::TestAllTypesProto3::repeated_float].
    pub fn set_repeated_float<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f32>,
    {
        use std::iter::Iterator;
        self.repeated_float = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_double][crate::generated::test_protos::TestAllTypesProto3::repeated_double].
    pub fn set_repeated_double<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.repeated_double = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_bool][crate::generated::test_protos::TestAllTypesProto3::repeated_bool].
    pub fn set_repeated_bool<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<bool>,
    {
        use std::iter::Iterator;
        self.repeated_bool = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_string][crate::generated::test_protos::TestAllTypesProto3::repeated_string].
    pub fn set_repeated_string<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.repeated_string = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_bytes][crate::generated::test_protos::TestAllTypesProto3::repeated_bytes].
    pub fn set_repeated_bytes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.repeated_bytes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_nested_message][crate::generated::test_protos::TestAllTypesProto3::repeated_nested_message].
    pub fn set_repeated_nested_message<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::generated::test_protos::test_all_types_proto_3::NestedMessage>,
    {
        use std::iter::Iterator;
        self.repeated_nested_message = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_foreign_message][crate::generated::test_protos::TestAllTypesProto3::repeated_foreign_message].
    pub fn set_repeated_foreign_message<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::generated::test_protos::ForeignMessage>,
    {
        use std::iter::Iterator;
        self.repeated_foreign_message = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_nested_enum][crate::generated::test_protos::TestAllTypesProto3::repeated_nested_enum].
    pub fn set_repeated_nested_enum<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::generated::test_protos::test_all_types_proto_3::NestedEnum>,
    {
        use std::iter::Iterator;
        self.repeated_nested_enum = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_foreign_enum][crate::generated::test_protos::TestAllTypesProto3::repeated_foreign_enum].
    pub fn set_repeated_foreign_enum<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::generated::test_protos::ForeignEnum>,
    {
        use std::iter::Iterator;
        self.repeated_foreign_enum = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_string_piece][crate::generated::test_protos::TestAllTypesProto3::repeated_string_piece].
    pub fn set_repeated_string_piece<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.repeated_string_piece = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_cord][crate::generated::test_protos::TestAllTypesProto3::repeated_cord].
    pub fn set_repeated_cord<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.repeated_cord = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [packed_int32][crate::generated::test_protos::TestAllTypesProto3::packed_int32].
    pub fn set_packed_int32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.packed_int32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [packed_int64][crate::generated::test_protos::TestAllTypesProto3::packed_int64].
    pub fn set_packed_int64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.packed_int64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [packed_uint32][crate::generated::test_protos::TestAllTypesProto3::packed_uint32].
    pub fn set_packed_uint32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u32>,
    {
        use std::iter::Iterator;
        self.packed_uint32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [packed_uint64][crate::generated::test_protos::TestAllTypesProto3::packed_uint64].
    pub fn set_packed_uint64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u64>,
    {
        use std::iter::Iterator;
        self.packed_uint64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [packed_sint32][crate::generated::test_protos::TestAllTypesProto3::packed_sint32].
    pub fn set_packed_sint32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.packed_sint32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [packed_sint64][crate::generated::test_protos::TestAllTypesProto3::packed_sint64].
    pub fn set_packed_sint64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.packed_sint64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [packed_fixed32][crate::generated::test_protos::TestAllTypesProto3::packed_fixed32].
    pub fn set_packed_fixed32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u32>,
    {
        use std::iter::Iterator;
        self.packed_fixed32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [packed_fixed64][crate::generated::test_protos::TestAllTypesProto3::packed_fixed64].
    pub fn set_packed_fixed64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u64>,
    {
        use std::iter::Iterator;
        self.packed_fixed64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [packed_sfixed32][crate::generated::test_protos::TestAllTypesProto3::packed_sfixed32].
    pub fn set_packed_sfixed32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.packed_sfixed32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [packed_sfixed64][crate::generated::test_protos::TestAllTypesProto3::packed_sfixed64].
    pub fn set_packed_sfixed64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.packed_sfixed64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [packed_float][crate::generated::test_protos::TestAllTypesProto3::packed_float].
    pub fn set_packed_float<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f32>,
    {
        use std::iter::Iterator;
        self.packed_float = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [packed_double][crate::generated::test_protos::TestAllTypesProto3::packed_double].
    pub fn set_packed_double<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.packed_double = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [packed_bool][crate::generated::test_protos::TestAllTypesProto3::packed_bool].
    pub fn set_packed_bool<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<bool>,
    {
        use std::iter::Iterator;
        self.packed_bool = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [packed_nested_enum][crate::generated::test_protos::TestAllTypesProto3::packed_nested_enum].
    pub fn set_packed_nested_enum<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::generated::test_protos::test_all_types_proto_3::NestedEnum>,
    {
        use std::iter::Iterator;
        self.packed_nested_enum = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unpacked_int32][crate::generated::test_protos::TestAllTypesProto3::unpacked_int32].
    pub fn set_unpacked_int32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.unpacked_int32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unpacked_int64][crate::generated::test_protos::TestAllTypesProto3::unpacked_int64].
    pub fn set_unpacked_int64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.unpacked_int64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unpacked_uint32][crate::generated::test_protos::TestAllTypesProto3::unpacked_uint32].
    pub fn set_unpacked_uint32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u32>,
    {
        use std::iter::Iterator;
        self.unpacked_uint32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unpacked_uint64][crate::generated::test_protos::TestAllTypesProto3::unpacked_uint64].
    pub fn set_unpacked_uint64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u64>,
    {
        use std::iter::Iterator;
        self.unpacked_uint64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unpacked_sint32][crate::generated::test_protos::TestAllTypesProto3::unpacked_sint32].
    pub fn set_unpacked_sint32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.unpacked_sint32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unpacked_sint64][crate::generated::test_protos::TestAllTypesProto3::unpacked_sint64].
    pub fn set_unpacked_sint64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.unpacked_sint64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unpacked_fixed32][crate::generated::test_protos::TestAllTypesProto3::unpacked_fixed32].
    pub fn set_unpacked_fixed32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u32>,
    {
        use std::iter::Iterator;
        self.unpacked_fixed32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unpacked_fixed64][crate::generated::test_protos::TestAllTypesProto3::unpacked_fixed64].
    pub fn set_unpacked_fixed64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<u64>,
    {
        use std::iter::Iterator;
        self.unpacked_fixed64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unpacked_sfixed32][crate::generated::test_protos::TestAllTypesProto3::unpacked_sfixed32].
    pub fn set_unpacked_sfixed32<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.unpacked_sfixed32 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unpacked_sfixed64][crate::generated::test_protos::TestAllTypesProto3::unpacked_sfixed64].
    pub fn set_unpacked_sfixed64<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.unpacked_sfixed64 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unpacked_float][crate::generated::test_protos::TestAllTypesProto3::unpacked_float].
    pub fn set_unpacked_float<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f32>,
    {
        use std::iter::Iterator;
        self.unpacked_float = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unpacked_double][crate::generated::test_protos::TestAllTypesProto3::unpacked_double].
    pub fn set_unpacked_double<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.unpacked_double = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unpacked_bool][crate::generated::test_protos::TestAllTypesProto3::unpacked_bool].
    pub fn set_unpacked_bool<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<bool>,
    {
        use std::iter::Iterator;
        self.unpacked_bool = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unpacked_nested_enum][crate::generated::test_protos::TestAllTypesProto3::unpacked_nested_enum].
    pub fn set_unpacked_nested_enum<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::generated::test_protos::test_all_types_proto_3::NestedEnum>,
    {
        use std::iter::Iterator;
        self.unpacked_nested_enum = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [map_int32_int32][crate::generated::test_protos::TestAllTypesProto3::map_int32_int32].
    pub fn set_map_int32_int32<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i32>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.map_int32_int32 = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_int64_int64][crate::generated::test_protos::TestAllTypesProto3::map_int64_int64].
    pub fn set_map_int64_int64<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i64>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.map_int64_int64 = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_uint32_uint32][crate::generated::test_protos::TestAllTypesProto3::map_uint32_uint32].
    pub fn set_map_uint32_uint32<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<u32>,
        V: std::convert::Into<u32>,
    {
        use std::iter::Iterator;
        self.map_uint32_uint32 = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_uint64_uint64][crate::generated::test_protos::TestAllTypesProto3::map_uint64_uint64].
    pub fn set_map_uint64_uint64<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<u64>,
        V: std::convert::Into<u64>,
    {
        use std::iter::Iterator;
        self.map_uint64_uint64 = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_sint32_sint32][crate::generated::test_protos::TestAllTypesProto3::map_sint32_sint32].
    pub fn set_map_sint32_sint32<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i32>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.map_sint32_sint32 = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_sint64_sint64][crate::generated::test_protos::TestAllTypesProto3::map_sint64_sint64].
    pub fn set_map_sint64_sint64<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i64>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.map_sint64_sint64 = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_fixed32_fixed32][crate::generated::test_protos::TestAllTypesProto3::map_fixed32_fixed32].
    pub fn set_map_fixed32_fixed32<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<u32>,
        V: std::convert::Into<u32>,
    {
        use std::iter::Iterator;
        self.map_fixed32_fixed32 = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_fixed64_fixed64][crate::generated::test_protos::TestAllTypesProto3::map_fixed64_fixed64].
    pub fn set_map_fixed64_fixed64<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<u64>,
        V: std::convert::Into<u64>,
    {
        use std::iter::Iterator;
        self.map_fixed64_fixed64 = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_sfixed32_sfixed32][crate::generated::test_protos::TestAllTypesProto3::map_sfixed32_sfixed32].
    pub fn set_map_sfixed32_sfixed32<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i32>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.map_sfixed32_sfixed32 = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_sfixed64_sfixed64][crate::generated::test_protos::TestAllTypesProto3::map_sfixed64_sfixed64].
    pub fn set_map_sfixed64_sfixed64<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i64>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.map_sfixed64_sfixed64 = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_int32_float][crate::generated::test_protos::TestAllTypesProto3::map_int32_float].
    pub fn set_map_int32_float<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i32>,
        V: std::convert::Into<f32>,
    {
        use std::iter::Iterator;
        self.map_int32_float = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_int32_double][crate::generated::test_protos::TestAllTypesProto3::map_int32_double].
    pub fn set_map_int32_double<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i32>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.map_int32_double = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_bool_bool][crate::generated::test_protos::TestAllTypesProto3::map_bool_bool].
    pub fn set_map_bool_bool<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<bool>,
        V: std::convert::Into<bool>,
    {
        use std::iter::Iterator;
        self.map_bool_bool = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_string_string][crate::generated::test_protos::TestAllTypesProto3::map_string_string].
    pub fn set_map_string_string<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.map_string_string = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_string_bytes][crate::generated::test_protos::TestAllTypesProto3::map_string_bytes].
    pub fn set_map_string_bytes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.map_string_bytes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_string_nested_message][crate::generated::test_protos::TestAllTypesProto3::map_string_nested_message].
    pub fn set_map_string_nested_message<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::generated::test_protos::test_all_types_proto_3::NestedMessage>,
    {
        use std::iter::Iterator;
        self.map_string_nested_message = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_string_foreign_message][crate::generated::test_protos::TestAllTypesProto3::map_string_foreign_message].
    pub fn set_map_string_foreign_message<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::generated::test_protos::ForeignMessage>,
    {
        use std::iter::Iterator;
        self.map_string_foreign_message =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_string_nested_enum][crate::generated::test_protos::TestAllTypesProto3::map_string_nested_enum].
    pub fn set_map_string_nested_enum<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::generated::test_protos::test_all_types_proto_3::NestedEnum>,
    {
        use std::iter::Iterator;
        self.map_string_nested_enum = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [map_string_foreign_enum][crate::generated::test_protos::TestAllTypesProto3::map_string_foreign_enum].
    pub fn set_map_string_foreign_enum<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::generated::test_protos::ForeignEnum>,
    {
        use std::iter::Iterator;
        self.map_string_foreign_enum = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [optional_bool_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_bool_wrapper].
    pub fn set_optional_bool_wrapper<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.optional_bool_wrapper = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_bool_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_bool_wrapper].
    pub fn set_or_clear_optional_bool_wrapper<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.optional_bool_wrapper = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_int32_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_int32_wrapper].
    pub fn set_optional_int32_wrapper<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.optional_int32_wrapper = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_int32_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_int32_wrapper].
    pub fn set_or_clear_optional_int32_wrapper<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.optional_int32_wrapper = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_int64_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_int64_wrapper].
    pub fn set_optional_int64_wrapper<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.optional_int64_wrapper = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_int64_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_int64_wrapper].
    pub fn set_or_clear_optional_int64_wrapper<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.optional_int64_wrapper = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_uint32_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_uint32_wrapper].
    pub fn set_optional_uint32_wrapper<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::UInt32Value>,
    {
        self.optional_uint32_wrapper = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_uint32_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_uint32_wrapper].
    pub fn set_or_clear_optional_uint32_wrapper<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::UInt32Value>,
    {
        self.optional_uint32_wrapper = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_uint64_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_uint64_wrapper].
    pub fn set_optional_uint64_wrapper<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::UInt64Value>,
    {
        self.optional_uint64_wrapper = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_uint64_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_uint64_wrapper].
    pub fn set_or_clear_optional_uint64_wrapper<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::UInt64Value>,
    {
        self.optional_uint64_wrapper = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_float_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_float_wrapper].
    pub fn set_optional_float_wrapper<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FloatValue>,
    {
        self.optional_float_wrapper = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_float_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_float_wrapper].
    pub fn set_or_clear_optional_float_wrapper<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FloatValue>,
    {
        self.optional_float_wrapper = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_double_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_double_wrapper].
    pub fn set_optional_double_wrapper<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::DoubleValue>,
    {
        self.optional_double_wrapper = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_double_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_double_wrapper].
    pub fn set_or_clear_optional_double_wrapper<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::DoubleValue>,
    {
        self.optional_double_wrapper = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_string_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_string_wrapper].
    pub fn set_optional_string_wrapper<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.optional_string_wrapper = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_string_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_string_wrapper].
    pub fn set_or_clear_optional_string_wrapper<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::StringValue>,
    {
        self.optional_string_wrapper = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_bytes_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_bytes_wrapper].
    pub fn set_optional_bytes_wrapper<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BytesValue>,
    {
        self.optional_bytes_wrapper = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_bytes_wrapper][crate::generated::test_protos::TestAllTypesProto3::optional_bytes_wrapper].
    pub fn set_or_clear_optional_bytes_wrapper<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BytesValue>,
    {
        self.optional_bytes_wrapper = v.map(|x| x.into());
        self
    }

    /// Sets the value of [repeated_bool_wrapper][crate::generated::test_protos::TestAllTypesProto3::repeated_bool_wrapper].
    pub fn set_repeated_bool_wrapper<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::BoolValue>,
    {
        use std::iter::Iterator;
        self.repeated_bool_wrapper = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_int32_wrapper][crate::generated::test_protos::TestAllTypesProto3::repeated_int32_wrapper].
    pub fn set_repeated_int32_wrapper<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Int32Value>,
    {
        use std::iter::Iterator;
        self.repeated_int32_wrapper = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_int64_wrapper][crate::generated::test_protos::TestAllTypesProto3::repeated_int64_wrapper].
    pub fn set_repeated_int64_wrapper<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Int64Value>,
    {
        use std::iter::Iterator;
        self.repeated_int64_wrapper = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_uint32_wrapper][crate::generated::test_protos::TestAllTypesProto3::repeated_uint32_wrapper].
    pub fn set_repeated_uint32_wrapper<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::UInt32Value>,
    {
        use std::iter::Iterator;
        self.repeated_uint32_wrapper = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_uint64_wrapper][crate::generated::test_protos::TestAllTypesProto3::repeated_uint64_wrapper].
    pub fn set_repeated_uint64_wrapper<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::UInt64Value>,
    {
        use std::iter::Iterator;
        self.repeated_uint64_wrapper = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_float_wrapper][crate::generated::test_protos::TestAllTypesProto3::repeated_float_wrapper].
    pub fn set_repeated_float_wrapper<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::FloatValue>,
    {
        use std::iter::Iterator;
        self.repeated_float_wrapper = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_double_wrapper][crate::generated::test_protos::TestAllTypesProto3::repeated_double_wrapper].
    pub fn set_repeated_double_wrapper<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::DoubleValue>,
    {
        use std::iter::Iterator;
        self.repeated_double_wrapper = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_string_wrapper][crate::generated::test_protos::TestAllTypesProto3::repeated_string_wrapper].
    pub fn set_repeated_string_wrapper<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::StringValue>,
    {
        use std::iter::Iterator;
        self.repeated_string_wrapper = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_bytes_wrapper][crate::generated::test_protos::TestAllTypesProto3::repeated_bytes_wrapper].
    pub fn set_repeated_bytes_wrapper<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::BytesValue>,
    {
        use std::iter::Iterator;
        self.repeated_bytes_wrapper = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [optional_duration][crate::generated::test_protos::TestAllTypesProto3::optional_duration].
    pub fn set_optional_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.optional_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_duration][crate::generated::test_protos::TestAllTypesProto3::optional_duration].
    pub fn set_or_clear_optional_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.optional_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_timestamp][crate::generated::test_protos::TestAllTypesProto3::optional_timestamp].
    pub fn set_optional_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.optional_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_timestamp][crate::generated::test_protos::TestAllTypesProto3::optional_timestamp].
    pub fn set_or_clear_optional_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.optional_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_field_mask][crate::generated::test_protos::TestAllTypesProto3::optional_field_mask].
    pub fn set_optional_field_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.optional_field_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_field_mask][crate::generated::test_protos::TestAllTypesProto3::optional_field_mask].
    pub fn set_or_clear_optional_field_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.optional_field_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_struct][crate::generated::test_protos::TestAllTypesProto3::optional_struct].
    pub fn set_optional_struct<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.optional_struct = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_struct][crate::generated::test_protos::TestAllTypesProto3::optional_struct].
    pub fn set_or_clear_optional_struct<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.optional_struct = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_any][crate::generated::test_protos::TestAllTypesProto3::optional_any].
    pub fn set_optional_any<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Any>,
    {
        self.optional_any = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_any][crate::generated::test_protos::TestAllTypesProto3::optional_any].
    pub fn set_or_clear_optional_any<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Any>,
    {
        self.optional_any = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_value][crate::generated::test_protos::TestAllTypesProto3::optional_value].
    pub fn set_optional_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Value>,
    {
        self.optional_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [optional_value][crate::generated::test_protos::TestAllTypesProto3::optional_value].
    pub fn set_or_clear_optional_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Value>,
    {
        self.optional_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [optional_null_value][crate::generated::test_protos::TestAllTypesProto3::optional_null_value].
    pub fn set_optional_null_value<T: std::convert::Into<wkt::NullValue>>(mut self, v: T) -> Self {
        self.optional_null_value = v.into();
        self
    }

    /// Sets the value of [repeated_duration][crate::generated::test_protos::TestAllTypesProto3::repeated_duration].
    pub fn set_repeated_duration<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Duration>,
    {
        use std::iter::Iterator;
        self.repeated_duration = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_timestamp][crate::generated::test_protos::TestAllTypesProto3::repeated_timestamp].
    pub fn set_repeated_timestamp<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Timestamp>,
    {
        use std::iter::Iterator;
        self.repeated_timestamp = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_fieldmask][crate::generated::test_protos::TestAllTypesProto3::repeated_fieldmask].
    pub fn set_repeated_fieldmask<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::FieldMask>,
    {
        use std::iter::Iterator;
        self.repeated_fieldmask = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_struct][crate::generated::test_protos::TestAllTypesProto3::repeated_struct].
    pub fn set_repeated_struct<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Struct>,
    {
        use std::iter::Iterator;
        self.repeated_struct = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_any][crate::generated::test_protos::TestAllTypesProto3::repeated_any].
    pub fn set_repeated_any<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Any>,
    {
        use std::iter::Iterator;
        self.repeated_any = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_value][crate::generated::test_protos::TestAllTypesProto3::repeated_value].
    pub fn set_repeated_value<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.repeated_value = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repeated_list_value][crate::generated::test_protos::TestAllTypesProto3::repeated_list_value].
    pub fn set_repeated_list_value<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::ListValue>,
    {
        use std::iter::Iterator;
        self.repeated_list_value = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [fieldname1][crate::generated::test_protos::TestAllTypesProto3::fieldname1].
    pub fn set_fieldname1<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.fieldname1 = v.into();
        self
    }

    /// Sets the value of [field_name2][crate::generated::test_protos::TestAllTypesProto3::field_name2].
    pub fn set_field_name2<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.field_name2 = v.into();
        self
    }

    /// Sets the value of [_field_name3][crate::generated::test_protos::TestAllTypesProto3::_field_name3].
    pub fn set__field_name3<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self._field_name3 = v.into();
        self
    }

    /// Sets the value of [field__name4_][crate::generated::test_protos::TestAllTypesProto3::field__name4_].
    pub fn set_field__name4_<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.field__name4_ = v.into();
        self
    }

    /// Sets the value of [field0name5][crate::generated::test_protos::TestAllTypesProto3::field0name5].
    pub fn set_field0name5<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.field0name5 = v.into();
        self
    }

    /// Sets the value of [field_0_name6][crate::generated::test_protos::TestAllTypesProto3::field_0_name6].
    pub fn set_field_0_name6<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.field_0_name6 = v.into();
        self
    }

    /// Sets the value of [field_name_7][crate::generated::test_protos::TestAllTypesProto3::field_name_7].
    pub fn set_field_name_7<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.field_name_7 = v.into();
        self
    }

    /// Sets the value of [field_name_8][crate::generated::test_protos::TestAllTypesProto3::field_name_8].
    pub fn set_field_name_8<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.field_name_8 = v.into();
        self
    }

    /// Sets the value of [field_name_9][crate::generated::test_protos::TestAllTypesProto3::field_name_9].
    pub fn set_field_name_9<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.field_name_9 = v.into();
        self
    }

    /// Sets the value of [field_name_10][crate::generated::test_protos::TestAllTypesProto3::field_name_10].
    pub fn set_field_name_10<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.field_name_10 = v.into();
        self
    }

    /// Sets the value of [field_name_11][crate::generated::test_protos::TestAllTypesProto3::field_name_11].
    pub fn set_field_name_11<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.field_name_11 = v.into();
        self
    }

    /// Sets the value of [field_name_12][crate::generated::test_protos::TestAllTypesProto3::field_name_12].
    pub fn set_field_name_12<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.field_name_12 = v.into();
        self
    }

    /// Sets the value of [__field_name13][crate::generated::test_protos::TestAllTypesProto3::__field_name13].
    pub fn set___field_name13<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.__field_name13 = v.into();
        self
    }

    /// Sets the value of [__field_name_14][crate::generated::test_protos::TestAllTypesProto3::__field_name_14].
    pub fn set___field_name_14<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.__field_name_14 = v.into();
        self
    }

    /// Sets the value of [field__name15][crate::generated::test_protos::TestAllTypesProto3::field__name15].
    pub fn set_field__name15<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.field__name15 = v.into();
        self
    }

    /// Sets the value of [field__name_16][crate::generated::test_protos::TestAllTypesProto3::field__name_16].
    pub fn set_field__name_16<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.field__name_16 = v.into();
        self
    }

    /// Sets the value of [field_name17__][crate::generated::test_protos::TestAllTypesProto3::field_name17__].
    pub fn set_field_name17__<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.field_name17__ = v.into();
        self
    }

    /// Sets the value of [field_name_18__][crate::generated::test_protos::TestAllTypesProto3::field_name_18__].
    pub fn set_field_name_18__<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.field_name_18__ = v.into();
        self
    }

    /// Sets the value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field].
    ///
    /// Note that all the setters affecting `oneof_field` are mutually
    /// exclusive.
    pub fn set_oneof_field<
        T: std::convert::Into<
                std::option::Option<
                    crate::generated::test_protos::test_all_types_proto_3::OneofField,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oneof_field = v.into();
        self
    }

    /// The value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// if it holds a `OneofUint32`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oneof_uint32(&self) -> std::option::Option<&u32> {
        #[allow(unreachable_patterns)]
        self.oneof_field.as_ref().and_then(|v| match v {
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofUint32(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// to hold a `OneofUint32`.
    ///
    /// Note that all the setters affecting `oneof_field` are
    /// mutually exclusive.
    pub fn set_oneof_uint32<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.oneof_field = std::option::Option::Some(
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofUint32(
                v.into(),
            ),
        );
        self
    }

    /// The value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// if it holds a `OneofNestedMessage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oneof_nested_message(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::generated::test_protos::test_all_types_proto_3::NestedMessage>,
    > {
        #[allow(unreachable_patterns)]
        self.oneof_field.as_ref().and_then(|v| match v {
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofNestedMessage(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// to hold a `OneofNestedMessage`.
    ///
    /// Note that all the setters affecting `oneof_field` are
    /// mutually exclusive.
    pub fn set_oneof_nested_message<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::generated::test_protos::test_all_types_proto_3::NestedMessage,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oneof_field = std::option::Option::Some(
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofNestedMessage(
                v.into(),
            ),
        );
        self
    }

    /// The value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// if it holds a `OneofString`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oneof_string(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.oneof_field.as_ref().and_then(|v| match v {
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofString(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// to hold a `OneofString`.
    ///
    /// Note that all the setters affecting `oneof_field` are
    /// mutually exclusive.
    pub fn set_oneof_string<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oneof_field = std::option::Option::Some(
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofString(
                v.into(),
            ),
        );
        self
    }

    /// The value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// if it holds a `OneofBytes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oneof_bytes(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.oneof_field.as_ref().and_then(|v| match v {
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofBytes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// to hold a `OneofBytes`.
    ///
    /// Note that all the setters affecting `oneof_field` are
    /// mutually exclusive.
    pub fn set_oneof_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.oneof_field = std::option::Option::Some(
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofBytes(v.into()),
        );
        self
    }

    /// The value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// if it holds a `OneofBool`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oneof_bool(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.oneof_field.as_ref().and_then(|v| match v {
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofBool(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// to hold a `OneofBool`.
    ///
    /// Note that all the setters affecting `oneof_field` are
    /// mutually exclusive.
    pub fn set_oneof_bool<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.oneof_field = std::option::Option::Some(
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofBool(v.into()),
        );
        self
    }

    /// The value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// if it holds a `OneofUint64`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oneof_uint64(&self) -> std::option::Option<&u64> {
        #[allow(unreachable_patterns)]
        self.oneof_field.as_ref().and_then(|v| match v {
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofUint64(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// to hold a `OneofUint64`.
    ///
    /// Note that all the setters affecting `oneof_field` are
    /// mutually exclusive.
    pub fn set_oneof_uint64<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.oneof_field = std::option::Option::Some(
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofUint64(
                v.into(),
            ),
        );
        self
    }

    /// The value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// if it holds a `OneofFloat`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oneof_float(&self) -> std::option::Option<&f32> {
        #[allow(unreachable_patterns)]
        self.oneof_field.as_ref().and_then(|v| match v {
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofFloat(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// to hold a `OneofFloat`.
    ///
    /// Note that all the setters affecting `oneof_field` are
    /// mutually exclusive.
    pub fn set_oneof_float<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.oneof_field = std::option::Option::Some(
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofFloat(v.into()),
        );
        self
    }

    /// The value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// if it holds a `OneofDouble`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oneof_double(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.oneof_field.as_ref().and_then(|v| match v {
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofDouble(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// to hold a `OneofDouble`.
    ///
    /// Note that all the setters affecting `oneof_field` are
    /// mutually exclusive.
    pub fn set_oneof_double<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.oneof_field = std::option::Option::Some(
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofDouble(
                v.into(),
            ),
        );
        self
    }

    /// The value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// if it holds a `OneofEnum`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oneof_enum(
        &self,
    ) -> std::option::Option<&crate::generated::test_protos::test_all_types_proto_3::NestedEnum>
    {
        #[allow(unreachable_patterns)]
        self.oneof_field.as_ref().and_then(|v| match v {
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofEnum(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// to hold a `OneofEnum`.
    ///
    /// Note that all the setters affecting `oneof_field` are
    /// mutually exclusive.
    pub fn set_oneof_enum<
        T: std::convert::Into<crate::generated::test_protos::test_all_types_proto_3::NestedEnum>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oneof_field = std::option::Option::Some(
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofEnum(v.into()),
        );
        self
    }

    /// The value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// if it holds a `OneofNullValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oneof_null_value(&self) -> std::option::Option<&wkt::NullValue> {
        #[allow(unreachable_patterns)]
        self.oneof_field.as_ref().and_then(|v| match v {
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofNullValue(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oneof_field][crate::generated::test_protos::TestAllTypesProto3::oneof_field]
    /// to hold a `OneofNullValue`.
    ///
    /// Note that all the setters affecting `oneof_field` are
    /// mutually exclusive.
    pub fn set_oneof_null_value<T: std::convert::Into<wkt::NullValue>>(mut self, v: T) -> Self {
        self.oneof_field = std::option::Option::Some(
            crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofNullValue(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for TestAllTypesProto3 {
    fn typename() -> &'static str {
        "type.googleapis.com/protobuf_test_messages.proto3.TestAllTypesProto3"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TestAllTypesProto3 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __optional_int32,
            __optional_int64,
            __optional_uint32,
            __optional_uint64,
            __optional_sint32,
            __optional_sint64,
            __optional_fixed32,
            __optional_fixed64,
            __optional_sfixed32,
            __optional_sfixed64,
            __optional_float,
            __optional_double,
            __optional_bool,
            __optional_string,
            __optional_bytes,
            __optional_nested_message,
            __optional_foreign_message,
            __optional_nested_enum,
            __optional_foreign_enum,
            __optional_aliased_enum,
            __optional_string_piece,
            __optional_cord,
            __recursive_message,
            __repeated_int32,
            __repeated_int64,
            __repeated_uint32,
            __repeated_uint64,
            __repeated_sint32,
            __repeated_sint64,
            __repeated_fixed32,
            __repeated_fixed64,
            __repeated_sfixed32,
            __repeated_sfixed64,
            __repeated_float,
            __repeated_double,
            __repeated_bool,
            __repeated_string,
            __repeated_bytes,
            __repeated_nested_message,
            __repeated_foreign_message,
            __repeated_nested_enum,
            __repeated_foreign_enum,
            __repeated_string_piece,
            __repeated_cord,
            __packed_int32,
            __packed_int64,
            __packed_uint32,
            __packed_uint64,
            __packed_sint32,
            __packed_sint64,
            __packed_fixed32,
            __packed_fixed64,
            __packed_sfixed32,
            __packed_sfixed64,
            __packed_float,
            __packed_double,
            __packed_bool,
            __packed_nested_enum,
            __unpacked_int32,
            __unpacked_int64,
            __unpacked_uint32,
            __unpacked_uint64,
            __unpacked_sint32,
            __unpacked_sint64,
            __unpacked_fixed32,
            __unpacked_fixed64,
            __unpacked_sfixed32,
            __unpacked_sfixed64,
            __unpacked_float,
            __unpacked_double,
            __unpacked_bool,
            __unpacked_nested_enum,
            __map_int32_int32,
            __map_int64_int64,
            __map_uint32_uint32,
            __map_uint64_uint64,
            __map_sint32_sint32,
            __map_sint64_sint64,
            __map_fixed32_fixed32,
            __map_fixed64_fixed64,
            __map_sfixed32_sfixed32,
            __map_sfixed64_sfixed64,
            __map_int32_float,
            __map_int32_double,
            __map_bool_bool,
            __map_string_string,
            __map_string_bytes,
            __map_string_nested_message,
            __map_string_foreign_message,
            __map_string_nested_enum,
            __map_string_foreign_enum,
            __oneof_uint32,
            __oneof_nested_message,
            __oneof_string,
            __oneof_bytes,
            __oneof_bool,
            __oneof_uint64,
            __oneof_float,
            __oneof_double,
            __oneof_enum,
            __oneof_null_value,
            __optional_bool_wrapper,
            __optional_int32_wrapper,
            __optional_int64_wrapper,
            __optional_uint32_wrapper,
            __optional_uint64_wrapper,
            __optional_float_wrapper,
            __optional_double_wrapper,
            __optional_string_wrapper,
            __optional_bytes_wrapper,
            __repeated_bool_wrapper,
            __repeated_int32_wrapper,
            __repeated_int64_wrapper,
            __repeated_uint32_wrapper,
            __repeated_uint64_wrapper,
            __repeated_float_wrapper,
            __repeated_double_wrapper,
            __repeated_string_wrapper,
            __repeated_bytes_wrapper,
            __optional_duration,
            __optional_timestamp,
            __optional_field_mask,
            __optional_struct,
            __optional_any,
            __optional_value,
            __optional_null_value,
            __repeated_duration,
            __repeated_timestamp,
            __repeated_fieldmask,
            __repeated_struct,
            __repeated_any,
            __repeated_value,
            __repeated_list_value,
            __fieldname1,
            __field_name2,
            ___field_name3,
            __field__name4_,
            __field0name5,
            __field_0_name6,
            __field_name_7,
            __field_name_8,
            __field_name_9,
            __field_name_10,
            __field_name_11,
            __field_name_12,
            ____field_name13,
            ____field_name_14,
            __field__name15,
            __field__name_16,
            __field_name17__,
            __field_name_18__,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TestAllTypesProto3")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        match value {
                            "optionalInt32" => Ok(__FieldTag::__optional_int32),
                            "optional_int32" => Ok(__FieldTag::__optional_int32),
                            "optionalInt64" => Ok(__FieldTag::__optional_int64),
                            "optional_int64" => Ok(__FieldTag::__optional_int64),
                            "optionalUint32" => Ok(__FieldTag::__optional_uint32),
                            "optional_uint32" => Ok(__FieldTag::__optional_uint32),
                            "optionalUint64" => Ok(__FieldTag::__optional_uint64),
                            "optional_uint64" => Ok(__FieldTag::__optional_uint64),
                            "optionalSint32" => Ok(__FieldTag::__optional_sint32),
                            "optional_sint32" => Ok(__FieldTag::__optional_sint32),
                            "optionalSint64" => Ok(__FieldTag::__optional_sint64),
                            "optional_sint64" => Ok(__FieldTag::__optional_sint64),
                            "optionalFixed32" => Ok(__FieldTag::__optional_fixed32),
                            "optional_fixed32" => Ok(__FieldTag::__optional_fixed32),
                            "optionalFixed64" => Ok(__FieldTag::__optional_fixed64),
                            "optional_fixed64" => Ok(__FieldTag::__optional_fixed64),
                            "optionalSfixed32" => Ok(__FieldTag::__optional_sfixed32),
                            "optional_sfixed32" => Ok(__FieldTag::__optional_sfixed32),
                            "optionalSfixed64" => Ok(__FieldTag::__optional_sfixed64),
                            "optional_sfixed64" => Ok(__FieldTag::__optional_sfixed64),
                            "optionalFloat" => Ok(__FieldTag::__optional_float),
                            "optional_float" => Ok(__FieldTag::__optional_float),
                            "optionalDouble" => Ok(__FieldTag::__optional_double),
                            "optional_double" => Ok(__FieldTag::__optional_double),
                            "optionalBool" => Ok(__FieldTag::__optional_bool),
                            "optional_bool" => Ok(__FieldTag::__optional_bool),
                            "optionalString" => Ok(__FieldTag::__optional_string),
                            "optional_string" => Ok(__FieldTag::__optional_string),
                            "optionalBytes" => Ok(__FieldTag::__optional_bytes),
                            "optional_bytes" => Ok(__FieldTag::__optional_bytes),
                            "optionalNestedMessage" => Ok(__FieldTag::__optional_nested_message),
                            "optional_nested_message" => Ok(__FieldTag::__optional_nested_message),
                            "optionalForeignMessage" => Ok(__FieldTag::__optional_foreign_message),
                            "optional_foreign_message" => {
                                Ok(__FieldTag::__optional_foreign_message)
                            }
                            "optionalNestedEnum" => Ok(__FieldTag::__optional_nested_enum),
                            "optional_nested_enum" => Ok(__FieldTag::__optional_nested_enum),
                            "optionalForeignEnum" => Ok(__FieldTag::__optional_foreign_enum),
                            "optional_foreign_enum" => Ok(__FieldTag::__optional_foreign_enum),
                            "optionalAliasedEnum" => Ok(__FieldTag::__optional_aliased_enum),
                            "optional_aliased_enum" => Ok(__FieldTag::__optional_aliased_enum),
                            "optionalStringPiece" => Ok(__FieldTag::__optional_string_piece),
                            "optional_string_piece" => Ok(__FieldTag::__optional_string_piece),
                            "optionalCord" => Ok(__FieldTag::__optional_cord),
                            "optional_cord" => Ok(__FieldTag::__optional_cord),
                            "recursiveMessage" => Ok(__FieldTag::__recursive_message),
                            "recursive_message" => Ok(__FieldTag::__recursive_message),
                            "repeatedInt32" => Ok(__FieldTag::__repeated_int32),
                            "repeated_int32" => Ok(__FieldTag::__repeated_int32),
                            "repeatedInt64" => Ok(__FieldTag::__repeated_int64),
                            "repeated_int64" => Ok(__FieldTag::__repeated_int64),
                            "repeatedUint32" => Ok(__FieldTag::__repeated_uint32),
                            "repeated_uint32" => Ok(__FieldTag::__repeated_uint32),
                            "repeatedUint64" => Ok(__FieldTag::__repeated_uint64),
                            "repeated_uint64" => Ok(__FieldTag::__repeated_uint64),
                            "repeatedSint32" => Ok(__FieldTag::__repeated_sint32),
                            "repeated_sint32" => Ok(__FieldTag::__repeated_sint32),
                            "repeatedSint64" => Ok(__FieldTag::__repeated_sint64),
                            "repeated_sint64" => Ok(__FieldTag::__repeated_sint64),
                            "repeatedFixed32" => Ok(__FieldTag::__repeated_fixed32),
                            "repeated_fixed32" => Ok(__FieldTag::__repeated_fixed32),
                            "repeatedFixed64" => Ok(__FieldTag::__repeated_fixed64),
                            "repeated_fixed64" => Ok(__FieldTag::__repeated_fixed64),
                            "repeatedSfixed32" => Ok(__FieldTag::__repeated_sfixed32),
                            "repeated_sfixed32" => Ok(__FieldTag::__repeated_sfixed32),
                            "repeatedSfixed64" => Ok(__FieldTag::__repeated_sfixed64),
                            "repeated_sfixed64" => Ok(__FieldTag::__repeated_sfixed64),
                            "repeatedFloat" => Ok(__FieldTag::__repeated_float),
                            "repeated_float" => Ok(__FieldTag::__repeated_float),
                            "repeatedDouble" => Ok(__FieldTag::__repeated_double),
                            "repeated_double" => Ok(__FieldTag::__repeated_double),
                            "repeatedBool" => Ok(__FieldTag::__repeated_bool),
                            "repeated_bool" => Ok(__FieldTag::__repeated_bool),
                            "repeatedString" => Ok(__FieldTag::__repeated_string),
                            "repeated_string" => Ok(__FieldTag::__repeated_string),
                            "repeatedBytes" => Ok(__FieldTag::__repeated_bytes),
                            "repeated_bytes" => Ok(__FieldTag::__repeated_bytes),
                            "repeatedNestedMessage" => Ok(__FieldTag::__repeated_nested_message),
                            "repeated_nested_message" => Ok(__FieldTag::__repeated_nested_message),
                            "repeatedForeignMessage" => Ok(__FieldTag::__repeated_foreign_message),
                            "repeated_foreign_message" => {
                                Ok(__FieldTag::__repeated_foreign_message)
                            }
                            "repeatedNestedEnum" => Ok(__FieldTag::__repeated_nested_enum),
                            "repeated_nested_enum" => Ok(__FieldTag::__repeated_nested_enum),
                            "repeatedForeignEnum" => Ok(__FieldTag::__repeated_foreign_enum),
                            "repeated_foreign_enum" => Ok(__FieldTag::__repeated_foreign_enum),
                            "repeatedStringPiece" => Ok(__FieldTag::__repeated_string_piece),
                            "repeated_string_piece" => Ok(__FieldTag::__repeated_string_piece),
                            "repeatedCord" => Ok(__FieldTag::__repeated_cord),
                            "repeated_cord" => Ok(__FieldTag::__repeated_cord),
                            "packedInt32" => Ok(__FieldTag::__packed_int32),
                            "packed_int32" => Ok(__FieldTag::__packed_int32),
                            "packedInt64" => Ok(__FieldTag::__packed_int64),
                            "packed_int64" => Ok(__FieldTag::__packed_int64),
                            "packedUint32" => Ok(__FieldTag::__packed_uint32),
                            "packed_uint32" => Ok(__FieldTag::__packed_uint32),
                            "packedUint64" => Ok(__FieldTag::__packed_uint64),
                            "packed_uint64" => Ok(__FieldTag::__packed_uint64),
                            "packedSint32" => Ok(__FieldTag::__packed_sint32),
                            "packed_sint32" => Ok(__FieldTag::__packed_sint32),
                            "packedSint64" => Ok(__FieldTag::__packed_sint64),
                            "packed_sint64" => Ok(__FieldTag::__packed_sint64),
                            "packedFixed32" => Ok(__FieldTag::__packed_fixed32),
                            "packed_fixed32" => Ok(__FieldTag::__packed_fixed32),
                            "packedFixed64" => Ok(__FieldTag::__packed_fixed64),
                            "packed_fixed64" => Ok(__FieldTag::__packed_fixed64),
                            "packedSfixed32" => Ok(__FieldTag::__packed_sfixed32),
                            "packed_sfixed32" => Ok(__FieldTag::__packed_sfixed32),
                            "packedSfixed64" => Ok(__FieldTag::__packed_sfixed64),
                            "packed_sfixed64" => Ok(__FieldTag::__packed_sfixed64),
                            "packedFloat" => Ok(__FieldTag::__packed_float),
                            "packed_float" => Ok(__FieldTag::__packed_float),
                            "packedDouble" => Ok(__FieldTag::__packed_double),
                            "packed_double" => Ok(__FieldTag::__packed_double),
                            "packedBool" => Ok(__FieldTag::__packed_bool),
                            "packed_bool" => Ok(__FieldTag::__packed_bool),
                            "packedNestedEnum" => Ok(__FieldTag::__packed_nested_enum),
                            "packed_nested_enum" => Ok(__FieldTag::__packed_nested_enum),
                            "unpackedInt32" => Ok(__FieldTag::__unpacked_int32),
                            "unpacked_int32" => Ok(__FieldTag::__unpacked_int32),
                            "unpackedInt64" => Ok(__FieldTag::__unpacked_int64),
                            "unpacked_int64" => Ok(__FieldTag::__unpacked_int64),
                            "unpackedUint32" => Ok(__FieldTag::__unpacked_uint32),
                            "unpacked_uint32" => Ok(__FieldTag::__unpacked_uint32),
                            "unpackedUint64" => Ok(__FieldTag::__unpacked_uint64),
                            "unpacked_uint64" => Ok(__FieldTag::__unpacked_uint64),
                            "unpackedSint32" => Ok(__FieldTag::__unpacked_sint32),
                            "unpacked_sint32" => Ok(__FieldTag::__unpacked_sint32),
                            "unpackedSint64" => Ok(__FieldTag::__unpacked_sint64),
                            "unpacked_sint64" => Ok(__FieldTag::__unpacked_sint64),
                            "unpackedFixed32" => Ok(__FieldTag::__unpacked_fixed32),
                            "unpacked_fixed32" => Ok(__FieldTag::__unpacked_fixed32),
                            "unpackedFixed64" => Ok(__FieldTag::__unpacked_fixed64),
                            "unpacked_fixed64" => Ok(__FieldTag::__unpacked_fixed64),
                            "unpackedSfixed32" => Ok(__FieldTag::__unpacked_sfixed32),
                            "unpacked_sfixed32" => Ok(__FieldTag::__unpacked_sfixed32),
                            "unpackedSfixed64" => Ok(__FieldTag::__unpacked_sfixed64),
                            "unpacked_sfixed64" => Ok(__FieldTag::__unpacked_sfixed64),
                            "unpackedFloat" => Ok(__FieldTag::__unpacked_float),
                            "unpacked_float" => Ok(__FieldTag::__unpacked_float),
                            "unpackedDouble" => Ok(__FieldTag::__unpacked_double),
                            "unpacked_double" => Ok(__FieldTag::__unpacked_double),
                            "unpackedBool" => Ok(__FieldTag::__unpacked_bool),
                            "unpacked_bool" => Ok(__FieldTag::__unpacked_bool),
                            "unpackedNestedEnum" => Ok(__FieldTag::__unpacked_nested_enum),
                            "unpacked_nested_enum" => Ok(__FieldTag::__unpacked_nested_enum),
                            "mapInt32Int32" => Ok(__FieldTag::__map_int32_int32),
                            "map_int32_int32" => Ok(__FieldTag::__map_int32_int32),
                            "mapInt64Int64" => Ok(__FieldTag::__map_int64_int64),
                            "map_int64_int64" => Ok(__FieldTag::__map_int64_int64),
                            "mapUint32Uint32" => Ok(__FieldTag::__map_uint32_uint32),
                            "map_uint32_uint32" => Ok(__FieldTag::__map_uint32_uint32),
                            "mapUint64Uint64" => Ok(__FieldTag::__map_uint64_uint64),
                            "map_uint64_uint64" => Ok(__FieldTag::__map_uint64_uint64),
                            "mapSint32Sint32" => Ok(__FieldTag::__map_sint32_sint32),
                            "map_sint32_sint32" => Ok(__FieldTag::__map_sint32_sint32),
                            "mapSint64Sint64" => Ok(__FieldTag::__map_sint64_sint64),
                            "map_sint64_sint64" => Ok(__FieldTag::__map_sint64_sint64),
                            "mapFixed32Fixed32" => Ok(__FieldTag::__map_fixed32_fixed32),
                            "map_fixed32_fixed32" => Ok(__FieldTag::__map_fixed32_fixed32),
                            "mapFixed64Fixed64" => Ok(__FieldTag::__map_fixed64_fixed64),
                            "map_fixed64_fixed64" => Ok(__FieldTag::__map_fixed64_fixed64),
                            "mapSfixed32Sfixed32" => Ok(__FieldTag::__map_sfixed32_sfixed32),
                            "map_sfixed32_sfixed32" => Ok(__FieldTag::__map_sfixed32_sfixed32),
                            "mapSfixed64Sfixed64" => Ok(__FieldTag::__map_sfixed64_sfixed64),
                            "map_sfixed64_sfixed64" => Ok(__FieldTag::__map_sfixed64_sfixed64),
                            "mapInt32Float" => Ok(__FieldTag::__map_int32_float),
                            "map_int32_float" => Ok(__FieldTag::__map_int32_float),
                            "mapInt32Double" => Ok(__FieldTag::__map_int32_double),
                            "map_int32_double" => Ok(__FieldTag::__map_int32_double),
                            "mapBoolBool" => Ok(__FieldTag::__map_bool_bool),
                            "map_bool_bool" => Ok(__FieldTag::__map_bool_bool),
                            "mapStringString" => Ok(__FieldTag::__map_string_string),
                            "map_string_string" => Ok(__FieldTag::__map_string_string),
                            "mapStringBytes" => Ok(__FieldTag::__map_string_bytes),
                            "map_string_bytes" => Ok(__FieldTag::__map_string_bytes),
                            "mapStringNestedMessage" => Ok(__FieldTag::__map_string_nested_message),
                            "map_string_nested_message" => {
                                Ok(__FieldTag::__map_string_nested_message)
                            }
                            "mapStringForeignMessage" => {
                                Ok(__FieldTag::__map_string_foreign_message)
                            }
                            "map_string_foreign_message" => {
                                Ok(__FieldTag::__map_string_foreign_message)
                            }
                            "mapStringNestedEnum" => Ok(__FieldTag::__map_string_nested_enum),
                            "map_string_nested_enum" => Ok(__FieldTag::__map_string_nested_enum),
                            "mapStringForeignEnum" => Ok(__FieldTag::__map_string_foreign_enum),
                            "map_string_foreign_enum" => Ok(__FieldTag::__map_string_foreign_enum),
                            "oneofUint32" => Ok(__FieldTag::__oneof_uint32),
                            "oneof_uint32" => Ok(__FieldTag::__oneof_uint32),
                            "oneofNestedMessage" => Ok(__FieldTag::__oneof_nested_message),
                            "oneof_nested_message" => Ok(__FieldTag::__oneof_nested_message),
                            "oneofString" => Ok(__FieldTag::__oneof_string),
                            "oneof_string" => Ok(__FieldTag::__oneof_string),
                            "oneofBytes" => Ok(__FieldTag::__oneof_bytes),
                            "oneof_bytes" => Ok(__FieldTag::__oneof_bytes),
                            "oneofBool" => Ok(__FieldTag::__oneof_bool),
                            "oneof_bool" => Ok(__FieldTag::__oneof_bool),
                            "oneofUint64" => Ok(__FieldTag::__oneof_uint64),
                            "oneof_uint64" => Ok(__FieldTag::__oneof_uint64),
                            "oneofFloat" => Ok(__FieldTag::__oneof_float),
                            "oneof_float" => Ok(__FieldTag::__oneof_float),
                            "oneofDouble" => Ok(__FieldTag::__oneof_double),
                            "oneof_double" => Ok(__FieldTag::__oneof_double),
                            "oneofEnum" => Ok(__FieldTag::__oneof_enum),
                            "oneof_enum" => Ok(__FieldTag::__oneof_enum),
                            "oneofNullValue" => Ok(__FieldTag::__oneof_null_value),
                            "oneof_null_value" => Ok(__FieldTag::__oneof_null_value),
                            "optionalBoolWrapper" => Ok(__FieldTag::__optional_bool_wrapper),
                            "optional_bool_wrapper" => Ok(__FieldTag::__optional_bool_wrapper),
                            "optionalInt32Wrapper" => Ok(__FieldTag::__optional_int32_wrapper),
                            "optional_int32_wrapper" => Ok(__FieldTag::__optional_int32_wrapper),
                            "optionalInt64Wrapper" => Ok(__FieldTag::__optional_int64_wrapper),
                            "optional_int64_wrapper" => Ok(__FieldTag::__optional_int64_wrapper),
                            "optionalUint32Wrapper" => Ok(__FieldTag::__optional_uint32_wrapper),
                            "optional_uint32_wrapper" => Ok(__FieldTag::__optional_uint32_wrapper),
                            "optionalUint64Wrapper" => Ok(__FieldTag::__optional_uint64_wrapper),
                            "optional_uint64_wrapper" => Ok(__FieldTag::__optional_uint64_wrapper),
                            "optionalFloatWrapper" => Ok(__FieldTag::__optional_float_wrapper),
                            "optional_float_wrapper" => Ok(__FieldTag::__optional_float_wrapper),
                            "optionalDoubleWrapper" => Ok(__FieldTag::__optional_double_wrapper),
                            "optional_double_wrapper" => Ok(__FieldTag::__optional_double_wrapper),
                            "optionalStringWrapper" => Ok(__FieldTag::__optional_string_wrapper),
                            "optional_string_wrapper" => Ok(__FieldTag::__optional_string_wrapper),
                            "optionalBytesWrapper" => Ok(__FieldTag::__optional_bytes_wrapper),
                            "optional_bytes_wrapper" => Ok(__FieldTag::__optional_bytes_wrapper),
                            "repeatedBoolWrapper" => Ok(__FieldTag::__repeated_bool_wrapper),
                            "repeated_bool_wrapper" => Ok(__FieldTag::__repeated_bool_wrapper),
                            "repeatedInt32Wrapper" => Ok(__FieldTag::__repeated_int32_wrapper),
                            "repeated_int32_wrapper" => Ok(__FieldTag::__repeated_int32_wrapper),
                            "repeatedInt64Wrapper" => Ok(__FieldTag::__repeated_int64_wrapper),
                            "repeated_int64_wrapper" => Ok(__FieldTag::__repeated_int64_wrapper),
                            "repeatedUint32Wrapper" => Ok(__FieldTag::__repeated_uint32_wrapper),
                            "repeated_uint32_wrapper" => Ok(__FieldTag::__repeated_uint32_wrapper),
                            "repeatedUint64Wrapper" => Ok(__FieldTag::__repeated_uint64_wrapper),
                            "repeated_uint64_wrapper" => Ok(__FieldTag::__repeated_uint64_wrapper),
                            "repeatedFloatWrapper" => Ok(__FieldTag::__repeated_float_wrapper),
                            "repeated_float_wrapper" => Ok(__FieldTag::__repeated_float_wrapper),
                            "repeatedDoubleWrapper" => Ok(__FieldTag::__repeated_double_wrapper),
                            "repeated_double_wrapper" => Ok(__FieldTag::__repeated_double_wrapper),
                            "repeatedStringWrapper" => Ok(__FieldTag::__repeated_string_wrapper),
                            "repeated_string_wrapper" => Ok(__FieldTag::__repeated_string_wrapper),
                            "repeatedBytesWrapper" => Ok(__FieldTag::__repeated_bytes_wrapper),
                            "repeated_bytes_wrapper" => Ok(__FieldTag::__repeated_bytes_wrapper),
                            "optionalDuration" => Ok(__FieldTag::__optional_duration),
                            "optional_duration" => Ok(__FieldTag::__optional_duration),
                            "optionalTimestamp" => Ok(__FieldTag::__optional_timestamp),
                            "optional_timestamp" => Ok(__FieldTag::__optional_timestamp),
                            "optionalFieldMask" => Ok(__FieldTag::__optional_field_mask),
                            "optional_field_mask" => Ok(__FieldTag::__optional_field_mask),
                            "optionalStruct" => Ok(__FieldTag::__optional_struct),
                            "optional_struct" => Ok(__FieldTag::__optional_struct),
                            "optionalAny" => Ok(__FieldTag::__optional_any),
                            "optional_any" => Ok(__FieldTag::__optional_any),
                            "optionalValue" => Ok(__FieldTag::__optional_value),
                            "optional_value" => Ok(__FieldTag::__optional_value),
                            "optionalNullValue" => Ok(__FieldTag::__optional_null_value),
                            "optional_null_value" => Ok(__FieldTag::__optional_null_value),
                            "repeatedDuration" => Ok(__FieldTag::__repeated_duration),
                            "repeated_duration" => Ok(__FieldTag::__repeated_duration),
                            "repeatedTimestamp" => Ok(__FieldTag::__repeated_timestamp),
                            "repeated_timestamp" => Ok(__FieldTag::__repeated_timestamp),
                            "repeatedFieldmask" => Ok(__FieldTag::__repeated_fieldmask),
                            "repeated_fieldmask" => Ok(__FieldTag::__repeated_fieldmask),
                            "repeatedStruct" => Ok(__FieldTag::__repeated_struct),
                            "repeated_struct" => Ok(__FieldTag::__repeated_struct),
                            "repeatedAny" => Ok(__FieldTag::__repeated_any),
                            "repeated_any" => Ok(__FieldTag::__repeated_any),
                            "repeatedValue" => Ok(__FieldTag::__repeated_value),
                            "repeated_value" => Ok(__FieldTag::__repeated_value),
                            "repeatedListValue" => Ok(__FieldTag::__repeated_list_value),
                            "repeated_list_value" => Ok(__FieldTag::__repeated_list_value),
                            "fieldname1" => Ok(__FieldTag::__fieldname1),
                            "fieldName2" => Ok(__FieldTag::__field_name2),
                            "field_name2" => Ok(__FieldTag::__field_name2),
                            "FieldName3" => Ok(__FieldTag::___field_name3),
                            "_field_name3" => Ok(__FieldTag::___field_name3),
                            "fieldName4" => Ok(__FieldTag::__field__name4_),
                            "field__name4_" => Ok(__FieldTag::__field__name4_),
                            "field0name5" => Ok(__FieldTag::__field0name5),
                            "field0Name6" => Ok(__FieldTag::__field_0_name6),
                            "field_0_name6" => Ok(__FieldTag::__field_0_name6),
                            "fieldName7" => Ok(__FieldTag::__field_name_7),
                            "FieldName8" => Ok(__FieldTag::__field_name_8),
                            "fieldName9" => Ok(__FieldTag::__field_name_9),
                            "field_Name9" => Ok(__FieldTag::__field_name_9),
                            "FieldName10" => Ok(__FieldTag::__field_name_10),
                            "Field_Name10" => Ok(__FieldTag::__field_name_10),
                            "FIELDNAME11" => Ok(__FieldTag::__field_name_11),
                            "FIELD_NAME11" => Ok(__FieldTag::__field_name_11),
                            "FIELDName12" => Ok(__FieldTag::__field_name_12),
                            "FIELD_name12" => Ok(__FieldTag::__field_name_12),
                            "FieldName13" => Ok(__FieldTag::____field_name13),
                            "__field_name13" => Ok(__FieldTag::____field_name13),
                            "FieldName14" => Ok(__FieldTag::____field_name_14),
                            "__Field_name14" => Ok(__FieldTag::____field_name_14),
                            "fieldName15" => Ok(__FieldTag::__field__name15),
                            "field__name15" => Ok(__FieldTag::__field__name15),
                            "fieldName16" => Ok(__FieldTag::__field__name_16),
                            "field__Name16" => Ok(__FieldTag::__field__name_16),
                            "fieldName17" => Ok(__FieldTag::__field_name17__),
                            "field_name17__" => Ok(__FieldTag::__field_name17__),
                            "FieldName18" => Ok(__FieldTag::__field_name_18__),
                            "Field_name18__" => Ok(__FieldTag::__field_name_18__),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TestAllTypesProto3;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TestAllTypesProto3")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__optional_int32 => {
                            if !fields.insert(__FieldTag::__optional_int32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_int32",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_int32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional_int64 => {
                            if !fields.insert(__FieldTag::__optional_int64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_int64",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_int64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional_uint32 => {
                            if !fields.insert(__FieldTag::__optional_uint32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_uint32",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_uint32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional_uint64 => {
                            if !fields.insert(__FieldTag::__optional_uint64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_uint64",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_uint64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional_sint32 => {
                            if !fields.insert(__FieldTag::__optional_sint32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_sint32",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_sint32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional_sint64 => {
                            if !fields.insert(__FieldTag::__optional_sint64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_sint64",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_sint64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional_fixed32 => {
                            if !fields.insert(__FieldTag::__optional_fixed32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_fixed32",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_fixed32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional_fixed64 => {
                            if !fields.insert(__FieldTag::__optional_fixed64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_fixed64",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_fixed64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional_sfixed32 => {
                            if !fields.insert(__FieldTag::__optional_sfixed32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_sfixed32",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_sfixed32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional_sfixed64 => {
                            if !fields.insert(__FieldTag::__optional_sfixed64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_sfixed64",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_sfixed64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional_float => {
                            if !fields.insert(__FieldTag::__optional_float) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_float",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_float =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional_double => {
                            if !fields.insert(__FieldTag::__optional_double) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_double",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_double =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional_bool => {
                            if !fields.insert(__FieldTag::__optional_bool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_bool",
                                ));
                            }
                            result.optional_bool = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__optional_string => {
                            if !fields.insert(__FieldTag::__optional_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_string",
                                ));
                            }
                            result.optional_string = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__optional_bytes => {
                            if !fields.insert(__FieldTag::__optional_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_bytes",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional_nested_message => {
                            if !fields.insert(__FieldTag::__optional_nested_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_nested_message",
                                ));
                            }
                            result.optional_nested_message = map.next_value::<std::option::Option<std::boxed::Box<crate::generated::test_protos::test_all_types_proto_3::NestedMessage>>>()?
                                ;
                        }
                        __FieldTag::__optional_foreign_message => {
                            if !fields.insert(__FieldTag::__optional_foreign_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_foreign_message",
                                ));
                            }
                            result.optional_foreign_message = map
                                .next_value::<std::option::Option<
                                    crate::generated::test_protos::ForeignMessage,
                                >>()?;
                        }
                        __FieldTag::__optional_nested_enum => {
                            if !fields.insert(__FieldTag::__optional_nested_enum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_nested_enum",
                                ));
                            }
                            result.optional_nested_enum = map.next_value::<std::option::Option<crate::generated::test_protos::test_all_types_proto_3::NestedEnum>>()?.unwrap_or_default();
                        }
                        __FieldTag::__optional_foreign_enum => {
                            if !fields.insert(__FieldTag::__optional_foreign_enum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_foreign_enum",
                                ));
                            }
                            result.optional_foreign_enum = map.next_value::<std::option::Option<crate::generated::test_protos::ForeignEnum>>()?.unwrap_or_default();
                        }
                        __FieldTag::__optional_aliased_enum => {
                            if !fields.insert(__FieldTag::__optional_aliased_enum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_aliased_enum",
                                ));
                            }
                            result.optional_aliased_enum = map.next_value::<std::option::Option<crate::generated::test_protos::test_all_types_proto_3::AliasedEnum>>()?.unwrap_or_default();
                        }
                        __FieldTag::__optional_string_piece => {
                            if !fields.insert(__FieldTag::__optional_string_piece) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_string_piece",
                                ));
                            }
                            result.optional_string_piece = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__optional_cord => {
                            if !fields.insert(__FieldTag::__optional_cord) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_cord",
                                ));
                            }
                            result.optional_cord = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__recursive_message => {
                            if !fields.insert(__FieldTag::__recursive_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recursive_message",
                                ));
                            }
                            result.recursive_message = map.next_value::<std::option::Option<
                                std::boxed::Box<crate::generated::test_protos::TestAllTypesProto3>,
                            >>()?;
                        }
                        __FieldTag::__repeated_int32 => {
                            if !fields.insert(__FieldTag::__repeated_int32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_int32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_int32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_int64 => {
                            if !fields.insert(__FieldTag::__repeated_int64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_int64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_int64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_uint32 => {
                            if !fields.insert(__FieldTag::__repeated_uint32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_uint32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<u32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_uint32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_uint64 => {
                            if !fields.insert(__FieldTag::__repeated_uint64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_uint64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<u64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_uint64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_sint32 => {
                            if !fields.insert(__FieldTag::__repeated_sint32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_sint32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_sint32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_sint64 => {
                            if !fields.insert(__FieldTag::__repeated_sint64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_sint64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_sint64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_fixed32 => {
                            if !fields.insert(__FieldTag::__repeated_fixed32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_fixed32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<u32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_fixed32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_fixed64 => {
                            if !fields.insert(__FieldTag::__repeated_fixed64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_fixed64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<u64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_fixed64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_sfixed32 => {
                            if !fields.insert(__FieldTag::__repeated_sfixed32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_sfixed32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_sfixed32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_sfixed64 => {
                            if !fields.insert(__FieldTag::__repeated_sfixed64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_sfixed64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_sfixed64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_float => {
                            if !fields.insert(__FieldTag::__repeated_float) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_float",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_float =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_double => {
                            if !fields.insert(__FieldTag::__repeated_double) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_double",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_double =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_bool => {
                            if !fields.insert(__FieldTag::__repeated_bool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_bool",
                                ));
                            }
                            result.repeated_bool = map
                                .next_value::<std::option::Option<std::vec::Vec<bool>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repeated_string => {
                            if !fields.insert(__FieldTag::__repeated_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_string",
                                ));
                            }
                            result.repeated_string = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__repeated_bytes => {
                            if !fields.insert(__FieldTag::__repeated_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_bytes",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<::bytes::Bytes>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::vec::Vec<serde_with::base64::Base64>,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_nested_message => {
                            if !fields.insert(__FieldTag::__repeated_nested_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_nested_message",
                                ));
                            }
                            result.repeated_nested_message = map.next_value::<std::option::Option<std::vec::Vec<crate::generated::test_protos::test_all_types_proto_3::NestedMessage>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__repeated_foreign_message => {
                            if !fields.insert(__FieldTag::__repeated_foreign_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_foreign_message",
                                ));
                            }
                            result.repeated_foreign_message = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::generated::test_protos::ForeignMessage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repeated_nested_enum => {
                            if !fields.insert(__FieldTag::__repeated_nested_enum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_nested_enum",
                                ));
                            }
                            result.repeated_nested_enum = map.next_value::<std::option::Option<std::vec::Vec<crate::generated::test_protos::test_all_types_proto_3::NestedEnum>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__repeated_foreign_enum => {
                            if !fields.insert(__FieldTag::__repeated_foreign_enum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_foreign_enum",
                                ));
                            }
                            result.repeated_foreign_enum = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::generated::test_protos::ForeignEnum>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repeated_string_piece => {
                            if !fields.insert(__FieldTag::__repeated_string_piece) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_string_piece",
                                ));
                            }
                            result.repeated_string_piece = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__repeated_cord => {
                            if !fields.insert(__FieldTag::__repeated_cord) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_cord",
                                ));
                            }
                            result.repeated_cord = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__packed_int32 => {
                            if !fields.insert(__FieldTag::__packed_int32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packed_int32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.packed_int32 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__packed_int64 => {
                            if !fields.insert(__FieldTag::__packed_int64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packed_int64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.packed_int64 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__packed_uint32 => {
                            if !fields.insert(__FieldTag::__packed_uint32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packed_uint32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<u32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.packed_uint32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__packed_uint64 => {
                            if !fields.insert(__FieldTag::__packed_uint64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packed_uint64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<u64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.packed_uint64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__packed_sint32 => {
                            if !fields.insert(__FieldTag::__packed_sint32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packed_sint32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.packed_sint32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__packed_sint64 => {
                            if !fields.insert(__FieldTag::__packed_sint64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packed_sint64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.packed_sint64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__packed_fixed32 => {
                            if !fields.insert(__FieldTag::__packed_fixed32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packed_fixed32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<u32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.packed_fixed32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__packed_fixed64 => {
                            if !fields.insert(__FieldTag::__packed_fixed64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packed_fixed64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<u64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.packed_fixed64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__packed_sfixed32 => {
                            if !fields.insert(__FieldTag::__packed_sfixed32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packed_sfixed32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.packed_sfixed32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__packed_sfixed64 => {
                            if !fields.insert(__FieldTag::__packed_sfixed64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packed_sfixed64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.packed_sfixed64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__packed_float => {
                            if !fields.insert(__FieldTag::__packed_float) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packed_float",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.packed_float = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__packed_double => {
                            if !fields.insert(__FieldTag::__packed_double) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packed_double",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.packed_double =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__packed_bool => {
                            if !fields.insert(__FieldTag::__packed_bool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packed_bool",
                                ));
                            }
                            result.packed_bool = map
                                .next_value::<std::option::Option<std::vec::Vec<bool>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__packed_nested_enum => {
                            if !fields.insert(__FieldTag::__packed_nested_enum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for packed_nested_enum",
                                ));
                            }
                            result.packed_nested_enum = map.next_value::<std::option::Option<std::vec::Vec<crate::generated::test_protos::test_all_types_proto_3::NestedEnum>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__unpacked_int32 => {
                            if !fields.insert(__FieldTag::__unpacked_int32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unpacked_int32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.unpacked_int32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unpacked_int64 => {
                            if !fields.insert(__FieldTag::__unpacked_int64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unpacked_int64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.unpacked_int64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unpacked_uint32 => {
                            if !fields.insert(__FieldTag::__unpacked_uint32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unpacked_uint32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<u32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.unpacked_uint32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unpacked_uint64 => {
                            if !fields.insert(__FieldTag::__unpacked_uint64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unpacked_uint64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<u64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.unpacked_uint64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unpacked_sint32 => {
                            if !fields.insert(__FieldTag::__unpacked_sint32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unpacked_sint32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.unpacked_sint32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unpacked_sint64 => {
                            if !fields.insert(__FieldTag::__unpacked_sint64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unpacked_sint64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.unpacked_sint64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unpacked_fixed32 => {
                            if !fields.insert(__FieldTag::__unpacked_fixed32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unpacked_fixed32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<u32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.unpacked_fixed32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unpacked_fixed64 => {
                            if !fields.insert(__FieldTag::__unpacked_fixed64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unpacked_fixed64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<u64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.unpacked_fixed64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unpacked_sfixed32 => {
                            if !fields.insert(__FieldTag::__unpacked_sfixed32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unpacked_sfixed32",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.unpacked_sfixed32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unpacked_sfixed64 => {
                            if !fields.insert(__FieldTag::__unpacked_sfixed64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unpacked_sfixed64",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.unpacked_sfixed64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unpacked_float => {
                            if !fields.insert(__FieldTag::__unpacked_float) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unpacked_float",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.unpacked_float =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unpacked_double => {
                            if !fields.insert(__FieldTag::__unpacked_double) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unpacked_double",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.unpacked_double =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unpacked_bool => {
                            if !fields.insert(__FieldTag::__unpacked_bool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unpacked_bool",
                                ));
                            }
                            result.unpacked_bool = map
                                .next_value::<std::option::Option<std::vec::Vec<bool>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unpacked_nested_enum => {
                            if !fields.insert(__FieldTag::__unpacked_nested_enum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unpacked_nested_enum",
                                ));
                            }
                            result.unpacked_nested_enum = map.next_value::<std::option::Option<std::vec::Vec<crate::generated::test_protos::test_all_types_proto_3::NestedEnum>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__map_int32_int32 => {
                            if !fields.insert(__FieldTag::__map_int32_int32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_int32_int32",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<i32, i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I32,
                                                wkt::internal::I32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_int32_int32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_int64_int64 => {
                            if !fields.insert(__FieldTag::__map_int64_int64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_int64_int64",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<i64, i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I64,
                                                wkt::internal::I64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_int64_int64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_uint32_uint32 => {
                            if !fields.insert(__FieldTag::__map_uint32_uint32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_uint32_uint32",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<u32, u32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::U32,
                                                wkt::internal::U32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_uint32_uint32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_uint64_uint64 => {
                            if !fields.insert(__FieldTag::__map_uint64_uint64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_uint64_uint64",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<u64, u64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::U64,
                                                wkt::internal::U64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_uint64_uint64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_sint32_sint32 => {
                            if !fields.insert(__FieldTag::__map_sint32_sint32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_sint32_sint32",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<i32, i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I32,
                                                wkt::internal::I32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_sint32_sint32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_sint64_sint64 => {
                            if !fields.insert(__FieldTag::__map_sint64_sint64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_sint64_sint64",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<i64, i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I64,
                                                wkt::internal::I64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_sint64_sint64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_fixed32_fixed32 => {
                            if !fields.insert(__FieldTag::__map_fixed32_fixed32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_fixed32_fixed32",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<u32, u32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::U32,
                                                wkt::internal::U32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_fixed32_fixed32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_fixed64_fixed64 => {
                            if !fields.insert(__FieldTag::__map_fixed64_fixed64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_fixed64_fixed64",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<u64, u64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::U64,
                                                wkt::internal::U64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_fixed64_fixed64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_sfixed32_sfixed32 => {
                            if !fields.insert(__FieldTag::__map_sfixed32_sfixed32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_sfixed32_sfixed32",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<i32, i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I32,
                                                wkt::internal::I32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_sfixed32_sfixed32 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_sfixed64_sfixed64 => {
                            if !fields.insert(__FieldTag::__map_sfixed64_sfixed64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_sfixed64_sfixed64",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<i64, i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I64,
                                                wkt::internal::I64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_sfixed64_sfixed64 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_int32_float => {
                            if !fields.insert(__FieldTag::__map_int32_float) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_int32_float",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<i32, f32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I32,
                                                wkt::internal::F32,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_int32_float =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_int32_double => {
                            if !fields.insert(__FieldTag::__map_int32_double) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_int32_double",
                                ));
                            }
                            struct __With(std::option::Option<std::collections::HashMap<i32, f64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I32,
                                                wkt::internal::F64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_int32_double =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_bool_bool => {
                            if !fields.insert(__FieldTag::__map_bool_bool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_bool_bool",
                                ));
                            }
                            struct __With(
                                std::option::Option<std::collections::HashMap<bool, bool>>,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::DisplayFromStr,
                                                serde_with::Same,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_bool_bool =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_string_string => {
                            if !fields.insert(__FieldTag::__map_string_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_string_string",
                                ));
                            }
                            result.map_string_string = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__map_string_bytes => {
                            if !fields.insert(__FieldTag::__map_string_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_string_bytes",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, ::bytes::Bytes>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                serde_with::base64::Base64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.map_string_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__map_string_nested_message => {
                            if !fields.insert(__FieldTag::__map_string_nested_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_string_nested_message",
                                ));
                            }
                            result.map_string_nested_message = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::generated::test_protos::test_all_types_proto_3::NestedMessage>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__map_string_foreign_message => {
                            if !fields.insert(__FieldTag::__map_string_foreign_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_string_foreign_message",
                                ));
                            }
                            result.map_string_foreign_message = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::generated::test_protos::ForeignMessage,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__map_string_nested_enum => {
                            if !fields.insert(__FieldTag::__map_string_nested_enum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_string_nested_enum",
                                ));
                            }
                            result.map_string_nested_enum = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::generated::test_protos::test_all_types_proto_3::NestedEnum>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__map_string_foreign_enum => {
                            if !fields.insert(__FieldTag::__map_string_foreign_enum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_string_foreign_enum",
                                ));
                            }
                            result.map_string_foreign_enum = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::generated::test_protos::ForeignEnum,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oneof_uint32 => {
                            if !fields.insert(__FieldTag::__oneof_uint32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oneof_uint32",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.oneof_field.is_some() {
                                return Err(A::Error::duplicate_field(
                                    "multiple values for `oneof_field`, a oneof with full ID .protobuf_test_messages.proto3.TestAllTypesProto3.oneof_uint32, latest field was oneofUint32",
                                ));
                            }
                            result.oneof_field = std::option::Option::Some(
                                crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofUint32(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__oneof_nested_message => {
                            if !fields.insert(__FieldTag::__oneof_nested_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oneof_nested_message",
                                ));
                            }
                            if result.oneof_field.is_some() {
                                return Err(A::Error::duplicate_field(
                                    "multiple values for `oneof_field`, a oneof with full ID .protobuf_test_messages.proto3.TestAllTypesProto3.oneof_nested_message, latest field was oneofNestedMessage",
                                ));
                            }
                            result.oneof_field = std::option::Option::Some(
                                crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofNestedMessage(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::generated::test_protos::test_all_types_proto_3::NestedMessage>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__oneof_string => {
                            if !fields.insert(__FieldTag::__oneof_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oneof_string",
                                ));
                            }
                            if result.oneof_field.is_some() {
                                return Err(A::Error::duplicate_field(
                                    "multiple values for `oneof_field`, a oneof with full ID .protobuf_test_messages.proto3.TestAllTypesProto3.oneof_string, latest field was oneofString",
                                ));
                            }
                            result.oneof_field = std::option::Option::Some(
                                crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofString(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__oneof_bytes => {
                            if !fields.insert(__FieldTag::__oneof_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oneof_bytes",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.oneof_field.is_some() {
                                return Err(A::Error::duplicate_field(
                                    "multiple values for `oneof_field`, a oneof with full ID .protobuf_test_messages.proto3.TestAllTypesProto3.oneof_bytes, latest field was oneofBytes",
                                ));
                            }
                            result.oneof_field = std::option::Option::Some(
                                crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofBytes(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__oneof_bool => {
                            if !fields.insert(__FieldTag::__oneof_bool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oneof_bool",
                                ));
                            }
                            if result.oneof_field.is_some() {
                                return Err(A::Error::duplicate_field(
                                    "multiple values for `oneof_field`, a oneof with full ID .protobuf_test_messages.proto3.TestAllTypesProto3.oneof_bool, latest field was oneofBool",
                                ));
                            }
                            result.oneof_field = std::option::Option::Some(
                                crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofBool(
                                    map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__oneof_uint64 => {
                            if !fields.insert(__FieldTag::__oneof_uint64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oneof_uint64",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.oneof_field.is_some() {
                                return Err(A::Error::duplicate_field(
                                    "multiple values for `oneof_field`, a oneof with full ID .protobuf_test_messages.proto3.TestAllTypesProto3.oneof_uint64, latest field was oneofUint64",
                                ));
                            }
                            result.oneof_field = std::option::Option::Some(
                                crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofUint64(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__oneof_float => {
                            if !fields.insert(__FieldTag::__oneof_float) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oneof_float",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.oneof_field.is_some() {
                                return Err(A::Error::duplicate_field(
                                    "multiple values for `oneof_field`, a oneof with full ID .protobuf_test_messages.proto3.TestAllTypesProto3.oneof_float, latest field was oneofFloat",
                                ));
                            }
                            result.oneof_field = std::option::Option::Some(
                                crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofFloat(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__oneof_double => {
                            if !fields.insert(__FieldTag::__oneof_double) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oneof_double",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.oneof_field.is_some() {
                                return Err(A::Error::duplicate_field(
                                    "multiple values for `oneof_field`, a oneof with full ID .protobuf_test_messages.proto3.TestAllTypesProto3.oneof_double, latest field was oneofDouble",
                                ));
                            }
                            result.oneof_field = std::option::Option::Some(
                                crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofDouble(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__oneof_enum => {
                            if !fields.insert(__FieldTag::__oneof_enum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oneof_enum",
                                ));
                            }
                            if result.oneof_field.is_some() {
                                return Err(A::Error::duplicate_field(
                                    "multiple values for `oneof_field`, a oneof with full ID .protobuf_test_messages.proto3.TestAllTypesProto3.oneof_enum, latest field was oneofEnum",
                                ));
                            }
                            result.oneof_field = std::option::Option::Some(
                                crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofEnum(
                                    map.next_value::<std::option::Option<crate::generated::test_protos::test_all_types_proto_3::NestedEnum>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__oneof_null_value => {
                            if !fields.insert(__FieldTag::__oneof_null_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oneof_null_value",
                                ));
                            }
                            if result.oneof_field.is_some() {
                                return Err(A::Error::duplicate_field(
                                    "multiple values for `oneof_field`, a oneof with full ID .protobuf_test_messages.proto3.TestAllTypesProto3.oneof_null_value, latest field was oneofNullValue",
                                ));
                            }
                            result.oneof_field = std::option::Option::Some(
                                crate::generated::test_protos::test_all_types_proto_3::OneofField::OneofNullValue(
                                    map.next_value::<std::option::Option<wkt::NullValue>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__optional_bool_wrapper => {
                            if !fields.insert(__FieldTag::__optional_bool_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_bool_wrapper",
                                ));
                            }
                            result.optional_bool_wrapper =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__optional_int32_wrapper => {
                            if !fields.insert(__FieldTag::__optional_int32_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_int32_wrapper",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_int32_wrapper = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__optional_int64_wrapper => {
                            if !fields.insert(__FieldTag::__optional_int64_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_int64_wrapper",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_int64_wrapper = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__optional_uint32_wrapper => {
                            if !fields.insert(__FieldTag::__optional_uint32_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_uint32_wrapper",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_uint32_wrapper = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__optional_uint64_wrapper => {
                            if !fields.insert(__FieldTag::__optional_uint64_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_uint64_wrapper",
                                ));
                            }
                            struct __With(std::option::Option<wkt::UInt64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_uint64_wrapper = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__optional_float_wrapper => {
                            if !fields.insert(__FieldTag::__optional_float_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_float_wrapper",
                                ));
                            }
                            struct __With(std::option::Option<wkt::FloatValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_float_wrapper = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__optional_double_wrapper => {
                            if !fields.insert(__FieldTag::__optional_double_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_double_wrapper",
                                ));
                            }
                            struct __With(std::option::Option<wkt::DoubleValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_double_wrapper = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__optional_string_wrapper => {
                            if !fields.insert(__FieldTag::__optional_string_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_string_wrapper",
                                ));
                            }
                            result.optional_string_wrapper =
                                map.next_value::<std::option::Option<wkt::StringValue>>()?;
                        }
                        __FieldTag::__optional_bytes_wrapper => {
                            if !fields.insert(__FieldTag::__optional_bytes_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_bytes_wrapper",
                                ));
                            }
                            struct __With(std::option::Option<wkt::BytesValue>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.optional_bytes_wrapper = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__repeated_bool_wrapper => {
                            if !fields.insert(__FieldTag::__repeated_bool_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_bool_wrapper",
                                ));
                            }
                            result.repeated_bool_wrapper = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::BoolValue>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repeated_int32_wrapper => {
                            if !fields.insert(__FieldTag::__repeated_int32_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_int32_wrapper",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::Int32Value>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_int32_wrapper =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_int64_wrapper => {
                            if !fields.insert(__FieldTag::__repeated_int64_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_int64_wrapper",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::Int64Value>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_int64_wrapper =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_uint32_wrapper => {
                            if !fields.insert(__FieldTag::__repeated_uint32_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_uint32_wrapper",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::UInt32Value>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_uint32_wrapper =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_uint64_wrapper => {
                            if !fields.insert(__FieldTag::__repeated_uint64_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_uint64_wrapper",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::UInt64Value>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::U64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_uint64_wrapper =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_float_wrapper => {
                            if !fields.insert(__FieldTag::__repeated_float_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_float_wrapper",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::FloatValue>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_float_wrapper =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_double_wrapper => {
                            if !fields.insert(__FieldTag::__repeated_double_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_double_wrapper",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::DoubleValue>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_double_wrapper =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repeated_string_wrapper => {
                            if !fields.insert(__FieldTag::__repeated_string_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_string_wrapper",
                                ));
                            }
                            result.repeated_string_wrapper = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::StringValue>>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repeated_bytes_wrapper => {
                            if !fields.insert(__FieldTag::__repeated_bytes_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_bytes_wrapper",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<wkt::BytesValue>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::vec::Vec<serde_with::base64::Base64>,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.repeated_bytes_wrapper =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__optional_duration => {
                            if !fields.insert(__FieldTag::__optional_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_duration",
                                ));
                            }
                            result.optional_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__optional_timestamp => {
                            if !fields.insert(__FieldTag::__optional_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_timestamp",
                                ));
                            }
                            result.optional_timestamp =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__optional_field_mask => {
                            if !fields.insert(__FieldTag::__optional_field_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_field_mask",
                                ));
                            }
                            result.optional_field_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__optional_struct => {
                            if !fields.insert(__FieldTag::__optional_struct) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_struct",
                                ));
                            }
                            result.optional_struct =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__optional_any => {
                            if !fields.insert(__FieldTag::__optional_any) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_any",
                                ));
                            }
                            result.optional_any =
                                map.next_value::<std::option::Option<wkt::Any>>()?;
                        }
                        __FieldTag::__optional_value => {
                            if !fields.insert(__FieldTag::__optional_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_value",
                                ));
                            }
                            result.optional_value = map
                                .next_value::<std::option::Option<wkt::Value>>()?
                                .or(Some(wkt::Value::Null));
                        }
                        __FieldTag::__optional_null_value => {
                            if !fields.insert(__FieldTag::__optional_null_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_null_value",
                                ));
                            }
                            result.optional_null_value = map
                                .next_value::<std::option::Option<wkt::NullValue>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repeated_duration => {
                            if !fields.insert(__FieldTag::__repeated_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_duration",
                                ));
                            }
                            result.repeated_duration = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repeated_timestamp => {
                            if !fields.insert(__FieldTag::__repeated_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_timestamp",
                                ));
                            }
                            result.repeated_timestamp = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Timestamp>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repeated_fieldmask => {
                            if !fields.insert(__FieldTag::__repeated_fieldmask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_fieldmask",
                                ));
                            }
                            result.repeated_fieldmask = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::FieldMask>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repeated_struct => {
                            if !fields.insert(__FieldTag::__repeated_struct) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_struct",
                                ));
                            }
                            result.repeated_struct = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Struct>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repeated_any => {
                            if !fields.insert(__FieldTag::__repeated_any) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_any",
                                ));
                            }
                            result.repeated_any = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Any>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repeated_value => {
                            if !fields.insert(__FieldTag::__repeated_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_value",
                                ));
                            }
                            result.repeated_value = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Value>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repeated_list_value => {
                            if !fields.insert(__FieldTag::__repeated_list_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repeated_list_value",
                                ));
                            }
                            result.repeated_list_value = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::ListValue>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fieldname1 => {
                            if !fields.insert(__FieldTag::__fieldname1) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fieldname1",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.fieldname1 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__field_name2 => {
                            if !fields.insert(__FieldTag::__field_name2) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_name2",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.field_name2 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::___field_name3 => {
                            if !fields.insert(__FieldTag::___field_name3) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for _field_name3",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result._field_name3 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__field__name4_ => {
                            if !fields.insert(__FieldTag::__field__name4_) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field__name4_",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.field__name4_ =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__field0name5 => {
                            if !fields.insert(__FieldTag::__field0name5) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field0name5",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.field0name5 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__field_0_name6 => {
                            if !fields.insert(__FieldTag::__field_0_name6) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_0_name6",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.field_0_name6 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__field_name_7 => {
                            if !fields.insert(__FieldTag::__field_name_7) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_name_7",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.field_name_7 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__field_name_8 => {
                            if !fields.insert(__FieldTag::__field_name_8) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_name_8",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.field_name_8 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__field_name_9 => {
                            if !fields.insert(__FieldTag::__field_name_9) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_name_9",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.field_name_9 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__field_name_10 => {
                            if !fields.insert(__FieldTag::__field_name_10) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_name_10",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.field_name_10 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__field_name_11 => {
                            if !fields.insert(__FieldTag::__field_name_11) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_name_11",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.field_name_11 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__field_name_12 => {
                            if !fields.insert(__FieldTag::__field_name_12) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_name_12",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.field_name_12 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::____field_name13 => {
                            if !fields.insert(__FieldTag::____field_name13) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for __field_name13",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.__field_name13 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::____field_name_14 => {
                            if !fields.insert(__FieldTag::____field_name_14) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for __field_name_14",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.__field_name_14 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__field__name15 => {
                            if !fields.insert(__FieldTag::__field__name15) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field__name15",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.field__name15 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__field__name_16 => {
                            if !fields.insert(__FieldTag::__field__name_16) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field__name_16",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.field__name_16 =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__field_name17__ => {
                            if !fields.insert(__FieldTag::__field_name17__) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_name17__",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.field_name17__ =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__field_name_18__ => {
                            if !fields.insert(__FieldTag::__field_name_18__) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_name_18__",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.field_name_18__ =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TestAllTypesProto3 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(None)?;
        if !wkt::internal::is_default(&self.optional_int32) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalInt32", &__With(&self.optional_int32))?;
        }
        if !wkt::internal::is_default(&self.optional_int64) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalInt64", &__With(&self.optional_int64))?;
        }
        if !wkt::internal::is_default(&self.optional_uint32) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalUint32", &__With(&self.optional_uint32))?;
        }
        if !wkt::internal::is_default(&self.optional_uint64) {
            struct __With<'a>(&'a u64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalUint64", &__With(&self.optional_uint64))?;
        }
        if !wkt::internal::is_default(&self.optional_sint32) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalSint32", &__With(&self.optional_sint32))?;
        }
        if !wkt::internal::is_default(&self.optional_sint64) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalSint64", &__With(&self.optional_sint64))?;
        }
        if !wkt::internal::is_default(&self.optional_fixed32) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalFixed32", &__With(&self.optional_fixed32))?;
        }
        if !wkt::internal::is_default(&self.optional_fixed64) {
            struct __With<'a>(&'a u64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalFixed64", &__With(&self.optional_fixed64))?;
        }
        if !wkt::internal::is_default(&self.optional_sfixed32) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalSfixed32", &__With(&self.optional_sfixed32))?;
        }
        if !wkt::internal::is_default(&self.optional_sfixed64) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalSfixed64", &__With(&self.optional_sfixed64))?;
        }
        if !wkt::internal::is_default(&self.optional_float) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalFloat", &__With(&self.optional_float))?;
        }
        if !wkt::internal::is_default(&self.optional_double) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalDouble", &__With(&self.optional_double))?;
        }
        if !wkt::internal::is_default(&self.optional_bool) {
            state.serialize_entry("optionalBool", &self.optional_bool)?;
        }
        if !self.optional_string.is_empty() {
            state.serialize_entry("optionalString", &self.optional_string)?;
        }
        if !self.optional_bytes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("optionalBytes", &__With(&self.optional_bytes))?;
        }
        if self.optional_nested_message.is_some() {
            state.serialize_entry("optionalNestedMessage", &self.optional_nested_message)?;
        }
        if self.optional_foreign_message.is_some() {
            state.serialize_entry("optionalForeignMessage", &self.optional_foreign_message)?;
        }
        if !wkt::internal::is_default(&self.optional_nested_enum) {
            state.serialize_entry("optionalNestedEnum", &self.optional_nested_enum)?;
        }
        if !wkt::internal::is_default(&self.optional_foreign_enum) {
            state.serialize_entry("optionalForeignEnum", &self.optional_foreign_enum)?;
        }
        if !wkt::internal::is_default(&self.optional_aliased_enum) {
            state.serialize_entry("optionalAliasedEnum", &self.optional_aliased_enum)?;
        }
        if !self.optional_string_piece.is_empty() {
            state.serialize_entry("optionalStringPiece", &self.optional_string_piece)?;
        }
        if !self.optional_cord.is_empty() {
            state.serialize_entry("optionalCord", &self.optional_cord)?;
        }
        if self.recursive_message.is_some() {
            state.serialize_entry("recursiveMessage", &self.recursive_message)?;
        }
        if !self.repeated_int32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedInt32", &__With(&self.repeated_int32))?;
        }
        if !self.repeated_int64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedInt64", &__With(&self.repeated_int64))?;
        }
        if !self.repeated_uint32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedUint32", &__With(&self.repeated_uint32))?;
        }
        if !self.repeated_uint64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedUint64", &__With(&self.repeated_uint64))?;
        }
        if !self.repeated_sint32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedSint32", &__With(&self.repeated_sint32))?;
        }
        if !self.repeated_sint64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedSint64", &__With(&self.repeated_sint64))?;
        }
        if !self.repeated_fixed32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedFixed32", &__With(&self.repeated_fixed32))?;
        }
        if !self.repeated_fixed64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedFixed64", &__With(&self.repeated_fixed64))?;
        }
        if !self.repeated_sfixed32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedSfixed32", &__With(&self.repeated_sfixed32))?;
        }
        if !self.repeated_sfixed64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedSfixed64", &__With(&self.repeated_sfixed64))?;
        }
        if !self.repeated_float.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedFloat", &__With(&self.repeated_float))?;
        }
        if !self.repeated_double.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedDouble", &__With(&self.repeated_double))?;
        }
        if !self.repeated_bool.is_empty() {
            state.serialize_entry("repeatedBool", &self.repeated_bool)?;
        }
        if !self.repeated_string.is_empty() {
            state.serialize_entry("repeatedString", &self.repeated_string)?;
        }
        if !self.repeated_bytes.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<serde_with::base64::Base64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("repeatedBytes", &__With(&self.repeated_bytes))?;
        }
        if !self.repeated_nested_message.is_empty() {
            state.serialize_entry("repeatedNestedMessage", &self.repeated_nested_message)?;
        }
        if !self.repeated_foreign_message.is_empty() {
            state.serialize_entry("repeatedForeignMessage", &self.repeated_foreign_message)?;
        }
        if !self.repeated_nested_enum.is_empty() {
            state.serialize_entry("repeatedNestedEnum", &self.repeated_nested_enum)?;
        }
        if !self.repeated_foreign_enum.is_empty() {
            state.serialize_entry("repeatedForeignEnum", &self.repeated_foreign_enum)?;
        }
        if !self.repeated_string_piece.is_empty() {
            state.serialize_entry("repeatedStringPiece", &self.repeated_string_piece)?;
        }
        if !self.repeated_cord.is_empty() {
            state.serialize_entry("repeatedCord", &self.repeated_cord)?;
        }
        if !self.packed_int32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedInt32", &__With(&self.packed_int32))?;
        }
        if !self.packed_int64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedInt64", &__With(&self.packed_int64))?;
        }
        if !self.packed_uint32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedUint32", &__With(&self.packed_uint32))?;
        }
        if !self.packed_uint64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedUint64", &__With(&self.packed_uint64))?;
        }
        if !self.packed_sint32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedSint32", &__With(&self.packed_sint32))?;
        }
        if !self.packed_sint64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedSint64", &__With(&self.packed_sint64))?;
        }
        if !self.packed_fixed32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedFixed32", &__With(&self.packed_fixed32))?;
        }
        if !self.packed_fixed64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedFixed64", &__With(&self.packed_fixed64))?;
        }
        if !self.packed_sfixed32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedSfixed32", &__With(&self.packed_sfixed32))?;
        }
        if !self.packed_sfixed64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedSfixed64", &__With(&self.packed_sfixed64))?;
        }
        if !self.packed_float.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedFloat", &__With(&self.packed_float))?;
        }
        if !self.packed_double.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("packedDouble", &__With(&self.packed_double))?;
        }
        if !self.packed_bool.is_empty() {
            state.serialize_entry("packedBool", &self.packed_bool)?;
        }
        if !self.packed_nested_enum.is_empty() {
            state.serialize_entry("packedNestedEnum", &self.packed_nested_enum)?;
        }
        if !self.unpacked_int32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedInt32", &__With(&self.unpacked_int32))?;
        }
        if !self.unpacked_int64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedInt64", &__With(&self.unpacked_int64))?;
        }
        if !self.unpacked_uint32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedUint32", &__With(&self.unpacked_uint32))?;
        }
        if !self.unpacked_uint64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedUint64", &__With(&self.unpacked_uint64))?;
        }
        if !self.unpacked_sint32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedSint32", &__With(&self.unpacked_sint32))?;
        }
        if !self.unpacked_sint64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedSint64", &__With(&self.unpacked_sint64))?;
        }
        if !self.unpacked_fixed32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedFixed32", &__With(&self.unpacked_fixed32))?;
        }
        if !self.unpacked_fixed64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedFixed64", &__With(&self.unpacked_fixed64))?;
        }
        if !self.unpacked_sfixed32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedSfixed32", &__With(&self.unpacked_sfixed32))?;
        }
        if !self.unpacked_sfixed64.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedSfixed64", &__With(&self.unpacked_sfixed64))?;
        }
        if !self.unpacked_float.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedFloat", &__With(&self.unpacked_float))?;
        }
        if !self.unpacked_double.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unpackedDouble", &__With(&self.unpacked_double))?;
        }
        if !self.unpacked_bool.is_empty() {
            state.serialize_entry("unpackedBool", &self.unpacked_bool)?;
        }
        if !self.unpacked_nested_enum.is_empty() {
            state.serialize_entry("unpackedNestedEnum", &self.unpacked_nested_enum)?;
        }
        if !self.map_int32_int32.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i32, i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I32, wkt::internal::I32>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapInt32Int32", &__With(&self.map_int32_int32))?;
        }
        if !self.map_int64_int64.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i64, i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I64, wkt::internal::I64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapInt64Int64", &__With(&self.map_int64_int64))?;
        }
        if !self.map_uint32_uint32.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<u32, u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::U32, wkt::internal::U32>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapUint32Uint32", &__With(&self.map_uint32_uint32))?;
        }
        if !self.map_uint64_uint64.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<u64, u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::U64, wkt::internal::U64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapUint64Uint64", &__With(&self.map_uint64_uint64))?;
        }
        if !self.map_sint32_sint32.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i32, i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I32, wkt::internal::I32>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapSint32Sint32", &__With(&self.map_sint32_sint32))?;
        }
        if !self.map_sint64_sint64.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i64, i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I64, wkt::internal::I64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapSint64Sint64", &__With(&self.map_sint64_sint64))?;
        }
        if !self.map_fixed32_fixed32.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<u32, u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::U32, wkt::internal::U32>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapFixed32Fixed32", &__With(&self.map_fixed32_fixed32))?;
        }
        if !self.map_fixed64_fixed64.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<u64, u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::U64, wkt::internal::U64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapFixed64Fixed64", &__With(&self.map_fixed64_fixed64))?;
        }
        if !self.map_sfixed32_sfixed32.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i32, i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I32, wkt::internal::I32>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapSfixed32Sfixed32", &__With(&self.map_sfixed32_sfixed32))?;
        }
        if !self.map_sfixed64_sfixed64.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i64, i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I64, wkt::internal::I64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapSfixed64Sfixed64", &__With(&self.map_sfixed64_sfixed64))?;
        }
        if !self.map_int32_float.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i32, f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I32, wkt::internal::F32>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapInt32Float", &__With(&self.map_int32_float))?;
        }
        if !self.map_int32_double.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i32, f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<wkt::internal::I32, wkt::internal::F64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapInt32Double", &__With(&self.map_int32_double))?;
        }
        if !self.map_bool_bool.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<bool, bool>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<serde_with::DisplayFromStr, serde_with::Same>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapBoolBool", &__With(&self.map_bool_bool))?;
        }
        if !self.map_string_string.is_empty() {
            state.serialize_entry("mapStringString", &self.map_string_string)?;
        }
        if !self.map_string_bytes.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, ::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::collections::HashMap<serde_with::Same, serde_with::base64::Base64>,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mapStringBytes", &__With(&self.map_string_bytes))?;
        }
        if !self.map_string_nested_message.is_empty() {
            state.serialize_entry("mapStringNestedMessage", &self.map_string_nested_message)?;
        }
        if !self.map_string_foreign_message.is_empty() {
            state.serialize_entry("mapStringForeignMessage", &self.map_string_foreign_message)?;
        }
        if !self.map_string_nested_enum.is_empty() {
            state.serialize_entry("mapStringNestedEnum", &self.map_string_nested_enum)?;
        }
        if !self.map_string_foreign_enum.is_empty() {
            state.serialize_entry("mapStringForeignEnum", &self.map_string_foreign_enum)?;
        }
        if let Some(value) = self.oneof_uint32() {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oneofUint32", &__With(value))?;
        }
        if let Some(value) = self.oneof_nested_message() {
            state.serialize_entry("oneofNestedMessage", value)?;
        }
        if let Some(value) = self.oneof_string() {
            state.serialize_entry("oneofString", value)?;
        }
        if let Some(value) = self.oneof_bytes() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oneofBytes", &__With(value))?;
        }
        if let Some(value) = self.oneof_bool() {
            state.serialize_entry("oneofBool", value)?;
        }
        if let Some(value) = self.oneof_uint64() {
            struct __With<'a>(&'a u64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oneofUint64", &__With(value))?;
        }
        if let Some(value) = self.oneof_float() {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oneofFloat", &__With(value))?;
        }
        if let Some(value) = self.oneof_double() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oneofDouble", &__With(value))?;
        }
        if let Some(value) = self.oneof_enum() {
            state.serialize_entry("oneofEnum", value)?;
        }
        if let Some(value) = self.oneof_null_value() {
            state.serialize_entry("oneofNullValue", value)?;
        }
        if self.optional_bool_wrapper.is_some() {
            state.serialize_entry("optionalBoolWrapper", &self.optional_bool_wrapper)?;
        }
        if self.optional_int32_wrapper.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "optionalInt32Wrapper",
                &__With(&self.optional_int32_wrapper),
            )?;
        }
        if self.optional_int64_wrapper.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "optionalInt64Wrapper",
                &__With(&self.optional_int64_wrapper),
            )?;
        }
        if self.optional_uint32_wrapper.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::UInt32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "optionalUint32Wrapper",
                &__With(&self.optional_uint32_wrapper),
            )?;
        }
        if self.optional_uint64_wrapper.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::UInt64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "optionalUint64Wrapper",
                &__With(&self.optional_uint64_wrapper),
            )?;
        }
        if self.optional_float_wrapper.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::FloatValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "optionalFloatWrapper",
                &__With(&self.optional_float_wrapper),
            )?;
        }
        if self.optional_double_wrapper.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "optionalDoubleWrapper",
                &__With(&self.optional_double_wrapper),
            )?;
        }
        if self.optional_string_wrapper.is_some() {
            state.serialize_entry("optionalStringWrapper", &self.optional_string_wrapper)?;
        }
        if self.optional_bytes_wrapper.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::BytesValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<serde_with::base64::Base64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "optionalBytesWrapper",
                &__With(&self.optional_bytes_wrapper),
            )?;
        }
        if !self.repeated_bool_wrapper.is_empty() {
            state.serialize_entry("repeatedBoolWrapper", &self.repeated_bool_wrapper)?;
        }
        if !self.repeated_int32_wrapper.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "repeatedInt32Wrapper",
                &__With(&self.repeated_int32_wrapper),
            )?;
        }
        if !self.repeated_int64_wrapper.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "repeatedInt64Wrapper",
                &__With(&self.repeated_int64_wrapper),
            )?;
        }
        if !self.repeated_uint32_wrapper.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<wkt::UInt32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "repeatedUint32Wrapper",
                &__With(&self.repeated_uint32_wrapper),
            )?;
        }
        if !self.repeated_uint64_wrapper.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<wkt::UInt64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "repeatedUint64Wrapper",
                &__With(&self.repeated_uint64_wrapper),
            )?;
        }
        if !self.repeated_float_wrapper.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<wkt::FloatValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "repeatedFloatWrapper",
                &__With(&self.repeated_float_wrapper),
            )?;
        }
        if !self.repeated_double_wrapper.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<wkt::DoubleValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "repeatedDoubleWrapper",
                &__With(&self.repeated_double_wrapper),
            )?;
        }
        if !self.repeated_string_wrapper.is_empty() {
            state.serialize_entry("repeatedStringWrapper", &self.repeated_string_wrapper)?;
        }
        if !self.repeated_bytes_wrapper.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<wkt::BytesValue>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<serde_with::base64::Base64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "repeatedBytesWrapper",
                &__With(&self.repeated_bytes_wrapper),
            )?;
        }
        if self.optional_duration.is_some() {
            state.serialize_entry("optionalDuration", &self.optional_duration)?;
        }
        if self.optional_timestamp.is_some() {
            state.serialize_entry("optionalTimestamp", &self.optional_timestamp)?;
        }
        if self.optional_field_mask.is_some() {
            state.serialize_entry("optionalFieldMask", &self.optional_field_mask)?;
        }
        if self.optional_struct.is_some() {
            state.serialize_entry("optionalStruct", &self.optional_struct)?;
        }
        if self.optional_any.is_some() {
            state.serialize_entry("optionalAny", &self.optional_any)?;
        }
        if self.optional_value.is_some() {
            state.serialize_entry("optionalValue", &self.optional_value)?;
        }
        if !wkt::internal::is_default(&self.optional_null_value) {
            state.serialize_entry("optionalNullValue", &self.optional_null_value)?;
        }
        if !self.repeated_duration.is_empty() {
            state.serialize_entry("repeatedDuration", &self.repeated_duration)?;
        }
        if !self.repeated_timestamp.is_empty() {
            state.serialize_entry("repeatedTimestamp", &self.repeated_timestamp)?;
        }
        if !self.repeated_fieldmask.is_empty() {
            state.serialize_entry("repeatedFieldmask", &self.repeated_fieldmask)?;
        }
        if !self.repeated_struct.is_empty() {
            state.serialize_entry("repeatedStruct", &self.repeated_struct)?;
        }
        if !self.repeated_any.is_empty() {
            state.serialize_entry("repeatedAny", &self.repeated_any)?;
        }
        if !self.repeated_value.is_empty() {
            state.serialize_entry("repeatedValue", &self.repeated_value)?;
        }
        if !self.repeated_list_value.is_empty() {
            state.serialize_entry("repeatedListValue", &self.repeated_list_value)?;
        }
        if !wkt::internal::is_default(&self.fieldname1) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldname1", &__With(&self.fieldname1))?;
        }
        if !wkt::internal::is_default(&self.field_name2) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldName2", &__With(&self.field_name2))?;
        }
        if !wkt::internal::is_default(&self._field_name3) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FieldName3", &__With(&self._field_name3))?;
        }
        if !wkt::internal::is_default(&self.field__name4_) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldName4", &__With(&self.field__name4_))?;
        }
        if !wkt::internal::is_default(&self.field0name5) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("field0name5", &__With(&self.field0name5))?;
        }
        if !wkt::internal::is_default(&self.field_0_name6) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("field0Name6", &__With(&self.field_0_name6))?;
        }
        if !wkt::internal::is_default(&self.field_name_7) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldName7", &__With(&self.field_name_7))?;
        }
        if !wkt::internal::is_default(&self.field_name_8) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FieldName8", &__With(&self.field_name_8))?;
        }
        if !wkt::internal::is_default(&self.field_name_9) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldName9", &__With(&self.field_name_9))?;
        }
        if !wkt::internal::is_default(&self.field_name_10) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FieldName10", &__With(&self.field_name_10))?;
        }
        if !wkt::internal::is_default(&self.field_name_11) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FIELDNAME11", &__With(&self.field_name_11))?;
        }
        if !wkt::internal::is_default(&self.field_name_12) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FIELDName12", &__With(&self.field_name_12))?;
        }
        if !wkt::internal::is_default(&self.__field_name13) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FieldName13", &__With(&self.__field_name13))?;
        }
        if !wkt::internal::is_default(&self.__field_name_14) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FieldName14", &__With(&self.__field_name_14))?;
        }
        if !wkt::internal::is_default(&self.field__name15) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldName15", &__With(&self.field__name15))?;
        }
        if !wkt::internal::is_default(&self.field__name_16) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldName16", &__With(&self.field__name_16))?;
        }
        if !wkt::internal::is_default(&self.field_name17__) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fieldName17", &__With(&self.field_name17__))?;
        }
        if !wkt::internal::is_default(&self.field_name_18__) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("FieldName18", &__With(&self.field_name_18__))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TestAllTypesProto3].
pub mod test_all_types_proto_3 {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NestedMessage {
        pub a: i32,

        pub corecursive:
            std::option::Option<std::boxed::Box<crate::generated::test_protos::TestAllTypesProto3>>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NestedMessage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [a][crate::generated::test_protos::test_all_types_proto_3::NestedMessage::a].
        pub fn set_a<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.a = v.into();
            self
        }

        /// Sets the value of [corecursive][crate::generated::test_protos::test_all_types_proto_3::NestedMessage::corecursive].
        pub fn set_corecursive<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::generated::test_protos::TestAllTypesProto3>,
        {
            self.corecursive = std::option::Option::Some(std::boxed::Box::new(v.into()));
            self
        }

        /// Sets or clears the value of [corecursive][crate::generated::test_protos::test_all_types_proto_3::NestedMessage::corecursive].
        pub fn set_or_clear_corecursive<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::generated::test_protos::TestAllTypesProto3>,
        {
            self.corecursive = v.map(|x| std::boxed::Box::new(x.into()));
            self
        }
    }

    impl wkt::message::Message for NestedMessage {
        fn typename() -> &'static str {
            "type.googleapis.com/protobuf_test_messages.proto3.TestAllTypesProto3.NestedMessage"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NestedMessage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __a,
                __corecursive,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NestedMessage")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            match value {
                                "a" => Ok(__FieldTag::__a),
                                "corecursive" => Ok(__FieldTag::__corecursive),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NestedMessage;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NestedMessage")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__a => {
                                if !fields.insert(__FieldTag::__a) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for a",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.a = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__corecursive => {
                                if !fields.insert(__FieldTag::__corecursive) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for corecursive",
                                    ));
                                }
                                result.corecursive = map.next_value::<std::option::Option<
                                    std::boxed::Box<
                                        crate::generated::test_protos::TestAllTypesProto3,
                                    >,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NestedMessage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            let mut state = serializer.serialize_map(None)?;
            if !wkt::internal::is_default(&self.a) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("a", &__With(&self.a))?;
            }
            if self.corecursive.is_some() {
                state.serialize_entry("corecursive", &self.corecursive)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NestedEnum {
        Foo,
        Bar,
        Baz,
        Neg,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NestedEnum::value] or
        /// [NestedEnum::name].
        UnknownValue(nested_enum::UnknownValue),
    }

    #[doc(hidden)]
    pub mod nested_enum {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NestedEnum {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Foo => std::option::Option::Some(0),
                Self::Bar => std::option::Option::Some(1),
                Self::Baz => std::option::Option::Some(2),
                Self::Neg => std::option::Option::Some(-1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Foo => std::option::Option::Some("FOO"),
                Self::Bar => std::option::Option::Some("BAR"),
                Self::Baz => std::option::Option::Some("BAZ"),
                Self::Neg => std::option::Option::Some("NEG"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NestedEnum {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NestedEnum {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NestedEnum {
        fn from(value: i32) -> Self {
            match value {
                -1 => Self::Neg,
                0 => Self::Foo,
                1 => Self::Bar,
                2 => Self::Baz,
                _ => Self::UnknownValue(nested_enum::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NestedEnum {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FOO" => Self::Foo,
                "BAR" => Self::Bar,
                "BAZ" => Self::Baz,
                "NEG" => Self::Neg,
                _ => Self::UnknownValue(nested_enum::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NestedEnum {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Foo => serializer.serialize_i32(0),
                Self::Bar => serializer.serialize_i32(1),
                Self::Baz => serializer.serialize_i32(2),
                Self::Neg => serializer.serialize_i32(-1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NestedEnum {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NestedEnum>::new(
                ".protobuf_test_messages.proto3.TestAllTypesProto3.NestedEnum",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AliasedEnum {
        AliasFoo,
        AliasBar,
        AliasBaz,
        Moo,
        BAz,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AliasedEnum::value] or
        /// [AliasedEnum::name].
        UnknownValue(aliased_enum::UnknownValue),
    }

    #[doc(hidden)]
    pub mod aliased_enum {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AliasedEnum {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::AliasFoo => std::option::Option::Some(0),
                Self::AliasBar => std::option::Option::Some(1),
                Self::AliasBaz => std::option::Option::Some(2),
                Self::Moo => std::option::Option::Some(2),
                Self::BAz => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::AliasFoo => std::option::Option::Some("ALIAS_FOO"),
                Self::AliasBar => std::option::Option::Some("ALIAS_BAR"),
                Self::AliasBaz => std::option::Option::Some("ALIAS_BAZ"),
                Self::Moo => std::option::Option::Some("MOO"),
                Self::BAz => std::option::Option::Some("bAz"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AliasedEnum {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AliasedEnum {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AliasedEnum {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::AliasFoo,
                1 => Self::AliasBar,
                2 => Self::Moo,
                _ => Self::UnknownValue(aliased_enum::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AliasedEnum {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ALIAS_FOO" => Self::AliasFoo,
                "ALIAS_BAR" => Self::AliasBar,
                "ALIAS_BAZ" => Self::AliasBaz,
                "MOO" => Self::Moo,
                "moo" => Self::Moo,
                "bAz" => Self::BAz,
                _ => Self::UnknownValue(aliased_enum::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AliasedEnum {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::AliasFoo => serializer.serialize_i32(0),
                Self::AliasBar => serializer.serialize_i32(1),
                Self::AliasBaz => serializer.serialize_i32(2),
                Self::Moo => serializer.serialize_i32(2),
                Self::BAz => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AliasedEnum {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AliasedEnum>::new(
                ".protobuf_test_messages.proto3.TestAllTypesProto3.AliasedEnum",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OneofField {
        OneofUint32(u32),
        OneofNestedMessage(
            std::boxed::Box<crate::generated::test_protos::test_all_types_proto_3::NestedMessage>,
        ),
        OneofString(std::string::String),
        OneofBytes(::bytes::Bytes),
        OneofBool(bool),
        OneofUint64(u64),
        OneofFloat(f32),
        OneofDouble(f64),
        OneofEnum(crate::generated::test_protos::test_all_types_proto_3::NestedEnum),
        OneofNullValue(wkt::NullValue),
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ForeignMessage {
    pub c: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ForeignMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [c][crate::generated::test_protos::ForeignMessage::c].
    pub fn set_c<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.c = v.into();
        self
    }
}

impl wkt::message::Message for ForeignMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/protobuf_test_messages.proto3.ForeignMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ForeignMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __c,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForeignMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        match value {
                            "c" => Ok(__FieldTag::__c),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ForeignMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForeignMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__c => {
                            if !fields.insert(__FieldTag::__c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for c",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.c = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ForeignMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(None)?;
        if !wkt::internal::is_default(&self.c) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("c", &__With(&self.c))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NullHypothesisProto3 {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NullHypothesisProto3 {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for NullHypothesisProto3 {
    fn typename() -> &'static str {
        "type.googleapis.com/protobuf_test_messages.proto3.NullHypothesisProto3"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NullHypothesisProto3 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NullHypothesisProto3")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NullHypothesisProto3;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NullHypothesisProto3")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NullHypothesisProto3 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnumOnlyProto3 {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnumOnlyProto3 {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for EnumOnlyProto3 {
    fn typename() -> &'static str {
        "type.googleapis.com/protobuf_test_messages.proto3.EnumOnlyProto3"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnumOnlyProto3 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnumOnlyProto3")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnumOnlyProto3;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnumOnlyProto3")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnumOnlyProto3 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EnumOnlyProto3].
pub mod enum_only_proto_3 {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Bool {
        KFalse,
        KTrue,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Bool::value] or
        /// [Bool::name].
        UnknownValue(bool::UnknownValue),
    }

    #[doc(hidden)]
    pub mod bool {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Bool {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::KFalse => std::option::Option::Some(0),
                Self::KTrue => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::KFalse => std::option::Option::Some("kFalse"),
                Self::KTrue => std::option::Option::Some("kTrue"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Bool {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Bool {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Bool {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::KFalse,
                1 => Self::KTrue,
                _ => Self::UnknownValue(bool::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Bool {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "kFalse" => Self::KFalse,
                "kTrue" => Self::KTrue,
                _ => Self::UnknownValue(bool::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Bool {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::KFalse => serializer.serialize_i32(0),
                Self::KTrue => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Bool {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Bool>::new(
                ".protobuf_test_messages.proto3.EnumOnlyProto3.Bool",
            ))
        }
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ForeignEnum {
    ForeignFoo,
    ForeignBar,
    ForeignBaz,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ForeignEnum::value] or
    /// [ForeignEnum::name].
    UnknownValue(foreign_enum::UnknownValue),
}

#[doc(hidden)]
pub mod foreign_enum {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ForeignEnum {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::ForeignFoo => std::option::Option::Some(0),
            Self::ForeignBar => std::option::Option::Some(1),
            Self::ForeignBaz => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::ForeignFoo => std::option::Option::Some("FOREIGN_FOO"),
            Self::ForeignBar => std::option::Option::Some("FOREIGN_BAR"),
            Self::ForeignBaz => std::option::Option::Some("FOREIGN_BAZ"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ForeignEnum {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ForeignEnum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ForeignEnum {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::ForeignFoo,
            1 => Self::ForeignBar,
            2 => Self::ForeignBaz,
            _ => Self::UnknownValue(foreign_enum::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ForeignEnum {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FOREIGN_FOO" => Self::ForeignFoo,
            "FOREIGN_BAR" => Self::ForeignBar,
            "FOREIGN_BAZ" => Self::ForeignBaz,
            _ => Self::UnknownValue(foreign_enum::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ForeignEnum {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::ForeignFoo => serializer.serialize_i32(0),
            Self::ForeignBar => serializer.serialize_i32(1),
            Self::ForeignBaz => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ForeignEnum {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ForeignEnum>::new(
            ".protobuf_test_messages.proto3.ForeignEnum",
        ))
    }
}
