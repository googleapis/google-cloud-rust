// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]

/// Meant to encapsulate all types of tests: successes, skips, failures, etc.
/// Therefore, this may or may not have a failure message. Failure messages
/// may be truncated for our failure lists.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TestStatus {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub failure_message: std::string::String,

    /// What an actual test name matched to in a failure list. Can be wildcarded or
    /// an exact match without wildcards.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub matched_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TestStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::generated::gapic::model::TestStatus::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [failure_message][crate::generated::gapic::model::TestStatus::failure_message].
    pub fn set_failure_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_message = v.into();
        self
    }

    /// Sets the value of [matched_name][crate::generated::gapic::model::TestStatus::matched_name].
    pub fn set_matched_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.matched_name = v.into();
        self
    }
}

impl wkt::message::Message for TestStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/conformance.TestStatus"
    }
}

/// The conformance runner will request a list of failures as the first request.
/// This will be known by message_type == "conformance.FailureSet", a conformance
/// test should return a serialized FailureSet in protobuf_payload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FailureSet {
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub test: std::vec::Vec<crate::generated::gapic::model::TestStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FailureSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [test][crate::generated::gapic::model::FailureSet::test].
    pub fn set_test<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::generated::gapic::model::TestStatus>,
    {
        use std::iter::Iterator;
        self.test = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FailureSet {
    fn typename() -> &'static str {
        "type.googleapis.com/conformance.FailureSet"
    }
}

/// Represents a single test case's input.  The testee should:
///
/// 1. parse this proto (which should always succeed)
/// 1. parse the protobuf or JSON payload in "payload" (which may fail)
/// 1. if the parse succeeded, serialize the message in the requested format.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConformanceRequest {
    /// Which format should the testee serialize its message to?
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub requested_output_format: crate::generated::gapic::model::WireFormat,

    /// The full name for the test message to use; for the moment, either:
    /// protobuf_test_messages.proto3.TestAllTypesProto3 or
    /// protobuf_test_messages.proto2.TestAllTypesProto2 or
    /// protobuf_test_messages.editions.proto2.TestAllTypesProto2 or
    /// protobuf_test_messages.editions.proto3.TestAllTypesProto3 or
    /// protobuf_test_messages.editions.TestAllTypesEdition2023.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub message_type: std::string::String,

    /// Each test is given a specific test category. Some category may need
    /// specific support in testee programs. Refer to the definition of
    /// TestCategory for more information.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub test_category: crate::generated::gapic::model::TestCategory,

    /// Specify details for how to encode jspb.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub jspb_encoding_options:
        std::option::Option<crate::generated::gapic::model::JspbEncodingConfig>,

    /// This can be used in json and text format. If true, testee should print
    /// unknown fields instead of ignore. This feature is optional.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub print_unknown_fields: bool,

    /// The payload (whether protobuf of JSON) is always for a
    /// protobuf_test_messages.proto3.TestAllTypes proto (as defined in
    /// src/google/protobuf/proto3_test_messages.proto).
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub payload: std::option::Option<crate::generated::gapic::model::conformance_request::Payload>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConformanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requested_output_format][crate::generated::gapic::model::ConformanceRequest::requested_output_format].
    pub fn set_requested_output_format<
        T: std::convert::Into<crate::generated::gapic::model::WireFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_output_format = v.into();
        self
    }

    /// Sets the value of [message_type][crate::generated::gapic::model::ConformanceRequest::message_type].
    pub fn set_message_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message_type = v.into();
        self
    }

    /// Sets the value of [test_category][crate::generated::gapic::model::ConformanceRequest::test_category].
    pub fn set_test_category<
        T: std::convert::Into<crate::generated::gapic::model::TestCategory>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.test_category = v.into();
        self
    }

    /// Sets the value of [jspb_encoding_options][crate::generated::gapic::model::ConformanceRequest::jspb_encoding_options].
    pub fn set_jspb_encoding_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::generated::gapic::model::JspbEncodingConfig>,
    {
        self.jspb_encoding_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [jspb_encoding_options][crate::generated::gapic::model::ConformanceRequest::jspb_encoding_options].
    pub fn set_or_clear_jspb_encoding_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::generated::gapic::model::JspbEncodingConfig>,
    {
        self.jspb_encoding_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [print_unknown_fields][crate::generated::gapic::model::ConformanceRequest::print_unknown_fields].
    pub fn set_print_unknown_fields<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.print_unknown_fields = v.into();
        self
    }

    /// Sets the value of [payload][crate::generated::gapic::model::ConformanceRequest::payload].
    ///
    /// Note that all the setters affecting `payload` are mutually
    /// exclusive.
    pub fn set_payload<
        T: std::convert::Into<
                std::option::Option<crate::generated::gapic::model::conformance_request::Payload>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }

    /// The value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// if it holds a `ProtobufPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn protobuf_payload(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_request::Payload::ProtobufPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// to hold a `ProtobufPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_protobuf_payload<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.payload = std::option::Option::Some(
            crate::generated::gapic::model::conformance_request::Payload::ProtobufPayload(v.into()),
        );
        self
    }

    /// The value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// if it holds a `JsonPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_request::Payload::JsonPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// to hold a `JsonPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_json_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload = std::option::Option::Some(
            crate::generated::gapic::model::conformance_request::Payload::JsonPayload(v.into()),
        );
        self
    }

    /// The value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// if it holds a `JspbPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn jspb_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_request::Payload::JspbPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// to hold a `JspbPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_jspb_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload = std::option::Option::Some(
            crate::generated::gapic::model::conformance_request::Payload::JspbPayload(v.into()),
        );
        self
    }

    /// The value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// if it holds a `TextPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_request::Payload::TextPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// to hold a `TextPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_text_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload = std::option::Option::Some(
            crate::generated::gapic::model::conformance_request::Payload::TextPayload(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConformanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/conformance.ConformanceRequest"
    }
}

/// Defines additional types related to [ConformanceRequest].
pub mod conformance_request {
    #[allow(unused_imports)]
    use super::*;

    /// The payload (whether protobuf of JSON) is always for a
    /// protobuf_test_messages.proto3.TestAllTypes proto (as defined in
    /// src/google/protobuf/proto3_test_messages.proto).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Payload {
        ProtobufPayload(
            #[serde_as(as = "serde_with::DefaultOnNull<serde_with::base64::Base64>")]
            ::bytes::Bytes,
        ),
        JsonPayload(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// Only used inside Google.  Opensource testees just skip it.
        JspbPayload(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        TextPayload(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
    }

    impl Payload {
        /// Initializes the enum to the [ProtobufPayload](Self::ProtobufPayload) branch.
        pub fn from_protobuf_payload(value: impl std::convert::Into<::bytes::Bytes>) -> Self {
            Self::ProtobufPayload(value.into())
        }
        /// Initializes the enum to the [JsonPayload](Self::JsonPayload) branch.
        pub fn from_json_payload(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::JsonPayload(value.into())
        }
        /// Initializes the enum to the [JspbPayload](Self::JspbPayload) branch.
        pub fn from_jspb_payload(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::JspbPayload(value.into())
        }
        /// Initializes the enum to the [TextPayload](Self::TextPayload) branch.
        pub fn from_text_payload(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::TextPayload(value.into())
        }
    }
}

/// Represents a single test case's output.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConformanceResponse {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::generated::gapic::model::conformance_response::Result>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConformanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<
                std::option::Option<crate::generated::gapic::model::conformance_response::Result>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `ParseError`, `None` if the field is not set or
    /// holds a different branch.
    pub fn parse_error(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::ParseError(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `ParseError`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_parse_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::ParseError(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `SerializeError`, `None` if the field is not set or
    /// holds a different branch.
    pub fn serialize_error(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::SerializeError(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `SerializeError`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_serialize_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::SerializeError(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `TimeoutError`, `None` if the field is not set or
    /// holds a different branch.
    pub fn timeout_error(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::TimeoutError(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `TimeoutError`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_timeout_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::TimeoutError(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `RuntimeError`, `None` if the field is not set or
    /// holds a different branch.
    pub fn runtime_error(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::RuntimeError(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `RuntimeError`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_runtime_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::RuntimeError(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `ProtobufPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn protobuf_payload(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::ProtobufPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `ProtobufPayload`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_protobuf_payload<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::ProtobufPayload(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `JsonPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::JsonPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `JsonPayload`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_json_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::JsonPayload(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `Skipped`, `None` if the field is not set or
    /// holds a different branch.
    pub fn skipped(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::Skipped(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `Skipped`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_skipped<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::Skipped(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `JspbPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn jspb_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::JspbPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `JspbPayload`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_jspb_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::JspbPayload(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `TextPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::TextPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `TextPayload`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_text_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::TextPayload(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConformanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/conformance.ConformanceResponse"
    }
}

/// Defines additional types related to [ConformanceResponse].
pub mod conformance_response {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Result {
        /// This string should be set to indicate parsing failed.  The string can
        /// provide more information about the parse error if it is available.
        ///
        /// Setting this string does not necessarily mean the testee failed the
        /// test.  Some of the test cases are intentionally invalid input.
        ParseError(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// If the input was successfully parsed but errors occurred when
        /// serializing it to the requested output format, set the error message in
        /// this field.
        SerializeError(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// This should be set if the test program timed out.  The string should
        /// provide more information about what the child process was doing when it
        /// was killed.
        TimeoutError(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// This should be set if some other error occurred.  This will always
        /// indicate that the test failed.  The string can provide more information
        /// about the failure.
        RuntimeError(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// If the input was successfully parsed and the requested output was
        /// protobuf, serialize it to protobuf and set it in this field.
        ProtobufPayload(
            #[serde_as(as = "serde_with::DefaultOnNull<serde_with::base64::Base64>")]
            ::bytes::Bytes,
        ),
        /// If the input was successfully parsed and the requested output was JSON,
        /// serialize to JSON and set it in this field.
        JsonPayload(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// For when the testee skipped the test, likely because a certain feature
        /// wasn't supported, like JSON input/output.
        Skipped(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// If the input was successfully parsed and the requested output was JSPB,
        /// serialize to JSPB and set it in this field. JSPB is only used inside
        /// Google. Opensource testees can just skip it.
        JspbPayload(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
        /// If the input was successfully parsed and the requested output was
        /// TEXT_FORMAT, serialize to TEXT_FORMAT and set it in this field.
        TextPayload(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
    }

    impl Result {
        /// Initializes the enum to the [ParseError](Self::ParseError) branch.
        pub fn from_parse_error(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::ParseError(value.into())
        }
        /// Initializes the enum to the [SerializeError](Self::SerializeError) branch.
        pub fn from_serialize_error(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::SerializeError(value.into())
        }
        /// Initializes the enum to the [TimeoutError](Self::TimeoutError) branch.
        pub fn from_timeout_error(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::TimeoutError(value.into())
        }
        /// Initializes the enum to the [RuntimeError](Self::RuntimeError) branch.
        pub fn from_runtime_error(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::RuntimeError(value.into())
        }
        /// Initializes the enum to the [ProtobufPayload](Self::ProtobufPayload) branch.
        pub fn from_protobuf_payload(value: impl std::convert::Into<::bytes::Bytes>) -> Self {
            Self::ProtobufPayload(value.into())
        }
        /// Initializes the enum to the [JsonPayload](Self::JsonPayload) branch.
        pub fn from_json_payload(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::JsonPayload(value.into())
        }
        /// Initializes the enum to the [Skipped](Self::Skipped) branch.
        pub fn from_skipped(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::Skipped(value.into())
        }
        /// Initializes the enum to the [JspbPayload](Self::JspbPayload) branch.
        pub fn from_jspb_payload(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::JspbPayload(value.into())
        }
        /// Initializes the enum to the [TextPayload](Self::TextPayload) branch.
        pub fn from_text_payload(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::TextPayload(value.into())
        }
    }
}

/// Encoding options for jspb format.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JspbEncodingConfig {
    /// Encode the value field of Any as jspb array if true, otherwise binary.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub use_jspb_array_any_format: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JspbEncodingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_jspb_array_any_format][crate::generated::gapic::model::JspbEncodingConfig::use_jspb_array_any_format].
    pub fn set_use_jspb_array_any_format<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_jspb_array_any_format = v.into();
        self
    }
}

impl wkt::message::Message for JspbEncodingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/conformance.JspbEncodingConfig"
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum WireFormat {
    Unspecified,
    Protobuf,
    Json,
    Jspb,
    TextFormat,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [WireFormat::value] or
    /// [WireFormat::name].
    UnknownValue(wire_format::UnknownValue),
}

#[doc(hidden)]
pub mod wire_format {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl WireFormat {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Protobuf => std::option::Option::Some(1),
            Self::Json => std::option::Option::Some(2),
            Self::Jspb => std::option::Option::Some(3),
            Self::TextFormat => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
            Self::Protobuf => std::option::Option::Some("PROTOBUF"),
            Self::Json => std::option::Option::Some("JSON"),
            Self::Jspb => std::option::Option::Some("JSPB"),
            Self::TextFormat => std::option::Option::Some("TEXT_FORMAT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for WireFormat {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for WireFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for WireFormat {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Protobuf,
            2 => Self::Json,
            3 => Self::Jspb,
            4 => Self::TextFormat,
            _ => Self::UnknownValue(wire_format::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for WireFormat {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UNSPECIFIED" => Self::Unspecified,
            "PROTOBUF" => Self::Protobuf,
            "JSON" => Self::Json,
            "JSPB" => Self::Jspb,
            "TEXT_FORMAT" => Self::TextFormat,
            _ => Self::UnknownValue(wire_format::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for WireFormat {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Protobuf => serializer.serialize_i32(1),
            Self::Json => serializer.serialize_i32(2),
            Self::Jspb => serializer.serialize_i32(3),
            Self::TextFormat => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for WireFormat {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<WireFormat>::new(
            ".conformance.WireFormat",
        ))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TestCategory {
    UnspecifiedTest,
    BinaryTest,
    JsonTest,
    /// Similar to JSON_TEST. However, during parsing json, testee should ignore
    /// unknown fields. This feature is optional. Each implementation can decide
    /// whether to support it.  See
    /// <https://developers.google.com/protocol-buffers/docs/proto3#json_options>
    /// for more detail.
    JsonIgnoreUnknownParsingTest,
    /// Test jspb wire format. Only used inside Google. Opensource testees just
    /// skip it.
    JspbTest,
    /// Test text format. For cpp, java and python, testees can already deal with
    /// this type. Testees of other languages can simply skip it.
    TextFormatTest,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TestCategory::value] or
    /// [TestCategory::name].
    UnknownValue(test_category::UnknownValue),
}

#[doc(hidden)]
pub mod test_category {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TestCategory {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::UnspecifiedTest => std::option::Option::Some(0),
            Self::BinaryTest => std::option::Option::Some(1),
            Self::JsonTest => std::option::Option::Some(2),
            Self::JsonIgnoreUnknownParsingTest => std::option::Option::Some(3),
            Self::JspbTest => std::option::Option::Some(4),
            Self::TextFormatTest => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::UnspecifiedTest => std::option::Option::Some("UNSPECIFIED_TEST"),
            Self::BinaryTest => std::option::Option::Some("BINARY_TEST"),
            Self::JsonTest => std::option::Option::Some("JSON_TEST"),
            Self::JsonIgnoreUnknownParsingTest => {
                std::option::Option::Some("JSON_IGNORE_UNKNOWN_PARSING_TEST")
            }
            Self::JspbTest => std::option::Option::Some("JSPB_TEST"),
            Self::TextFormatTest => std::option::Option::Some("TEXT_FORMAT_TEST"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TestCategory {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TestCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TestCategory {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::UnspecifiedTest,
            1 => Self::BinaryTest,
            2 => Self::JsonTest,
            3 => Self::JsonIgnoreUnknownParsingTest,
            4 => Self::JspbTest,
            5 => Self::TextFormatTest,
            _ => Self::UnknownValue(test_category::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TestCategory {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UNSPECIFIED_TEST" => Self::UnspecifiedTest,
            "BINARY_TEST" => Self::BinaryTest,
            "JSON_TEST" => Self::JsonTest,
            "JSON_IGNORE_UNKNOWN_PARSING_TEST" => Self::JsonIgnoreUnknownParsingTest,
            "JSPB_TEST" => Self::JspbTest,
            "TEXT_FORMAT_TEST" => Self::TextFormatTest,
            _ => Self::UnknownValue(test_category::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TestCategory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::UnspecifiedTest => serializer.serialize_i32(0),
            Self::BinaryTest => serializer.serialize_i32(1),
            Self::JsonTest => serializer.serialize_i32(2),
            Self::JsonIgnoreUnknownParsingTest => serializer.serialize_i32(3),
            Self::JspbTest => serializer.serialize_i32(4),
            Self::TextFormatTest => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TestCategory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TestCategory>::new(
            ".conformance.TestCategory",
        ))
    }
}
