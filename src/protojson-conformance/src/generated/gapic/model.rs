// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]

/// Meant to encapsulate all types of tests: successes, skips, failures, etc.
/// Therefore, this may or may not have a failure message. Failure messages
/// may be truncated for our failure lists.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TestStatus {
    pub name: std::string::String,

    pub failure_message: std::string::String,

    /// What an actual test name matched to in a failure list. Can be wildcarded or
    /// an exact match without wildcards.
    pub matched_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TestStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::generated::gapic::model::TestStatus::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [failure_message][crate::generated::gapic::model::TestStatus::failure_message].
    pub fn set_failure_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_message = v.into();
        self
    }

    /// Sets the value of [matched_name][crate::generated::gapic::model::TestStatus::matched_name].
    pub fn set_matched_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.matched_name = v.into();
        self
    }
}

impl wkt::message::Message for TestStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/conformance.TestStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TestStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __failure_message,
            __matched_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TestStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "failureMessage" => Ok(__FieldTag::__failure_message),
                            "failure_message" => Ok(__FieldTag::__failure_message),
                            "matchedName" => Ok(__FieldTag::__matched_name),
                            "matched_name" => Ok(__FieldTag::__matched_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TestStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TestStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failure_message => {
                            if !fields.insert(__FieldTag::__failure_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_message",
                                ));
                            }
                            result.failure_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__matched_name => {
                            if !fields.insert(__FieldTag::__matched_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matched_name",
                                ));
                            }
                            result.matched_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TestStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.failure_message.is_empty() {
            state.serialize_entry("failureMessage", &self.failure_message)?;
        }
        if !self.matched_name.is_empty() {
            state.serialize_entry("matchedName", &self.matched_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The conformance runner will request a list of failures as the first request.
/// This will be known by message_type == "conformance.FailureSet", a conformance
/// test should return a serialized FailureSet in protobuf_payload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FailureSet {
    pub test: std::vec::Vec<crate::generated::gapic::model::TestStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FailureSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [test][crate::generated::gapic::model::FailureSet::test].
    pub fn set_test<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::generated::gapic::model::TestStatus>,
    {
        use std::iter::Iterator;
        self.test = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FailureSet {
    fn typename() -> &'static str {
        "type.googleapis.com/conformance.FailureSet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FailureSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __test,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FailureSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "test" => Ok(__FieldTag::__test),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FailureSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FailureSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__test => {
                            if !fields.insert(__FieldTag::__test) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test",
                                ));
                            }
                            result.test = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::generated::gapic::model::TestStatus>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FailureSet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.test.is_empty() {
            state.serialize_entry("test", &self.test)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a single test case's input.  The testee should:
///
/// 1. parse this proto (which should always succeed)
/// 1. parse the protobuf or JSON payload in "payload" (which may fail)
/// 1. if the parse succeeded, serialize the message in the requested format.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConformanceRequest {
    /// Which format should the testee serialize its message to?
    pub requested_output_format: crate::generated::gapic::model::WireFormat,

    /// The full name for the test message to use; for the moment, either:
    /// protobuf_test_messages.proto3.TestAllTypesProto3 or
    /// protobuf_test_messages.proto2.TestAllTypesProto2 or
    /// protobuf_test_messages.editions.proto2.TestAllTypesProto2 or
    /// protobuf_test_messages.editions.proto3.TestAllTypesProto3 or
    /// protobuf_test_messages.editions.TestAllTypesEdition2023.
    pub message_type: std::string::String,

    /// Each test is given a specific test category. Some category may need
    /// specific support in testee programs. Refer to the definition of
    /// TestCategory for more information.
    pub test_category: crate::generated::gapic::model::TestCategory,

    /// Specify details for how to encode jspb.
    pub jspb_encoding_options:
        std::option::Option<crate::generated::gapic::model::JspbEncodingConfig>,

    /// This can be used in json and text format. If true, testee should print
    /// unknown fields instead of ignore. This feature is optional.
    pub print_unknown_fields: bool,

    /// The payload (whether protobuf of JSON) is always for a
    /// protobuf_test_messages.proto3.TestAllTypes proto (as defined in
    /// src/google/protobuf/proto3_test_messages.proto).
    pub payload: std::option::Option<crate::generated::gapic::model::conformance_request::Payload>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConformanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requested_output_format][crate::generated::gapic::model::ConformanceRequest::requested_output_format].
    pub fn set_requested_output_format<
        T: std::convert::Into<crate::generated::gapic::model::WireFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_output_format = v.into();
        self
    }

    /// Sets the value of [message_type][crate::generated::gapic::model::ConformanceRequest::message_type].
    pub fn set_message_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message_type = v.into();
        self
    }

    /// Sets the value of [test_category][crate::generated::gapic::model::ConformanceRequest::test_category].
    pub fn set_test_category<
        T: std::convert::Into<crate::generated::gapic::model::TestCategory>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.test_category = v.into();
        self
    }

    /// Sets the value of [jspb_encoding_options][crate::generated::gapic::model::ConformanceRequest::jspb_encoding_options].
    pub fn set_jspb_encoding_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::generated::gapic::model::JspbEncodingConfig>,
    {
        self.jspb_encoding_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [jspb_encoding_options][crate::generated::gapic::model::ConformanceRequest::jspb_encoding_options].
    pub fn set_or_clear_jspb_encoding_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::generated::gapic::model::JspbEncodingConfig>,
    {
        self.jspb_encoding_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [print_unknown_fields][crate::generated::gapic::model::ConformanceRequest::print_unknown_fields].
    pub fn set_print_unknown_fields<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.print_unknown_fields = v.into();
        self
    }

    /// Sets the value of [payload][crate::generated::gapic::model::ConformanceRequest::payload].
    ///
    /// Note that all the setters affecting `payload` are mutually
    /// exclusive.
    pub fn set_payload<
        T: std::convert::Into<
                std::option::Option<crate::generated::gapic::model::conformance_request::Payload>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }

    /// The value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// if it holds a `ProtobufPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn protobuf_payload(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_request::Payload::ProtobufPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// to hold a `ProtobufPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_protobuf_payload<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.payload = std::option::Option::Some(
            crate::generated::gapic::model::conformance_request::Payload::ProtobufPayload(v.into()),
        );
        self
    }

    /// The value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// if it holds a `JsonPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_request::Payload::JsonPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// to hold a `JsonPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_json_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload = std::option::Option::Some(
            crate::generated::gapic::model::conformance_request::Payload::JsonPayload(v.into()),
        );
        self
    }

    /// The value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// if it holds a `JspbPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn jspb_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_request::Payload::JspbPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// to hold a `JspbPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_jspb_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload = std::option::Option::Some(
            crate::generated::gapic::model::conformance_request::Payload::JspbPayload(v.into()),
        );
        self
    }

    /// The value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// if it holds a `TextPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_request::Payload::TextPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::generated::gapic::model::ConformanceRequest::payload]
    /// to hold a `TextPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_text_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload = std::option::Option::Some(
            crate::generated::gapic::model::conformance_request::Payload::TextPayload(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConformanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/conformance.ConformanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConformanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __protobuf_payload,
            __json_payload,
            __jspb_payload,
            __text_payload,
            __requested_output_format,
            __message_type,
            __test_category,
            __jspb_encoding_options,
            __print_unknown_fields,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConformanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "protobufPayload" => Ok(__FieldTag::__protobuf_payload),
                            "protobuf_payload" => Ok(__FieldTag::__protobuf_payload),
                            "jsonPayload" => Ok(__FieldTag::__json_payload),
                            "json_payload" => Ok(__FieldTag::__json_payload),
                            "jspbPayload" => Ok(__FieldTag::__jspb_payload),
                            "jspb_payload" => Ok(__FieldTag::__jspb_payload),
                            "textPayload" => Ok(__FieldTag::__text_payload),
                            "text_payload" => Ok(__FieldTag::__text_payload),
                            "requestedOutputFormat" => Ok(__FieldTag::__requested_output_format),
                            "requested_output_format" => Ok(__FieldTag::__requested_output_format),
                            "messageType" => Ok(__FieldTag::__message_type),
                            "message_type" => Ok(__FieldTag::__message_type),
                            "testCategory" => Ok(__FieldTag::__test_category),
                            "test_category" => Ok(__FieldTag::__test_category),
                            "jspbEncodingOptions" => Ok(__FieldTag::__jspb_encoding_options),
                            "jspb_encoding_options" => Ok(__FieldTag::__jspb_encoding_options),
                            "printUnknownFields" => Ok(__FieldTag::__print_unknown_fields),
                            "print_unknown_fields" => Ok(__FieldTag::__print_unknown_fields),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConformanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConformanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__protobuf_payload => {
                            if !fields.insert(__FieldTag::__protobuf_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protobuf_payload",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .conformance.ConformanceRequest.protobuf_payload, latest field was protobufPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_request::Payload::ProtobufPayload(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__json_payload => {
                            if !fields.insert(__FieldTag::__json_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for json_payload",
                                ));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .conformance.ConformanceRequest.json_payload, latest field was jsonPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_request::Payload::JsonPayload(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__jspb_payload => {
                            if !fields.insert(__FieldTag::__jspb_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jspb_payload",
                                ));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .conformance.ConformanceRequest.jspb_payload, latest field was jspbPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_request::Payload::JspbPayload(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__text_payload => {
                            if !fields.insert(__FieldTag::__text_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_payload",
                                ));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .conformance.ConformanceRequest.text_payload, latest field was textPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_request::Payload::TextPayload(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__requested_output_format => {
                            if !fields.insert(__FieldTag::__requested_output_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_output_format",
                                ));
                            }
                            result.requested_output_format = map.next_value::<std::option::Option<crate::generated::gapic::model::WireFormat>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message_type => {
                            if !fields.insert(__FieldTag::__message_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_type",
                                ));
                            }
                            result.message_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__test_category => {
                            if !fields.insert(__FieldTag::__test_category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_category",
                                ));
                            }
                            result.test_category =
                                map.next_value::<std::option::Option<
                                    crate::generated::gapic::model::TestCategory,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jspb_encoding_options => {
                            if !fields.insert(__FieldTag::__jspb_encoding_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jspb_encoding_options",
                                ));
                            }
                            result.jspb_encoding_options = map.next_value::<std::option::Option<
                                crate::generated::gapic::model::JspbEncodingConfig,
                            >>()?;
                        }
                        __FieldTag::__print_unknown_fields => {
                            if !fields.insert(__FieldTag::__print_unknown_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for print_unknown_fields",
                                ));
                            }
                            result.print_unknown_fields = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConformanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.protobuf_payload() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("protobufPayload", &__With(value))?;
        }
        if let Some(value) = self.json_payload() {
            state.serialize_entry("jsonPayload", value)?;
        }
        if let Some(value) = self.jspb_payload() {
            state.serialize_entry("jspbPayload", value)?;
        }
        if let Some(value) = self.text_payload() {
            state.serialize_entry("textPayload", value)?;
        }
        if !wkt::internal::is_default(&self.requested_output_format) {
            state.serialize_entry("requestedOutputFormat", &self.requested_output_format)?;
        }
        if !self.message_type.is_empty() {
            state.serialize_entry("messageType", &self.message_type)?;
        }
        if !wkt::internal::is_default(&self.test_category) {
            state.serialize_entry("testCategory", &self.test_category)?;
        }
        if self.jspb_encoding_options.is_some() {
            state.serialize_entry("jspbEncodingOptions", &self.jspb_encoding_options)?;
        }
        if !wkt::internal::is_default(&self.print_unknown_fields) {
            state.serialize_entry("printUnknownFields", &self.print_unknown_fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ConformanceRequest].
pub mod conformance_request {
    #[allow(unused_imports)]
    use super::*;

    /// The payload (whether protobuf of JSON) is always for a
    /// protobuf_test_messages.proto3.TestAllTypes proto (as defined in
    /// src/google/protobuf/proto3_test_messages.proto).
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Payload {
        ProtobufPayload(::bytes::Bytes),
        JsonPayload(std::string::String),
        /// Only used inside Google.  Opensource testees just skip it.
        JspbPayload(std::string::String),
        TextPayload(std::string::String),
    }

    impl Payload {
        /// Initializes the enum to the [ProtobufPayload](Self::ProtobufPayload) branch.
        pub fn from_protobuf_payload(value: impl std::convert::Into<::bytes::Bytes>) -> Self {
            Self::ProtobufPayload(value.into())
        }
        /// Initializes the enum to the [JsonPayload](Self::JsonPayload) branch.
        pub fn from_json_payload(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::JsonPayload(value.into())
        }
        /// Initializes the enum to the [JspbPayload](Self::JspbPayload) branch.
        pub fn from_jspb_payload(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::JspbPayload(value.into())
        }
        /// Initializes the enum to the [TextPayload](Self::TextPayload) branch.
        pub fn from_text_payload(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::TextPayload(value.into())
        }
    }
}

/// Represents a single test case's output.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConformanceResponse {
    pub result: std::option::Option<crate::generated::gapic::model::conformance_response::Result>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConformanceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<
                std::option::Option<crate::generated::gapic::model::conformance_response::Result>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `ParseError`, `None` if the field is not set or
    /// holds a different branch.
    pub fn parse_error(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::ParseError(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `ParseError`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_parse_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::ParseError(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `SerializeError`, `None` if the field is not set or
    /// holds a different branch.
    pub fn serialize_error(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::SerializeError(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `SerializeError`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_serialize_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::SerializeError(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `TimeoutError`, `None` if the field is not set or
    /// holds a different branch.
    pub fn timeout_error(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::TimeoutError(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `TimeoutError`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_timeout_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::TimeoutError(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `RuntimeError`, `None` if the field is not set or
    /// holds a different branch.
    pub fn runtime_error(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::RuntimeError(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `RuntimeError`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_runtime_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::RuntimeError(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `ProtobufPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn protobuf_payload(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::ProtobufPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `ProtobufPayload`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_protobuf_payload<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::ProtobufPayload(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `JsonPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::JsonPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `JsonPayload`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_json_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::JsonPayload(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `Skipped`, `None` if the field is not set or
    /// holds a different branch.
    pub fn skipped(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::Skipped(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `Skipped`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_skipped<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::Skipped(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `JspbPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn jspb_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::JspbPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `JspbPayload`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_jspb_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::JspbPayload(v.into()),
        );
        self
    }

    /// The value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// if it holds a `TextPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::generated::gapic::model::conformance_response::Result::TextPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::generated::gapic::model::ConformanceResponse::result]
    /// to hold a `TextPayload`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_text_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.result = std::option::Option::Some(
            crate::generated::gapic::model::conformance_response::Result::TextPayload(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConformanceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/conformance.ConformanceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConformanceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parse_error,
            __serialize_error,
            __timeout_error,
            __runtime_error,
            __protobuf_payload,
            __json_payload,
            __skipped,
            __jspb_payload,
            __text_payload,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConformanceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parseError" => Ok(__FieldTag::__parse_error),
                            "parse_error" => Ok(__FieldTag::__parse_error),
                            "serializeError" => Ok(__FieldTag::__serialize_error),
                            "serialize_error" => Ok(__FieldTag::__serialize_error),
                            "timeoutError" => Ok(__FieldTag::__timeout_error),
                            "timeout_error" => Ok(__FieldTag::__timeout_error),
                            "runtimeError" => Ok(__FieldTag::__runtime_error),
                            "runtime_error" => Ok(__FieldTag::__runtime_error),
                            "protobufPayload" => Ok(__FieldTag::__protobuf_payload),
                            "protobuf_payload" => Ok(__FieldTag::__protobuf_payload),
                            "jsonPayload" => Ok(__FieldTag::__json_payload),
                            "json_payload" => Ok(__FieldTag::__json_payload),
                            "skipped" => Ok(__FieldTag::__skipped),
                            "jspbPayload" => Ok(__FieldTag::__jspb_payload),
                            "jspb_payload" => Ok(__FieldTag::__jspb_payload),
                            "textPayload" => Ok(__FieldTag::__text_payload),
                            "text_payload" => Ok(__FieldTag::__text_payload),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConformanceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConformanceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parse_error => {
                            if !fields.insert(__FieldTag::__parse_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parse_error",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.parse_error, latest field was parseError",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::ParseError(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__serialize_error => {
                            if !fields.insert(__FieldTag::__serialize_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serialize_error",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.serialize_error, latest field was serializeError",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::SerializeError(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__timeout_error => {
                            if !fields.insert(__FieldTag::__timeout_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout_error",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.timeout_error, latest field was timeoutError",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::TimeoutError(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__runtime_error => {
                            if !fields.insert(__FieldTag::__runtime_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_error",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.runtime_error, latest field was runtimeError",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::RuntimeError(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__protobuf_payload => {
                            if !fields.insert(__FieldTag::__protobuf_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protobuf_payload",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.protobuf_payload, latest field was protobufPayload",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::ProtobufPayload(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__json_payload => {
                            if !fields.insert(__FieldTag::__json_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for json_payload",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.json_payload, latest field was jsonPayload",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::JsonPayload(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__skipped => {
                            if !fields.insert(__FieldTag::__skipped) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skipped",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.skipped, latest field was skipped",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::Skipped(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__jspb_payload => {
                            if !fields.insert(__FieldTag::__jspb_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jspb_payload",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.jspb_payload, latest field was jspbPayload",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::JspbPayload(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__text_payload => {
                            if !fields.insert(__FieldTag::__text_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_payload",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .conformance.ConformanceResponse.text_payload, latest field was textPayload",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::generated::gapic::model::conformance_response::Result::TextPayload(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConformanceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.parse_error() {
            state.serialize_entry("parseError", value)?;
        }
        if let Some(value) = self.serialize_error() {
            state.serialize_entry("serializeError", value)?;
        }
        if let Some(value) = self.timeout_error() {
            state.serialize_entry("timeoutError", value)?;
        }
        if let Some(value) = self.runtime_error() {
            state.serialize_entry("runtimeError", value)?;
        }
        if let Some(value) = self.protobuf_payload() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("protobufPayload", &__With(value))?;
        }
        if let Some(value) = self.json_payload() {
            state.serialize_entry("jsonPayload", value)?;
        }
        if let Some(value) = self.skipped() {
            state.serialize_entry("skipped", value)?;
        }
        if let Some(value) = self.jspb_payload() {
            state.serialize_entry("jspbPayload", value)?;
        }
        if let Some(value) = self.text_payload() {
            state.serialize_entry("textPayload", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ConformanceResponse].
pub mod conformance_response {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// This string should be set to indicate parsing failed.  The string can
        /// provide more information about the parse error if it is available.
        ///
        /// Setting this string does not necessarily mean the testee failed the
        /// test.  Some of the test cases are intentionally invalid input.
        ParseError(std::string::String),
        /// If the input was successfully parsed but errors occurred when
        /// serializing it to the requested output format, set the error message in
        /// this field.
        SerializeError(std::string::String),
        /// This should be set if the test program timed out.  The string should
        /// provide more information about what the child process was doing when it
        /// was killed.
        TimeoutError(std::string::String),
        /// This should be set if some other error occurred.  This will always
        /// indicate that the test failed.  The string can provide more information
        /// about the failure.
        RuntimeError(std::string::String),
        /// If the input was successfully parsed and the requested output was
        /// protobuf, serialize it to protobuf and set it in this field.
        ProtobufPayload(::bytes::Bytes),
        /// If the input was successfully parsed and the requested output was JSON,
        /// serialize to JSON and set it in this field.
        JsonPayload(std::string::String),
        /// For when the testee skipped the test, likely because a certain feature
        /// wasn't supported, like JSON input/output.
        Skipped(std::string::String),
        /// If the input was successfully parsed and the requested output was JSPB,
        /// serialize to JSPB and set it in this field. JSPB is only used inside
        /// Google. Opensource testees can just skip it.
        JspbPayload(std::string::String),
        /// If the input was successfully parsed and the requested output was
        /// TEXT_FORMAT, serialize to TEXT_FORMAT and set it in this field.
        TextPayload(std::string::String),
    }

    impl Result {
        /// Initializes the enum to the [ParseError](Self::ParseError) branch.
        pub fn from_parse_error(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::ParseError(value.into())
        }
        /// Initializes the enum to the [SerializeError](Self::SerializeError) branch.
        pub fn from_serialize_error(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::SerializeError(value.into())
        }
        /// Initializes the enum to the [TimeoutError](Self::TimeoutError) branch.
        pub fn from_timeout_error(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::TimeoutError(value.into())
        }
        /// Initializes the enum to the [RuntimeError](Self::RuntimeError) branch.
        pub fn from_runtime_error(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::RuntimeError(value.into())
        }
        /// Initializes the enum to the [ProtobufPayload](Self::ProtobufPayload) branch.
        pub fn from_protobuf_payload(value: impl std::convert::Into<::bytes::Bytes>) -> Self {
            Self::ProtobufPayload(value.into())
        }
        /// Initializes the enum to the [JsonPayload](Self::JsonPayload) branch.
        pub fn from_json_payload(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::JsonPayload(value.into())
        }
        /// Initializes the enum to the [Skipped](Self::Skipped) branch.
        pub fn from_skipped(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::Skipped(value.into())
        }
        /// Initializes the enum to the [JspbPayload](Self::JspbPayload) branch.
        pub fn from_jspb_payload(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::JspbPayload(value.into())
        }
        /// Initializes the enum to the [TextPayload](Self::TextPayload) branch.
        pub fn from_text_payload(value: impl std::convert::Into<std::string::String>) -> Self {
            Self::TextPayload(value.into())
        }
    }
}

/// Encoding options for jspb format.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct JspbEncodingConfig {
    /// Encode the value field of Any as jspb array if true, otherwise binary.
    pub use_jspb_array_any_format: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JspbEncodingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_jspb_array_any_format][crate::generated::gapic::model::JspbEncodingConfig::use_jspb_array_any_format].
    pub fn set_use_jspb_array_any_format<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_jspb_array_any_format = v.into();
        self
    }
}

impl wkt::message::Message for JspbEncodingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/conformance.JspbEncodingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JspbEncodingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __use_jspb_array_any_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JspbEncodingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "useJspbArrayAnyFormat" => Ok(__FieldTag::__use_jspb_array_any_format),
                            "use_jspb_array_any_format" => {
                                Ok(__FieldTag::__use_jspb_array_any_format)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JspbEncodingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JspbEncodingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__use_jspb_array_any_format => {
                            if !fields.insert(__FieldTag::__use_jspb_array_any_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_jspb_array_any_format",
                                ));
                            }
                            result.use_jspb_array_any_format = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JspbEncodingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.use_jspb_array_any_format) {
            state.serialize_entry("useJspbArrayAnyFormat", &self.use_jspb_array_any_format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum WireFormat {
    Unspecified,
    Protobuf,
    Json,
    Jspb,
    TextFormat,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [WireFormat::value] or
    /// [WireFormat::name].
    UnknownValue(wire_format::UnknownValue),
}

#[doc(hidden)]
pub mod wire_format {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl WireFormat {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Protobuf => std::option::Option::Some(1),
            Self::Json => std::option::Option::Some(2),
            Self::Jspb => std::option::Option::Some(3),
            Self::TextFormat => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
            Self::Protobuf => std::option::Option::Some("PROTOBUF"),
            Self::Json => std::option::Option::Some("JSON"),
            Self::Jspb => std::option::Option::Some("JSPB"),
            Self::TextFormat => std::option::Option::Some("TEXT_FORMAT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for WireFormat {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for WireFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for WireFormat {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Protobuf,
            2 => Self::Json,
            3 => Self::Jspb,
            4 => Self::TextFormat,
            _ => Self::UnknownValue(wire_format::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for WireFormat {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UNSPECIFIED" => Self::Unspecified,
            "PROTOBUF" => Self::Protobuf,
            "JSON" => Self::Json,
            "JSPB" => Self::Jspb,
            "TEXT_FORMAT" => Self::TextFormat,
            _ => Self::UnknownValue(wire_format::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for WireFormat {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Protobuf => serializer.serialize_i32(1),
            Self::Json => serializer.serialize_i32(2),
            Self::Jspb => serializer.serialize_i32(3),
            Self::TextFormat => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for WireFormat {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<WireFormat>::new(
            ".conformance.WireFormat",
        ))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TestCategory {
    UnspecifiedTest,
    BinaryTest,
    JsonTest,
    /// Similar to JSON_TEST. However, during parsing json, testee should ignore
    /// unknown fields. This feature is optional. Each implementation can decide
    /// whether to support it.  See
    /// <https://developers.google.com/protocol-buffers/docs/proto3#json_options>
    /// for more detail.
    JsonIgnoreUnknownParsingTest,
    /// Test jspb wire format. Only used inside Google. Opensource testees just
    /// skip it.
    JspbTest,
    /// Test text format. For cpp, java and python, testees can already deal with
    /// this type. Testees of other languages can simply skip it.
    TextFormatTest,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TestCategory::value] or
    /// [TestCategory::name].
    UnknownValue(test_category::UnknownValue),
}

#[doc(hidden)]
pub mod test_category {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TestCategory {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::UnspecifiedTest => std::option::Option::Some(0),
            Self::BinaryTest => std::option::Option::Some(1),
            Self::JsonTest => std::option::Option::Some(2),
            Self::JsonIgnoreUnknownParsingTest => std::option::Option::Some(3),
            Self::JspbTest => std::option::Option::Some(4),
            Self::TextFormatTest => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::UnspecifiedTest => std::option::Option::Some("UNSPECIFIED_TEST"),
            Self::BinaryTest => std::option::Option::Some("BINARY_TEST"),
            Self::JsonTest => std::option::Option::Some("JSON_TEST"),
            Self::JsonIgnoreUnknownParsingTest => {
                std::option::Option::Some("JSON_IGNORE_UNKNOWN_PARSING_TEST")
            }
            Self::JspbTest => std::option::Option::Some("JSPB_TEST"),
            Self::TextFormatTest => std::option::Option::Some("TEXT_FORMAT_TEST"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TestCategory {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TestCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TestCategory {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::UnspecifiedTest,
            1 => Self::BinaryTest,
            2 => Self::JsonTest,
            3 => Self::JsonIgnoreUnknownParsingTest,
            4 => Self::JspbTest,
            5 => Self::TextFormatTest,
            _ => Self::UnknownValue(test_category::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TestCategory {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UNSPECIFIED_TEST" => Self::UnspecifiedTest,
            "BINARY_TEST" => Self::BinaryTest,
            "JSON_TEST" => Self::JsonTest,
            "JSON_IGNORE_UNKNOWN_PARSING_TEST" => Self::JsonIgnoreUnknownParsingTest,
            "JSPB_TEST" => Self::JspbTest,
            "TEXT_FORMAT_TEST" => Self::TextFormatTest,
            _ => Self::UnknownValue(test_category::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TestCategory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::UnspecifiedTest => serializer.serialize_i32(0),
            Self::BinaryTest => serializer.serialize_i32(1),
            Self::JsonTest => serializer.serialize_i32(2),
            Self::JsonIgnoreUnknownParsingTest => serializer.serialize_i32(3),
            Self::JspbTest => serializer.serialize_i32(4),
            Self::TextFormatTest => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TestCategory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TestCategory>::new(
            ".conformance.TestCategory",
        ))
    }
}
