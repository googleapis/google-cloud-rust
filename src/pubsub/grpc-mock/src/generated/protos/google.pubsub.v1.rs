// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Schema {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "schema::Type", tag = "2")]
    pub r#type: i32,
    #[prost(string, tag = "3")]
    pub definition: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub revision_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub revision_create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Schema`.
pub mod schema {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        ProtocolBuffer = 1,
        Avro = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::ProtocolBuffer => "PROTOCOL_BUFFER",
                Self::Avro => "AVRO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROTOCOL_BUFFER" => Some(Self::ProtocolBuffer),
                "AVRO" => Some(Self::Avro),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateSchemaRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub schema: ::core::option::Option<Schema>,
    #[prost(string, tag = "3")]
    pub schema_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "SchemaView", tag = "2")]
    pub view: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSchemasRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(enumeration = "SchemaView", tag = "2")]
    pub view: i32,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemasResponse {
    #[prost(message, repeated, tag = "1")]
    pub schemas: ::prost::alloc::vec::Vec<Schema>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSchemaRevisionsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "SchemaView", tag = "2")]
    pub view: i32,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemaRevisionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub schemas: ::prost::alloc::vec::Vec<Schema>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommitSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub schema: ::core::option::Option<Schema>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RollbackSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub revision_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteSchemaRevisionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "2")]
    pub revision_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ValidateSchemaRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub schema: ::core::option::Option<Schema>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ValidateSchemaResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ValidateMessageRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "Encoding", tag = "5")]
    pub encoding: i32,
    #[prost(oneof = "validate_message_request::SchemaSpec", tags = "2, 3")]
    pub schema_spec: ::core::option::Option<validate_message_request::SchemaSpec>,
}
/// Nested message and enum types in `ValidateMessageRequest`.
pub mod validate_message_request {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum SchemaSpec {
        #[prost(string, tag = "2")]
        Name(::prost::alloc::string::String),
        #[prost(message, tag = "3")]
        Schema(super::Schema),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ValidateMessageResponse {}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SchemaView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
}
impl SchemaView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SCHEMA_VIEW_UNSPECIFIED",
            Self::Basic => "BASIC",
            Self::Full => "FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCHEMA_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "BASIC" => Some(Self::Basic),
            "FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Encoding {
    Unspecified = 0,
    Json = 1,
    Binary = 2,
}
impl Encoding {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENCODING_UNSPECIFIED",
            Self::Json => "JSON",
            Self::Binary => "BINARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENCODING_UNSPECIFIED" => Some(Self::Unspecified),
            "JSON" => Some(Self::Json),
            "BINARY" => Some(Self::Binary),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod schema_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for doing schema-related operations.
    #[derive(Debug, Clone)]
    pub struct SchemaServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SchemaServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SchemaServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SchemaServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a schema.
        pub async fn create_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::Schema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.SchemaService/CreateSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.SchemaService", "CreateSchema"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a schema.
        pub async fn get_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::Schema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.SchemaService/GetSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.pubsub.v1.SchemaService", "GetSchema"));
            self.inner.unary(req, path, codec).await
        }
        /// Lists schemas in a project.
        pub async fn list_schemas(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSchemasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSchemasResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.SchemaService/ListSchemas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.SchemaService", "ListSchemas"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all schema revisions for the named schema.
        pub async fn list_schema_revisions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSchemaRevisionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSchemaRevisionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.SchemaService/ListSchemaRevisions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.pubsub.v1.SchemaService",
                        "ListSchemaRevisions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Commits a new schema revision to an existing schema.
        pub async fn commit_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::CommitSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::Schema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.SchemaService/CommitSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.SchemaService", "CommitSchema"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new schema revision that is a copy of the provided revision_id.
        pub async fn rollback_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::RollbackSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::Schema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.SchemaService/RollbackSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.SchemaService", "RollbackSchema"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a specific schema revision.
        pub async fn delete_schema_revision(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSchemaRevisionRequest>,
        ) -> std::result::Result<tonic::Response<super::Schema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.SchemaService/DeleteSchemaRevision",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.pubsub.v1.SchemaService",
                        "DeleteSchemaRevision",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a schema.
        pub async fn delete_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSchemaRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.SchemaService/DeleteSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.SchemaService", "DeleteSchema"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Validates a schema.
        pub async fn validate_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateSchemaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.SchemaService/ValidateSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.SchemaService", "ValidateSchema"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Validates a message against a schema.
        pub async fn validate_message(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateMessageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateMessageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.SchemaService/ValidateMessage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.SchemaService", "ValidateMessage"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod schema_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SchemaServiceServer.
    #[async_trait]
    pub trait SchemaService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a schema.
        async fn create_schema(
            &self,
            request: tonic::Request<super::CreateSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::Schema>, tonic::Status>;
        /// Gets a schema.
        async fn get_schema(
            &self,
            request: tonic::Request<super::GetSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::Schema>, tonic::Status>;
        /// Lists schemas in a project.
        async fn list_schemas(
            &self,
            request: tonic::Request<super::ListSchemasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSchemasResponse>,
            tonic::Status,
        >;
        /// Lists all schema revisions for the named schema.
        async fn list_schema_revisions(
            &self,
            request: tonic::Request<super::ListSchemaRevisionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSchemaRevisionsResponse>,
            tonic::Status,
        >;
        /// Commits a new schema revision to an existing schema.
        async fn commit_schema(
            &self,
            request: tonic::Request<super::CommitSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::Schema>, tonic::Status>;
        /// Creates a new schema revision that is a copy of the provided revision_id.
        async fn rollback_schema(
            &self,
            request: tonic::Request<super::RollbackSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::Schema>, tonic::Status>;
        /// Deletes a specific schema revision.
        async fn delete_schema_revision(
            &self,
            request: tonic::Request<super::DeleteSchemaRevisionRequest>,
        ) -> std::result::Result<tonic::Response<super::Schema>, tonic::Status>;
        /// Deletes a schema.
        async fn delete_schema(
            &self,
            request: tonic::Request<super::DeleteSchemaRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Validates a schema.
        async fn validate_schema(
            &self,
            request: tonic::Request<super::ValidateSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateSchemaResponse>,
            tonic::Status,
        >;
        /// Validates a message against a schema.
        async fn validate_message(
            &self,
            request: tonic::Request<super::ValidateMessageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateMessageResponse>,
            tonic::Status,
        >;
    }
    /// Service for doing schema-related operations.
    #[derive(Debug)]
    pub struct SchemaServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SchemaServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SchemaServiceServer<T>
    where
        T: SchemaService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.pubsub.v1.SchemaService/CreateSchema" => {
                    #[allow(non_camel_case_types)]
                    struct CreateSchemaSvc<T: SchemaService>(pub Arc<T>);
                    impl<
                        T: SchemaService,
                    > tonic::server::UnaryService<super::CreateSchemaRequest>
                    for CreateSchemaSvc<T> {
                        type Response = super::Schema;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateSchemaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SchemaService>::create_schema(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateSchemaSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.SchemaService/GetSchema" => {
                    #[allow(non_camel_case_types)]
                    struct GetSchemaSvc<T: SchemaService>(pub Arc<T>);
                    impl<
                        T: SchemaService,
                    > tonic::server::UnaryService<super::GetSchemaRequest>
                    for GetSchemaSvc<T> {
                        type Response = super::Schema;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSchemaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SchemaService>::get_schema(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSchemaSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.SchemaService/ListSchemas" => {
                    #[allow(non_camel_case_types)]
                    struct ListSchemasSvc<T: SchemaService>(pub Arc<T>);
                    impl<
                        T: SchemaService,
                    > tonic::server::UnaryService<super::ListSchemasRequest>
                    for ListSchemasSvc<T> {
                        type Response = super::ListSchemasResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListSchemasRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SchemaService>::list_schemas(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListSchemasSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.SchemaService/ListSchemaRevisions" => {
                    #[allow(non_camel_case_types)]
                    struct ListSchemaRevisionsSvc<T: SchemaService>(pub Arc<T>);
                    impl<
                        T: SchemaService,
                    > tonic::server::UnaryService<super::ListSchemaRevisionsRequest>
                    for ListSchemaRevisionsSvc<T> {
                        type Response = super::ListSchemaRevisionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListSchemaRevisionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SchemaService>::list_schema_revisions(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListSchemaRevisionsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.SchemaService/CommitSchema" => {
                    #[allow(non_camel_case_types)]
                    struct CommitSchemaSvc<T: SchemaService>(pub Arc<T>);
                    impl<
                        T: SchemaService,
                    > tonic::server::UnaryService<super::CommitSchemaRequest>
                    for CommitSchemaSvc<T> {
                        type Response = super::Schema;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CommitSchemaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SchemaService>::commit_schema(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CommitSchemaSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.SchemaService/RollbackSchema" => {
                    #[allow(non_camel_case_types)]
                    struct RollbackSchemaSvc<T: SchemaService>(pub Arc<T>);
                    impl<
                        T: SchemaService,
                    > tonic::server::UnaryService<super::RollbackSchemaRequest>
                    for RollbackSchemaSvc<T> {
                        type Response = super::Schema;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RollbackSchemaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SchemaService>::rollback_schema(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RollbackSchemaSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.SchemaService/DeleteSchemaRevision" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSchemaRevisionSvc<T: SchemaService>(pub Arc<T>);
                    impl<
                        T: SchemaService,
                    > tonic::server::UnaryService<super::DeleteSchemaRevisionRequest>
                    for DeleteSchemaRevisionSvc<T> {
                        type Response = super::Schema;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteSchemaRevisionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SchemaService>::delete_schema_revision(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteSchemaRevisionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.SchemaService/DeleteSchema" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSchemaSvc<T: SchemaService>(pub Arc<T>);
                    impl<
                        T: SchemaService,
                    > tonic::server::UnaryService<super::DeleteSchemaRequest>
                    for DeleteSchemaSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteSchemaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SchemaService>::delete_schema(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteSchemaSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.SchemaService/ValidateSchema" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateSchemaSvc<T: SchemaService>(pub Arc<T>);
                    impl<
                        T: SchemaService,
                    > tonic::server::UnaryService<super::ValidateSchemaRequest>
                    for ValidateSchemaSvc<T> {
                        type Response = super::ValidateSchemaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValidateSchemaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SchemaService>::validate_schema(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateSchemaSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.SchemaService/ValidateMessage" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateMessageSvc<T: SchemaService>(pub Arc<T>);
                    impl<
                        T: SchemaService,
                    > tonic::server::UnaryService<super::ValidateMessageRequest>
                    for ValidateMessageSvc<T> {
                        type Response = super::ValidateMessageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValidateMessageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SchemaService>::validate_message(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateMessageSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SchemaServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.pubsub.v1.SchemaService";
    impl<T> tonic::server::NamedService for SchemaServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MessageStoragePolicy {
    #[prost(string, repeated, tag = "1")]
    pub allowed_persistence_regions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "2")]
    pub enforce_in_transit: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SchemaSettings {
    #[prost(string, tag = "1")]
    pub schema: ::prost::alloc::string::String,
    #[prost(enumeration = "Encoding", tag = "2")]
    pub encoding: i32,
    #[prost(string, tag = "3")]
    pub first_revision_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub last_revision_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IngestionDataSourceSettings {
    #[prost(message, optional, tag = "4")]
    pub platform_logs_settings: ::core::option::Option<PlatformLogsSettings>,
    #[prost(oneof = "ingestion_data_source_settings::Source", tags = "1, 2, 3, 5, 6")]
    pub source: ::core::option::Option<ingestion_data_source_settings::Source>,
}
/// Nested message and enum types in `IngestionDataSourceSettings`.
pub mod ingestion_data_source_settings {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AwsKinesis {
        #[prost(enumeration = "aws_kinesis::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub stream_arn: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub consumer_arn: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub aws_role_arn: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub gcp_service_account: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `AwsKinesis`.
    pub mod aws_kinesis {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Active = 1,
            KinesisPermissionDenied = 2,
            PublishPermissionDenied = 3,
            StreamNotFound = 4,
            ConsumerNotFound = 5,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::KinesisPermissionDenied => "KINESIS_PERMISSION_DENIED",
                    Self::PublishPermissionDenied => "PUBLISH_PERMISSION_DENIED",
                    Self::StreamNotFound => "STREAM_NOT_FOUND",
                    Self::ConsumerNotFound => "CONSUMER_NOT_FOUND",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "KINESIS_PERMISSION_DENIED" => Some(Self::KinesisPermissionDenied),
                    "PUBLISH_PERMISSION_DENIED" => Some(Self::PublishPermissionDenied),
                    "STREAM_NOT_FOUND" => Some(Self::StreamNotFound),
                    "CONSUMER_NOT_FOUND" => Some(Self::ConsumerNotFound),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CloudStorage {
        #[prost(enumeration = "cloud_storage::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub bucket: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "6")]
        pub minimum_object_create_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(string, tag = "9")]
        pub match_glob: ::prost::alloc::string::String,
        #[prost(oneof = "cloud_storage::InputFormat", tags = "3, 4, 5")]
        pub input_format: ::core::option::Option<cloud_storage::InputFormat>,
    }
    /// Nested message and enum types in `CloudStorage`.
    pub mod cloud_storage {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct TextFormat {
            #[prost(string, optional, tag = "1")]
            pub delimiter: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AvroFormat {}
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct PubSubAvroFormat {}
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Active = 1,
            CloudStoragePermissionDenied = 2,
            PublishPermissionDenied = 3,
            BucketNotFound = 4,
            TooManyObjects = 5,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::CloudStoragePermissionDenied => {
                        "CLOUD_STORAGE_PERMISSION_DENIED"
                    }
                    Self::PublishPermissionDenied => "PUBLISH_PERMISSION_DENIED",
                    Self::BucketNotFound => "BUCKET_NOT_FOUND",
                    Self::TooManyObjects => "TOO_MANY_OBJECTS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "CLOUD_STORAGE_PERMISSION_DENIED" => {
                        Some(Self::CloudStoragePermissionDenied)
                    }
                    "PUBLISH_PERMISSION_DENIED" => Some(Self::PublishPermissionDenied),
                    "BUCKET_NOT_FOUND" => Some(Self::BucketNotFound),
                    "TOO_MANY_OBJECTS" => Some(Self::TooManyObjects),
                    _ => None,
                }
            }
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum InputFormat {
            #[prost(message, tag = "3")]
            TextFormat(TextFormat),
            #[prost(message, tag = "4")]
            AvroFormat(AvroFormat),
            #[prost(message, tag = "5")]
            PubsubAvroFormat(PubSubAvroFormat),
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AzureEventHubs {
        #[prost(enumeration = "azure_event_hubs::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub resource_group: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub namespace: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub event_hub: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub client_id: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub tenant_id: ::prost::alloc::string::String,
        #[prost(string, tag = "7")]
        pub subscription_id: ::prost::alloc::string::String,
        #[prost(string, tag = "8")]
        pub gcp_service_account: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `AzureEventHubs`.
    pub mod azure_event_hubs {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Active = 1,
            EventHubsPermissionDenied = 2,
            PublishPermissionDenied = 3,
            NamespaceNotFound = 4,
            EventHubNotFound = 5,
            SubscriptionNotFound = 6,
            ResourceGroupNotFound = 7,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::EventHubsPermissionDenied => "EVENT_HUBS_PERMISSION_DENIED",
                    Self::PublishPermissionDenied => "PUBLISH_PERMISSION_DENIED",
                    Self::NamespaceNotFound => "NAMESPACE_NOT_FOUND",
                    Self::EventHubNotFound => "EVENT_HUB_NOT_FOUND",
                    Self::SubscriptionNotFound => "SUBSCRIPTION_NOT_FOUND",
                    Self::ResourceGroupNotFound => "RESOURCE_GROUP_NOT_FOUND",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "EVENT_HUBS_PERMISSION_DENIED" => {
                        Some(Self::EventHubsPermissionDenied)
                    }
                    "PUBLISH_PERMISSION_DENIED" => Some(Self::PublishPermissionDenied),
                    "NAMESPACE_NOT_FOUND" => Some(Self::NamespaceNotFound),
                    "EVENT_HUB_NOT_FOUND" => Some(Self::EventHubNotFound),
                    "SUBSCRIPTION_NOT_FOUND" => Some(Self::SubscriptionNotFound),
                    "RESOURCE_GROUP_NOT_FOUND" => Some(Self::ResourceGroupNotFound),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AwsMsk {
        #[prost(enumeration = "aws_msk::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub cluster_arn: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub topic: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub aws_role_arn: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub gcp_service_account: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `AwsMsk`.
    pub mod aws_msk {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Active = 1,
            MskPermissionDenied = 2,
            PublishPermissionDenied = 3,
            ClusterNotFound = 4,
            TopicNotFound = 5,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::MskPermissionDenied => "MSK_PERMISSION_DENIED",
                    Self::PublishPermissionDenied => "PUBLISH_PERMISSION_DENIED",
                    Self::ClusterNotFound => "CLUSTER_NOT_FOUND",
                    Self::TopicNotFound => "TOPIC_NOT_FOUND",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "MSK_PERMISSION_DENIED" => Some(Self::MskPermissionDenied),
                    "PUBLISH_PERMISSION_DENIED" => Some(Self::PublishPermissionDenied),
                    "CLUSTER_NOT_FOUND" => Some(Self::ClusterNotFound),
                    "TOPIC_NOT_FOUND" => Some(Self::TopicNotFound),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ConfluentCloud {
        #[prost(enumeration = "confluent_cloud::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub bootstrap_server: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub cluster_id: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub topic: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub identity_pool_id: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub gcp_service_account: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `ConfluentCloud`.
    pub mod confluent_cloud {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Active = 1,
            ConfluentCloudPermissionDenied = 2,
            PublishPermissionDenied = 3,
            UnreachableBootstrapServer = 4,
            ClusterNotFound = 5,
            TopicNotFound = 6,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::ConfluentCloudPermissionDenied => {
                        "CONFLUENT_CLOUD_PERMISSION_DENIED"
                    }
                    Self::PublishPermissionDenied => "PUBLISH_PERMISSION_DENIED",
                    Self::UnreachableBootstrapServer => "UNREACHABLE_BOOTSTRAP_SERVER",
                    Self::ClusterNotFound => "CLUSTER_NOT_FOUND",
                    Self::TopicNotFound => "TOPIC_NOT_FOUND",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "CONFLUENT_CLOUD_PERMISSION_DENIED" => {
                        Some(Self::ConfluentCloudPermissionDenied)
                    }
                    "PUBLISH_PERMISSION_DENIED" => Some(Self::PublishPermissionDenied),
                    "UNREACHABLE_BOOTSTRAP_SERVER" => {
                        Some(Self::UnreachableBootstrapServer)
                    }
                    "CLUSTER_NOT_FOUND" => Some(Self::ClusterNotFound),
                    "TOPIC_NOT_FOUND" => Some(Self::TopicNotFound),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "1")]
        AwsKinesis(AwsKinesis),
        #[prost(message, tag = "2")]
        CloudStorage(CloudStorage),
        #[prost(message, tag = "3")]
        AzureEventHubs(AzureEventHubs),
        #[prost(message, tag = "5")]
        AwsMsk(AwsMsk),
        #[prost(message, tag = "6")]
        ConfluentCloud(ConfluentCloud),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlatformLogsSettings {
    #[prost(enumeration = "platform_logs_settings::Severity", tag = "1")]
    pub severity: i32,
}
/// Nested message and enum types in `PlatformLogsSettings`.
pub mod platform_logs_settings {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Severity {
        Unspecified = 0,
        Disabled = 1,
        Debug = 2,
        Info = 3,
        Warning = 4,
        Error = 5,
    }
    impl Severity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SEVERITY_UNSPECIFIED",
                Self::Disabled => "DISABLED",
                Self::Debug => "DEBUG",
                Self::Info => "INFO",
                Self::Warning => "WARNING",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
                "DISABLED" => Some(Self::Disabled),
                "DEBUG" => Some(Self::Debug),
                "INFO" => Some(Self::Info),
                "WARNING" => Some(Self::Warning),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IngestionFailureEvent {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(oneof = "ingestion_failure_event::Failure", tags = "3, 4, 5, 6, 7")]
    pub failure: ::core::option::Option<ingestion_failure_event::Failure>,
}
/// Nested message and enum types in `IngestionFailureEvent`.
pub mod ingestion_failure_event {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ApiViolationReason {}
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AvroFailureReason {}
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SchemaViolationReason {}
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MessageTransformationFailureReason {}
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CloudStorageFailure {
        #[prost(string, tag = "1")]
        pub bucket: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub object_name: ::prost::alloc::string::String,
        #[prost(int64, tag = "3")]
        pub object_generation: i64,
        #[prost(oneof = "cloud_storage_failure::Reason", tags = "5, 6, 7, 8")]
        pub reason: ::core::option::Option<cloud_storage_failure::Reason>,
    }
    /// Nested message and enum types in `CloudStorageFailure`.
    pub mod cloud_storage_failure {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "5")]
            AvroFailureReason(super::AvroFailureReason),
            #[prost(message, tag = "6")]
            ApiViolationReason(super::ApiViolationReason),
            #[prost(message, tag = "7")]
            SchemaViolationReason(super::SchemaViolationReason),
            #[prost(message, tag = "8")]
            MessageTransformationFailureReason(
                super::MessageTransformationFailureReason,
            ),
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AwsMskFailureReason {
        #[prost(string, tag = "1")]
        pub cluster_arn: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub kafka_topic: ::prost::alloc::string::String,
        #[prost(int64, tag = "3")]
        pub partition_id: i64,
        #[prost(int64, tag = "4")]
        pub offset: i64,
        #[prost(oneof = "aws_msk_failure_reason::Reason", tags = "5, 6, 7")]
        pub reason: ::core::option::Option<aws_msk_failure_reason::Reason>,
    }
    /// Nested message and enum types in `AwsMskFailureReason`.
    pub mod aws_msk_failure_reason {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "5")]
            ApiViolationReason(super::ApiViolationReason),
            #[prost(message, tag = "6")]
            SchemaViolationReason(super::SchemaViolationReason),
            #[prost(message, tag = "7")]
            MessageTransformationFailureReason(
                super::MessageTransformationFailureReason,
            ),
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AzureEventHubsFailureReason {
        #[prost(string, tag = "1")]
        pub namespace: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub event_hub: ::prost::alloc::string::String,
        #[prost(int64, tag = "3")]
        pub partition_id: i64,
        #[prost(int64, tag = "4")]
        pub offset: i64,
        #[prost(oneof = "azure_event_hubs_failure_reason::Reason", tags = "5, 6, 7")]
        pub reason: ::core::option::Option<azure_event_hubs_failure_reason::Reason>,
    }
    /// Nested message and enum types in `AzureEventHubsFailureReason`.
    pub mod azure_event_hubs_failure_reason {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "5")]
            ApiViolationReason(super::ApiViolationReason),
            #[prost(message, tag = "6")]
            SchemaViolationReason(super::SchemaViolationReason),
            #[prost(message, tag = "7")]
            MessageTransformationFailureReason(
                super::MessageTransformationFailureReason,
            ),
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ConfluentCloudFailureReason {
        #[prost(string, tag = "1")]
        pub cluster_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub kafka_topic: ::prost::alloc::string::String,
        #[prost(int64, tag = "3")]
        pub partition_id: i64,
        #[prost(int64, tag = "4")]
        pub offset: i64,
        #[prost(oneof = "confluent_cloud_failure_reason::Reason", tags = "5, 6, 7")]
        pub reason: ::core::option::Option<confluent_cloud_failure_reason::Reason>,
    }
    /// Nested message and enum types in `ConfluentCloudFailureReason`.
    pub mod confluent_cloud_failure_reason {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "5")]
            ApiViolationReason(super::ApiViolationReason),
            #[prost(message, tag = "6")]
            SchemaViolationReason(super::SchemaViolationReason),
            #[prost(message, tag = "7")]
            MessageTransformationFailureReason(
                super::MessageTransformationFailureReason,
            ),
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AwsKinesisFailureReason {
        #[prost(string, tag = "1")]
        pub stream_arn: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub partition_key: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub sequence_number: ::prost::alloc::string::String,
        #[prost(oneof = "aws_kinesis_failure_reason::Reason", tags = "4, 5, 6")]
        pub reason: ::core::option::Option<aws_kinesis_failure_reason::Reason>,
    }
    /// Nested message and enum types in `AwsKinesisFailureReason`.
    pub mod aws_kinesis_failure_reason {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "4")]
            SchemaViolationReason(super::SchemaViolationReason),
            #[prost(message, tag = "5")]
            MessageTransformationFailureReason(
                super::MessageTransformationFailureReason,
            ),
            #[prost(message, tag = "6")]
            ApiViolationReason(super::ApiViolationReason),
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Failure {
        #[prost(message, tag = "3")]
        CloudStorageFailure(CloudStorageFailure),
        #[prost(message, tag = "4")]
        AwsMskFailure(AwsMskFailureReason),
        #[prost(message, tag = "5")]
        AzureEventHubsFailure(AzureEventHubsFailureReason),
        #[prost(message, tag = "6")]
        ConfluentCloudFailure(ConfluentCloudFailureReason),
        #[prost(message, tag = "7")]
        AwsKinesisFailure(AwsKinesisFailureReason),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct JavaScriptUdf {
    #[prost(string, tag = "1")]
    pub function_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MessageTransform {
    #[deprecated]
    #[prost(bool, tag = "3")]
    pub enabled: bool,
    #[prost(bool, tag = "4")]
    pub disabled: bool,
    #[prost(oneof = "message_transform::Transform", tags = "2")]
    pub transform: ::core::option::Option<message_transform::Transform>,
}
/// Nested message and enum types in `MessageTransform`.
pub mod message_transform {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Transform {
        #[prost(message, tag = "2")]
        JavascriptUdf(super::JavaScriptUdf),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Topic {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "2")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "3")]
    pub message_storage_policy: ::core::option::Option<MessageStoragePolicy>,
    #[prost(string, tag = "5")]
    pub kms_key_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub schema_settings: ::core::option::Option<SchemaSettings>,
    #[prost(bool, tag = "7")]
    pub satisfies_pzs: bool,
    #[prost(message, optional, tag = "8")]
    pub message_retention_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(enumeration = "topic::State", tag = "9")]
    pub state: i32,
    #[prost(message, optional, tag = "10")]
    pub ingestion_data_source_settings: ::core::option::Option<
        IngestionDataSourceSettings,
    >,
    #[prost(message, repeated, tag = "13")]
    pub message_transforms: ::prost::alloc::vec::Vec<MessageTransform>,
    #[prost(map = "string, string", tag = "14")]
    pub tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `Topic`.
pub mod topic {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        IngestionResourceError = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::IngestionResourceError => "INGESTION_RESOURCE_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INGESTION_RESOURCE_ERROR" => Some(Self::IngestionResourceError),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PubsubMessage {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(map = "string, string", tag = "2")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "3")]
    pub message_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub publish_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub ordering_key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTopicRequest {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTopicRequest {
    #[prost(message, optional, tag = "1")]
    pub topic: ::core::option::Option<Topic>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishRequest {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub messages: ::prost::alloc::vec::Vec<PubsubMessage>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PublishResponse {
    #[prost(string, repeated, tag = "1")]
    pub message_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListTopicsRequest {
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTopicsResponse {
    #[prost(message, repeated, tag = "1")]
    pub topics: ::prost::alloc::vec::Vec<Topic>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListTopicSubscriptionsRequest {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListTopicSubscriptionsResponse {
    #[prost(string, repeated, tag = "1")]
    pub subscriptions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListTopicSnapshotsRequest {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListTopicSnapshotsResponse {
    #[prost(string, repeated, tag = "1")]
    pub snapshots: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteTopicRequest {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DetachSubscriptionRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DetachSubscriptionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subscription {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub push_config: ::core::option::Option<PushConfig>,
    #[prost(message, optional, tag = "18")]
    pub bigquery_config: ::core::option::Option<BigQueryConfig>,
    #[prost(message, optional, tag = "22")]
    pub cloud_storage_config: ::core::option::Option<CloudStorageConfig>,
    #[prost(int32, tag = "5")]
    pub ack_deadline_seconds: i32,
    #[prost(bool, tag = "7")]
    pub retain_acked_messages: bool,
    #[prost(message, optional, tag = "8")]
    pub message_retention_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(map = "string, string", tag = "9")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "10")]
    pub enable_message_ordering: bool,
    #[prost(message, optional, tag = "11")]
    pub expiration_policy: ::core::option::Option<ExpirationPolicy>,
    #[prost(string, tag = "12")]
    pub filter: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "13")]
    pub dead_letter_policy: ::core::option::Option<DeadLetterPolicy>,
    #[prost(message, optional, tag = "14")]
    pub retry_policy: ::core::option::Option<RetryPolicy>,
    #[prost(bool, tag = "15")]
    pub detached: bool,
    #[prost(bool, tag = "16")]
    pub enable_exactly_once_delivery: bool,
    #[prost(message, optional, tag = "17")]
    pub topic_message_retention_duration: ::core::option::Option<
        ::prost_types::Duration,
    >,
    #[prost(enumeration = "subscription::State", tag = "19")]
    pub state: i32,
    #[prost(message, optional, tag = "23")]
    pub analytics_hub_subscription_info: ::core::option::Option<
        subscription::AnalyticsHubSubscriptionInfo,
    >,
    #[prost(message, repeated, tag = "25")]
    pub message_transforms: ::prost::alloc::vec::Vec<MessageTransform>,
    #[prost(map = "string, string", tag = "26")]
    pub tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `Subscription`.
pub mod subscription {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AnalyticsHubSubscriptionInfo {
        #[prost(string, tag = "1")]
        pub listing: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub subscription: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        ResourceError = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::ResourceError => "RESOURCE_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "RESOURCE_ERROR" => Some(Self::ResourceError),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RetryPolicy {
    #[prost(message, optional, tag = "1")]
    pub minimum_backoff: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "2")]
    pub maximum_backoff: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeadLetterPolicy {
    #[prost(string, tag = "1")]
    pub dead_letter_topic: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub max_delivery_attempts: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExpirationPolicy {
    #[prost(message, optional, tag = "1")]
    pub ttl: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushConfig {
    #[prost(string, tag = "1")]
    pub push_endpoint: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "2")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(oneof = "push_config::AuthenticationMethod", tags = "3")]
    pub authentication_method: ::core::option::Option<push_config::AuthenticationMethod>,
    #[prost(oneof = "push_config::Wrapper", tags = "4, 5")]
    pub wrapper: ::core::option::Option<push_config::Wrapper>,
}
/// Nested message and enum types in `PushConfig`.
pub mod push_config {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct OidcToken {
        #[prost(string, tag = "1")]
        pub service_account_email: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub audience: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PubsubWrapper {}
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct NoWrapper {
        #[prost(bool, tag = "1")]
        pub write_metadata: bool,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum AuthenticationMethod {
        #[prost(message, tag = "3")]
        OidcToken(OidcToken),
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Wrapper {
        #[prost(message, tag = "4")]
        PubsubWrapper(PubsubWrapper),
        #[prost(message, tag = "5")]
        NoWrapper(NoWrapper),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BigQueryConfig {
    #[prost(string, tag = "1")]
    pub table: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub use_topic_schema: bool,
    #[prost(bool, tag = "3")]
    pub write_metadata: bool,
    #[prost(bool, tag = "4")]
    pub drop_unknown_fields: bool,
    #[prost(enumeration = "big_query_config::State", tag = "5")]
    pub state: i32,
    #[prost(bool, tag = "6")]
    pub use_table_schema: bool,
    #[prost(string, tag = "7")]
    pub service_account_email: ::prost::alloc::string::String,
}
/// Nested message and enum types in `BigQueryConfig`.
pub mod big_query_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        PermissionDenied = 2,
        NotFound = 3,
        SchemaMismatch = 4,
        InTransitLocationRestriction = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::PermissionDenied => "PERMISSION_DENIED",
                Self::NotFound => "NOT_FOUND",
                Self::SchemaMismatch => "SCHEMA_MISMATCH",
                Self::InTransitLocationRestriction => "IN_TRANSIT_LOCATION_RESTRICTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                "NOT_FOUND" => Some(Self::NotFound),
                "SCHEMA_MISMATCH" => Some(Self::SchemaMismatch),
                "IN_TRANSIT_LOCATION_RESTRICTION" => {
                    Some(Self::InTransitLocationRestriction)
                }
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CloudStorageConfig {
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filename_prefix: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub filename_suffix: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub filename_datetime_format: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub max_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(int64, tag = "7")]
    pub max_bytes: i64,
    #[prost(int64, tag = "8")]
    pub max_messages: i64,
    #[prost(enumeration = "cloud_storage_config::State", tag = "9")]
    pub state: i32,
    #[prost(string, tag = "11")]
    pub service_account_email: ::prost::alloc::string::String,
    #[prost(oneof = "cloud_storage_config::OutputFormat", tags = "4, 5")]
    pub output_format: ::core::option::Option<cloud_storage_config::OutputFormat>,
}
/// Nested message and enum types in `CloudStorageConfig`.
pub mod cloud_storage_config {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct TextConfig {}
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AvroConfig {
        #[prost(bool, tag = "1")]
        pub write_metadata: bool,
        #[prost(bool, tag = "2")]
        pub use_topic_schema: bool,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        PermissionDenied = 2,
        NotFound = 3,
        InTransitLocationRestriction = 4,
        SchemaMismatch = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::PermissionDenied => "PERMISSION_DENIED",
                Self::NotFound => "NOT_FOUND",
                Self::InTransitLocationRestriction => "IN_TRANSIT_LOCATION_RESTRICTION",
                Self::SchemaMismatch => "SCHEMA_MISMATCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                "NOT_FOUND" => Some(Self::NotFound),
                "IN_TRANSIT_LOCATION_RESTRICTION" => {
                    Some(Self::InTransitLocationRestriction)
                }
                "SCHEMA_MISMATCH" => Some(Self::SchemaMismatch),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum OutputFormat {
        #[prost(message, tag = "4")]
        TextConfig(TextConfig),
        #[prost(message, tag = "5")]
        AvroConfig(AvroConfig),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceivedMessage {
    #[prost(string, tag = "1")]
    pub ack_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub message: ::core::option::Option<PubsubMessage>,
    #[prost(int32, tag = "3")]
    pub delivery_attempt: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSubscriptionRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSubscriptionRequest {
    #[prost(message, optional, tag = "1")]
    pub subscription: ::core::option::Option<Subscription>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSubscriptionsRequest {
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubscriptionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub subscriptions: ::prost::alloc::vec::Vec<Subscription>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteSubscriptionRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModifyPushConfigRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub push_config: ::core::option::Option<PushConfig>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PullRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(bool, tag = "2")]
    pub return_immediately: bool,
    #[prost(int32, tag = "3")]
    pub max_messages: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullResponse {
    #[prost(message, repeated, tag = "1")]
    pub received_messages: ::prost::alloc::vec::Vec<ReceivedMessage>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ModifyAckDeadlineRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub ack_deadline_seconds: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AcknowledgeRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StreamingPullRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub modify_deadline_seconds: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag = "4")]
    pub modify_deadline_ack_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(int32, tag = "5")]
    pub stream_ack_deadline_seconds: i32,
    #[prost(string, tag = "6")]
    pub client_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "7")]
    pub max_outstanding_messages: i64,
    #[prost(int64, tag = "8")]
    pub max_outstanding_bytes: i64,
    #[prost(int64, tag = "10")]
    pub protocol_version: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingPullResponse {
    #[prost(message, repeated, tag = "1")]
    pub received_messages: ::prost::alloc::vec::Vec<ReceivedMessage>,
    #[prost(message, optional, tag = "5")]
    pub acknowledge_confirmation: ::core::option::Option<
        streaming_pull_response::AcknowledgeConfirmation,
    >,
    #[prost(message, optional, tag = "3")]
    pub modify_ack_deadline_confirmation: ::core::option::Option<
        streaming_pull_response::ModifyAckDeadlineConfirmation,
    >,
    #[prost(message, optional, tag = "4")]
    pub subscription_properties: ::core::option::Option<
        streaming_pull_response::SubscriptionProperties,
    >,
}
/// Nested message and enum types in `StreamingPullResponse`.
pub mod streaming_pull_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AcknowledgeConfirmation {
        #[prost(string, repeated, tag = "1")]
        pub ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "2")]
        pub invalid_ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub unordered_ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "4")]
        pub temporary_failed_ack_ids: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ModifyAckDeadlineConfirmation {
        #[prost(string, repeated, tag = "1")]
        pub ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "2")]
        pub invalid_ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub temporary_failed_ack_ids: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SubscriptionProperties {
        #[prost(bool, tag = "1")]
        pub exactly_once_delivery_enabled: bool,
        #[prost(bool, tag = "2")]
        pub message_ordering_enabled: bool,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSnapshotRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "4")]
    pub tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSnapshotRequest {
    #[prost(message, optional, tag = "1")]
    pub snapshot: ::core::option::Option<Snapshot>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Snapshot {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub expire_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSnapshotRequest {
    #[prost(string, tag = "1")]
    pub snapshot: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSnapshotsRequest {
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSnapshotsResponse {
    #[prost(message, repeated, tag = "1")]
    pub snapshots: ::prost::alloc::vec::Vec<Snapshot>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteSnapshotRequest {
    #[prost(string, tag = "1")]
    pub snapshot: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SeekRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(oneof = "seek_request::Target", tags = "2, 3")]
    pub target: ::core::option::Option<seek_request::Target>,
}
/// Nested message and enum types in `SeekRequest`.
pub mod seek_request {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Target {
        #[prost(message, tag = "2")]
        Time(::prost_types::Timestamp),
        #[prost(string, tag = "3")]
        Snapshot(::prost::alloc::string::String),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SeekResponse {}
/// Generated client implementations.
pub mod publisher_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The service that an application uses to manipulate topics, and to send
    /// messages to a topic.
    #[derive(Debug, Clone)]
    pub struct PublisherClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> PublisherClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PublisherClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PublisherClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates the given topic with the given name. See the [resource name rules]
        /// (https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names).
        pub async fn create_topic(
            &mut self,
            request: impl tonic::IntoRequest<super::Topic>,
        ) -> std::result::Result<tonic::Response<super::Topic>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Publisher/CreateTopic",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.pubsub.v1.Publisher", "CreateTopic"));
            self.inner.unary(req, path, codec).await
        }
        /// Updates an existing topic by updating the fields specified in the update
        /// mask. Note that certain properties of a topic are not modifiable.
        pub async fn update_topic(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTopicRequest>,
        ) -> std::result::Result<tonic::Response<super::Topic>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Publisher/UpdateTopic",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.pubsub.v1.Publisher", "UpdateTopic"));
            self.inner.unary(req, path, codec).await
        }
        /// Adds one or more messages to the topic. Returns `NOT_FOUND` if the topic
        /// does not exist.
        pub async fn publish(
            &mut self,
            request: impl tonic::IntoRequest<super::PublishRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PublishResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Publisher/Publish",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.pubsub.v1.Publisher", "Publish"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the configuration of a topic.
        pub async fn get_topic(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTopicRequest>,
        ) -> std::result::Result<tonic::Response<super::Topic>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Publisher/GetTopic",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.pubsub.v1.Publisher", "GetTopic"));
            self.inner.unary(req, path, codec).await
        }
        /// Lists matching topics.
        pub async fn list_topics(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTopicsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTopicsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Publisher/ListTopics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.pubsub.v1.Publisher", "ListTopics"));
            self.inner.unary(req, path, codec).await
        }
        /// Lists the names of the attached subscriptions on this topic.
        pub async fn list_topic_subscriptions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTopicSubscriptionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTopicSubscriptionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Publisher/ListTopicSubscriptions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.pubsub.v1.Publisher",
                        "ListTopicSubscriptions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the names of the snapshots on this topic. Snapshots are used in
        /// [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,
        /// which allow you to manage message acknowledgments in bulk. That is, you can
        /// set the acknowledgment state of messages in an existing subscription to the
        /// state captured by a snapshot.
        pub async fn list_topic_snapshots(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTopicSnapshotsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTopicSnapshotsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Publisher/ListTopicSnapshots",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.Publisher", "ListTopicSnapshots"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the topic with the given name. Returns `NOT_FOUND` if the topic
        /// does not exist. After a topic is deleted, a new topic may be created with
        /// the same name; this is an entirely new topic with none of the old
        /// configuration or subscriptions. Existing subscriptions to this topic are
        /// not deleted, but their `topic` field is set to `_deleted-topic_`.
        pub async fn delete_topic(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTopicRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Publisher/DeleteTopic",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.pubsub.v1.Publisher", "DeleteTopic"));
            self.inner.unary(req, path, codec).await
        }
        /// Detaches a subscription from this topic. All messages retained in the
        /// subscription are dropped. Subsequent `Pull` and `StreamingPull` requests
        /// will return FAILED_PRECONDITION. If the subscription is a push
        /// subscription, pushes to the endpoint will stop.
        pub async fn detach_subscription(
            &mut self,
            request: impl tonic::IntoRequest<super::DetachSubscriptionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DetachSubscriptionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Publisher/DetachSubscription",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.Publisher", "DetachSubscription"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod publisher_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with PublisherServer.
    #[async_trait]
    pub trait Publisher: std::marker::Send + std::marker::Sync + 'static {
        /// Creates the given topic with the given name. See the [resource name rules]
        /// (https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names).
        async fn create_topic(
            &self,
            request: tonic::Request<super::Topic>,
        ) -> std::result::Result<tonic::Response<super::Topic>, tonic::Status>;
        /// Updates an existing topic by updating the fields specified in the update
        /// mask. Note that certain properties of a topic are not modifiable.
        async fn update_topic(
            &self,
            request: tonic::Request<super::UpdateTopicRequest>,
        ) -> std::result::Result<tonic::Response<super::Topic>, tonic::Status>;
        /// Adds one or more messages to the topic. Returns `NOT_FOUND` if the topic
        /// does not exist.
        async fn publish(
            &self,
            request: tonic::Request<super::PublishRequest>,
        ) -> std::result::Result<tonic::Response<super::PublishResponse>, tonic::Status>;
        /// Gets the configuration of a topic.
        async fn get_topic(
            &self,
            request: tonic::Request<super::GetTopicRequest>,
        ) -> std::result::Result<tonic::Response<super::Topic>, tonic::Status>;
        /// Lists matching topics.
        async fn list_topics(
            &self,
            request: tonic::Request<super::ListTopicsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTopicsResponse>,
            tonic::Status,
        >;
        /// Lists the names of the attached subscriptions on this topic.
        async fn list_topic_subscriptions(
            &self,
            request: tonic::Request<super::ListTopicSubscriptionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTopicSubscriptionsResponse>,
            tonic::Status,
        >;
        /// Lists the names of the snapshots on this topic. Snapshots are used in
        /// [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,
        /// which allow you to manage message acknowledgments in bulk. That is, you can
        /// set the acknowledgment state of messages in an existing subscription to the
        /// state captured by a snapshot.
        async fn list_topic_snapshots(
            &self,
            request: tonic::Request<super::ListTopicSnapshotsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTopicSnapshotsResponse>,
            tonic::Status,
        >;
        /// Deletes the topic with the given name. Returns `NOT_FOUND` if the topic
        /// does not exist. After a topic is deleted, a new topic may be created with
        /// the same name; this is an entirely new topic with none of the old
        /// configuration or subscriptions. Existing subscriptions to this topic are
        /// not deleted, but their `topic` field is set to `_deleted-topic_`.
        async fn delete_topic(
            &self,
            request: tonic::Request<super::DeleteTopicRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Detaches a subscription from this topic. All messages retained in the
        /// subscription are dropped. Subsequent `Pull` and `StreamingPull` requests
        /// will return FAILED_PRECONDITION. If the subscription is a push
        /// subscription, pushes to the endpoint will stop.
        async fn detach_subscription(
            &self,
            request: tonic::Request<super::DetachSubscriptionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DetachSubscriptionResponse>,
            tonic::Status,
        >;
    }
    /// The service that an application uses to manipulate topics, and to send
    /// messages to a topic.
    #[derive(Debug)]
    pub struct PublisherServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> PublisherServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for PublisherServer<T>
    where
        T: Publisher,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.pubsub.v1.Publisher/CreateTopic" => {
                    #[allow(non_camel_case_types)]
                    struct CreateTopicSvc<T: Publisher>(pub Arc<T>);
                    impl<T: Publisher> tonic::server::UnaryService<super::Topic>
                    for CreateTopicSvc<T> {
                        type Response = super::Topic;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Topic>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Publisher>::create_topic(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateTopicSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Publisher/UpdateTopic" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateTopicSvc<T: Publisher>(pub Arc<T>);
                    impl<
                        T: Publisher,
                    > tonic::server::UnaryService<super::UpdateTopicRequest>
                    for UpdateTopicSvc<T> {
                        type Response = super::Topic;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateTopicRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Publisher>::update_topic(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateTopicSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Publisher/Publish" => {
                    #[allow(non_camel_case_types)]
                    struct PublishSvc<T: Publisher>(pub Arc<T>);
                    impl<T: Publisher> tonic::server::UnaryService<super::PublishRequest>
                    for PublishSvc<T> {
                        type Response = super::PublishResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PublishRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Publisher>::publish(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PublishSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Publisher/GetTopic" => {
                    #[allow(non_camel_case_types)]
                    struct GetTopicSvc<T: Publisher>(pub Arc<T>);
                    impl<
                        T: Publisher,
                    > tonic::server::UnaryService<super::GetTopicRequest>
                    for GetTopicSvc<T> {
                        type Response = super::Topic;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTopicRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Publisher>::get_topic(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTopicSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Publisher/ListTopics" => {
                    #[allow(non_camel_case_types)]
                    struct ListTopicsSvc<T: Publisher>(pub Arc<T>);
                    impl<
                        T: Publisher,
                    > tonic::server::UnaryService<super::ListTopicsRequest>
                    for ListTopicsSvc<T> {
                        type Response = super::ListTopicsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListTopicsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Publisher>::list_topics(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListTopicsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Publisher/ListTopicSubscriptions" => {
                    #[allow(non_camel_case_types)]
                    struct ListTopicSubscriptionsSvc<T: Publisher>(pub Arc<T>);
                    impl<
                        T: Publisher,
                    > tonic::server::UnaryService<super::ListTopicSubscriptionsRequest>
                    for ListTopicSubscriptionsSvc<T> {
                        type Response = super::ListTopicSubscriptionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListTopicSubscriptionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Publisher>::list_topic_subscriptions(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListTopicSubscriptionsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Publisher/ListTopicSnapshots" => {
                    #[allow(non_camel_case_types)]
                    struct ListTopicSnapshotsSvc<T: Publisher>(pub Arc<T>);
                    impl<
                        T: Publisher,
                    > tonic::server::UnaryService<super::ListTopicSnapshotsRequest>
                    for ListTopicSnapshotsSvc<T> {
                        type Response = super::ListTopicSnapshotsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListTopicSnapshotsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Publisher>::list_topic_snapshots(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListTopicSnapshotsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Publisher/DeleteTopic" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteTopicSvc<T: Publisher>(pub Arc<T>);
                    impl<
                        T: Publisher,
                    > tonic::server::UnaryService<super::DeleteTopicRequest>
                    for DeleteTopicSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteTopicRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Publisher>::delete_topic(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteTopicSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Publisher/DetachSubscription" => {
                    #[allow(non_camel_case_types)]
                    struct DetachSubscriptionSvc<T: Publisher>(pub Arc<T>);
                    impl<
                        T: Publisher,
                    > tonic::server::UnaryService<super::DetachSubscriptionRequest>
                    for DetachSubscriptionSvc<T> {
                        type Response = super::DetachSubscriptionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DetachSubscriptionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Publisher>::detach_subscription(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DetachSubscriptionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for PublisherServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.pubsub.v1.Publisher";
    impl<T> tonic::server::NamedService for PublisherServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated client implementations.
pub mod subscriber_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The service that an application uses to manipulate subscriptions and to
    /// consume messages from a subscription via the `Pull` method or by
    /// establishing a bi-directional stream using the `StreamingPull` method.
    #[derive(Debug, Clone)]
    pub struct SubscriberClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SubscriberClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SubscriberClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SubscriberClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a subscription to a given topic. See the [resource name rules]
        /// (https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names).
        /// If the subscription already exists, returns `ALREADY_EXISTS`.
        /// If the corresponding topic doesn't exist, returns `NOT_FOUND`.
        ///
        /// If the name is not provided in the request, the server will assign a random
        /// name for this subscription on the same project as the topic, conforming
        /// to the [resource name format]
        /// (https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names). The
        /// generated name is populated in the returned Subscription object. Note that
        /// for REST API requests, you must specify a name in the request.
        pub async fn create_subscription(
            &mut self,
            request: impl tonic::IntoRequest<super::Subscription>,
        ) -> std::result::Result<tonic::Response<super::Subscription>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/CreateSubscription",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.Subscriber", "CreateSubscription"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the configuration details of a subscription.
        pub async fn get_subscription(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSubscriptionRequest>,
        ) -> std::result::Result<tonic::Response<super::Subscription>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/GetSubscription",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.Subscriber", "GetSubscription"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an existing subscription by updating the fields specified in the
        /// update mask. Note that certain properties of a subscription, such as its
        /// topic, are not modifiable.
        pub async fn update_subscription(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSubscriptionRequest>,
        ) -> std::result::Result<tonic::Response<super::Subscription>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/UpdateSubscription",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.Subscriber", "UpdateSubscription"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists matching subscriptions.
        pub async fn list_subscriptions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSubscriptionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSubscriptionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/ListSubscriptions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.Subscriber", "ListSubscriptions"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an existing subscription. All messages retained in the subscription
        /// are immediately dropped. Calls to `Pull` after deletion will return
        /// `NOT_FOUND`. After a subscription is deleted, a new one may be created with
        /// the same name, but the new one has no association with the old
        /// subscription or its topic unless the same topic is specified.
        pub async fn delete_subscription(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSubscriptionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/DeleteSubscription",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.Subscriber", "DeleteSubscription"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Modifies the ack deadline for a specific message. This method is useful
        /// to indicate that more time is needed to process a message by the
        /// subscriber, or to make the message available for redelivery if the
        /// processing was interrupted. Note that this does not modify the
        /// subscription-level `ackDeadlineSeconds` used for subsequent messages.
        pub async fn modify_ack_deadline(
            &mut self,
            request: impl tonic::IntoRequest<super::ModifyAckDeadlineRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/ModifyAckDeadline",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.Subscriber", "ModifyAckDeadline"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Acknowledges the messages associated with the `ack_ids` in the
        /// `AcknowledgeRequest`. The Pub/Sub system can remove the relevant messages
        /// from the subscription.
        ///
        /// Acknowledging a message whose ack deadline has expired may succeed,
        /// but such a message may be redelivered later. Acknowledging a message more
        /// than once will not result in an error.
        pub async fn acknowledge(
            &mut self,
            request: impl tonic::IntoRequest<super::AcknowledgeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/Acknowledge",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.pubsub.v1.Subscriber", "Acknowledge"));
            self.inner.unary(req, path, codec).await
        }
        /// Pulls messages from the server.
        pub async fn pull(
            &mut self,
            request: impl tonic::IntoRequest<super::PullRequest>,
        ) -> std::result::Result<tonic::Response<super::PullResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/Pull",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.pubsub.v1.Subscriber", "Pull"));
            self.inner.unary(req, path, codec).await
        }
        /// Establishes a stream with the server, which sends messages down to the
        /// client. The client streams acknowledgments and ack deadline modifications
        /// back to the server. The server will close the stream and return the status
        /// on any error. The server may close the stream with status `UNAVAILABLE` to
        /// reassign server-side resources, in which case, the client should
        /// re-establish the stream. Flow control can be achieved by configuring the
        /// underlying RPC channel.
        pub async fn streaming_pull(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::StreamingPullRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::StreamingPullResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/StreamingPull",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.pubsub.v1.Subscriber", "StreamingPull"));
            self.inner.streaming(req, path, codec).await
        }
        /// Modifies the `PushConfig` for a specified subscription.
        ///
        /// This may be used to change a push subscription to a pull one (signified by
        /// an empty `PushConfig`) or vice versa, or change the endpoint URL and other
        /// attributes of a push subscription. Messages will accumulate for delivery
        /// continuously through the call regardless of changes to the `PushConfig`.
        pub async fn modify_push_config(
            &mut self,
            request: impl tonic::IntoRequest<super::ModifyPushConfigRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/ModifyPushConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.Subscriber", "ModifyPushConfig"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the configuration details of a snapshot. Snapshots are used in
        /// [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,
        /// which allow you to manage message acknowledgments in bulk. That is, you can
        /// set the acknowledgment state of messages in an existing subscription to the
        /// state captured by a snapshot.
        pub async fn get_snapshot(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Snapshot>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/GetSnapshot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.pubsub.v1.Subscriber", "GetSnapshot"));
            self.inner.unary(req, path, codec).await
        }
        /// Lists the existing snapshots. Snapshots are used in [Seek](
        /// https://cloud.google.com/pubsub/docs/replay-overview) operations, which
        /// allow you to manage message acknowledgments in bulk. That is, you can set
        /// the acknowledgment state of messages in an existing subscription to the
        /// state captured by a snapshot.
        pub async fn list_snapshots(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSnapshotsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSnapshotsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/ListSnapshots",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.pubsub.v1.Subscriber", "ListSnapshots"));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a snapshot from the requested subscription. Snapshots are used in
        /// [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,
        /// which allow you to manage message acknowledgments in bulk. That is, you can
        /// set the acknowledgment state of messages in an existing subscription to the
        /// state captured by a snapshot.
        /// If the snapshot already exists, returns `ALREADY_EXISTS`.
        /// If the requested subscription doesn't exist, returns `NOT_FOUND`.
        /// If the backlog in the subscription is too old -- and the resulting snapshot
        /// would expire in less than 1 hour -- then `FAILED_PRECONDITION` is returned.
        /// See also the `Snapshot.expire_time` field. If the name is not provided in
        /// the request, the server will assign a random
        /// name for this snapshot on the same project as the subscription, conforming
        /// to the [resource name format]
        /// (https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names). The
        /// generated name is populated in the returned Snapshot object. Note that for
        /// REST API requests, you must specify a name in the request.
        pub async fn create_snapshot(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Snapshot>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/CreateSnapshot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.Subscriber", "CreateSnapshot"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an existing snapshot by updating the fields specified in the update
        /// mask. Snapshots are used in
        /// [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,
        /// which allow you to manage message acknowledgments in bulk. That is, you can
        /// set the acknowledgment state of messages in an existing subscription to the
        /// state captured by a snapshot.
        pub async fn update_snapshot(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Snapshot>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/UpdateSnapshot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.Subscriber", "UpdateSnapshot"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Removes an existing snapshot. Snapshots are used in [Seek]
        /// (https://cloud.google.com/pubsub/docs/replay-overview) operations, which
        /// allow you to manage message acknowledgments in bulk. That is, you can set
        /// the acknowledgment state of messages in an existing subscription to the
        /// state captured by a snapshot.
        /// When the snapshot is deleted, all messages retained in the snapshot
        /// are immediately dropped. After a snapshot is deleted, a new one may be
        /// created with the same name, but the new one has no association with the old
        /// snapshot or its subscription, unless the same subscription is specified.
        pub async fn delete_snapshot(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/DeleteSnapshot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.pubsub.v1.Subscriber", "DeleteSnapshot"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Seeks an existing subscription to a point in time or to a given snapshot,
        /// whichever is provided in the request. Snapshots are used in [Seek]
        /// (https://cloud.google.com/pubsub/docs/replay-overview) operations, which
        /// allow you to manage message acknowledgments in bulk. That is, you can set
        /// the acknowledgment state of messages in an existing subscription to the
        /// state captured by a snapshot. Note that both the subscription and the
        /// snapshot must be on the same topic.
        pub async fn seek(
            &mut self,
            request: impl tonic::IntoRequest<super::SeekRequest>,
        ) -> std::result::Result<tonic::Response<super::SeekResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.pubsub.v1.Subscriber/Seek",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.pubsub.v1.Subscriber", "Seek"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod subscriber_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SubscriberServer.
    #[async_trait]
    pub trait Subscriber: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a subscription to a given topic. See the [resource name rules]
        /// (https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names).
        /// If the subscription already exists, returns `ALREADY_EXISTS`.
        /// If the corresponding topic doesn't exist, returns `NOT_FOUND`.
        ///
        /// If the name is not provided in the request, the server will assign a random
        /// name for this subscription on the same project as the topic, conforming
        /// to the [resource name format]
        /// (https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names). The
        /// generated name is populated in the returned Subscription object. Note that
        /// for REST API requests, you must specify a name in the request.
        async fn create_subscription(
            &self,
            request: tonic::Request<super::Subscription>,
        ) -> std::result::Result<tonic::Response<super::Subscription>, tonic::Status>;
        /// Gets the configuration details of a subscription.
        async fn get_subscription(
            &self,
            request: tonic::Request<super::GetSubscriptionRequest>,
        ) -> std::result::Result<tonic::Response<super::Subscription>, tonic::Status>;
        /// Updates an existing subscription by updating the fields specified in the
        /// update mask. Note that certain properties of a subscription, such as its
        /// topic, are not modifiable.
        async fn update_subscription(
            &self,
            request: tonic::Request<super::UpdateSubscriptionRequest>,
        ) -> std::result::Result<tonic::Response<super::Subscription>, tonic::Status>;
        /// Lists matching subscriptions.
        async fn list_subscriptions(
            &self,
            request: tonic::Request<super::ListSubscriptionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSubscriptionsResponse>,
            tonic::Status,
        >;
        /// Deletes an existing subscription. All messages retained in the subscription
        /// are immediately dropped. Calls to `Pull` after deletion will return
        /// `NOT_FOUND`. After a subscription is deleted, a new one may be created with
        /// the same name, but the new one has no association with the old
        /// subscription or its topic unless the same topic is specified.
        async fn delete_subscription(
            &self,
            request: tonic::Request<super::DeleteSubscriptionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Modifies the ack deadline for a specific message. This method is useful
        /// to indicate that more time is needed to process a message by the
        /// subscriber, or to make the message available for redelivery if the
        /// processing was interrupted. Note that this does not modify the
        /// subscription-level `ackDeadlineSeconds` used for subsequent messages.
        async fn modify_ack_deadline(
            &self,
            request: tonic::Request<super::ModifyAckDeadlineRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Acknowledges the messages associated with the `ack_ids` in the
        /// `AcknowledgeRequest`. The Pub/Sub system can remove the relevant messages
        /// from the subscription.
        ///
        /// Acknowledging a message whose ack deadline has expired may succeed,
        /// but such a message may be redelivered later. Acknowledging a message more
        /// than once will not result in an error.
        async fn acknowledge(
            &self,
            request: tonic::Request<super::AcknowledgeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Pulls messages from the server.
        async fn pull(
            &self,
            request: tonic::Request<super::PullRequest>,
        ) -> std::result::Result<tonic::Response<super::PullResponse>, tonic::Status>;
        /// Server streaming response type for the StreamingPull method.
        type StreamingPullStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::StreamingPullResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Establishes a stream with the server, which sends messages down to the
        /// client. The client streams acknowledgments and ack deadline modifications
        /// back to the server. The server will close the stream and return the status
        /// on any error. The server may close the stream with status `UNAVAILABLE` to
        /// reassign server-side resources, in which case, the client should
        /// re-establish the stream. Flow control can be achieved by configuring the
        /// underlying RPC channel.
        async fn streaming_pull(
            &self,
            request: tonic::Request<tonic::Streaming<super::StreamingPullRequest>>,
        ) -> std::result::Result<
            tonic::Response<Self::StreamingPullStream>,
            tonic::Status,
        >;
        /// Modifies the `PushConfig` for a specified subscription.
        ///
        /// This may be used to change a push subscription to a pull one (signified by
        /// an empty `PushConfig`) or vice versa, or change the endpoint URL and other
        /// attributes of a push subscription. Messages will accumulate for delivery
        /// continuously through the call regardless of changes to the `PushConfig`.
        async fn modify_push_config(
            &self,
            request: tonic::Request<super::ModifyPushConfigRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Gets the configuration details of a snapshot. Snapshots are used in
        /// [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,
        /// which allow you to manage message acknowledgments in bulk. That is, you can
        /// set the acknowledgment state of messages in an existing subscription to the
        /// state captured by a snapshot.
        async fn get_snapshot(
            &self,
            request: tonic::Request<super::GetSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Snapshot>, tonic::Status>;
        /// Lists the existing snapshots. Snapshots are used in [Seek](
        /// https://cloud.google.com/pubsub/docs/replay-overview) operations, which
        /// allow you to manage message acknowledgments in bulk. That is, you can set
        /// the acknowledgment state of messages in an existing subscription to the
        /// state captured by a snapshot.
        async fn list_snapshots(
            &self,
            request: tonic::Request<super::ListSnapshotsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSnapshotsResponse>,
            tonic::Status,
        >;
        /// Creates a snapshot from the requested subscription. Snapshots are used in
        /// [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,
        /// which allow you to manage message acknowledgments in bulk. That is, you can
        /// set the acknowledgment state of messages in an existing subscription to the
        /// state captured by a snapshot.
        /// If the snapshot already exists, returns `ALREADY_EXISTS`.
        /// If the requested subscription doesn't exist, returns `NOT_FOUND`.
        /// If the backlog in the subscription is too old -- and the resulting snapshot
        /// would expire in less than 1 hour -- then `FAILED_PRECONDITION` is returned.
        /// See also the `Snapshot.expire_time` field. If the name is not provided in
        /// the request, the server will assign a random
        /// name for this snapshot on the same project as the subscription, conforming
        /// to the [resource name format]
        /// (https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names). The
        /// generated name is populated in the returned Snapshot object. Note that for
        /// REST API requests, you must specify a name in the request.
        async fn create_snapshot(
            &self,
            request: tonic::Request<super::CreateSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Snapshot>, tonic::Status>;
        /// Updates an existing snapshot by updating the fields specified in the update
        /// mask. Snapshots are used in
        /// [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,
        /// which allow you to manage message acknowledgments in bulk. That is, you can
        /// set the acknowledgment state of messages in an existing subscription to the
        /// state captured by a snapshot.
        async fn update_snapshot(
            &self,
            request: tonic::Request<super::UpdateSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Snapshot>, tonic::Status>;
        /// Removes an existing snapshot. Snapshots are used in [Seek]
        /// (https://cloud.google.com/pubsub/docs/replay-overview) operations, which
        /// allow you to manage message acknowledgments in bulk. That is, you can set
        /// the acknowledgment state of messages in an existing subscription to the
        /// state captured by a snapshot.
        /// When the snapshot is deleted, all messages retained in the snapshot
        /// are immediately dropped. After a snapshot is deleted, a new one may be
        /// created with the same name, but the new one has no association with the old
        /// snapshot or its subscription, unless the same subscription is specified.
        async fn delete_snapshot(
            &self,
            request: tonic::Request<super::DeleteSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Seeks an existing subscription to a point in time or to a given snapshot,
        /// whichever is provided in the request. Snapshots are used in [Seek]
        /// (https://cloud.google.com/pubsub/docs/replay-overview) operations, which
        /// allow you to manage message acknowledgments in bulk. That is, you can set
        /// the acknowledgment state of messages in an existing subscription to the
        /// state captured by a snapshot. Note that both the subscription and the
        /// snapshot must be on the same topic.
        async fn seek(
            &self,
            request: tonic::Request<super::SeekRequest>,
        ) -> std::result::Result<tonic::Response<super::SeekResponse>, tonic::Status>;
    }
    /// The service that an application uses to manipulate subscriptions and to
    /// consume messages from a subscription via the `Pull` method or by
    /// establishing a bi-directional stream using the `StreamingPull` method.
    #[derive(Debug)]
    pub struct SubscriberServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SubscriberServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SubscriberServer<T>
    where
        T: Subscriber,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.pubsub.v1.Subscriber/CreateSubscription" => {
                    #[allow(non_camel_case_types)]
                    struct CreateSubscriptionSvc<T: Subscriber>(pub Arc<T>);
                    impl<T: Subscriber> tonic::server::UnaryService<super::Subscription>
                    for CreateSubscriptionSvc<T> {
                        type Response = super::Subscription;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Subscription>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::create_subscription(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateSubscriptionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/GetSubscription" => {
                    #[allow(non_camel_case_types)]
                    struct GetSubscriptionSvc<T: Subscriber>(pub Arc<T>);
                    impl<
                        T: Subscriber,
                    > tonic::server::UnaryService<super::GetSubscriptionRequest>
                    for GetSubscriptionSvc<T> {
                        type Response = super::Subscription;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSubscriptionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::get_subscription(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSubscriptionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/UpdateSubscription" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateSubscriptionSvc<T: Subscriber>(pub Arc<T>);
                    impl<
                        T: Subscriber,
                    > tonic::server::UnaryService<super::UpdateSubscriptionRequest>
                    for UpdateSubscriptionSvc<T> {
                        type Response = super::Subscription;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateSubscriptionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::update_subscription(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateSubscriptionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/ListSubscriptions" => {
                    #[allow(non_camel_case_types)]
                    struct ListSubscriptionsSvc<T: Subscriber>(pub Arc<T>);
                    impl<
                        T: Subscriber,
                    > tonic::server::UnaryService<super::ListSubscriptionsRequest>
                    for ListSubscriptionsSvc<T> {
                        type Response = super::ListSubscriptionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListSubscriptionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::list_subscriptions(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListSubscriptionsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/DeleteSubscription" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSubscriptionSvc<T: Subscriber>(pub Arc<T>);
                    impl<
                        T: Subscriber,
                    > tonic::server::UnaryService<super::DeleteSubscriptionRequest>
                    for DeleteSubscriptionSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteSubscriptionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::delete_subscription(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteSubscriptionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/ModifyAckDeadline" => {
                    #[allow(non_camel_case_types)]
                    struct ModifyAckDeadlineSvc<T: Subscriber>(pub Arc<T>);
                    impl<
                        T: Subscriber,
                    > tonic::server::UnaryService<super::ModifyAckDeadlineRequest>
                    for ModifyAckDeadlineSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ModifyAckDeadlineRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::modify_ack_deadline(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ModifyAckDeadlineSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/Acknowledge" => {
                    #[allow(non_camel_case_types)]
                    struct AcknowledgeSvc<T: Subscriber>(pub Arc<T>);
                    impl<
                        T: Subscriber,
                    > tonic::server::UnaryService<super::AcknowledgeRequest>
                    for AcknowledgeSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AcknowledgeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::acknowledge(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AcknowledgeSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/Pull" => {
                    #[allow(non_camel_case_types)]
                    struct PullSvc<T: Subscriber>(pub Arc<T>);
                    impl<T: Subscriber> tonic::server::UnaryService<super::PullRequest>
                    for PullSvc<T> {
                        type Response = super::PullResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PullRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::pull(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PullSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/StreamingPull" => {
                    #[allow(non_camel_case_types)]
                    struct StreamingPullSvc<T: Subscriber>(pub Arc<T>);
                    impl<
                        T: Subscriber,
                    > tonic::server::StreamingService<super::StreamingPullRequest>
                    for StreamingPullSvc<T> {
                        type Response = super::StreamingPullResponse;
                        type ResponseStream = T::StreamingPullStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::StreamingPullRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::streaming_pull(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StreamingPullSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/ModifyPushConfig" => {
                    #[allow(non_camel_case_types)]
                    struct ModifyPushConfigSvc<T: Subscriber>(pub Arc<T>);
                    impl<
                        T: Subscriber,
                    > tonic::server::UnaryService<super::ModifyPushConfigRequest>
                    for ModifyPushConfigSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ModifyPushConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::modify_push_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ModifyPushConfigSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/GetSnapshot" => {
                    #[allow(non_camel_case_types)]
                    struct GetSnapshotSvc<T: Subscriber>(pub Arc<T>);
                    impl<
                        T: Subscriber,
                    > tonic::server::UnaryService<super::GetSnapshotRequest>
                    for GetSnapshotSvc<T> {
                        type Response = super::Snapshot;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSnapshotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::get_snapshot(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSnapshotSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/ListSnapshots" => {
                    #[allow(non_camel_case_types)]
                    struct ListSnapshotsSvc<T: Subscriber>(pub Arc<T>);
                    impl<
                        T: Subscriber,
                    > tonic::server::UnaryService<super::ListSnapshotsRequest>
                    for ListSnapshotsSvc<T> {
                        type Response = super::ListSnapshotsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListSnapshotsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::list_snapshots(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListSnapshotsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/CreateSnapshot" => {
                    #[allow(non_camel_case_types)]
                    struct CreateSnapshotSvc<T: Subscriber>(pub Arc<T>);
                    impl<
                        T: Subscriber,
                    > tonic::server::UnaryService<super::CreateSnapshotRequest>
                    for CreateSnapshotSvc<T> {
                        type Response = super::Snapshot;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateSnapshotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::create_snapshot(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateSnapshotSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/UpdateSnapshot" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateSnapshotSvc<T: Subscriber>(pub Arc<T>);
                    impl<
                        T: Subscriber,
                    > tonic::server::UnaryService<super::UpdateSnapshotRequest>
                    for UpdateSnapshotSvc<T> {
                        type Response = super::Snapshot;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateSnapshotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::update_snapshot(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateSnapshotSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/DeleteSnapshot" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSnapshotSvc<T: Subscriber>(pub Arc<T>);
                    impl<
                        T: Subscriber,
                    > tonic::server::UnaryService<super::DeleteSnapshotRequest>
                    for DeleteSnapshotSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteSnapshotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::delete_snapshot(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteSnapshotSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.pubsub.v1.Subscriber/Seek" => {
                    #[allow(non_camel_case_types)]
                    struct SeekSvc<T: Subscriber>(pub Arc<T>);
                    impl<T: Subscriber> tonic::server::UnaryService<super::SeekRequest>
                    for SeekSvc<T> {
                        type Response = super::SeekResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SeekRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Subscriber>::seek(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SeekSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SubscriberServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.pubsub.v1.Subscriber";
    impl<T> tonic::server::NamedService for SubscriberServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
