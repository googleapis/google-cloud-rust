// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]

mod debug;
mod deserialize;
mod serialize;

/// A policy constraining the storage of messages published to the topic.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MessageStoragePolicy {
    /// Optional. A list of IDs of Google Cloud regions where messages that are
    /// published to the topic may be persisted in storage. Messages published by
    /// publishers running in non-allowed Google Cloud regions (or running outside
    /// of Google Cloud altogether) are routed for storage in one of the allowed
    /// regions. An empty list means that no regions are allowed, and is not a
    /// valid configuration.
    pub allowed_persistence_regions: std::vec::Vec<std::string::String>,

    /// Optional. If true, `allowed_persistence_regions` is also used to enforce
    /// in-transit guarantees for messages. That is, Pub/Sub will fail
    /// Publish operations on this topic and subscribe operations
    /// on any subscription attached to this topic in any region that is
    /// not in `allowed_persistence_regions`.
    pub enforce_in_transit: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MessageStoragePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_persistence_regions][crate::model::MessageStoragePolicy::allowed_persistence_regions].
    pub fn set_allowed_persistence_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_persistence_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [enforce_in_transit][crate::model::MessageStoragePolicy::enforce_in_transit].
    pub fn set_enforce_in_transit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enforce_in_transit = v.into();
        self
    }
}

impl wkt::message::Message for MessageStoragePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.MessageStoragePolicy"
    }
}

/// Settings for validating messages published against a schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchemaSettings {
    /// Required. The name of the schema that messages published should be
    /// validated against. Format is `projects/{project}/schemas/{schema}`. The
    /// value of this field will be `_deleted-schema_` if the schema has been
    /// deleted.
    pub schema: std::string::String,

    /// Optional. The encoding of messages validated against `schema`.
    pub encoding: crate::model::Encoding,

    /// Optional. The minimum (inclusive) revision allowed for validating messages.
    /// If empty or not present, allow any revision to be validated against
    /// last_revision or any revision created before.
    pub first_revision_id: std::string::String,

    /// Optional. The maximum (inclusive) revision allowed for validating messages.
    /// If empty or not present, allow any revision to be validated against
    /// first_revision or any revision created after.
    pub last_revision_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchemaSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema][crate::model::SchemaSettings::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [encoding][crate::model::SchemaSettings::encoding].
    pub fn set_encoding<T: std::convert::Into<crate::model::Encoding>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [first_revision_id][crate::model::SchemaSettings::first_revision_id].
    pub fn set_first_revision_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.first_revision_id = v.into();
        self
    }

    /// Sets the value of [last_revision_id][crate::model::SchemaSettings::last_revision_id].
    pub fn set_last_revision_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_revision_id = v.into();
        self
    }
}

impl wkt::message::Message for SchemaSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.SchemaSettings"
    }
}

/// Settings for an ingestion data source on a topic.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IngestionDataSourceSettings {
    /// Optional. Platform Logs settings. If unset, no Platform Logs will be
    /// generated.
    pub platform_logs_settings: std::option::Option<crate::model::PlatformLogsSettings>,

    /// Only one source type can have settings set.
    pub source: std::option::Option<crate::model::ingestion_data_source_settings::Source>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IngestionDataSourceSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [platform_logs_settings][crate::model::IngestionDataSourceSettings::platform_logs_settings].
    pub fn set_platform_logs_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PlatformLogsSettings>,
    {
        self.platform_logs_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [platform_logs_settings][crate::model::IngestionDataSourceSettings::platform_logs_settings].
    pub fn set_or_clear_platform_logs_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PlatformLogsSettings>,
    {
        self.platform_logs_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::IngestionDataSourceSettings::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::ingestion_data_source_settings::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::IngestionDataSourceSettings::source]
    /// if it holds a `AwsKinesis`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_kinesis(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::ingestion_data_source_settings::AwsKinesis>,
    > {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::ingestion_data_source_settings::Source::AwsKinesis(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::IngestionDataSourceSettings::source]
    /// to hold a `AwsKinesis`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_aws_kinesis<
        T: std::convert::Into<
                std::boxed::Box<crate::model::ingestion_data_source_settings::AwsKinesis>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::ingestion_data_source_settings::Source::AwsKinesis(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::IngestionDataSourceSettings::source]
    /// if it holds a `CloudStorage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::ingestion_data_source_settings::CloudStorage>,
    > {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::ingestion_data_source_settings::Source::CloudStorage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::IngestionDataSourceSettings::source]
    /// to hold a `CloudStorage`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_cloud_storage<
        T: std::convert::Into<
                std::boxed::Box<crate::model::ingestion_data_source_settings::CloudStorage>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::ingestion_data_source_settings::Source::CloudStorage(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::IngestionDataSourceSettings::source]
    /// if it holds a `AzureEventHubs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn azure_event_hubs(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::ingestion_data_source_settings::AzureEventHubs>,
    > {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::ingestion_data_source_settings::Source::AzureEventHubs(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::IngestionDataSourceSettings::source]
    /// to hold a `AzureEventHubs`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_azure_event_hubs<
        T: std::convert::Into<
                std::boxed::Box<crate::model::ingestion_data_source_settings::AzureEventHubs>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::ingestion_data_source_settings::Source::AzureEventHubs(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::IngestionDataSourceSettings::source]
    /// if it holds a `AwsMsk`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_msk(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ingestion_data_source_settings::AwsMsk>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::ingestion_data_source_settings::Source::AwsMsk(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::IngestionDataSourceSettings::source]
    /// to hold a `AwsMsk`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_aws_msk<
        T: std::convert::Into<std::boxed::Box<crate::model::ingestion_data_source_settings::AwsMsk>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::ingestion_data_source_settings::Source::AwsMsk(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::IngestionDataSourceSettings::source]
    /// if it holds a `ConfluentCloud`, `None` if the field is not set or
    /// holds a different branch.
    pub fn confluent_cloud(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::ingestion_data_source_settings::ConfluentCloud>,
    > {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::ingestion_data_source_settings::Source::ConfluentCloud(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::IngestionDataSourceSettings::source]
    /// to hold a `ConfluentCloud`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_confluent_cloud<
        T: std::convert::Into<
                std::boxed::Box<crate::model::ingestion_data_source_settings::ConfluentCloud>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::ingestion_data_source_settings::Source::ConfluentCloud(v.into()),
        );
        self
    }
}

impl wkt::message::Message for IngestionDataSourceSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings"
    }
}

/// Defines additional types related to [IngestionDataSourceSettings].
pub mod ingestion_data_source_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Ingestion settings for Amazon Kinesis Data Streams.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AwsKinesis {
        /// Output only. An output-only field that indicates the state of the Kinesis
        /// ingestion source.
        pub state: crate::model::ingestion_data_source_settings::aws_kinesis::State,

        /// Required. The Kinesis stream ARN to ingest data from.
        pub stream_arn: std::string::String,

        /// Required. The Kinesis consumer ARN to used for ingestion in Enhanced
        /// Fan-Out mode. The consumer must be already created and ready to be used.
        pub consumer_arn: std::string::String,

        /// Required. AWS role ARN to be used for Federated Identity authentication
        /// with Kinesis. Check the Pub/Sub docs for how to set up this role and the
        /// required permissions that need to be attached to it.
        pub aws_role_arn: std::string::String,

        /// Required. The GCP service account to be used for Federated Identity
        /// authentication with Kinesis (via a `AssumeRoleWithWebIdentity` call for
        /// the provided role). The `aws_role_arn` must be set up with
        /// `accounts.google.com:sub` equals to this service account number.
        pub gcp_service_account: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AwsKinesis {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::ingestion_data_source_settings::AwsKinesis::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::ingestion_data_source_settings::aws_kinesis::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [stream_arn][crate::model::ingestion_data_source_settings::AwsKinesis::stream_arn].
        pub fn set_stream_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.stream_arn = v.into();
            self
        }

        /// Sets the value of [consumer_arn][crate::model::ingestion_data_source_settings::AwsKinesis::consumer_arn].
        pub fn set_consumer_arn<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.consumer_arn = v.into();
            self
        }

        /// Sets the value of [aws_role_arn][crate::model::ingestion_data_source_settings::AwsKinesis::aws_role_arn].
        pub fn set_aws_role_arn<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.aws_role_arn = v.into();
            self
        }

        /// Sets the value of [gcp_service_account][crate::model::ingestion_data_source_settings::AwsKinesis::gcp_service_account].
        pub fn set_gcp_service_account<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gcp_service_account = v.into();
            self
        }
    }

    impl wkt::message::Message for AwsKinesis {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.AwsKinesis"
        }
    }

    /// Defines additional types related to [AwsKinesis].
    pub mod aws_kinesis {
        #[allow(unused_imports)]
        use super::*;

        /// Possible states for ingestion from Amazon Kinesis Data Streams.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Default value. This value is unused.
            Unspecified,
            /// Ingestion is active.
            Active,
            /// Permission denied encountered while consuming data from Kinesis.
            /// This can happen if:
            ///
            /// - The provided `aws_role_arn` does not exist or does not have the
            ///   appropriate permissions attached.
            /// - The provided `aws_role_arn` is not set up properly for Identity
            ///   Federation using `gcp_service_account`.
            /// - The Pub/Sub SA is not granted the
            ///   `iam.serviceAccounts.getOpenIdToken` permission on
            ///   `gcp_service_account`.
            KinesisPermissionDenied,
            /// Permission denied encountered while publishing to the topic. This can
            /// happen if the Pub/Sub SA has not been granted the [appropriate publish
            /// permissions](https://cloud.google.com/pubsub/docs/access-control#pubsub.publisher)
            PublishPermissionDenied,
            /// The Kinesis stream does not exist.
            StreamNotFound,
            /// The Kinesis consumer does not exist.
            ConsumerNotFound,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Active => std::option::Option::Some(1),
                    Self::KinesisPermissionDenied => std::option::Option::Some(2),
                    Self::PublishPermissionDenied => std::option::Option::Some(3),
                    Self::StreamNotFound => std::option::Option::Some(4),
                    Self::ConsumerNotFound => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Active => std::option::Option::Some("ACTIVE"),
                    Self::KinesisPermissionDenied => {
                        std::option::Option::Some("KINESIS_PERMISSION_DENIED")
                    }
                    Self::PublishPermissionDenied => {
                        std::option::Option::Some("PUBLISH_PERMISSION_DENIED")
                    }
                    Self::StreamNotFound => std::option::Option::Some("STREAM_NOT_FOUND"),
                    Self::ConsumerNotFound => std::option::Option::Some("CONSUMER_NOT_FOUND"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Active,
                    2 => Self::KinesisPermissionDenied,
                    3 => Self::PublishPermissionDenied,
                    4 => Self::StreamNotFound,
                    5 => Self::ConsumerNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "ACTIVE" => Self::Active,
                    "KINESIS_PERMISSION_DENIED" => Self::KinesisPermissionDenied,
                    "PUBLISH_PERMISSION_DENIED" => Self::PublishPermissionDenied,
                    "STREAM_NOT_FOUND" => Self::StreamNotFound,
                    "CONSUMER_NOT_FOUND" => Self::ConsumerNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Active => serializer.serialize_i32(1),
                    Self::KinesisPermissionDenied => serializer.serialize_i32(2),
                    Self::PublishPermissionDenied => serializer.serialize_i32(3),
                    Self::StreamNotFound => serializer.serialize_i32(4),
                    Self::ConsumerNotFound => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.pubsub.v1.IngestionDataSourceSettings.AwsKinesis.State",
                ))
            }
        }
    }

    /// Ingestion settings for Cloud Storage.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CloudStorage {
        /// Output only. An output-only field that indicates the state of the Cloud
        /// Storage ingestion source.
        pub state: crate::model::ingestion_data_source_settings::cloud_storage::State,

        /// Optional. Cloud Storage bucket. The bucket name must be without any
        /// prefix like "gs://". See the [bucket naming requirements]
        /// (<https://cloud.google.com/storage/docs/buckets#naming>).
        pub bucket: std::string::String,

        /// Optional. Only objects with a larger or equal creation timestamp will be
        /// ingested.
        pub minimum_object_create_time: std::option::Option<wkt::Timestamp>,

        /// Optional. Glob pattern used to match objects that will be ingested. If
        /// unset, all objects will be ingested. See the [supported
        /// patterns](https://cloud.google.com/storage/docs/json_api/v1/objects/list#list-objects-and-prefixes-using-glob).
        pub match_glob: std::string::String,

        /// Defaults to text format.
        pub input_format: std::option::Option<
            crate::model::ingestion_data_source_settings::cloud_storage::InputFormat,
        >,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CloudStorage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::ingestion_data_source_settings::CloudStorage::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::ingestion_data_source_settings::cloud_storage::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [bucket][crate::model::ingestion_data_source_settings::CloudStorage::bucket].
        pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.bucket = v.into();
            self
        }

        /// Sets the value of [minimum_object_create_time][crate::model::ingestion_data_source_settings::CloudStorage::minimum_object_create_time].
        pub fn set_minimum_object_create_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.minimum_object_create_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [minimum_object_create_time][crate::model::ingestion_data_source_settings::CloudStorage::minimum_object_create_time].
        pub fn set_or_clear_minimum_object_create_time<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.minimum_object_create_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [match_glob][crate::model::ingestion_data_source_settings::CloudStorage::match_glob].
        pub fn set_match_glob<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.match_glob = v.into();
            self
        }

        /// Sets the value of [input_format][crate::model::ingestion_data_source_settings::CloudStorage::input_format].
        ///
        /// Note that all the setters affecting `input_format` are mutually
        /// exclusive.
        pub fn set_input_format<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::ingestion_data_source_settings::cloud_storage::InputFormat,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.input_format = v.into();
            self
        }

        /// The value of [input_format][crate::model::ingestion_data_source_settings::CloudStorage::input_format]
        /// if it holds a `TextFormat`, `None` if the field is not set or
        /// holds a different branch.
        pub fn text_format(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::ingestion_data_source_settings::cloud_storage::TextFormat,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.input_format.as_ref().and_then(|v| match v {
                crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::TextFormat(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [input_format][crate::model::ingestion_data_source_settings::CloudStorage::input_format]
        /// to hold a `TextFormat`.
        ///
        /// Note that all the setters affecting `input_format` are
        /// mutually exclusive.
        pub fn set_text_format<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::ingestion_data_source_settings::cloud_storage::TextFormat,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.input_format = std::option::Option::Some(
                crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::TextFormat(
                    v.into()
                )
            );
            self
        }

        /// The value of [input_format][crate::model::ingestion_data_source_settings::CloudStorage::input_format]
        /// if it holds a `AvroFormat`, `None` if the field is not set or
        /// holds a different branch.
        pub fn avro_format(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::ingestion_data_source_settings::cloud_storage::AvroFormat,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.input_format.as_ref().and_then(|v| match v {
                crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::AvroFormat(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [input_format][crate::model::ingestion_data_source_settings::CloudStorage::input_format]
        /// to hold a `AvroFormat`.
        ///
        /// Note that all the setters affecting `input_format` are
        /// mutually exclusive.
        pub fn set_avro_format<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::ingestion_data_source_settings::cloud_storage::AvroFormat,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.input_format = std::option::Option::Some(
                crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::AvroFormat(
                    v.into()
                )
            );
            self
        }

        /// The value of [input_format][crate::model::ingestion_data_source_settings::CloudStorage::input_format]
        /// if it holds a `PubsubAvroFormat`, `None` if the field is not set or
        /// holds a different branch.
        pub fn pubsub_avro_format(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::ingestion_data_source_settings::cloud_storage::PubSubAvroFormat,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.input_format.as_ref().and_then(|v| match v {
                crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::PubsubAvroFormat(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [input_format][crate::model::ingestion_data_source_settings::CloudStorage::input_format]
        /// to hold a `PubsubAvroFormat`.
        ///
        /// Note that all the setters affecting `input_format` are
        /// mutually exclusive.
        pub fn set_pubsub_avro_format<T: std::convert::Into<std::boxed::Box<crate::model::ingestion_data_source_settings::cloud_storage::PubSubAvroFormat>>>(mut self, v: T) -> Self{
            self.input_format = std::option::Option::Some(
                crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::PubsubAvroFormat(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for CloudStorage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.CloudStorage"
        }
    }

    /// Defines additional types related to [CloudStorage].
    pub mod cloud_storage {
        #[allow(unused_imports)]
        use super::*;

        /// Configuration for reading Cloud Storage data in text format. Each line of
        /// text as specified by the delimiter will be set to the `data` field of a
        /// Pub/Sub message.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TextFormat {
            /// Optional. When unset, '\n' is used.
            pub delimiter: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TextFormat {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [delimiter][crate::model::ingestion_data_source_settings::cloud_storage::TextFormat::delimiter].
            pub fn set_delimiter<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.delimiter = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [delimiter][crate::model::ingestion_data_source_settings::cloud_storage::TextFormat::delimiter].
            pub fn set_or_clear_delimiter<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.delimiter = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for TextFormat {
            fn typename() -> &'static str {
                "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.TextFormat"
            }
        }

        /// Configuration for reading Cloud Storage data in Avro binary format. The
        /// bytes of each object will be set to the `data` field of a Pub/Sub
        /// message.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AvroFormat {
            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AvroFormat {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for AvroFormat {
            fn typename() -> &'static str {
                "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.AvroFormat"
            }
        }

        /// Configuration for reading Cloud Storage data written via [Cloud Storage
        /// subscriptions](https://cloud.google.com/pubsub/docs/cloudstorage). The
        /// data and attributes fields of the originally exported Pub/Sub message
        /// will be restored when publishing.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct PubSubAvroFormat {
            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PubSubAvroFormat {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for PubSubAvroFormat {
            fn typename() -> &'static str {
                "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.PubSubAvroFormat"
            }
        }

        /// Possible states for ingestion from Cloud Storage.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Default value. This value is unused.
            Unspecified,
            /// Ingestion is active.
            Active,
            /// Permission denied encountered while calling the Cloud Storage API. This
            /// can happen if the Pub/Sub SA has not been granted the
            /// [appropriate
            /// permissions](https://cloud.google.com/storage/docs/access-control/iam-permissions):
            ///
            /// - storage.objects.list: to list the objects in a bucket.
            /// - storage.objects.get: to read the objects in a bucket.
            /// - storage.buckets.get: to verify the bucket exists.
            CloudStoragePermissionDenied,
            /// Permission denied encountered while publishing to the topic. This can
            /// happen if the Pub/Sub SA has not been granted the [appropriate publish
            /// permissions](https://cloud.google.com/pubsub/docs/access-control#pubsub.publisher)
            PublishPermissionDenied,
            /// The provided Cloud Storage bucket doesn't exist.
            BucketNotFound,
            /// The Cloud Storage bucket has too many objects, ingestion will be
            /// paused.
            TooManyObjects,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Active => std::option::Option::Some(1),
                    Self::CloudStoragePermissionDenied => std::option::Option::Some(2),
                    Self::PublishPermissionDenied => std::option::Option::Some(3),
                    Self::BucketNotFound => std::option::Option::Some(4),
                    Self::TooManyObjects => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Active => std::option::Option::Some("ACTIVE"),
                    Self::CloudStoragePermissionDenied => {
                        std::option::Option::Some("CLOUD_STORAGE_PERMISSION_DENIED")
                    }
                    Self::PublishPermissionDenied => {
                        std::option::Option::Some("PUBLISH_PERMISSION_DENIED")
                    }
                    Self::BucketNotFound => std::option::Option::Some("BUCKET_NOT_FOUND"),
                    Self::TooManyObjects => std::option::Option::Some("TOO_MANY_OBJECTS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Active,
                    2 => Self::CloudStoragePermissionDenied,
                    3 => Self::PublishPermissionDenied,
                    4 => Self::BucketNotFound,
                    5 => Self::TooManyObjects,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "ACTIVE" => Self::Active,
                    "CLOUD_STORAGE_PERMISSION_DENIED" => Self::CloudStoragePermissionDenied,
                    "PUBLISH_PERMISSION_DENIED" => Self::PublishPermissionDenied,
                    "BUCKET_NOT_FOUND" => Self::BucketNotFound,
                    "TOO_MANY_OBJECTS" => Self::TooManyObjects,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Active => serializer.serialize_i32(1),
                    Self::CloudStoragePermissionDenied => serializer.serialize_i32(2),
                    Self::PublishPermissionDenied => serializer.serialize_i32(3),
                    Self::BucketNotFound => serializer.serialize_i32(4),
                    Self::TooManyObjects => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.State",
                ))
            }
        }

        /// Defaults to text format.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum InputFormat {
            /// Optional. Data from Cloud Storage will be interpreted as text.
            TextFormat(
                std::boxed::Box<
                    crate::model::ingestion_data_source_settings::cloud_storage::TextFormat,
                >,
            ),
            /// Optional. Data from Cloud Storage will be interpreted in Avro format.
            AvroFormat(
                std::boxed::Box<
                    crate::model::ingestion_data_source_settings::cloud_storage::AvroFormat,
                >,
            ),
            /// Optional. It will be assumed data from Cloud Storage was written via
            /// [Cloud Storage
            /// subscriptions](https://cloud.google.com/pubsub/docs/cloudstorage).
            PubsubAvroFormat(
                std::boxed::Box<
                    crate::model::ingestion_data_source_settings::cloud_storage::PubSubAvroFormat,
                >,
            ),
        }
    }

    /// Ingestion settings for Azure Event Hubs.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AzureEventHubs {
        /// Output only. An output-only field that indicates the state of the Event
        /// Hubs ingestion source.
        pub state: crate::model::ingestion_data_source_settings::azure_event_hubs::State,

        /// Optional. Name of the resource group within the azure subscription.
        pub resource_group: std::string::String,

        /// Optional. The name of the Event Hubs namespace.
        pub namespace: std::string::String,

        /// Optional. The name of the Event Hub.
        pub event_hub: std::string::String,

        /// Optional. The client id of the Azure application that is being used to
        /// authenticate Pub/Sub.
        pub client_id: std::string::String,

        /// Optional. The tenant id of the Azure application that is being used to
        /// authenticate Pub/Sub.
        pub tenant_id: std::string::String,

        /// Optional. The Azure subscription id.
        pub subscription_id: std::string::String,

        /// Optional. The GCP service account to be used for Federated Identity
        /// authentication.
        pub gcp_service_account: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AzureEventHubs {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::ingestion_data_source_settings::AzureEventHubs::state].
        pub fn set_state<
            T: std::convert::Into<
                    crate::model::ingestion_data_source_settings::azure_event_hubs::State,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [resource_group][crate::model::ingestion_data_source_settings::AzureEventHubs::resource_group].
        pub fn set_resource_group<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_group = v.into();
            self
        }

        /// Sets the value of [namespace][crate::model::ingestion_data_source_settings::AzureEventHubs::namespace].
        pub fn set_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.namespace = v.into();
            self
        }

        /// Sets the value of [event_hub][crate::model::ingestion_data_source_settings::AzureEventHubs::event_hub].
        pub fn set_event_hub<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.event_hub = v.into();
            self
        }

        /// Sets the value of [client_id][crate::model::ingestion_data_source_settings::AzureEventHubs::client_id].
        pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client_id = v.into();
            self
        }

        /// Sets the value of [tenant_id][crate::model::ingestion_data_source_settings::AzureEventHubs::tenant_id].
        pub fn set_tenant_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.tenant_id = v.into();
            self
        }

        /// Sets the value of [subscription_id][crate::model::ingestion_data_source_settings::AzureEventHubs::subscription_id].
        pub fn set_subscription_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.subscription_id = v.into();
            self
        }

        /// Sets the value of [gcp_service_account][crate::model::ingestion_data_source_settings::AzureEventHubs::gcp_service_account].
        pub fn set_gcp_service_account<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gcp_service_account = v.into();
            self
        }
    }

    impl wkt::message::Message for AzureEventHubs {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.AzureEventHubs"
        }
    }

    /// Defines additional types related to [AzureEventHubs].
    pub mod azure_event_hubs {
        #[allow(unused_imports)]
        use super::*;

        /// Possible states for managed ingestion from Event Hubs.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Default value. This value is unused.
            Unspecified,
            /// Ingestion is active.
            Active,
            /// Permission denied encountered while consuming data from Event Hubs.
            /// This can happen when `client_id`, or `tenant_id` are invalid. Or the
            /// right permissions haven't been granted.
            EventHubsPermissionDenied,
            /// Permission denied encountered while publishing to the topic.
            PublishPermissionDenied,
            /// The provided Event Hubs namespace couldn't be found.
            NamespaceNotFound,
            /// The provided Event Hub couldn't be found.
            EventHubNotFound,
            /// The provided Event Hubs subscription couldn't be found.
            SubscriptionNotFound,
            /// The provided Event Hubs resource group couldn't be found.
            ResourceGroupNotFound,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Active => std::option::Option::Some(1),
                    Self::EventHubsPermissionDenied => std::option::Option::Some(2),
                    Self::PublishPermissionDenied => std::option::Option::Some(3),
                    Self::NamespaceNotFound => std::option::Option::Some(4),
                    Self::EventHubNotFound => std::option::Option::Some(5),
                    Self::SubscriptionNotFound => std::option::Option::Some(6),
                    Self::ResourceGroupNotFound => std::option::Option::Some(7),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Active => std::option::Option::Some("ACTIVE"),
                    Self::EventHubsPermissionDenied => {
                        std::option::Option::Some("EVENT_HUBS_PERMISSION_DENIED")
                    }
                    Self::PublishPermissionDenied => {
                        std::option::Option::Some("PUBLISH_PERMISSION_DENIED")
                    }
                    Self::NamespaceNotFound => std::option::Option::Some("NAMESPACE_NOT_FOUND"),
                    Self::EventHubNotFound => std::option::Option::Some("EVENT_HUB_NOT_FOUND"),
                    Self::SubscriptionNotFound => {
                        std::option::Option::Some("SUBSCRIPTION_NOT_FOUND")
                    }
                    Self::ResourceGroupNotFound => {
                        std::option::Option::Some("RESOURCE_GROUP_NOT_FOUND")
                    }
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Active,
                    2 => Self::EventHubsPermissionDenied,
                    3 => Self::PublishPermissionDenied,
                    4 => Self::NamespaceNotFound,
                    5 => Self::EventHubNotFound,
                    6 => Self::SubscriptionNotFound,
                    7 => Self::ResourceGroupNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "ACTIVE" => Self::Active,
                    "EVENT_HUBS_PERMISSION_DENIED" => Self::EventHubsPermissionDenied,
                    "PUBLISH_PERMISSION_DENIED" => Self::PublishPermissionDenied,
                    "NAMESPACE_NOT_FOUND" => Self::NamespaceNotFound,
                    "EVENT_HUB_NOT_FOUND" => Self::EventHubNotFound,
                    "SUBSCRIPTION_NOT_FOUND" => Self::SubscriptionNotFound,
                    "RESOURCE_GROUP_NOT_FOUND" => Self::ResourceGroupNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Active => serializer.serialize_i32(1),
                    Self::EventHubsPermissionDenied => serializer.serialize_i32(2),
                    Self::PublishPermissionDenied => serializer.serialize_i32(3),
                    Self::NamespaceNotFound => serializer.serialize_i32(4),
                    Self::EventHubNotFound => serializer.serialize_i32(5),
                    Self::SubscriptionNotFound => serializer.serialize_i32(6),
                    Self::ResourceGroupNotFound => serializer.serialize_i32(7),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.pubsub.v1.IngestionDataSourceSettings.AzureEventHubs.State",
                ))
            }
        }
    }

    /// Ingestion settings for Amazon MSK.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AwsMsk {
        /// Output only. An output-only field that indicates the state of the Amazon
        /// MSK ingestion source.
        pub state: crate::model::ingestion_data_source_settings::aws_msk::State,

        /// Required. The Amazon Resource Name (ARN) that uniquely identifies the
        /// cluster.
        pub cluster_arn: std::string::String,

        /// Required. The name of the topic in the Amazon MSK cluster that Pub/Sub
        /// will import from.
        pub topic: std::string::String,

        /// Required. AWS role ARN to be used for Federated Identity authentication
        /// with Amazon MSK. Check the Pub/Sub docs for how to set up this role and
        /// the required permissions that need to be attached to it.
        pub aws_role_arn: std::string::String,

        /// Required. The GCP service account to be used for Federated Identity
        /// authentication with Amazon MSK (via a `AssumeRoleWithWebIdentity` call
        /// for the provided role). The `aws_role_arn` must be set up with
        /// `accounts.google.com:sub` equals to this service account number.
        pub gcp_service_account: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AwsMsk {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::ingestion_data_source_settings::AwsMsk::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::ingestion_data_source_settings::aws_msk::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [cluster_arn][crate::model::ingestion_data_source_settings::AwsMsk::cluster_arn].
        pub fn set_cluster_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cluster_arn = v.into();
            self
        }

        /// Sets the value of [topic][crate::model::ingestion_data_source_settings::AwsMsk::topic].
        pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.topic = v.into();
            self
        }

        /// Sets the value of [aws_role_arn][crate::model::ingestion_data_source_settings::AwsMsk::aws_role_arn].
        pub fn set_aws_role_arn<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.aws_role_arn = v.into();
            self
        }

        /// Sets the value of [gcp_service_account][crate::model::ingestion_data_source_settings::AwsMsk::gcp_service_account].
        pub fn set_gcp_service_account<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gcp_service_account = v.into();
            self
        }
    }

    impl wkt::message::Message for AwsMsk {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.AwsMsk"
        }
    }

    /// Defines additional types related to [AwsMsk].
    pub mod aws_msk {
        #[allow(unused_imports)]
        use super::*;

        /// Possible states for managed ingestion from Amazon MSK.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Default value. This value is unused.
            Unspecified,
            /// Ingestion is active.
            Active,
            /// Permission denied encountered while consuming data from Amazon MSK.
            MskPermissionDenied,
            /// Permission denied encountered while publishing to the topic.
            PublishPermissionDenied,
            /// The provided MSK cluster wasn't found.
            ClusterNotFound,
            /// The provided topic wasn't found.
            TopicNotFound,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Active => std::option::Option::Some(1),
                    Self::MskPermissionDenied => std::option::Option::Some(2),
                    Self::PublishPermissionDenied => std::option::Option::Some(3),
                    Self::ClusterNotFound => std::option::Option::Some(4),
                    Self::TopicNotFound => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Active => std::option::Option::Some("ACTIVE"),
                    Self::MskPermissionDenied => std::option::Option::Some("MSK_PERMISSION_DENIED"),
                    Self::PublishPermissionDenied => {
                        std::option::Option::Some("PUBLISH_PERMISSION_DENIED")
                    }
                    Self::ClusterNotFound => std::option::Option::Some("CLUSTER_NOT_FOUND"),
                    Self::TopicNotFound => std::option::Option::Some("TOPIC_NOT_FOUND"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Active,
                    2 => Self::MskPermissionDenied,
                    3 => Self::PublishPermissionDenied,
                    4 => Self::ClusterNotFound,
                    5 => Self::TopicNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "ACTIVE" => Self::Active,
                    "MSK_PERMISSION_DENIED" => Self::MskPermissionDenied,
                    "PUBLISH_PERMISSION_DENIED" => Self::PublishPermissionDenied,
                    "CLUSTER_NOT_FOUND" => Self::ClusterNotFound,
                    "TOPIC_NOT_FOUND" => Self::TopicNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Active => serializer.serialize_i32(1),
                    Self::MskPermissionDenied => serializer.serialize_i32(2),
                    Self::PublishPermissionDenied => serializer.serialize_i32(3),
                    Self::ClusterNotFound => serializer.serialize_i32(4),
                    Self::TopicNotFound => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.pubsub.v1.IngestionDataSourceSettings.AwsMsk.State",
                ))
            }
        }
    }

    /// Ingestion settings for Confluent Cloud.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConfluentCloud {
        /// Output only. An output-only field that indicates the state of the
        /// Confluent Cloud ingestion source.
        pub state: crate::model::ingestion_data_source_settings::confluent_cloud::State,

        /// Required. The address of the bootstrap server. The format is url:port.
        pub bootstrap_server: std::string::String,

        /// Required. The id of the cluster.
        pub cluster_id: std::string::String,

        /// Required. The name of the topic in the Confluent Cloud cluster that
        /// Pub/Sub will import from.
        pub topic: std::string::String,

        /// Required. The id of the identity pool to be used for Federated Identity
        /// authentication with Confluent Cloud. See
        /// <https://docs.confluent.io/cloud/current/security/authenticate/workload-identities/identity-providers/oauth/identity-pools.html#add-oauth-identity-pools>.
        pub identity_pool_id: std::string::String,

        /// Required. The GCP service account to be used for Federated Identity
        /// authentication with `identity_pool_id`.
        pub gcp_service_account: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConfluentCloud {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::ingestion_data_source_settings::ConfluentCloud::state].
        pub fn set_state<
            T: std::convert::Into<
                    crate::model::ingestion_data_source_settings::confluent_cloud::State,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [bootstrap_server][crate::model::ingestion_data_source_settings::ConfluentCloud::bootstrap_server].
        pub fn set_bootstrap_server<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.bootstrap_server = v.into();
            self
        }

        /// Sets the value of [cluster_id][crate::model::ingestion_data_source_settings::ConfluentCloud::cluster_id].
        pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cluster_id = v.into();
            self
        }

        /// Sets the value of [topic][crate::model::ingestion_data_source_settings::ConfluentCloud::topic].
        pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.topic = v.into();
            self
        }

        /// Sets the value of [identity_pool_id][crate::model::ingestion_data_source_settings::ConfluentCloud::identity_pool_id].
        pub fn set_identity_pool_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.identity_pool_id = v.into();
            self
        }

        /// Sets the value of [gcp_service_account][crate::model::ingestion_data_source_settings::ConfluentCloud::gcp_service_account].
        pub fn set_gcp_service_account<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gcp_service_account = v.into();
            self
        }
    }

    impl wkt::message::Message for ConfluentCloud {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.ConfluentCloud"
        }
    }

    /// Defines additional types related to [ConfluentCloud].
    pub mod confluent_cloud {
        #[allow(unused_imports)]
        use super::*;

        /// Possible states for managed ingestion from Confluent Cloud.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Default value. This value is unused.
            Unspecified,
            /// Ingestion is active.
            Active,
            /// Permission denied encountered while consuming data from Confluent
            /// Cloud.
            ConfluentCloudPermissionDenied,
            /// Permission denied encountered while publishing to the topic.
            PublishPermissionDenied,
            /// The provided bootstrap server address is unreachable.
            UnreachableBootstrapServer,
            /// The provided cluster wasn't found.
            ClusterNotFound,
            /// The provided topic wasn't found.
            TopicNotFound,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Active => std::option::Option::Some(1),
                    Self::ConfluentCloudPermissionDenied => std::option::Option::Some(2),
                    Self::PublishPermissionDenied => std::option::Option::Some(3),
                    Self::UnreachableBootstrapServer => std::option::Option::Some(4),
                    Self::ClusterNotFound => std::option::Option::Some(5),
                    Self::TopicNotFound => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Active => std::option::Option::Some("ACTIVE"),
                    Self::ConfluentCloudPermissionDenied => {
                        std::option::Option::Some("CONFLUENT_CLOUD_PERMISSION_DENIED")
                    }
                    Self::PublishPermissionDenied => {
                        std::option::Option::Some("PUBLISH_PERMISSION_DENIED")
                    }
                    Self::UnreachableBootstrapServer => {
                        std::option::Option::Some("UNREACHABLE_BOOTSTRAP_SERVER")
                    }
                    Self::ClusterNotFound => std::option::Option::Some("CLUSTER_NOT_FOUND"),
                    Self::TopicNotFound => std::option::Option::Some("TOPIC_NOT_FOUND"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Active,
                    2 => Self::ConfluentCloudPermissionDenied,
                    3 => Self::PublishPermissionDenied,
                    4 => Self::UnreachableBootstrapServer,
                    5 => Self::ClusterNotFound,
                    6 => Self::TopicNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "ACTIVE" => Self::Active,
                    "CONFLUENT_CLOUD_PERMISSION_DENIED" => Self::ConfluentCloudPermissionDenied,
                    "PUBLISH_PERMISSION_DENIED" => Self::PublishPermissionDenied,
                    "UNREACHABLE_BOOTSTRAP_SERVER" => Self::UnreachableBootstrapServer,
                    "CLUSTER_NOT_FOUND" => Self::ClusterNotFound,
                    "TOPIC_NOT_FOUND" => Self::TopicNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Active => serializer.serialize_i32(1),
                    Self::ConfluentCloudPermissionDenied => serializer.serialize_i32(2),
                    Self::PublishPermissionDenied => serializer.serialize_i32(3),
                    Self::UnreachableBootstrapServer => serializer.serialize_i32(4),
                    Self::ClusterNotFound => serializer.serialize_i32(5),
                    Self::TopicNotFound => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.pubsub.v1.IngestionDataSourceSettings.ConfluentCloud.State",
                ))
            }
        }
    }

    /// Only one source type can have settings set.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Optional. Amazon Kinesis Data Streams.
        AwsKinesis(std::boxed::Box<crate::model::ingestion_data_source_settings::AwsKinesis>),
        /// Optional. Cloud Storage.
        CloudStorage(std::boxed::Box<crate::model::ingestion_data_source_settings::CloudStorage>),
        /// Optional. Azure Event Hubs.
        AzureEventHubs(
            std::boxed::Box<crate::model::ingestion_data_source_settings::AzureEventHubs>,
        ),
        /// Optional. Amazon MSK.
        AwsMsk(std::boxed::Box<crate::model::ingestion_data_source_settings::AwsMsk>),
        /// Optional. Confluent Cloud.
        ConfluentCloud(
            std::boxed::Box<crate::model::ingestion_data_source_settings::ConfluentCloud>,
        ),
    }
}

/// Settings for Platform Logs produced by Pub/Sub.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PlatformLogsSettings {
    /// Optional. The minimum severity level of Platform Logs that will be written.
    pub severity: crate::model::platform_logs_settings::Severity,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PlatformLogsSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [severity][crate::model::PlatformLogsSettings::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::platform_logs_settings::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }
}

impl wkt::message::Message for PlatformLogsSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.PlatformLogsSettings"
    }
}

/// Defines additional types related to [PlatformLogsSettings].
pub mod platform_logs_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Severity levels of Platform Logs.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// Default value. Logs level is unspecified. Logs will be disabled.
        Unspecified,
        /// Logs will be disabled.
        Disabled,
        /// Debug logs and higher-severity logs will be written.
        Debug,
        /// Info logs and higher-severity logs will be written.
        Info,
        /// Warning logs and higher-severity logs will be written.
        Warning,
        /// Only error logs will be written.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Debug => std::option::Option::Some(2),
                Self::Info => std::option::Option::Some(3),
                Self::Warning => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Debug => std::option::Option::Some("DEBUG"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::Debug,
                3 => Self::Info,
                4 => Self::Warning,
                5 => Self::Error,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "DEBUG" => Self::Debug,
                "INFO" => Self::Info,
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Debug => serializer.serialize_i32(2),
                Self::Info => serializer.serialize_i32(3),
                Self::Warning => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.pubsub.v1.PlatformLogsSettings.Severity",
            ))
        }
    }
}

/// User-defined JavaScript function that can transform or filter a Pub/Sub
/// message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct JavaScriptUDF {
    /// Required. Name of the JavasScript function that should applied to Pub/Sub
    /// messages.
    pub function_name: std::string::String,

    /// Required. JavaScript code that contains a function `function_name` with the
    /// below signature:
    ///
    /// ```norust
    ///   /**
    ///   * Transforms a Pub/Sub message.
    ///
    ///   * @return {(Object<string, (string | Object<string, string>)>|null)} - To
    ///   * filter a message, return `null`. To transform a message return a map
    ///   * with the following keys:
    ///   *   - (required) 'data' : {string}
    ///   *   - (optional) 'attributes' : {Object<string, string>}
    ///   * Returning empty `attributes` will remove all attributes from the
    ///   * message.
    ///   *
    ///   * @param  {(Object<string, (string | Object<string, string>)>} Pub/Sub
    ///   * message. Keys:
    ///   *   - (required) 'data' : {string}
    ///   *   - (required) 'attributes' : {Object<string, string>}
    ///   *
    ///   * @param  {Object<string, any>} metadata - Pub/Sub message metadata.
    ///   * Keys:
    ///   *   - (optional) 'message_id'  : {string}
    ///   *   - (optional) 'publish_time': {string} YYYY-MM-DDTHH:MM:SSZ format
    ///   *   - (optional) 'ordering_key': {string}
    ///   */
    ///
    ///   function <function_name>(message, metadata) {
    ///   }
    /// ```
    pub code: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JavaScriptUDF {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [function_name][crate::model::JavaScriptUDF::function_name].
    pub fn set_function_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.function_name = v.into();
        self
    }

    /// Sets the value of [code][crate::model::JavaScriptUDF::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for JavaScriptUDF {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.JavaScriptUDF"
    }
}

/// All supported message transforms types.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MessageTransform {
    /// Optional. This field is deprecated, use the `disabled` field to disable
    /// transforms.
    #[deprecated]
    pub enabled: bool,

    /// Optional. If true, the transform is disabled and will not be applied to
    /// messages. Defaults to `false`.
    pub disabled: bool,

    /// The type of transform to apply to messages.
    pub transform: std::option::Option<crate::model::message_transform::Transform>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MessageTransform {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::MessageTransform::enabled].
    #[deprecated]
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::MessageTransform::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [transform][crate::model::MessageTransform::transform].
    ///
    /// Note that all the setters affecting `transform` are mutually
    /// exclusive.
    pub fn set_transform<
        T: std::convert::Into<std::option::Option<crate::model::message_transform::Transform>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transform = v.into();
        self
    }

    /// The value of [transform][crate::model::MessageTransform::transform]
    /// if it holds a `JavascriptUdf`, `None` if the field is not set or
    /// holds a different branch.
    pub fn javascript_udf(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::JavaScriptUDF>> {
        #[allow(unreachable_patterns)]
        self.transform.as_ref().and_then(|v| match v {
            crate::model::message_transform::Transform::JavascriptUdf(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transform][crate::model::MessageTransform::transform]
    /// to hold a `JavascriptUdf`.
    ///
    /// Note that all the setters affecting `transform` are
    /// mutually exclusive.
    pub fn set_javascript_udf<
        T: std::convert::Into<std::boxed::Box<crate::model::JavaScriptUDF>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transform = std::option::Option::Some(
            crate::model::message_transform::Transform::JavascriptUdf(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MessageTransform {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.MessageTransform"
    }
}

/// Defines additional types related to [MessageTransform].
pub mod message_transform {
    #[allow(unused_imports)]
    use super::*;

    /// The type of transform to apply to messages.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Transform {
        /// Optional. JavaScript User Defined Function. If multiple JavaScriptUDF's
        /// are specified on a resource, each must have a unique `function_name`.
        JavascriptUdf(std::boxed::Box<crate::model::JavaScriptUDF>),
    }
}

/// A topic resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Topic {
    /// Required. The name of the topic. It must have the format
    /// `"projects/{project}/topics/{topic}"`. `{topic}` must start with a letter,
    /// and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`),
    /// underscores (`_`), periods (`.`), tildes (`~`), plus (`+`) or percent
    /// signs (`%`). It must be between 3 and 255 characters in length, and it
    /// must not start with `"goog"`.
    pub name: std::string::String,

    /// Optional. See [Creating and managing labels]
    /// (<https://cloud.google.com/pubsub/docs/labels>).
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Policy constraining the set of Google Cloud Platform regions
    /// where messages published to the topic may be stored. If not present, then
    /// no constraints are in effect.
    pub message_storage_policy: std::option::Option<crate::model::MessageStoragePolicy>,

    /// Optional. The resource name of the Cloud KMS CryptoKey to be used to
    /// protect access to messages published on this topic.
    ///
    /// The expected format is `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    pub kms_key_name: std::string::String,

    /// Optional. Settings for validating messages published against a schema.
    pub schema_settings: std::option::Option<crate::model::SchemaSettings>,

    /// Optional. Reserved for future use. This field is set only in responses from
    /// the server; it is ignored if it is set in any requests.
    pub satisfies_pzs: bool,

    /// Optional. Indicates the minimum duration to retain a message after it is
    /// published to the topic. If this field is set, messages published to the
    /// topic in the last `message_retention_duration` are always available to
    /// subscribers. For instance, it allows any attached subscription to [seek to
    /// a
    /// timestamp](https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time)
    /// that is up to `message_retention_duration` in the past. If this field is
    /// not set, message retention is controlled by settings on individual
    /// subscriptions. Cannot be more than 31 days or less than 10 minutes.
    pub message_retention_duration: std::option::Option<wkt::Duration>,

    /// Output only. An output-only field indicating the state of the topic.
    pub state: crate::model::topic::State,

    /// Optional. Settings for ingestion from a data source into this topic.
    pub ingestion_data_source_settings:
        std::option::Option<crate::model::IngestionDataSourceSettings>,

    /// Optional. Transforms to be applied to messages published to the topic.
    /// Transforms are applied in the order specified.
    pub message_transforms: std::vec::Vec<crate::model::MessageTransform>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Topic {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Topic::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Topic::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [message_storage_policy][crate::model::Topic::message_storage_policy].
    pub fn set_message_storage_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MessageStoragePolicy>,
    {
        self.message_storage_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message_storage_policy][crate::model::Topic::message_storage_policy].
    pub fn set_or_clear_message_storage_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MessageStoragePolicy>,
    {
        self.message_storage_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Topic::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [schema_settings][crate::model::Topic::schema_settings].
    pub fn set_schema_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SchemaSettings>,
    {
        self.schema_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema_settings][crate::model::Topic::schema_settings].
    pub fn set_or_clear_schema_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SchemaSettings>,
    {
        self.schema_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Topic::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [message_retention_duration][crate::model::Topic::message_retention_duration].
    pub fn set_message_retention_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.message_retention_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message_retention_duration][crate::model::Topic::message_retention_duration].
    pub fn set_or_clear_message_retention_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.message_retention_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Topic::state].
    pub fn set_state<T: std::convert::Into<crate::model::topic::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [ingestion_data_source_settings][crate::model::Topic::ingestion_data_source_settings].
    pub fn set_ingestion_data_source_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IngestionDataSourceSettings>,
    {
        self.ingestion_data_source_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ingestion_data_source_settings][crate::model::Topic::ingestion_data_source_settings].
    pub fn set_or_clear_ingestion_data_source_settings<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::IngestionDataSourceSettings>,
    {
        self.ingestion_data_source_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message_transforms][crate::model::Topic::message_transforms].
    pub fn set_message_transforms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageTransform>,
    {
        use std::iter::Iterator;
        self.message_transforms = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Topic {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.Topic"
    }
}

/// Defines additional types related to [Topic].
pub mod topic {
    #[allow(unused_imports)]
    use super::*;

    /// The state of the topic.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// The topic does not have any persistent errors.
        Active,
        /// Ingestion from the data source has encountered a permanent error.
        /// See the more detailed error state in the corresponding ingestion
        /// source configuration.
        IngestionResourceError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::IngestionResourceError => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::IngestionResourceError => {
                    std::option::Option::Some("INGESTION_RESOURCE_ERROR")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::IngestionResourceError,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "INGESTION_RESOURCE_ERROR" => Self::IngestionResourceError,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::IngestionResourceError => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.pubsub.v1.Topic.State",
            ))
        }
    }
}

/// Request for the GetTopic method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTopicRequest {
    /// Required. The name of the topic to get.
    /// Format is `projects/{project}/topics/{topic}`.
    pub topic: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTopicRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic][crate::model::GetTopicRequest::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }
}

impl wkt::message::Message for GetTopicRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.GetTopicRequest"
    }
}

/// Request for the UpdateTopic method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTopicRequest {
    /// Required. The updated topic object.
    pub topic: std::option::Option<crate::model::Topic>,

    /// Required. Indicates which fields in the provided topic to update. Must be
    /// specified and non-empty. Note that if `update_mask` contains
    /// "message_storage_policy" but the `message_storage_policy` is not set in
    /// the `topic` provided above, then the updated value is determined by the
    /// policy configured at the project or organization level.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTopicRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic][crate::model::UpdateTopicRequest::topic].
    pub fn set_topic<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Topic>,
    {
        self.topic = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [topic][crate::model::UpdateTopicRequest::topic].
    pub fn set_or_clear_topic<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Topic>,
    {
        self.topic = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTopicRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTopicRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTopicRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.UpdateTopicRequest"
    }
}

/// Request for the `ListTopics` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTopicsRequest {
    /// Required. The name of the project in which to list topics.
    /// Format is `projects/{project-id}`.
    pub project: std::string::String,

    /// Optional. Maximum number of topics to return.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListTopicsResponse`; indicates
    /// that this is a continuation of a prior `ListTopics` call, and that the
    /// system should return the next page of data.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTopicsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::ListTopicsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTopicsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTopicsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTopicsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListTopicsRequest"
    }
}

/// Response for the `ListTopics` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTopicsResponse {
    /// Optional. The resulting topics.
    pub topics: std::vec::Vec<crate::model::Topic>,

    /// Optional. If not empty, indicates that there may be more topics that match
    /// the request; this value should be passed in a new `ListTopicsRequest`.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTopicsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topics][crate::model::ListTopicsResponse::topics].
    pub fn set_topics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Topic>,
    {
        use std::iter::Iterator;
        self.topics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTopicsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTopicsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListTopicsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTopicsResponse {
    type PageItem = crate::model::Topic;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.topics
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `ListTopicSubscriptions` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTopicSubscriptionsRequest {
    /// Required. The name of the topic that subscriptions are attached to.
    /// Format is `projects/{project}/topics/{topic}`.
    pub topic: std::string::String,

    /// Optional. Maximum number of subscription names to return.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListTopicSubscriptionsResponse`;
    /// indicates that this is a continuation of a prior `ListTopicSubscriptions`
    /// call, and that the system should return the next page of data.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTopicSubscriptionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic][crate::model::ListTopicSubscriptionsRequest::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTopicSubscriptionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTopicSubscriptionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTopicSubscriptionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListTopicSubscriptionsRequest"
    }
}

/// Response for the `ListTopicSubscriptions` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTopicSubscriptionsResponse {
    /// Optional. The names of subscriptions attached to the topic specified in the
    /// request.
    pub subscriptions: std::vec::Vec<std::string::String>,

    /// Optional. If not empty, indicates that there may be more subscriptions that
    /// match the request; this value should be passed in a new
    /// `ListTopicSubscriptionsRequest` to get more subscriptions.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTopicSubscriptionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscriptions][crate::model::ListTopicSubscriptionsResponse::subscriptions].
    pub fn set_subscriptions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subscriptions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTopicSubscriptionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTopicSubscriptionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListTopicSubscriptionsResponse"
    }
}

/// Request for the `ListTopicSnapshots` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTopicSnapshotsRequest {
    /// Required. The name of the topic that snapshots are attached to.
    /// Format is `projects/{project}/topics/{topic}`.
    pub topic: std::string::String,

    /// Optional. Maximum number of snapshot names to return.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListTopicSnapshotsResponse`;
    /// indicates that this is a continuation of a prior `ListTopicSnapshots` call,
    /// and that the system should return the next page of data.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTopicSnapshotsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic][crate::model::ListTopicSnapshotsRequest::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTopicSnapshotsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTopicSnapshotsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTopicSnapshotsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListTopicSnapshotsRequest"
    }
}

/// Response for the `ListTopicSnapshots` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTopicSnapshotsResponse {
    /// Optional. The names of the snapshots that match the request.
    pub snapshots: std::vec::Vec<std::string::String>,

    /// Optional. If not empty, indicates that there may be more snapshots that
    /// match the request; this value should be passed in a new
    /// `ListTopicSnapshotsRequest` to get more snapshots.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTopicSnapshotsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots][crate::model::ListTopicSnapshotsResponse::snapshots].
    pub fn set_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTopicSnapshotsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTopicSnapshotsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListTopicSnapshotsResponse"
    }
}

/// Request for the `DeleteTopic` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTopicRequest {
    /// Required. Name of the topic to delete.
    /// Format is `projects/{project}/topics/{topic}`.
    pub topic: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTopicRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic][crate::model::DeleteTopicRequest::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTopicRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DeleteTopicRequest"
    }
}

/// Request for the DetachSubscription method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DetachSubscriptionRequest {
    /// Required. The subscription to detach.
    /// Format is `projects/{project}/subscriptions/{subscription}`.
    pub subscription: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DetachSubscriptionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::DetachSubscriptionRequest::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }
}

impl wkt::message::Message for DetachSubscriptionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DetachSubscriptionRequest"
    }
}

/// Response for the DetachSubscription method.
/// Reserved for future use.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DetachSubscriptionResponse {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DetachSubscriptionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DetachSubscriptionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DetachSubscriptionResponse"
    }
}

/// A subscription resource. If none of `push_config`, `bigquery_config`, or
/// `cloud_storage_config` is set, then the subscriber will pull and ack messages
/// using API methods. At most one of these fields may be set.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Subscription {
    /// Required. The name of the subscription. It must have the format
    /// `"projects/{project}/subscriptions/{subscription}"`. `{subscription}` must
    /// start with a letter, and contain only letters (`[A-Za-z]`), numbers
    /// (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),
    /// plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters
    /// in length, and it must not start with `"goog"`.
    pub name: std::string::String,

    /// Required. The name of the topic from which this subscription is receiving
    /// messages. Format is `projects/{project}/topics/{topic}`. The value of this
    /// field will be `_deleted-topic_` if the topic has been deleted.
    pub topic: std::string::String,

    /// Optional. If push delivery is used with this subscription, this field is
    /// used to configure it.
    pub push_config: std::option::Option<crate::model::PushConfig>,

    /// Optional. If delivery to BigQuery is used with this subscription, this
    /// field is used to configure it.
    pub bigquery_config: std::option::Option<crate::model::BigQueryConfig>,

    /// Optional. If delivery to Google Cloud Storage is used with this
    /// subscription, this field is used to configure it.
    pub cloud_storage_config: std::option::Option<crate::model::CloudStorageConfig>,

    /// Optional. The approximate amount of time (on a best-effort basis) Pub/Sub
    /// waits for the subscriber to acknowledge receipt before resending the
    /// message. In the interval after the message is delivered and before it is
    /// acknowledged, it is considered to be _outstanding_. During that time
    /// period, the message will not be redelivered (on a best-effort basis).
    ///
    /// For pull subscriptions, this value is used as the initial value for the ack
    /// deadline. To override this value for a given message, call
    /// `ModifyAckDeadline` with the corresponding `ack_id` if using
    /// non-streaming pull or send the `ack_id` in a
    /// `StreamingModifyAckDeadlineRequest` if using streaming pull.
    /// The minimum custom deadline you can specify is 10 seconds.
    /// The maximum custom deadline you can specify is 600 seconds (10 minutes).
    /// If this parameter is 0, a default value of 10 seconds is used.
    ///
    /// For push delivery, this value is also used to set the request timeout for
    /// the call to the push endpoint.
    ///
    /// If the subscriber never acknowledges the message, the Pub/Sub
    /// system will eventually redeliver the message.
    pub ack_deadline_seconds: i32,

    /// Optional. Indicates whether to retain acknowledged messages. If true, then
    /// messages are not expunged from the subscription's backlog, even if they are
    /// acknowledged, until they fall out of the `message_retention_duration`
    /// window. This must be true if you would like to [`Seek` to a timestamp]
    /// (<https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time>) in
    /// the past to replay previously-acknowledged messages.
    pub retain_acked_messages: bool,

    /// Optional. How long to retain unacknowledged messages in the subscription's
    /// backlog, from the moment a message is published. If `retain_acked_messages`
    /// is true, then this also configures the retention of acknowledged messages,
    /// and thus configures how far back in time a `Seek` can be done. Defaults to
    /// 7 days. Cannot be more than 31 days or less than 10 minutes.
    pub message_retention_duration: std::option::Option<wkt::Duration>,

    /// Optional. See [Creating and managing
    /// labels](https://cloud.google.com/pubsub/docs/labels).
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. If true, messages published with the same `ordering_key` in
    /// `PubsubMessage` will be delivered to the subscribers in the order in which
    /// they are received by the Pub/Sub system. Otherwise, they may be delivered
    /// in any order.
    pub enable_message_ordering: bool,

    /// Optional. A policy that specifies the conditions for this subscription's
    /// expiration. A subscription is considered active as long as any connected
    /// subscriber is successfully consuming messages from the subscription or is
    /// issuing operations on the subscription. If `expiration_policy` is not set,
    /// a *default policy* with `ttl` of 31 days will be used. The minimum allowed
    /// value for `expiration_policy.ttl` is 1 day. If `expiration_policy` is set,
    /// but `expiration_policy.ttl` is not set, the subscription never expires.
    pub expiration_policy: std::option::Option<crate::model::ExpirationPolicy>,

    /// Optional. An expression written in the Pub/Sub [filter
    /// language](https://cloud.google.com/pubsub/docs/filtering). If non-empty,
    /// then only `PubsubMessage`s whose `attributes` field matches the filter are
    /// delivered on this subscription. If empty, then no messages are filtered
    /// out.
    pub filter: std::string::String,

    /// Optional. A policy that specifies the conditions for dead lettering
    /// messages in this subscription. If dead_letter_policy is not set, dead
    /// lettering is disabled.
    ///
    /// The Pub/Sub service account associated with this subscriptions's
    /// parent project (i.e.,
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
    /// permission to Acknowledge() messages on this subscription.
    pub dead_letter_policy: std::option::Option<crate::model::DeadLetterPolicy>,

    /// Optional. A policy that specifies how Pub/Sub retries message delivery for
    /// this subscription.
    ///
    /// If not set, the default retry policy is applied. This generally implies
    /// that messages will be retried as soon as possible for healthy subscribers.
    /// RetryPolicy will be triggered on NACKs or acknowledgment deadline exceeded
    /// events for a given message.
    pub retry_policy: std::option::Option<crate::model::RetryPolicy>,

    /// Optional. Indicates whether the subscription is detached from its topic.
    /// Detached subscriptions don't receive messages from their topic and don't
    /// retain any backlog. `Pull` and `StreamingPull` requests will return
    /// FAILED_PRECONDITION. If the subscription is a push subscription, pushes to
    /// the endpoint will not be made.
    pub detached: bool,

    /// Optional. If true, Pub/Sub provides the following guarantees for the
    /// delivery of a message with a given value of `message_id` on this
    /// subscription:
    ///
    /// * The message sent to a subscriber is guaranteed not to be resent
    ///   before the message's acknowledgment deadline expires.
    /// * An acknowledged message will not be resent to a subscriber.
    ///
    /// Note that subscribers may still receive multiple copies of a message
    /// when `enable_exactly_once_delivery` is true if the message was published
    /// multiple times by a publisher client. These copies are  considered distinct
    /// by Pub/Sub and have distinct `message_id` values.
    pub enable_exactly_once_delivery: bool,

    /// Output only. Indicates the minimum duration for which a message is retained
    /// after it is published to the subscription's topic. If this field is set,
    /// messages published to the subscription's topic in the last
    /// `topic_message_retention_duration` are always available to subscribers. See
    /// the `message_retention_duration` field in `Topic`. This field is set only
    /// in responses from the server; it is ignored if it is set in any requests.
    pub topic_message_retention_duration: std::option::Option<wkt::Duration>,

    /// Output only. An output-only field indicating whether or not the
    /// subscription can receive messages.
    pub state: crate::model::subscription::State,

    /// Output only. Information about the associated Analytics Hub subscription.
    /// Only set if the subscritpion is created by Analytics Hub.
    pub analytics_hub_subscription_info:
        std::option::Option<crate::model::subscription::AnalyticsHubSubscriptionInfo>,

    /// Optional. Transforms to be applied to messages before they are delivered to
    /// subscribers. Transforms are applied in the order specified.
    pub message_transforms: std::vec::Vec<crate::model::MessageTransform>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Subscription {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Subscription::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [topic][crate::model::Subscription::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }

    /// Sets the value of [push_config][crate::model::Subscription::push_config].
    pub fn set_push_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PushConfig>,
    {
        self.push_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [push_config][crate::model::Subscription::push_config].
    pub fn set_or_clear_push_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PushConfig>,
    {
        self.push_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [bigquery_config][crate::model::Subscription::bigquery_config].
    pub fn set_bigquery_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryConfig>,
    {
        self.bigquery_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bigquery_config][crate::model::Subscription::bigquery_config].
    pub fn set_or_clear_bigquery_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryConfig>,
    {
        self.bigquery_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cloud_storage_config][crate::model::Subscription::cloud_storage_config].
    pub fn set_cloud_storage_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudStorageConfig>,
    {
        self.cloud_storage_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_storage_config][crate::model::Subscription::cloud_storage_config].
    pub fn set_or_clear_cloud_storage_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudStorageConfig>,
    {
        self.cloud_storage_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ack_deadline_seconds][crate::model::Subscription::ack_deadline_seconds].
    pub fn set_ack_deadline_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ack_deadline_seconds = v.into();
        self
    }

    /// Sets the value of [retain_acked_messages][crate::model::Subscription::retain_acked_messages].
    pub fn set_retain_acked_messages<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.retain_acked_messages = v.into();
        self
    }

    /// Sets the value of [message_retention_duration][crate::model::Subscription::message_retention_duration].
    pub fn set_message_retention_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.message_retention_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message_retention_duration][crate::model::Subscription::message_retention_duration].
    pub fn set_or_clear_message_retention_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.message_retention_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Subscription::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [enable_message_ordering][crate::model::Subscription::enable_message_ordering].
    pub fn set_enable_message_ordering<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_message_ordering = v.into();
        self
    }

    /// Sets the value of [expiration_policy][crate::model::Subscription::expiration_policy].
    pub fn set_expiration_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExpirationPolicy>,
    {
        self.expiration_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_policy][crate::model::Subscription::expiration_policy].
    pub fn set_or_clear_expiration_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExpirationPolicy>,
    {
        self.expiration_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [filter][crate::model::Subscription::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [dead_letter_policy][crate::model::Subscription::dead_letter_policy].
    pub fn set_dead_letter_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeadLetterPolicy>,
    {
        self.dead_letter_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dead_letter_policy][crate::model::Subscription::dead_letter_policy].
    pub fn set_or_clear_dead_letter_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeadLetterPolicy>,
    {
        self.dead_letter_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [retry_policy][crate::model::Subscription::retry_policy].
    pub fn set_retry_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RetryPolicy>,
    {
        self.retry_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retry_policy][crate::model::Subscription::retry_policy].
    pub fn set_or_clear_retry_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RetryPolicy>,
    {
        self.retry_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [detached][crate::model::Subscription::detached].
    pub fn set_detached<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.detached = v.into();
        self
    }

    /// Sets the value of [enable_exactly_once_delivery][crate::model::Subscription::enable_exactly_once_delivery].
    pub fn set_enable_exactly_once_delivery<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_exactly_once_delivery = v.into();
        self
    }

    /// Sets the value of [topic_message_retention_duration][crate::model::Subscription::topic_message_retention_duration].
    pub fn set_topic_message_retention_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.topic_message_retention_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [topic_message_retention_duration][crate::model::Subscription::topic_message_retention_duration].
    pub fn set_or_clear_topic_message_retention_duration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.topic_message_retention_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Subscription::state].
    pub fn set_state<T: std::convert::Into<crate::model::subscription::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [analytics_hub_subscription_info][crate::model::Subscription::analytics_hub_subscription_info].
    pub fn set_analytics_hub_subscription_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::subscription::AnalyticsHubSubscriptionInfo>,
    {
        self.analytics_hub_subscription_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analytics_hub_subscription_info][crate::model::Subscription::analytics_hub_subscription_info].
    pub fn set_or_clear_analytics_hub_subscription_info<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::subscription::AnalyticsHubSubscriptionInfo>,
    {
        self.analytics_hub_subscription_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message_transforms][crate::model::Subscription::message_transforms].
    pub fn set_message_transforms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageTransform>,
    {
        use std::iter::Iterator;
        self.message_transforms = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Subscription {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.Subscription"
    }
}

/// Defines additional types related to [Subscription].
pub mod subscription {
    #[allow(unused_imports)]
    use super::*;

    /// Information about an associated [Analytics Hub
    /// subscription](https://cloud.google.com/bigquery/docs/analytics-hub-manage-subscriptions).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AnalyticsHubSubscriptionInfo {
        /// Optional. The name of the associated Analytics Hub listing resource.
        /// Pattern:
        /// "projects/{project}/locations/{location}/dataExchanges/{data_exchange}/listings/{listing}"
        pub listing: std::string::String,

        /// Optional. The name of the associated Analytics Hub subscription resource.
        /// Pattern:
        /// "projects/{project}/locations/{location}/subscriptions/{subscription}"
        pub subscription: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AnalyticsHubSubscriptionInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [listing][crate::model::subscription::AnalyticsHubSubscriptionInfo::listing].
        pub fn set_listing<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.listing = v.into();
            self
        }

        /// Sets the value of [subscription][crate::model::subscription::AnalyticsHubSubscriptionInfo::subscription].
        pub fn set_subscription<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.subscription = v.into();
            self
        }
    }

    impl wkt::message::Message for AnalyticsHubSubscriptionInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.Subscription.AnalyticsHubSubscriptionInfo"
        }
    }

    /// Possible states for a subscription.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// The subscription can actively receive messages
        Active,
        /// The subscription cannot receive messages because of an error with the
        /// resource to which it pushes messages. See the more detailed error state
        /// in the corresponding configuration.
        ResourceError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::ResourceError => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::ResourceError => std::option::Option::Some("RESOURCE_ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::ResourceError,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "RESOURCE_ERROR" => Self::ResourceError,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::ResourceError => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.pubsub.v1.Subscription.State",
            ))
        }
    }
}

/// A policy that specifies how Pub/Sub retries message delivery.
///
/// Retry delay will be exponential based on provided minimum and maximum
/// backoffs. <https://en.wikipedia.org/wiki/Exponential_backoff>.
///
/// RetryPolicy will be triggered on NACKs or acknowledgment deadline exceeded
/// events for a given message.
///
/// Retry Policy is implemented on a best effort basis. At times, the delay
/// between consecutive deliveries may not match the configuration. That is,
/// delay can be more or less than configured backoff.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RetryPolicy {
    /// Optional. The minimum delay between consecutive deliveries of a given
    /// message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
    pub minimum_backoff: std::option::Option<wkt::Duration>,

    /// Optional. The maximum delay between consecutive deliveries of a given
    /// message. Value should be between 0 and 600 seconds. Defaults to 600
    /// seconds.
    pub maximum_backoff: std::option::Option<wkt::Duration>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetryPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [minimum_backoff][crate::model::RetryPolicy::minimum_backoff].
    pub fn set_minimum_backoff<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.minimum_backoff = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [minimum_backoff][crate::model::RetryPolicy::minimum_backoff].
    pub fn set_or_clear_minimum_backoff<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.minimum_backoff = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maximum_backoff][crate::model::RetryPolicy::maximum_backoff].
    pub fn set_maximum_backoff<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.maximum_backoff = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maximum_backoff][crate::model::RetryPolicy::maximum_backoff].
    pub fn set_or_clear_maximum_backoff<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.maximum_backoff = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RetryPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.RetryPolicy"
    }
}

/// Dead lettering is done on a best effort basis. The same message might be
/// dead lettered multiple times.
///
/// If validation on any of the fields fails at subscription creation/updation,
/// the create/update subscription request will fail.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeadLetterPolicy {
    /// Optional. The name of the topic to which dead letter messages should be
    /// published. Format is `projects/{project}/topics/{topic}`.The Pub/Sub
    /// service account associated with the enclosing subscription's parent project
    /// (i.e., service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must
    /// have permission to Publish() to this topic.
    ///
    /// The operation will fail if the topic does not exist.
    /// Users should ensure that there is a subscription attached to this topic
    /// since messages published to a topic with no subscriptions are lost.
    pub dead_letter_topic: std::string::String,

    /// Optional. The maximum number of delivery attempts for any message. The
    /// value must be between 5 and 100.
    ///
    /// The number of delivery attempts is defined as 1 + (the sum of number of
    /// NACKs and number of times the acknowledgment deadline has been exceeded
    /// for the message).
    ///
    /// A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
    /// client libraries may automatically extend ack_deadlines.
    ///
    /// This field will be honored on a best effort basis.
    ///
    /// If this parameter is 0, a default value of 5 is used.
    pub max_delivery_attempts: i32,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeadLetterPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dead_letter_topic][crate::model::DeadLetterPolicy::dead_letter_topic].
    pub fn set_dead_letter_topic<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dead_letter_topic = v.into();
        self
    }

    /// Sets the value of [max_delivery_attempts][crate::model::DeadLetterPolicy::max_delivery_attempts].
    pub fn set_max_delivery_attempts<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_delivery_attempts = v.into();
        self
    }
}

impl wkt::message::Message for DeadLetterPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DeadLetterPolicy"
    }
}

/// A policy that specifies the conditions for resource expiration (i.e.,
/// automatic resource deletion).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExpirationPolicy {
    /// Optional. Specifies the "time-to-live" duration for an associated resource.
    /// The resource expires if it is not active for a period of `ttl`. The
    /// definition of "activity" depends on the type of the associated resource.
    /// The minimum and maximum allowed values for `ttl` depend on the type of the
    /// associated resource, as well. If `ttl` is not set, the associated resource
    /// never expires.
    pub ttl: std::option::Option<wkt::Duration>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExpirationPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ttl][crate::model::ExpirationPolicy::ttl].
    pub fn set_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ttl][crate::model::ExpirationPolicy::ttl].
    pub fn set_or_clear_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExpirationPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ExpirationPolicy"
    }
}

/// Configuration for a push delivery endpoint.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PushConfig {
    /// Optional. A URL locating the endpoint to which messages should be pushed.
    /// For example, a Webhook endpoint might use `<https://example.com/push>`.
    pub push_endpoint: std::string::String,

    /// Optional. Endpoint configuration attributes that can be used to control
    /// different aspects of the message delivery.
    ///
    /// The only currently supported attribute is `x-goog-version`, which you can
    /// use to change the format of the pushed message. This attribute
    /// indicates the version of the data expected by the endpoint. This
    /// controls the shape of the pushed message (i.e., its fields and metadata).
    ///
    /// If not present during the `CreateSubscription` call, it will default to
    /// the version of the Pub/Sub API used to make such call. If not present in a
    /// `ModifyPushConfig` call, its value will not be changed. `GetSubscription`
    /// calls will always return a valid version, even if the subscription was
    /// created without this attribute.
    ///
    /// The only supported values for the `x-goog-version` attribute are:
    ///
    /// * `v1beta1`: uses the push format defined in the v1beta1 Pub/Sub API.
    /// * `v1` or `v1beta2`: uses the push format defined in the v1 Pub/Sub API.
    ///
    /// For example:
    /// `attributes { "x-goog-version": "v1" }`
    pub attributes: std::collections::HashMap<std::string::String, std::string::String>,

    /// An authentication method used by push endpoints to verify the source of
    /// push requests. This can be used with push endpoints that are private by
    /// default to allow requests only from the Pub/Sub system, for example.
    /// This field is optional and should be set only by users interested in
    /// authenticated push.
    pub authentication_method: std::option::Option<crate::model::push_config::AuthenticationMethod>,

    /// The format of the delivered message to the push endpoint is defined by
    /// the chosen wrapper. When unset, `PubsubWrapper` is used.
    pub wrapper: std::option::Option<crate::model::push_config::Wrapper>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PushConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [push_endpoint][crate::model::PushConfig::push_endpoint].
    pub fn set_push_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.push_endpoint = v.into();
        self
    }

    /// Sets the value of [attributes][crate::model::PushConfig::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [authentication_method][crate::model::PushConfig::authentication_method].
    ///
    /// Note that all the setters affecting `authentication_method` are mutually
    /// exclusive.
    pub fn set_authentication_method<
        T: std::convert::Into<std::option::Option<crate::model::push_config::AuthenticationMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = v.into();
        self
    }

    /// The value of [authentication_method][crate::model::PushConfig::authentication_method]
    /// if it holds a `OidcToken`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oidc_token(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::push_config::OidcToken>> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::push_config::AuthenticationMethod::OidcToken(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::PushConfig::authentication_method]
    /// to hold a `OidcToken`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    pub fn set_oidc_token<
        T: std::convert::Into<std::boxed::Box<crate::model::push_config::OidcToken>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::push_config::AuthenticationMethod::OidcToken(v.into()),
        );
        self
    }

    /// Sets the value of [wrapper][crate::model::PushConfig::wrapper].
    ///
    /// Note that all the setters affecting `wrapper` are mutually
    /// exclusive.
    pub fn set_wrapper<
        T: std::convert::Into<std::option::Option<crate::model::push_config::Wrapper>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.wrapper = v.into();
        self
    }

    /// The value of [wrapper][crate::model::PushConfig::wrapper]
    /// if it holds a `PubsubWrapper`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pubsub_wrapper(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::push_config::PubsubWrapper>> {
        #[allow(unreachable_patterns)]
        self.wrapper.as_ref().and_then(|v| match v {
            crate::model::push_config::Wrapper::PubsubWrapper(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [wrapper][crate::model::PushConfig::wrapper]
    /// to hold a `PubsubWrapper`.
    ///
    /// Note that all the setters affecting `wrapper` are
    /// mutually exclusive.
    pub fn set_pubsub_wrapper<
        T: std::convert::Into<std::boxed::Box<crate::model::push_config::PubsubWrapper>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.wrapper =
            std::option::Option::Some(crate::model::push_config::Wrapper::PubsubWrapper(v.into()));
        self
    }

    /// The value of [wrapper][crate::model::PushConfig::wrapper]
    /// if it holds a `NoWrapper`, `None` if the field is not set or
    /// holds a different branch.
    pub fn no_wrapper(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::push_config::NoWrapper>> {
        #[allow(unreachable_patterns)]
        self.wrapper.as_ref().and_then(|v| match v {
            crate::model::push_config::Wrapper::NoWrapper(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [wrapper][crate::model::PushConfig::wrapper]
    /// to hold a `NoWrapper`.
    ///
    /// Note that all the setters affecting `wrapper` are
    /// mutually exclusive.
    pub fn set_no_wrapper<
        T: std::convert::Into<std::boxed::Box<crate::model::push_config::NoWrapper>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.wrapper =
            std::option::Option::Some(crate::model::push_config::Wrapper::NoWrapper(v.into()));
        self
    }
}

impl wkt::message::Message for PushConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.PushConfig"
    }
}

/// Defines additional types related to [PushConfig].
pub mod push_config {
    #[allow(unused_imports)]
    use super::*;

    /// Contains information needed for generating an
    /// [OpenID Connect
    /// token](https://developers.google.com/identity/protocols/OpenIDConnect).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OidcToken {
        /// Optional. [Service account
        /// email](https://cloud.google.com/iam/docs/service-accounts)
        /// used for generating the OIDC token. For more information
        /// on setting up authentication, see
        /// [Push subscriptions](https://cloud.google.com/pubsub/docs/push).
        pub service_account_email: std::string::String,

        /// Optional. Audience to be used when generating OIDC token. The audience
        /// claim identifies the recipients that the JWT is intended for. The
        /// audience value is a single case-sensitive string. Having multiple values
        /// (array) for the audience field is not supported. More info about the OIDC
        /// JWT token audience here:
        /// <https://tools.ietf.org/html/rfc7519#section-4.1.3> Note: if not specified,
        /// the Push endpoint URL will be used.
        pub audience: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OidcToken {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service_account_email][crate::model::push_config::OidcToken::service_account_email].
        pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_account_email = v.into();
            self
        }

        /// Sets the value of [audience][crate::model::push_config::OidcToken::audience].
        pub fn set_audience<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.audience = v.into();
            self
        }
    }

    impl wkt::message::Message for OidcToken {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.PushConfig.OidcToken"
        }
    }

    /// The payload to the push endpoint is in the form of the JSON representation
    /// of a PubsubMessage
    /// (<https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#pubsubmessage>).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PubsubWrapper {
        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PubsubWrapper {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PubsubWrapper {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.PushConfig.PubsubWrapper"
        }
    }

    /// Sets the `data` field as the HTTP body for delivery.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NoWrapper {
        /// Optional. When true, writes the Pub/Sub message metadata to
        /// `x-goog-pubsub-<KEY>:<VAL>` headers of the HTTP request. Writes the
        /// Pub/Sub message attributes to `<KEY>:<VAL>` headers of the HTTP request.
        pub write_metadata: bool,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NoWrapper {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [write_metadata][crate::model::push_config::NoWrapper::write_metadata].
        pub fn set_write_metadata<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.write_metadata = v.into();
            self
        }
    }

    impl wkt::message::Message for NoWrapper {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.PushConfig.NoWrapper"
        }
    }

    /// An authentication method used by push endpoints to verify the source of
    /// push requests. This can be used with push endpoints that are private by
    /// default to allow requests only from the Pub/Sub system, for example.
    /// This field is optional and should be set only by users interested in
    /// authenticated push.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthenticationMethod {
        /// Optional. If specified, Pub/Sub will generate and attach an OIDC JWT
        /// token as an `Authorization` header in the HTTP request for every pushed
        /// message.
        OidcToken(std::boxed::Box<crate::model::push_config::OidcToken>),
    }

    /// The format of the delivered message to the push endpoint is defined by
    /// the chosen wrapper. When unset, `PubsubWrapper` is used.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Wrapper {
        /// Optional. When set, the payload to the push endpoint is in the form of
        /// the JSON representation of a PubsubMessage
        /// (<https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#pubsubmessage>).
        PubsubWrapper(std::boxed::Box<crate::model::push_config::PubsubWrapper>),
        /// Optional. When set, the payload to the push endpoint is not wrapped.
        NoWrapper(std::boxed::Box<crate::model::push_config::NoWrapper>),
    }
}

/// Configuration for a BigQuery subscription.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryConfig {
    /// Optional. The name of the table to which to write data, of the form
    /// {projectId}.{datasetId}.{tableId}
    pub table: std::string::String,

    /// Optional. When true, use the topic's schema as the columns to write to in
    /// BigQuery, if it exists. `use_topic_schema` and `use_table_schema` cannot be
    /// enabled at the same time.
    pub use_topic_schema: bool,

    /// Optional. When true, write the subscription name, message_id, publish_time,
    /// attributes, and ordering_key to additional columns in the table. The
    /// subscription name, message_id, and publish_time fields are put in their own
    /// columns while all other message properties (other than data) are written to
    /// a JSON object in the attributes column.
    pub write_metadata: bool,

    /// Optional. When true and use_topic_schema is true, any fields that are a
    /// part of the topic schema that are not part of the BigQuery table schema are
    /// dropped when writing to BigQuery. Otherwise, the schemas must be kept in
    /// sync and any messages with extra fields are not written and remain in the
    /// subscription's backlog.
    pub drop_unknown_fields: bool,

    /// Output only. An output-only field that indicates whether or not the
    /// subscription can receive messages.
    pub state: crate::model::big_query_config::State,

    /// Optional. When true, use the BigQuery table's schema as the columns to
    /// write to in BigQuery. `use_table_schema` and `use_topic_schema` cannot be
    /// enabled at the same time.
    pub use_table_schema: bool,

    /// Optional. The service account to use to write to BigQuery. The subscription
    /// creator or updater that specifies this field must have
    /// `iam.serviceAccounts.actAs` permission on the service account. If not
    /// specified, the Pub/Sub [service
    /// agent](https://cloud.google.com/iam/docs/service-agents),
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
    pub service_account_email: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::BigQueryConfig::table].
    pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [use_topic_schema][crate::model::BigQueryConfig::use_topic_schema].
    pub fn set_use_topic_schema<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_topic_schema = v.into();
        self
    }

    /// Sets the value of [write_metadata][crate::model::BigQueryConfig::write_metadata].
    pub fn set_write_metadata<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.write_metadata = v.into();
        self
    }

    /// Sets the value of [drop_unknown_fields][crate::model::BigQueryConfig::drop_unknown_fields].
    pub fn set_drop_unknown_fields<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.drop_unknown_fields = v.into();
        self
    }

    /// Sets the value of [state][crate::model::BigQueryConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::big_query_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [use_table_schema][crate::model::BigQueryConfig::use_table_schema].
    pub fn set_use_table_schema<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_table_schema = v.into();
        self
    }

    /// Sets the value of [service_account_email][crate::model::BigQueryConfig::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.BigQueryConfig"
    }
}

/// Defines additional types related to [BigQueryConfig].
pub mod big_query_config {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states for a BigQuery subscription.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// The subscription can actively send messages to BigQuery
        Active,
        /// Cannot write to the BigQuery table because of permission denied errors.
        /// This can happen if
        ///
        /// - Pub/Sub SA has not been granted the [appropriate BigQuery IAM
        ///   permissions](https://cloud.google.com/pubsub/docs/create-subscription#assign_bigquery_service_account)
        /// - bigquery.googleapis.com API is not enabled for the project
        ///   ([instructions](https://cloud.google.com/service-usage/docs/enable-disable))
        PermissionDenied,
        /// Cannot write to the BigQuery table because it does not exist.
        NotFound,
        /// Cannot write to the BigQuery table due to a schema mismatch.
        SchemaMismatch,
        /// Cannot write to the destination because enforce_in_transit is set to true
        /// and the destination locations are not in the allowed regions.
        InTransitLocationRestriction,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::PermissionDenied => std::option::Option::Some(2),
                Self::NotFound => std::option::Option::Some(3),
                Self::SchemaMismatch => std::option::Option::Some(4),
                Self::InTransitLocationRestriction => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::NotFound => std::option::Option::Some("NOT_FOUND"),
                Self::SchemaMismatch => std::option::Option::Some("SCHEMA_MISMATCH"),
                Self::InTransitLocationRestriction => {
                    std::option::Option::Some("IN_TRANSIT_LOCATION_RESTRICTION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::PermissionDenied,
                3 => Self::NotFound,
                4 => Self::SchemaMismatch,
                5 => Self::InTransitLocationRestriction,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "PERMISSION_DENIED" => Self::PermissionDenied,
                "NOT_FOUND" => Self::NotFound,
                "SCHEMA_MISMATCH" => Self::SchemaMismatch,
                "IN_TRANSIT_LOCATION_RESTRICTION" => Self::InTransitLocationRestriction,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::PermissionDenied => serializer.serialize_i32(2),
                Self::NotFound => serializer.serialize_i32(3),
                Self::SchemaMismatch => serializer.serialize_i32(4),
                Self::InTransitLocationRestriction => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.pubsub.v1.BigQueryConfig.State",
            ))
        }
    }
}

/// Configuration for a Cloud Storage subscription.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudStorageConfig {
    /// Required. User-provided name for the Cloud Storage bucket.
    /// The bucket must be created by the user. The bucket name must be without
    /// any prefix like "gs://". See the [bucket naming
    /// requirements] (<https://cloud.google.com/storage/docs/buckets#naming>).
    pub bucket: std::string::String,

    /// Optional. User-provided prefix for Cloud Storage filename. See the [object
    /// naming requirements](https://cloud.google.com/storage/docs/objects#naming).
    pub filename_prefix: std::string::String,

    /// Optional. User-provided suffix for Cloud Storage filename. See the [object
    /// naming requirements](https://cloud.google.com/storage/docs/objects#naming).
    /// Must not end in "/".
    pub filename_suffix: std::string::String,

    /// Optional. User-provided format string specifying how to represent datetimes
    /// in Cloud Storage filenames. See the [datetime format
    /// guidance](https://cloud.google.com/pubsub/docs/create-cloudstorage-subscription#file_names).
    pub filename_datetime_format: std::string::String,

    /// Optional. The maximum duration that can elapse before a new Cloud Storage
    /// file is created. Min 1 minute, max 10 minutes, default 5 minutes. May not
    /// exceed the subscription's acknowledgment deadline.
    pub max_duration: std::option::Option<wkt::Duration>,

    /// Optional. The maximum bytes that can be written to a Cloud Storage file
    /// before a new file is created. Min 1 KB, max 10 GiB. The max_bytes limit may
    /// be exceeded in cases where messages are larger than the limit.
    pub max_bytes: i64,

    /// Optional. The maximum number of messages that can be written to a Cloud
    /// Storage file before a new file is created. Min 1000 messages.
    pub max_messages: i64,

    /// Output only. An output-only field that indicates whether or not the
    /// subscription can receive messages.
    pub state: crate::model::cloud_storage_config::State,

    /// Optional. The service account to use to write to Cloud Storage. The
    /// subscription creator or updater that specifies this field must have
    /// `iam.serviceAccounts.actAs` permission on the service account. If not
    /// specified, the Pub/Sub
    /// [service agent](https://cloud.google.com/iam/docs/service-agents),
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
    pub service_account_email: std::string::String,

    /// Defaults to text format.
    pub output_format: std::option::Option<crate::model::cloud_storage_config::OutputFormat>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::CloudStorageConfig::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [filename_prefix][crate::model::CloudStorageConfig::filename_prefix].
    pub fn set_filename_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filename_prefix = v.into();
        self
    }

    /// Sets the value of [filename_suffix][crate::model::CloudStorageConfig::filename_suffix].
    pub fn set_filename_suffix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filename_suffix = v.into();
        self
    }

    /// Sets the value of [filename_datetime_format][crate::model::CloudStorageConfig::filename_datetime_format].
    pub fn set_filename_datetime_format<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.filename_datetime_format = v.into();
        self
    }

    /// Sets the value of [max_duration][crate::model::CloudStorageConfig::max_duration].
    pub fn set_max_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_duration][crate::model::CloudStorageConfig::max_duration].
    pub fn set_or_clear_max_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_bytes][crate::model::CloudStorageConfig::max_bytes].
    pub fn set_max_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_bytes = v.into();
        self
    }

    /// Sets the value of [max_messages][crate::model::CloudStorageConfig::max_messages].
    pub fn set_max_messages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_messages = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CloudStorageConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::cloud_storage_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [service_account_email][crate::model::CloudStorageConfig::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [output_format][crate::model::CloudStorageConfig::output_format].
    ///
    /// Note that all the setters affecting `output_format` are mutually
    /// exclusive.
    pub fn set_output_format<
        T: std::convert::Into<std::option::Option<crate::model::cloud_storage_config::OutputFormat>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_format = v.into();
        self
    }

    /// The value of [output_format][crate::model::CloudStorageConfig::output_format]
    /// if it holds a `TextConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cloud_storage_config::TextConfig>> {
        #[allow(unreachable_patterns)]
        self.output_format.as_ref().and_then(|v| match v {
            crate::model::cloud_storage_config::OutputFormat::TextConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_format][crate::model::CloudStorageConfig::output_format]
    /// to hold a `TextConfig`.
    ///
    /// Note that all the setters affecting `output_format` are
    /// mutually exclusive.
    pub fn set_text_config<
        T: std::convert::Into<std::boxed::Box<crate::model::cloud_storage_config::TextConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_format = std::option::Option::Some(
            crate::model::cloud_storage_config::OutputFormat::TextConfig(v.into()),
        );
        self
    }

    /// The value of [output_format][crate::model::CloudStorageConfig::output_format]
    /// if it holds a `AvroConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn avro_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cloud_storage_config::AvroConfig>> {
        #[allow(unreachable_patterns)]
        self.output_format.as_ref().and_then(|v| match v {
            crate::model::cloud_storage_config::OutputFormat::AvroConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_format][crate::model::CloudStorageConfig::output_format]
    /// to hold a `AvroConfig`.
    ///
    /// Note that all the setters affecting `output_format` are
    /// mutually exclusive.
    pub fn set_avro_config<
        T: std::convert::Into<std::boxed::Box<crate::model::cloud_storage_config::AvroConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_format = std::option::Option::Some(
            crate::model::cloud_storage_config::OutputFormat::AvroConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloudStorageConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.CloudStorageConfig"
    }
}

/// Defines additional types related to [CloudStorageConfig].
pub mod cloud_storage_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for writing message data in text format.
    /// Message payloads will be written to files as raw text, separated by a
    /// newline.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TextConfig {
        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TextConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for TextConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.CloudStorageConfig.TextConfig"
        }
    }

    /// Configuration for writing message data in Avro format.
    /// Message payloads and metadata will be written to files as an Avro binary.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AvroConfig {
        /// Optional. When true, write the subscription name, message_id,
        /// publish_time, attributes, and ordering_key as additional fields in the
        /// output. The subscription name, message_id, and publish_time fields are
        /// put in their own fields while all other message properties other than
        /// data (for example, an ordering_key, if present) are added as entries in
        /// the attributes map.
        pub write_metadata: bool,

        /// Optional. When true, the output Cloud Storage file will be serialized
        /// using the topic schema, if it exists.
        pub use_topic_schema: bool,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AvroConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [write_metadata][crate::model::cloud_storage_config::AvroConfig::write_metadata].
        pub fn set_write_metadata<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.write_metadata = v.into();
            self
        }

        /// Sets the value of [use_topic_schema][crate::model::cloud_storage_config::AvroConfig::use_topic_schema].
        pub fn set_use_topic_schema<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.use_topic_schema = v.into();
            self
        }
    }

    impl wkt::message::Message for AvroConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.CloudStorageConfig.AvroConfig"
        }
    }

    /// Possible states for a Cloud Storage subscription.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// The subscription can actively send messages to Cloud Storage.
        Active,
        /// Cannot write to the Cloud Storage bucket because of permission denied
        /// errors.
        PermissionDenied,
        /// Cannot write to the Cloud Storage bucket because it does not exist.
        NotFound,
        /// Cannot write to the destination because enforce_in_transit is set to true
        /// and the destination locations are not in the allowed regions.
        InTransitLocationRestriction,
        /// Cannot write to the Cloud Storage bucket due to an incompatibility
        /// between the topic schema and subscription settings.
        SchemaMismatch,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::PermissionDenied => std::option::Option::Some(2),
                Self::NotFound => std::option::Option::Some(3),
                Self::InTransitLocationRestriction => std::option::Option::Some(4),
                Self::SchemaMismatch => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::NotFound => std::option::Option::Some("NOT_FOUND"),
                Self::InTransitLocationRestriction => {
                    std::option::Option::Some("IN_TRANSIT_LOCATION_RESTRICTION")
                }
                Self::SchemaMismatch => std::option::Option::Some("SCHEMA_MISMATCH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::PermissionDenied,
                3 => Self::NotFound,
                4 => Self::InTransitLocationRestriction,
                5 => Self::SchemaMismatch,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "PERMISSION_DENIED" => Self::PermissionDenied,
                "NOT_FOUND" => Self::NotFound,
                "IN_TRANSIT_LOCATION_RESTRICTION" => Self::InTransitLocationRestriction,
                "SCHEMA_MISMATCH" => Self::SchemaMismatch,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::PermissionDenied => serializer.serialize_i32(2),
                Self::NotFound => serializer.serialize_i32(3),
                Self::InTransitLocationRestriction => serializer.serialize_i32(4),
                Self::SchemaMismatch => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.pubsub.v1.CloudStorageConfig.State",
            ))
        }
    }

    /// Defaults to text format.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OutputFormat {
        /// Optional. If set, message data will be written to Cloud Storage in text
        /// format.
        TextConfig(std::boxed::Box<crate::model::cloud_storage_config::TextConfig>),
        /// Optional. If set, message data will be written to Cloud Storage in Avro
        /// format.
        AvroConfig(std::boxed::Box<crate::model::cloud_storage_config::AvroConfig>),
    }
}

/// Request for the GetSubscription method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSubscriptionRequest {
    /// Required. The name of the subscription to get.
    /// Format is `projects/{project}/subscriptions/{sub}`.
    pub subscription: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSubscriptionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::GetSubscriptionRequest::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }
}

impl wkt::message::Message for GetSubscriptionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.GetSubscriptionRequest"
    }
}

/// Request for the UpdateSubscription method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSubscriptionRequest {
    /// Required. The updated subscription object.
    pub subscription: std::option::Option<crate::model::Subscription>,

    /// Required. Indicates which fields in the provided subscription to update.
    /// Must be specified and non-empty.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSubscriptionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::UpdateSubscriptionRequest::subscription].
    pub fn set_subscription<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Subscription>,
    {
        self.subscription = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subscription][crate::model::UpdateSubscriptionRequest::subscription].
    pub fn set_or_clear_subscription<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Subscription>,
    {
        self.subscription = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSubscriptionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSubscriptionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSubscriptionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.UpdateSubscriptionRequest"
    }
}

/// Request for the `ListSubscriptions` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSubscriptionsRequest {
    /// Required. The name of the project in which to list subscriptions.
    /// Format is `projects/{project-id}`.
    pub project: std::string::String,

    /// Optional. Maximum number of subscriptions to return.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListSubscriptionsResponse`;
    /// indicates that this is a continuation of a prior `ListSubscriptions` call,
    /// and that the system should return the next page of data.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSubscriptionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::ListSubscriptionsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSubscriptionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSubscriptionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSubscriptionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSubscriptionsRequest"
    }
}

/// Response for the `ListSubscriptions` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSubscriptionsResponse {
    /// Optional. The subscriptions that match the request.
    pub subscriptions: std::vec::Vec<crate::model::Subscription>,

    /// Optional. If not empty, indicates that there may be more subscriptions that
    /// match the request; this value should be passed in a new
    /// `ListSubscriptionsRequest` to get more subscriptions.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSubscriptionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscriptions][crate::model::ListSubscriptionsResponse::subscriptions].
    pub fn set_subscriptions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Subscription>,
    {
        use std::iter::Iterator;
        self.subscriptions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSubscriptionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSubscriptionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSubscriptionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSubscriptionsResponse {
    type PageItem = crate::model::Subscription;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.subscriptions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the DeleteSubscription method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSubscriptionRequest {
    /// Required. The subscription to delete.
    /// Format is `projects/{project}/subscriptions/{sub}`.
    pub subscription: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSubscriptionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::DeleteSubscriptionRequest::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSubscriptionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DeleteSubscriptionRequest"
    }
}

/// Request for the ModifyPushConfig method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ModifyPushConfigRequest {
    /// Required. The name of the subscription.
    /// Format is `projects/{project}/subscriptions/{sub}`.
    pub subscription: std::string::String,

    /// Required. The push configuration for future deliveries.
    ///
    /// An empty `pushConfig` indicates that the Pub/Sub system should
    /// stop pushing messages from the given subscription and allow
    /// messages to be pulled and acknowledged - effectively pausing
    /// the subscription if `Pull` or `StreamingPull` is not called.
    pub push_config: std::option::Option<crate::model::PushConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModifyPushConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::ModifyPushConfigRequest::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }

    /// Sets the value of [push_config][crate::model::ModifyPushConfigRequest::push_config].
    pub fn set_push_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PushConfig>,
    {
        self.push_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [push_config][crate::model::ModifyPushConfigRequest::push_config].
    pub fn set_or_clear_push_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PushConfig>,
    {
        self.push_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ModifyPushConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ModifyPushConfigRequest"
    }
}

/// Request for the `CreateSnapshot` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSnapshotRequest {
    /// Required. User-provided name for this snapshot. If the name is not provided
    /// in the request, the server will assign a random name for this snapshot on
    /// the same project as the subscription. Note that for REST API requests, you
    /// must specify a name.  See the [resource name
    /// rules](https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names).
    /// Format is `projects/{project}/snapshots/{snap}`.
    pub name: std::string::String,

    /// Required. The subscription whose backlog the snapshot retains.
    /// Specifically, the created snapshot is guaranteed to retain:
    /// (a) The existing backlog on the subscription. More precisely, this is
    /// defined as the messages in the subscription's backlog that are
    /// unacknowledged upon the successful completion of the
    /// `CreateSnapshot` request; as well as:
    /// (b) Any messages published to the subscription's topic following the
    /// successful completion of the CreateSnapshot request.
    /// Format is `projects/{project}/subscriptions/{sub}`.
    pub subscription: std::string::String,

    /// Optional. See [Creating and managing
    /// labels](https://cloud.google.com/pubsub/docs/labels).
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CreateSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [subscription][crate::model::CreateSnapshotRequest::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::CreateSnapshotRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CreateSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.CreateSnapshotRequest"
    }
}

/// Request for the UpdateSnapshot method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSnapshotRequest {
    /// Required. The updated snapshot object.
    pub snapshot: std::option::Option<crate::model::Snapshot>,

    /// Required. Indicates which fields in the provided snapshot to update.
    /// Must be specified and non-empty.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshot][crate::model::UpdateSnapshotRequest::snapshot].
    pub fn set_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Snapshot>,
    {
        self.snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot][crate::model::UpdateSnapshotRequest::snapshot].
    pub fn set_or_clear_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Snapshot>,
    {
        self.snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSnapshotRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSnapshotRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.UpdateSnapshotRequest"
    }
}

/// A snapshot resource. Snapshots are used in
/// [Seek](https://cloud.google.com/pubsub/docs/replay-overview)
/// operations, which allow you to manage message acknowledgments in bulk. That
/// is, you can set the acknowledgment state of messages in an existing
/// subscription to the state captured by a snapshot.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Snapshot {
    /// Optional. The name of the snapshot.
    pub name: std::string::String,

    /// Optional. The name of the topic from which this snapshot is retaining
    /// messages.
    pub topic: std::string::String,

    /// Optional. The snapshot is guaranteed to exist up until this time.
    /// A newly-created snapshot expires no later than 7 days from the time of its
    /// creation. Its exact lifetime is determined at creation by the existing
    /// backlog in the source subscription. Specifically, the lifetime of the
    /// snapshot is `7 days - (age of oldest unacked message in the subscription)`.
    /// For example, consider a subscription whose oldest unacked message is 3 days
    /// old. If a snapshot is created from this subscription, the snapshot -- which
    /// will always capture this 3-day-old backlog as long as the snapshot
    /// exists -- will expire in 4 days. The service will refuse to create a
    /// snapshot that would expire in less than 1 hour after creation.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Optional. See [Creating and managing labels]
    /// (<https://cloud.google.com/pubsub/docs/labels>).
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Snapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Snapshot::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [topic][crate::model::Snapshot::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Snapshot::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Snapshot::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Snapshot::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Snapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.Snapshot"
    }
}

/// Request for the GetSnapshot method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSnapshotRequest {
    /// Required. The name of the snapshot to get.
    /// Format is `projects/{project}/snapshots/{snap}`.
    pub snapshot: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshot][crate::model::GetSnapshotRequest::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot = v.into();
        self
    }
}

impl wkt::message::Message for GetSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.GetSnapshotRequest"
    }
}

/// Request for the `ListSnapshots` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSnapshotsRequest {
    /// Required. The name of the project in which to list snapshots.
    /// Format is `projects/{project-id}`.
    pub project: std::string::String,

    /// Optional. Maximum number of snapshots to return.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListSnapshotsResponse`; indicates
    /// that this is a continuation of a prior `ListSnapshots` call, and that the
    /// system should return the next page of data.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSnapshotsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::ListSnapshotsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSnapshotsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSnapshotsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSnapshotsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSnapshotsRequest"
    }
}

/// Response for the `ListSnapshots` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSnapshotsResponse {
    /// Optional. The resulting snapshots.
    pub snapshots: std::vec::Vec<crate::model::Snapshot>,

    /// Optional. If not empty, indicates that there may be more snapshot that
    /// match the request; this value should be passed in a new
    /// `ListSnapshotsRequest`.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSnapshotsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots][crate::model::ListSnapshotsResponse::snapshots].
    pub fn set_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Snapshot>,
    {
        use std::iter::Iterator;
        self.snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSnapshotsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSnapshotsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSnapshotsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSnapshotsResponse {
    type PageItem = crate::model::Snapshot;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.snapshots
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `DeleteSnapshot` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSnapshotRequest {
    /// Required. The name of the snapshot to delete.
    /// Format is `projects/{project}/snapshots/{snap}`.
    pub snapshot: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshot][crate::model::DeleteSnapshotRequest::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DeleteSnapshotRequest"
    }
}

/// Request for the `Seek` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SeekRequest {
    /// Required. The subscription to affect.
    pub subscription: std::string::String,

    pub target: std::option::Option<crate::model::seek_request::Target>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SeekRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::SeekRequest::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }

    /// Sets the value of [target][crate::model::SeekRequest::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::seek_request::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::SeekRequest::target]
    /// if it holds a `Time`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::seek_request::Target::Time(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::SeekRequest::target]
    /// to hold a `Time`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(crate::model::seek_request::Target::Time(v.into()));
        self
    }

    /// The value of [target][crate::model::SeekRequest::target]
    /// if it holds a `Snapshot`, `None` if the field is not set or
    /// holds a different branch.
    pub fn snapshot(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::seek_request::Target::Snapshot(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::SeekRequest::target]
    /// to hold a `Snapshot`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target =
            std::option::Option::Some(crate::model::seek_request::Target::Snapshot(v.into()));
        self
    }
}

impl wkt::message::Message for SeekRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.SeekRequest"
    }
}

/// Defines additional types related to [SeekRequest].
pub mod seek_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Target {
        /// Optional. The time to seek to.
        /// Messages retained in the subscription that were published before this
        /// time are marked as acknowledged, and messages retained in the
        /// subscription that were published after this time are marked as
        /// unacknowledged. Note that this operation affects only those messages
        /// retained in the subscription (configured by the combination of
        /// `message_retention_duration` and `retain_acked_messages`). For example,
        /// if `time` corresponds to a point before the message retention
        /// window (or to a point before the system's notion of the subscription
        /// creation time), only retained messages will be marked as unacknowledged,
        /// and already-expunged messages will not be restored.
        Time(std::boxed::Box<wkt::Timestamp>),
        /// Optional. The snapshot to seek to. The snapshot's topic must be the same
        /// as that of the provided subscription. Format is
        /// `projects/{project}/snapshots/{snap}`.
        Snapshot(std::string::String),
    }
}

/// Response for the `Seek` method (this response is empty).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SeekResponse {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SeekResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SeekResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.SeekResponse"
    }
}

/// A schema resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Schema {
    /// Required. Name of the schema.
    /// Format is `projects/{project}/schemas/{schema}`.
    pub name: std::string::String,

    /// The type of the schema definition.
    pub r#type: crate::model::schema::Type,

    /// The definition of the schema. This should contain a string representing
    /// the full definition of the schema that is a valid schema definition of
    /// the type specified in `type`.
    pub definition: std::string::String,

    /// Output only. Immutable. The revision ID of the schema.
    pub revision_id: std::string::String,

    /// Output only. The timestamp that the revision was created.
    pub revision_create_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Schema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Schema::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Schema::type].
    pub fn set_type<T: std::convert::Into<crate::model::schema::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [definition][crate::model::Schema::definition].
    pub fn set_definition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.definition = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::Schema::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [revision_create_time][crate::model::Schema::revision_create_time].
    pub fn set_revision_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.revision_create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [revision_create_time][crate::model::Schema::revision_create_time].
    pub fn set_or_clear_revision_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.revision_create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Schema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.Schema"
    }
}

/// Defines additional types related to [Schema].
pub mod schema {
    #[allow(unused_imports)]
    use super::*;

    /// Possible schema definition types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default value. This value is unused.
        Unspecified,
        /// A Protocol Buffer schema definition.
        ProtocolBuffer,
        /// An Avro schema definition.
        Avro,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ProtocolBuffer => std::option::Option::Some(1),
                Self::Avro => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::ProtocolBuffer => std::option::Option::Some("PROTOCOL_BUFFER"),
                Self::Avro => std::option::Option::Some("AVRO"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ProtocolBuffer,
                2 => Self::Avro,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "PROTOCOL_BUFFER" => Self::ProtocolBuffer,
                "AVRO" => Self::Avro,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ProtocolBuffer => serializer.serialize_i32(1),
                Self::Avro => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.pubsub.v1.Schema.Type",
            ))
        }
    }
}

/// Request for the CreateSchema method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSchemaRequest {
    /// Required. The name of the project in which to create the schema.
    /// Format is `projects/{project-id}`.
    pub parent: std::string::String,

    /// Required. The schema object to create.
    ///
    /// This schema's `name` parameter is ignored. The schema object returned
    /// by CreateSchema will have a `name` made using the given `parent` and
    /// `schema_id`.
    pub schema: std::option::Option<crate::model::Schema>,

    /// The ID to use for the schema, which will become the final component of
    /// the schema's resource name.
    ///
    /// See <https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names> for
    /// resource name constraints.
    pub schema_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSchemaRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::CreateSchemaRequest::schema].
    pub fn set_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema][crate::model::CreateSchemaRequest::schema].
    pub fn set_or_clear_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schema_id][crate::model::CreateSchemaRequest::schema_id].
    pub fn set_schema_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.CreateSchemaRequest"
    }
}

/// Request for the GetSchema method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSchemaRequest {
    /// Required. The name of the schema to get.
    /// Format is `projects/{project}/schemas/{schema}`.
    pub name: std::string::String,

    /// The set of fields to return in the response. If not set, returns a Schema
    /// with all fields filled out. Set to `BASIC` to omit the `definition`.
    pub view: crate::model::SchemaView,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSchemaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetSchemaRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::SchemaView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.GetSchemaRequest"
    }
}

/// Request for the `ListSchemas` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemasRequest {
    /// Required. The name of the project in which to list schemas.
    /// Format is `projects/{project-id}`.
    pub parent: std::string::String,

    /// The set of Schema fields to return in the response. If not set, returns
    /// Schemas with `name` and `type`, but not `definition`. Set to `FULL` to
    /// retrieve all fields.
    pub view: crate::model::SchemaView,

    /// Maximum number of schemas to return.
    pub page_size: i32,

    /// The value returned by the last `ListSchemasResponse`; indicates that
    /// this is a continuation of a prior `ListSchemas` call, and that the
    /// system should return the next page of data.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSchemasRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListSchemasRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::SchemaView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSchemasRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSchemasRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSchemasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSchemasRequest"
    }
}

/// Response for the `ListSchemas` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemasResponse {
    /// The resulting schemas.
    pub schemas: std::vec::Vec<crate::model::Schema>,

    /// If not empty, indicates that there may be more schemas that match the
    /// request; this value should be passed in a new `ListSchemasRequest`.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schemas][crate::model::ListSchemasResponse::schemas].
    pub fn set_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Schema>,
    {
        use std::iter::Iterator;
        self.schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSchemasResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSchemasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSchemasResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSchemasResponse {
    type PageItem = crate::model::Schema;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.schemas
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the `ListSchemaRevisions` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemaRevisionsRequest {
    /// Required. The name of the schema to list revisions for.
    pub name: std::string::String,

    /// The set of Schema fields to return in the response. If not set, returns
    /// Schemas with `name` and `type`, but not `definition`. Set to `FULL` to
    /// retrieve all fields.
    pub view: crate::model::SchemaView,

    /// The maximum number of revisions to return per page.
    pub page_size: i32,

    /// The page token, received from a previous ListSchemaRevisions call.
    /// Provide this to retrieve the subsequent page.
    pub page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemaRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListSchemaRevisionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListSchemaRevisionsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::SchemaView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSchemaRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSchemaRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSchemaRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSchemaRevisionsRequest"
    }
}

/// Response for the `ListSchemaRevisions` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemaRevisionsResponse {
    /// The revisions of the schema.
    pub schemas: std::vec::Vec<crate::model::Schema>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is empty, there are no subsequent pages.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemaRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schemas][crate::model::ListSchemaRevisionsResponse::schemas].
    pub fn set_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Schema>,
    {
        use std::iter::Iterator;
        self.schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSchemaRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSchemaRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSchemaRevisionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSchemaRevisionsResponse {
    type PageItem = crate::model::Schema;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.schemas
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for CommitSchema method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CommitSchemaRequest {
    /// Required. The name of the schema we are revising.
    /// Format is `projects/{project}/schemas/{schema}`.
    pub name: std::string::String,

    /// Required. The schema revision to commit.
    pub schema: std::option::Option<crate::model::Schema>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommitSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CommitSchemaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::CommitSchemaRequest::schema].
    pub fn set_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema][crate::model::CommitSchemaRequest::schema].
    pub fn set_or_clear_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CommitSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.CommitSchemaRequest"
    }
}

/// Request for the `RollbackSchema` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RollbackSchemaRequest {
    /// Required. The schema being rolled back with revision id.
    pub name: std::string::String,

    /// Required. The revision ID to roll back to.
    /// It must be a revision of the same schema.
    ///
    /// Example: c7cfa2a8
    pub revision_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RollbackSchemaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::RollbackSchemaRequest::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }
}

impl wkt::message::Message for RollbackSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.RollbackSchemaRequest"
    }
}

/// Request for the `DeleteSchemaRevision` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSchemaRevisionRequest {
    /// Required. The name of the schema revision to be deleted, with a revision ID
    /// explicitly included.
    ///
    /// Example: `projects/123/schemas/my-schema@c7cfa2a8`
    pub name: std::string::String,

    /// Optional. This field is deprecated and should not be used for specifying
    /// the revision ID. The revision ID should be specified via the `name`
    /// parameter.
    #[deprecated]
    pub revision_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSchemaRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSchemaRevisionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::DeleteSchemaRevisionRequest::revision_id].
    #[deprecated]
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSchemaRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DeleteSchemaRevisionRequest"
    }
}

/// Request for the `DeleteSchema` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSchemaRequest {
    /// Required. Name of the schema to delete.
    /// Format is `projects/{project}/schemas/{schema}`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSchemaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DeleteSchemaRequest"
    }
}

/// Request for the `ValidateSchema` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateSchemaRequest {
    /// Required. The name of the project in which to validate schemas.
    /// Format is `projects/{project-id}`.
    pub parent: std::string::String,

    /// Required. The schema object to validate.
    pub schema: std::option::Option<crate::model::Schema>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ValidateSchemaRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::ValidateSchemaRequest::schema].
    pub fn set_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema][crate::model::ValidateSchemaRequest::schema].
    pub fn set_or_clear_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ValidateSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ValidateSchemaRequest"
    }
}

/// Response for the `ValidateSchema` method.
/// Empty for now.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateSchemaResponse {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateSchemaResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ValidateSchemaResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ValidateSchemaResponse"
    }
}

/// Request for the `ValidateMessage` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateMessageRequest {
    /// Required. The name of the project in which to validate schemas.
    /// Format is `projects/{project-id}`.
    pub parent: std::string::String,

    /// Message to validate against the provided `schema_spec`.
    pub message: ::bytes::Bytes,

    /// The encoding expected for messages
    pub encoding: crate::model::Encoding,

    pub schema_spec: std::option::Option<crate::model::validate_message_request::SchemaSpec>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateMessageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ValidateMessageRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [message][crate::model::ValidateMessageRequest::message].
    pub fn set_message<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [encoding][crate::model::ValidateMessageRequest::encoding].
    pub fn set_encoding<T: std::convert::Into<crate::model::Encoding>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [schema_spec][crate::model::ValidateMessageRequest::schema_spec].
    ///
    /// Note that all the setters affecting `schema_spec` are mutually
    /// exclusive.
    pub fn set_schema_spec<
        T: std::convert::Into<std::option::Option<crate::model::validate_message_request::SchemaSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema_spec = v.into();
        self
    }

    /// The value of [schema_spec][crate::model::ValidateMessageRequest::schema_spec]
    /// if it holds a `Name`, `None` if the field is not set or
    /// holds a different branch.
    pub fn name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.schema_spec.as_ref().and_then(|v| match v {
            crate::model::validate_message_request::SchemaSpec::Name(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema_spec][crate::model::ValidateMessageRequest::schema_spec]
    /// to hold a `Name`.
    ///
    /// Note that all the setters affecting `schema_spec` are
    /// mutually exclusive.
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_spec = std::option::Option::Some(
            crate::model::validate_message_request::SchemaSpec::Name(v.into()),
        );
        self
    }

    /// The value of [schema_spec][crate::model::ValidateMessageRequest::schema_spec]
    /// if it holds a `Schema`, `None` if the field is not set or
    /// holds a different branch.
    pub fn schema(&self) -> std::option::Option<&std::boxed::Box<crate::model::Schema>> {
        #[allow(unreachable_patterns)]
        self.schema_spec.as_ref().and_then(|v| match v {
            crate::model::validate_message_request::SchemaSpec::Schema(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema_spec][crate::model::ValidateMessageRequest::schema_spec]
    /// to hold a `Schema`.
    ///
    /// Note that all the setters affecting `schema_spec` are
    /// mutually exclusive.
    pub fn set_schema<T: std::convert::Into<std::boxed::Box<crate::model::Schema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema_spec = std::option::Option::Some(
            crate::model::validate_message_request::SchemaSpec::Schema(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ValidateMessageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ValidateMessageRequest"
    }
}

/// Defines additional types related to [ValidateMessageRequest].
pub mod validate_message_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SchemaSpec {
        /// Name of the schema against which to validate.
        ///
        /// Format is `projects/{project}/schemas/{schema}`.
        Name(std::string::String),
        /// Ad-hoc schema against which to validate
        Schema(std::boxed::Box<crate::model::Schema>),
    }
}

/// Response for the `ValidateMessage` method.
/// Empty for now.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateMessageResponse {
    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateMessageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ValidateMessageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ValidateMessageResponse"
    }
}

/// View of Schema object fields to be returned by GetSchema and ListSchemas.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SchemaView {
    /// The default / unset value.
    /// The API will default to the BASIC view.
    Unspecified,
    /// Include the name and type of the schema, but not the definition.
    Basic,
    /// Include all Schema object fields.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SchemaView::value] or
    /// [SchemaView::name].
    UnknownValue(schema_view::UnknownValue),
}

#[doc(hidden)]
pub mod schema_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SchemaView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SCHEMA_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SchemaView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SchemaView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SchemaView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(schema_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SchemaView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SCHEMA_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BASIC" => Self::Basic,
            "FULL" => Self::Full,
            _ => Self::UnknownValue(schema_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SchemaView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SchemaView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SchemaView>::new(
            ".google.pubsub.v1.SchemaView",
        ))
    }
}

/// Possible encoding types for messages.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Encoding {
    /// Unspecified
    Unspecified,
    /// JSON encoding
    Json,
    /// Binary encoding, as defined by the schema type. For some schema types,
    /// binary encoding may not be available.
    Binary,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Encoding::value] or
    /// [Encoding::name].
    UnknownValue(encoding::UnknownValue),
}

#[doc(hidden)]
pub mod encoding {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Encoding {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Json => std::option::Option::Some(1),
            Self::Binary => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ENCODING_UNSPECIFIED"),
            Self::Json => std::option::Option::Some("JSON"),
            Self::Binary => std::option::Option::Some("BINARY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Encoding {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Encoding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Encoding {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Json,
            2 => Self::Binary,
            _ => Self::UnknownValue(encoding::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Encoding {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENCODING_UNSPECIFIED" => Self::Unspecified,
            "JSON" => Self::Json,
            "BINARY" => Self::Binary,
            _ => Self::UnknownValue(encoding::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Encoding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Json => serializer.serialize_i32(1),
            Self::Binary => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Encoding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Encoding>::new(
            ".google.pubsub.v1.Encoding",
        ))
    }
}
