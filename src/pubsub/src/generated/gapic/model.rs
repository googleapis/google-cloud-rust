// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]

/// A policy constraining the storage of messages published to the topic.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MessageStoragePolicy {
    /// Optional. A list of IDs of Google Cloud regions where messages that are
    /// published to the topic may be persisted in storage. Messages published by
    /// publishers running in non-allowed Google Cloud regions (or running outside
    /// of Google Cloud altogether) are routed for storage in one of the allowed
    /// regions. An empty list means that no regions are allowed, and is not a
    /// valid configuration.
    pub allowed_persistence_regions: std::vec::Vec<std::string::String>,

    /// Optional. If true, `allowed_persistence_regions` is also used to enforce
    /// in-transit guarantees for messages. That is, Pub/Sub will fail
    /// Publish operations on this topic and subscribe operations
    /// on any subscription attached to this topic in any region that is
    /// not in `allowed_persistence_regions`.
    pub enforce_in_transit: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MessageStoragePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_persistence_regions][crate::model::MessageStoragePolicy::allowed_persistence_regions].
    pub fn set_allowed_persistence_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_persistence_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [enforce_in_transit][crate::model::MessageStoragePolicy::enforce_in_transit].
    pub fn set_enforce_in_transit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enforce_in_transit = v.into();
        self
    }
}

impl wkt::message::Message for MessageStoragePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.MessageStoragePolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MessageStoragePolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowed_persistence_regions,
            __enforce_in_transit,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageStoragePolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowedPersistenceRegions" => {
                                Ok(__FieldTag::__allowed_persistence_regions)
                            }
                            "allowed_persistence_regions" => {
                                Ok(__FieldTag::__allowed_persistence_regions)
                            }
                            "enforceInTransit" => Ok(__FieldTag::__enforce_in_transit),
                            "enforce_in_transit" => Ok(__FieldTag::__enforce_in_transit),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MessageStoragePolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageStoragePolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowed_persistence_regions => {
                            if !fields.insert(__FieldTag::__allowed_persistence_regions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_persistence_regions",
                                ));
                            }
                            result.allowed_persistence_regions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__enforce_in_transit => {
                            if !fields.insert(__FieldTag::__enforce_in_transit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enforce_in_transit",
                                ));
                            }
                            result.enforce_in_transit = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MessageStoragePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.allowed_persistence_regions.is_empty() {
            state.serialize_entry(
                "allowedPersistenceRegions",
                &self.allowed_persistence_regions,
            )?;
        }
        if !wkt::internal::is_default(&self.enforce_in_transit) {
            state.serialize_entry("enforceInTransit", &self.enforce_in_transit)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MessageStoragePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MessageStoragePolicy");
        debug_struct.field(
            "allowed_persistence_regions",
            &self.allowed_persistence_regions,
        );
        debug_struct.field("enforce_in_transit", &self.enforce_in_transit);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Settings for validating messages published against a schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchemaSettings {
    /// Required. The name of the schema that messages published should be
    /// validated against. Format is `projects/{project}/schemas/{schema}`. The
    /// value of this field will be `_deleted-schema_` if the schema has been
    /// deleted.
    pub schema: std::string::String,

    /// Optional. The encoding of messages validated against `schema`.
    pub encoding: crate::model::Encoding,

    /// Optional. The minimum (inclusive) revision allowed for validating messages.
    /// If empty or not present, allow any revision to be validated against
    /// last_revision or any revision created before.
    pub first_revision_id: std::string::String,

    /// Optional. The maximum (inclusive) revision allowed for validating messages.
    /// If empty or not present, allow any revision to be validated against
    /// first_revision or any revision created after.
    pub last_revision_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchemaSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema][crate::model::SchemaSettings::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [encoding][crate::model::SchemaSettings::encoding].
    pub fn set_encoding<T: std::convert::Into<crate::model::Encoding>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [first_revision_id][crate::model::SchemaSettings::first_revision_id].
    pub fn set_first_revision_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.first_revision_id = v.into();
        self
    }

    /// Sets the value of [last_revision_id][crate::model::SchemaSettings::last_revision_id].
    pub fn set_last_revision_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_revision_id = v.into();
        self
    }
}

impl wkt::message::Message for SchemaSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.SchemaSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SchemaSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schema,
            __encoding,
            __first_revision_id,
            __last_revision_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SchemaSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "schema" => Ok(__FieldTag::__schema),
                            "encoding" => Ok(__FieldTag::__encoding),
                            "firstRevisionId" => Ok(__FieldTag::__first_revision_id),
                            "first_revision_id" => Ok(__FieldTag::__first_revision_id),
                            "lastRevisionId" => Ok(__FieldTag::__last_revision_id),
                            "last_revision_id" => Ok(__FieldTag::__last_revision_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SchemaSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SchemaSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encoding => {
                            if !fields.insert(__FieldTag::__encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding",
                                ));
                            }
                            result.encoding = map
                                .next_value::<std::option::Option<crate::model::Encoding>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__first_revision_id => {
                            if !fields.insert(__FieldTag::__first_revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for first_revision_id",
                                ));
                            }
                            result.first_revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_revision_id => {
                            if !fields.insert(__FieldTag::__last_revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_revision_id",
                                ));
                            }
                            result.last_revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SchemaSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.schema.is_empty() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !wkt::internal::is_default(&self.encoding) {
            state.serialize_entry("encoding", &self.encoding)?;
        }
        if !self.first_revision_id.is_empty() {
            state.serialize_entry("firstRevisionId", &self.first_revision_id)?;
        }
        if !self.last_revision_id.is_empty() {
            state.serialize_entry("lastRevisionId", &self.last_revision_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SchemaSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SchemaSettings");
        debug_struct.field("schema", &self.schema);
        debug_struct.field("encoding", &self.encoding);
        debug_struct.field("first_revision_id", &self.first_revision_id);
        debug_struct.field("last_revision_id", &self.last_revision_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Settings for an ingestion data source on a topic.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IngestionDataSourceSettings {
    /// Optional. Platform Logs settings. If unset, no Platform Logs will be
    /// generated.
    pub platform_logs_settings: std::option::Option<crate::model::PlatformLogsSettings>,

    /// Only one source type can have settings set.
    pub source: std::option::Option<crate::model::ingestion_data_source_settings::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IngestionDataSourceSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [platform_logs_settings][crate::model::IngestionDataSourceSettings::platform_logs_settings].
    pub fn set_platform_logs_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PlatformLogsSettings>,
    {
        self.platform_logs_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [platform_logs_settings][crate::model::IngestionDataSourceSettings::platform_logs_settings].
    pub fn set_or_clear_platform_logs_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PlatformLogsSettings>,
    {
        self.platform_logs_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::IngestionDataSourceSettings::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::ingestion_data_source_settings::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::IngestionDataSourceSettings::source]
    /// if it holds a `AwsKinesis`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_kinesis(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::ingestion_data_source_settings::AwsKinesis>,
    > {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::ingestion_data_source_settings::Source::AwsKinesis(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::IngestionDataSourceSettings::source]
    /// to hold a `AwsKinesis`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_aws_kinesis<
        T: std::convert::Into<
                std::boxed::Box<crate::model::ingestion_data_source_settings::AwsKinesis>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::ingestion_data_source_settings::Source::AwsKinesis(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::IngestionDataSourceSettings::source]
    /// if it holds a `CloudStorage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::ingestion_data_source_settings::CloudStorage>,
    > {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::ingestion_data_source_settings::Source::CloudStorage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::IngestionDataSourceSettings::source]
    /// to hold a `CloudStorage`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_cloud_storage<
        T: std::convert::Into<
                std::boxed::Box<crate::model::ingestion_data_source_settings::CloudStorage>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::ingestion_data_source_settings::Source::CloudStorage(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::IngestionDataSourceSettings::source]
    /// if it holds a `AzureEventHubs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn azure_event_hubs(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::ingestion_data_source_settings::AzureEventHubs>,
    > {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::ingestion_data_source_settings::Source::AzureEventHubs(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::IngestionDataSourceSettings::source]
    /// to hold a `AzureEventHubs`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_azure_event_hubs<
        T: std::convert::Into<
                std::boxed::Box<crate::model::ingestion_data_source_settings::AzureEventHubs>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::ingestion_data_source_settings::Source::AzureEventHubs(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::IngestionDataSourceSettings::source]
    /// if it holds a `AwsMsk`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_msk(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ingestion_data_source_settings::AwsMsk>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::ingestion_data_source_settings::Source::AwsMsk(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::IngestionDataSourceSettings::source]
    /// to hold a `AwsMsk`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_aws_msk<
        T: std::convert::Into<std::boxed::Box<crate::model::ingestion_data_source_settings::AwsMsk>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::ingestion_data_source_settings::Source::AwsMsk(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::IngestionDataSourceSettings::source]
    /// if it holds a `ConfluentCloud`, `None` if the field is not set or
    /// holds a different branch.
    pub fn confluent_cloud(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::ingestion_data_source_settings::ConfluentCloud>,
    > {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::ingestion_data_source_settings::Source::ConfluentCloud(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::IngestionDataSourceSettings::source]
    /// to hold a `ConfluentCloud`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_confluent_cloud<
        T: std::convert::Into<
                std::boxed::Box<crate::model::ingestion_data_source_settings::ConfluentCloud>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::ingestion_data_source_settings::Source::ConfluentCloud(v.into()),
        );
        self
    }
}

impl wkt::message::Message for IngestionDataSourceSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IngestionDataSourceSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_kinesis,
            __cloud_storage,
            __azure_event_hubs,
            __aws_msk,
            __confluent_cloud,
            __platform_logs_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IngestionDataSourceSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsKinesis" => Ok(__FieldTag::__aws_kinesis),
                            "aws_kinesis" => Ok(__FieldTag::__aws_kinesis),
                            "cloudStorage" => Ok(__FieldTag::__cloud_storage),
                            "cloud_storage" => Ok(__FieldTag::__cloud_storage),
                            "azureEventHubs" => Ok(__FieldTag::__azure_event_hubs),
                            "azure_event_hubs" => Ok(__FieldTag::__azure_event_hubs),
                            "awsMsk" => Ok(__FieldTag::__aws_msk),
                            "aws_msk" => Ok(__FieldTag::__aws_msk),
                            "confluentCloud" => Ok(__FieldTag::__confluent_cloud),
                            "confluent_cloud" => Ok(__FieldTag::__confluent_cloud),
                            "platformLogsSettings" => Ok(__FieldTag::__platform_logs_settings),
                            "platform_logs_settings" => Ok(__FieldTag::__platform_logs_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IngestionDataSourceSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IngestionDataSourceSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_kinesis => {
                            if !fields.insert(__FieldTag::__aws_kinesis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_kinesis",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.pubsub.v1.IngestionDataSourceSettings.aws_kinesis, latest field was awsKinesis",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::ingestion_data_source_settings::Source::AwsKinesis(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ingestion_data_source_settings::AwsKinesis>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__cloud_storage => {
                            if !fields.insert(__FieldTag::__cloud_storage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_storage",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.pubsub.v1.IngestionDataSourceSettings.cloud_storage, latest field was cloudStorage",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::ingestion_data_source_settings::Source::CloudStorage(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ingestion_data_source_settings::CloudStorage>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__azure_event_hubs => {
                            if !fields.insert(__FieldTag::__azure_event_hubs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_event_hubs",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.pubsub.v1.IngestionDataSourceSettings.azure_event_hubs, latest field was azureEventHubs",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::ingestion_data_source_settings::Source::AzureEventHubs(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ingestion_data_source_settings::AzureEventHubs>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__aws_msk => {
                            if !fields.insert(__FieldTag::__aws_msk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_msk",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.pubsub.v1.IngestionDataSourceSettings.aws_msk, latest field was awsMsk",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::ingestion_data_source_settings::Source::AwsMsk(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::ingestion_data_source_settings::AwsMsk,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__confluent_cloud => {
                            if !fields.insert(__FieldTag::__confluent_cloud) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confluent_cloud",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.pubsub.v1.IngestionDataSourceSettings.confluent_cloud, latest field was confluentCloud",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::ingestion_data_source_settings::Source::ConfluentCloud(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ingestion_data_source_settings::ConfluentCloud>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__platform_logs_settings => {
                            if !fields.insert(__FieldTag::__platform_logs_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for platform_logs_settings",
                                ));
                            }
                            result.platform_logs_settings = map.next_value::<std::option::Option<crate::model::PlatformLogsSettings>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IngestionDataSourceSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.aws_kinesis() {
            state.serialize_entry("awsKinesis", value)?;
        }
        if let Some(value) = self.cloud_storage() {
            state.serialize_entry("cloudStorage", value)?;
        }
        if let Some(value) = self.azure_event_hubs() {
            state.serialize_entry("azureEventHubs", value)?;
        }
        if let Some(value) = self.aws_msk() {
            state.serialize_entry("awsMsk", value)?;
        }
        if let Some(value) = self.confluent_cloud() {
            state.serialize_entry("confluentCloud", value)?;
        }
        if self.platform_logs_settings.is_some() {
            state.serialize_entry("platformLogsSettings", &self.platform_logs_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IngestionDataSourceSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IngestionDataSourceSettings");
        debug_struct.field("platform_logs_settings", &self.platform_logs_settings);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [IngestionDataSourceSettings].
pub mod ingestion_data_source_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Ingestion settings for Amazon Kinesis Data Streams.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AwsKinesis {
        /// Output only. An output-only field that indicates the state of the Kinesis
        /// ingestion source.
        pub state: crate::model::ingestion_data_source_settings::aws_kinesis::State,

        /// Required. The Kinesis stream ARN to ingest data from.
        pub stream_arn: std::string::String,

        /// Required. The Kinesis consumer ARN to used for ingestion in Enhanced
        /// Fan-Out mode. The consumer must be already created and ready to be used.
        pub consumer_arn: std::string::String,

        /// Required. AWS role ARN to be used for Federated Identity authentication
        /// with Kinesis. Check the Pub/Sub docs for how to set up this role and the
        /// required permissions that need to be attached to it.
        pub aws_role_arn: std::string::String,

        /// Required. The GCP service account to be used for Federated Identity
        /// authentication with Kinesis (via a `AssumeRoleWithWebIdentity` call for
        /// the provided role). The `aws_role_arn` must be set up with
        /// `accounts.google.com:sub` equals to this service account number.
        pub gcp_service_account: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AwsKinesis {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::ingestion_data_source_settings::AwsKinesis::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::ingestion_data_source_settings::aws_kinesis::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [stream_arn][crate::model::ingestion_data_source_settings::AwsKinesis::stream_arn].
        pub fn set_stream_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.stream_arn = v.into();
            self
        }

        /// Sets the value of [consumer_arn][crate::model::ingestion_data_source_settings::AwsKinesis::consumer_arn].
        pub fn set_consumer_arn<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.consumer_arn = v.into();
            self
        }

        /// Sets the value of [aws_role_arn][crate::model::ingestion_data_source_settings::AwsKinesis::aws_role_arn].
        pub fn set_aws_role_arn<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.aws_role_arn = v.into();
            self
        }

        /// Sets the value of [gcp_service_account][crate::model::ingestion_data_source_settings::AwsKinesis::gcp_service_account].
        pub fn set_gcp_service_account<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gcp_service_account = v.into();
            self
        }
    }

    impl wkt::message::Message for AwsKinesis {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.AwsKinesis"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AwsKinesis {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __stream_arn,
                __consumer_arn,
                __aws_role_arn,
                __gcp_service_account,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AwsKinesis")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "streamArn" => Ok(__FieldTag::__stream_arn),
                                "stream_arn" => Ok(__FieldTag::__stream_arn),
                                "consumerArn" => Ok(__FieldTag::__consumer_arn),
                                "consumer_arn" => Ok(__FieldTag::__consumer_arn),
                                "awsRoleArn" => Ok(__FieldTag::__aws_role_arn),
                                "aws_role_arn" => Ok(__FieldTag::__aws_role_arn),
                                "gcpServiceAccount" => Ok(__FieldTag::__gcp_service_account),
                                "gcp_service_account" => Ok(__FieldTag::__gcp_service_account),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AwsKinesis;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AwsKinesis")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map.next_value::<std::option::Option<crate::model::ingestion_data_source_settings::aws_kinesis::State>>()?.unwrap_or_default();
                            }
                            __FieldTag::__stream_arn => {
                                if !fields.insert(__FieldTag::__stream_arn) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for stream_arn",
                                    ));
                                }
                                result.stream_arn = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__consumer_arn => {
                                if !fields.insert(__FieldTag::__consumer_arn) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for consumer_arn",
                                    ));
                                }
                                result.consumer_arn = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__aws_role_arn => {
                                if !fields.insert(__FieldTag::__aws_role_arn) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for aws_role_arn",
                                    ));
                                }
                                result.aws_role_arn = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__gcp_service_account => {
                                if !fields.insert(__FieldTag::__gcp_service_account) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gcp_service_account",
                                    ));
                                }
                                result.gcp_service_account = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AwsKinesis {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.stream_arn.is_empty() {
                state.serialize_entry("streamArn", &self.stream_arn)?;
            }
            if !self.consumer_arn.is_empty() {
                state.serialize_entry("consumerArn", &self.consumer_arn)?;
            }
            if !self.aws_role_arn.is_empty() {
                state.serialize_entry("awsRoleArn", &self.aws_role_arn)?;
            }
            if !self.gcp_service_account.is_empty() {
                state.serialize_entry("gcpServiceAccount", &self.gcp_service_account)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AwsKinesis {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AwsKinesis");
            debug_struct.field("state", &self.state);
            debug_struct.field("stream_arn", &self.stream_arn);
            debug_struct.field("consumer_arn", &self.consumer_arn);
            debug_struct.field("aws_role_arn", &self.aws_role_arn);
            debug_struct.field("gcp_service_account", &self.gcp_service_account);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [AwsKinesis].
    pub mod aws_kinesis {
        #[allow(unused_imports)]
        use super::*;

        /// Possible states for ingestion from Amazon Kinesis Data Streams.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Default value. This value is unused.
            Unspecified,
            /// Ingestion is active.
            Active,
            /// Permission denied encountered while consuming data from Kinesis.
            /// This can happen if:
            ///
            /// - The provided `aws_role_arn` does not exist or does not have the
            ///   appropriate permissions attached.
            /// - The provided `aws_role_arn` is not set up properly for Identity
            ///   Federation using `gcp_service_account`.
            /// - The Pub/Sub SA is not granted the
            ///   `iam.serviceAccounts.getOpenIdToken` permission on
            ///   `gcp_service_account`.
            KinesisPermissionDenied,
            /// Permission denied encountered while publishing to the topic. This can
            /// happen if the Pub/Sub SA has not been granted the [appropriate publish
            /// permissions](https://cloud.google.com/pubsub/docs/access-control#pubsub.publisher)
            PublishPermissionDenied,
            /// The Kinesis stream does not exist.
            StreamNotFound,
            /// The Kinesis consumer does not exist.
            ConsumerNotFound,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Active => std::option::Option::Some(1),
                    Self::KinesisPermissionDenied => std::option::Option::Some(2),
                    Self::PublishPermissionDenied => std::option::Option::Some(3),
                    Self::StreamNotFound => std::option::Option::Some(4),
                    Self::ConsumerNotFound => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Active => std::option::Option::Some("ACTIVE"),
                    Self::KinesisPermissionDenied => {
                        std::option::Option::Some("KINESIS_PERMISSION_DENIED")
                    }
                    Self::PublishPermissionDenied => {
                        std::option::Option::Some("PUBLISH_PERMISSION_DENIED")
                    }
                    Self::StreamNotFound => std::option::Option::Some("STREAM_NOT_FOUND"),
                    Self::ConsumerNotFound => std::option::Option::Some("CONSUMER_NOT_FOUND"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Active,
                    2 => Self::KinesisPermissionDenied,
                    3 => Self::PublishPermissionDenied,
                    4 => Self::StreamNotFound,
                    5 => Self::ConsumerNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "ACTIVE" => Self::Active,
                    "KINESIS_PERMISSION_DENIED" => Self::KinesisPermissionDenied,
                    "PUBLISH_PERMISSION_DENIED" => Self::PublishPermissionDenied,
                    "STREAM_NOT_FOUND" => Self::StreamNotFound,
                    "CONSUMER_NOT_FOUND" => Self::ConsumerNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Active => serializer.serialize_i32(1),
                    Self::KinesisPermissionDenied => serializer.serialize_i32(2),
                    Self::PublishPermissionDenied => serializer.serialize_i32(3),
                    Self::StreamNotFound => serializer.serialize_i32(4),
                    Self::ConsumerNotFound => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.pubsub.v1.IngestionDataSourceSettings.AwsKinesis.State",
                ))
            }
        }
    }

    /// Ingestion settings for Cloud Storage.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CloudStorage {
        /// Output only. An output-only field that indicates the state of the Cloud
        /// Storage ingestion source.
        pub state: crate::model::ingestion_data_source_settings::cloud_storage::State,

        /// Optional. Cloud Storage bucket. The bucket name must be without any
        /// prefix like "gs://". See the [bucket naming requirements]
        /// (<https://cloud.google.com/storage/docs/buckets#naming>).
        pub bucket: std::string::String,

        /// Optional. Only objects with a larger or equal creation timestamp will be
        /// ingested.
        pub minimum_object_create_time: std::option::Option<wkt::Timestamp>,

        /// Optional. Glob pattern used to match objects that will be ingested. If
        /// unset, all objects will be ingested. See the [supported
        /// patterns](https://cloud.google.com/storage/docs/json_api/v1/objects/list#list-objects-and-prefixes-using-glob).
        pub match_glob: std::string::String,

        /// Defaults to text format.
        pub input_format: std::option::Option<
            crate::model::ingestion_data_source_settings::cloud_storage::InputFormat,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CloudStorage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::ingestion_data_source_settings::CloudStorage::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::ingestion_data_source_settings::cloud_storage::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [bucket][crate::model::ingestion_data_source_settings::CloudStorage::bucket].
        pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.bucket = v.into();
            self
        }

        /// Sets the value of [minimum_object_create_time][crate::model::ingestion_data_source_settings::CloudStorage::minimum_object_create_time].
        pub fn set_minimum_object_create_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.minimum_object_create_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [minimum_object_create_time][crate::model::ingestion_data_source_settings::CloudStorage::minimum_object_create_time].
        pub fn set_or_clear_minimum_object_create_time<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.minimum_object_create_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [match_glob][crate::model::ingestion_data_source_settings::CloudStorage::match_glob].
        pub fn set_match_glob<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.match_glob = v.into();
            self
        }

        /// Sets the value of [input_format][crate::model::ingestion_data_source_settings::CloudStorage::input_format].
        ///
        /// Note that all the setters affecting `input_format` are mutually
        /// exclusive.
        pub fn set_input_format<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::ingestion_data_source_settings::cloud_storage::InputFormat,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.input_format = v.into();
            self
        }

        /// The value of [input_format][crate::model::ingestion_data_source_settings::CloudStorage::input_format]
        /// if it holds a `TextFormat`, `None` if the field is not set or
        /// holds a different branch.
        pub fn text_format(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::ingestion_data_source_settings::cloud_storage::TextFormat,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.input_format.as_ref().and_then(|v| match v {
                crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::TextFormat(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [input_format][crate::model::ingestion_data_source_settings::CloudStorage::input_format]
        /// to hold a `TextFormat`.
        ///
        /// Note that all the setters affecting `input_format` are
        /// mutually exclusive.
        pub fn set_text_format<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::ingestion_data_source_settings::cloud_storage::TextFormat,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.input_format = std::option::Option::Some(
                crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::TextFormat(
                    v.into()
                )
            );
            self
        }

        /// The value of [input_format][crate::model::ingestion_data_source_settings::CloudStorage::input_format]
        /// if it holds a `AvroFormat`, `None` if the field is not set or
        /// holds a different branch.
        pub fn avro_format(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::ingestion_data_source_settings::cloud_storage::AvroFormat,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.input_format.as_ref().and_then(|v| match v {
                crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::AvroFormat(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [input_format][crate::model::ingestion_data_source_settings::CloudStorage::input_format]
        /// to hold a `AvroFormat`.
        ///
        /// Note that all the setters affecting `input_format` are
        /// mutually exclusive.
        pub fn set_avro_format<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::ingestion_data_source_settings::cloud_storage::AvroFormat,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.input_format = std::option::Option::Some(
                crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::AvroFormat(
                    v.into()
                )
            );
            self
        }

        /// The value of [input_format][crate::model::ingestion_data_source_settings::CloudStorage::input_format]
        /// if it holds a `PubsubAvroFormat`, `None` if the field is not set or
        /// holds a different branch.
        pub fn pubsub_avro_format(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::ingestion_data_source_settings::cloud_storage::PubSubAvroFormat,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.input_format.as_ref().and_then(|v| match v {
                crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::PubsubAvroFormat(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [input_format][crate::model::ingestion_data_source_settings::CloudStorage::input_format]
        /// to hold a `PubsubAvroFormat`.
        ///
        /// Note that all the setters affecting `input_format` are
        /// mutually exclusive.
        pub fn set_pubsub_avro_format<T: std::convert::Into<std::boxed::Box<crate::model::ingestion_data_source_settings::cloud_storage::PubSubAvroFormat>>>(mut self, v: T) -> Self{
            self.input_format = std::option::Option::Some(
                crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::PubsubAvroFormat(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for CloudStorage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.CloudStorage"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CloudStorage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __bucket,
                __text_format,
                __avro_format,
                __pubsub_avro_format,
                __minimum_object_create_time,
                __match_glob,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CloudStorage")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "bucket" => Ok(__FieldTag::__bucket),
                                "textFormat" => Ok(__FieldTag::__text_format),
                                "text_format" => Ok(__FieldTag::__text_format),
                                "avroFormat" => Ok(__FieldTag::__avro_format),
                                "avro_format" => Ok(__FieldTag::__avro_format),
                                "pubsubAvroFormat" => Ok(__FieldTag::__pubsub_avro_format),
                                "pubsub_avro_format" => Ok(__FieldTag::__pubsub_avro_format),
                                "minimumObjectCreateTime" => {
                                    Ok(__FieldTag::__minimum_object_create_time)
                                }
                                "minimum_object_create_time" => {
                                    Ok(__FieldTag::__minimum_object_create_time)
                                }
                                "matchGlob" => Ok(__FieldTag::__match_glob),
                                "match_glob" => Ok(__FieldTag::__match_glob),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CloudStorage;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CloudStorage")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map.next_value::<std::option::Option<crate::model::ingestion_data_source_settings::cloud_storage::State>>()?.unwrap_or_default();
                            }
                            __FieldTag::__bucket => {
                                if !fields.insert(__FieldTag::__bucket) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bucket",
                                    ));
                                }
                                result.bucket = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__text_format => {
                                if !fields.insert(__FieldTag::__text_format) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text_format",
                                    ));
                                }
                                if result.input_format.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `input_format`, a oneof with full ID .google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.text_format, latest field was textFormat",
                                    ));
                                }
                                result.input_format = std::option::Option::Some(
                                    crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::TextFormat(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::ingestion_data_source_settings::cloud_storage::TextFormat>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__avro_format => {
                                if !fields.insert(__FieldTag::__avro_format) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for avro_format",
                                    ));
                                }
                                if result.input_format.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `input_format`, a oneof with full ID .google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.avro_format, latest field was avroFormat",
                                    ));
                                }
                                result.input_format = std::option::Option::Some(
                                    crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::AvroFormat(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::ingestion_data_source_settings::cloud_storage::AvroFormat>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__pubsub_avro_format => {
                                if !fields.insert(__FieldTag::__pubsub_avro_format) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pubsub_avro_format",
                                    ));
                                }
                                if result.input_format.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `input_format`, a oneof with full ID .google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.pubsub_avro_format, latest field was pubsubAvroFormat",
                                    ));
                                }
                                result.input_format = std::option::Option::Some(
                                    crate::model::ingestion_data_source_settings::cloud_storage::InputFormat::PubsubAvroFormat(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::ingestion_data_source_settings::cloud_storage::PubSubAvroFormat>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__minimum_object_create_time => {
                                if !fields.insert(__FieldTag::__minimum_object_create_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for minimum_object_create_time",
                                    ));
                                }
                                result.minimum_object_create_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__match_glob => {
                                if !fields.insert(__FieldTag::__match_glob) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for match_glob",
                                    ));
                                }
                                result.match_glob = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CloudStorage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.bucket.is_empty() {
                state.serialize_entry("bucket", &self.bucket)?;
            }
            if let Some(value) = self.text_format() {
                state.serialize_entry("textFormat", value)?;
            }
            if let Some(value) = self.avro_format() {
                state.serialize_entry("avroFormat", value)?;
            }
            if let Some(value) = self.pubsub_avro_format() {
                state.serialize_entry("pubsubAvroFormat", value)?;
            }
            if self.minimum_object_create_time.is_some() {
                state
                    .serialize_entry("minimumObjectCreateTime", &self.minimum_object_create_time)?;
            }
            if !self.match_glob.is_empty() {
                state.serialize_entry("matchGlob", &self.match_glob)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CloudStorage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CloudStorage");
            debug_struct.field("state", &self.state);
            debug_struct.field("bucket", &self.bucket);
            debug_struct.field(
                "minimum_object_create_time",
                &self.minimum_object_create_time,
            );
            debug_struct.field("match_glob", &self.match_glob);
            debug_struct.field("input_format", &self.input_format);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [CloudStorage].
    pub mod cloud_storage {
        #[allow(unused_imports)]
        use super::*;

        /// Configuration for reading Cloud Storage data in text format. Each line of
        /// text as specified by the delimiter will be set to the `data` field of a
        /// Pub/Sub message.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TextFormat {
            /// Optional. When unset, '\n' is used.
            pub delimiter: std::option::Option<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TextFormat {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [delimiter][crate::model::ingestion_data_source_settings::cloud_storage::TextFormat::delimiter].
            pub fn set_delimiter<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.delimiter = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [delimiter][crate::model::ingestion_data_source_settings::cloud_storage::TextFormat::delimiter].
            pub fn set_or_clear_delimiter<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.delimiter = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for TextFormat {
            fn typename() -> &'static str {
                "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.TextFormat"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for TextFormat {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __delimiter,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for TextFormat")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "delimiter" => Ok(__FieldTag::__delimiter),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = TextFormat;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct TextFormat")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__delimiter => {
                                    if !fields.insert(__FieldTag::__delimiter) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for delimiter",
                                            ),
                                        );
                                    }
                                    result.delimiter = map
                                        .next_value::<std::option::Option<std::string::String>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for TextFormat {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.delimiter.is_some() {
                    state.serialize_entry("delimiter", &self.delimiter)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for TextFormat {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("TextFormat");
                debug_struct.field("delimiter", &self.delimiter);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Configuration for reading Cloud Storage data in Avro binary format. The
        /// bytes of each object will be set to the `data` field of a Pub/Sub
        /// message.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AvroFormat {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AvroFormat {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for AvroFormat {
            fn typename() -> &'static str {
                "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.AvroFormat"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for AvroFormat {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for AvroFormat")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = AvroFormat;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct AvroFormat")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for AvroFormat {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for AvroFormat {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("AvroFormat");
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Configuration for reading Cloud Storage data written via [Cloud Storage
        /// subscriptions](https://cloud.google.com/pubsub/docs/cloudstorage). The
        /// data and attributes fields of the originally exported Pub/Sub message
        /// will be restored when publishing.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct PubSubAvroFormat {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PubSubAvroFormat {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for PubSubAvroFormat {
            fn typename() -> &'static str {
                "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.PubSubAvroFormat"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for PubSubAvroFormat {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for PubSubAvroFormat")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = PubSubAvroFormat;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct PubSubAvroFormat")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for PubSubAvroFormat {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for PubSubAvroFormat {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("PubSubAvroFormat");
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Possible states for ingestion from Cloud Storage.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Default value. This value is unused.
            Unspecified,
            /// Ingestion is active.
            Active,
            /// Permission denied encountered while calling the Cloud Storage API. This
            /// can happen if the Pub/Sub SA has not been granted the
            /// [appropriate
            /// permissions](https://cloud.google.com/storage/docs/access-control/iam-permissions):
            ///
            /// - storage.objects.list: to list the objects in a bucket.
            /// - storage.objects.get: to read the objects in a bucket.
            /// - storage.buckets.get: to verify the bucket exists.
            CloudStoragePermissionDenied,
            /// Permission denied encountered while publishing to the topic. This can
            /// happen if the Pub/Sub SA has not been granted the [appropriate publish
            /// permissions](https://cloud.google.com/pubsub/docs/access-control#pubsub.publisher)
            PublishPermissionDenied,
            /// The provided Cloud Storage bucket doesn't exist.
            BucketNotFound,
            /// The Cloud Storage bucket has too many objects, ingestion will be
            /// paused.
            TooManyObjects,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Active => std::option::Option::Some(1),
                    Self::CloudStoragePermissionDenied => std::option::Option::Some(2),
                    Self::PublishPermissionDenied => std::option::Option::Some(3),
                    Self::BucketNotFound => std::option::Option::Some(4),
                    Self::TooManyObjects => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Active => std::option::Option::Some("ACTIVE"),
                    Self::CloudStoragePermissionDenied => {
                        std::option::Option::Some("CLOUD_STORAGE_PERMISSION_DENIED")
                    }
                    Self::PublishPermissionDenied => {
                        std::option::Option::Some("PUBLISH_PERMISSION_DENIED")
                    }
                    Self::BucketNotFound => std::option::Option::Some("BUCKET_NOT_FOUND"),
                    Self::TooManyObjects => std::option::Option::Some("TOO_MANY_OBJECTS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Active,
                    2 => Self::CloudStoragePermissionDenied,
                    3 => Self::PublishPermissionDenied,
                    4 => Self::BucketNotFound,
                    5 => Self::TooManyObjects,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "ACTIVE" => Self::Active,
                    "CLOUD_STORAGE_PERMISSION_DENIED" => Self::CloudStoragePermissionDenied,
                    "PUBLISH_PERMISSION_DENIED" => Self::PublishPermissionDenied,
                    "BUCKET_NOT_FOUND" => Self::BucketNotFound,
                    "TOO_MANY_OBJECTS" => Self::TooManyObjects,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Active => serializer.serialize_i32(1),
                    Self::CloudStoragePermissionDenied => serializer.serialize_i32(2),
                    Self::PublishPermissionDenied => serializer.serialize_i32(3),
                    Self::BucketNotFound => serializer.serialize_i32(4),
                    Self::TooManyObjects => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.State",
                ))
            }
        }

        /// Defaults to text format.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum InputFormat {
            /// Optional. Data from Cloud Storage will be interpreted as text.
            TextFormat(
                std::boxed::Box<
                    crate::model::ingestion_data_source_settings::cloud_storage::TextFormat,
                >,
            ),
            /// Optional. Data from Cloud Storage will be interpreted in Avro format.
            AvroFormat(
                std::boxed::Box<
                    crate::model::ingestion_data_source_settings::cloud_storage::AvroFormat,
                >,
            ),
            /// Optional. It will be assumed data from Cloud Storage was written via
            /// [Cloud Storage
            /// subscriptions](https://cloud.google.com/pubsub/docs/cloudstorage).
            PubsubAvroFormat(
                std::boxed::Box<
                    crate::model::ingestion_data_source_settings::cloud_storage::PubSubAvroFormat,
                >,
            ),
        }
    }

    /// Ingestion settings for Azure Event Hubs.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AzureEventHubs {
        /// Output only. An output-only field that indicates the state of the Event
        /// Hubs ingestion source.
        pub state: crate::model::ingestion_data_source_settings::azure_event_hubs::State,

        /// Optional. Name of the resource group within the azure subscription.
        pub resource_group: std::string::String,

        /// Optional. The name of the Event Hubs namespace.
        pub namespace: std::string::String,

        /// Optional. The name of the Event Hub.
        pub event_hub: std::string::String,

        /// Optional. The client id of the Azure application that is being used to
        /// authenticate Pub/Sub.
        pub client_id: std::string::String,

        /// Optional. The tenant id of the Azure application that is being used to
        /// authenticate Pub/Sub.
        pub tenant_id: std::string::String,

        /// Optional. The Azure subscription id.
        pub subscription_id: std::string::String,

        /// Optional. The GCP service account to be used for Federated Identity
        /// authentication.
        pub gcp_service_account: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AzureEventHubs {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::ingestion_data_source_settings::AzureEventHubs::state].
        pub fn set_state<
            T: std::convert::Into<
                    crate::model::ingestion_data_source_settings::azure_event_hubs::State,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [resource_group][crate::model::ingestion_data_source_settings::AzureEventHubs::resource_group].
        pub fn set_resource_group<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_group = v.into();
            self
        }

        /// Sets the value of [namespace][crate::model::ingestion_data_source_settings::AzureEventHubs::namespace].
        pub fn set_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.namespace = v.into();
            self
        }

        /// Sets the value of [event_hub][crate::model::ingestion_data_source_settings::AzureEventHubs::event_hub].
        pub fn set_event_hub<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.event_hub = v.into();
            self
        }

        /// Sets the value of [client_id][crate::model::ingestion_data_source_settings::AzureEventHubs::client_id].
        pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client_id = v.into();
            self
        }

        /// Sets the value of [tenant_id][crate::model::ingestion_data_source_settings::AzureEventHubs::tenant_id].
        pub fn set_tenant_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.tenant_id = v.into();
            self
        }

        /// Sets the value of [subscription_id][crate::model::ingestion_data_source_settings::AzureEventHubs::subscription_id].
        pub fn set_subscription_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.subscription_id = v.into();
            self
        }

        /// Sets the value of [gcp_service_account][crate::model::ingestion_data_source_settings::AzureEventHubs::gcp_service_account].
        pub fn set_gcp_service_account<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gcp_service_account = v.into();
            self
        }
    }

    impl wkt::message::Message for AzureEventHubs {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.AzureEventHubs"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AzureEventHubs {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __resource_group,
                __namespace,
                __event_hub,
                __client_id,
                __tenant_id,
                __subscription_id,
                __gcp_service_account,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AzureEventHubs")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "resourceGroup" => Ok(__FieldTag::__resource_group),
                                "resource_group" => Ok(__FieldTag::__resource_group),
                                "namespace" => Ok(__FieldTag::__namespace),
                                "eventHub" => Ok(__FieldTag::__event_hub),
                                "event_hub" => Ok(__FieldTag::__event_hub),
                                "clientId" => Ok(__FieldTag::__client_id),
                                "client_id" => Ok(__FieldTag::__client_id),
                                "tenantId" => Ok(__FieldTag::__tenant_id),
                                "tenant_id" => Ok(__FieldTag::__tenant_id),
                                "subscriptionId" => Ok(__FieldTag::__subscription_id),
                                "subscription_id" => Ok(__FieldTag::__subscription_id),
                                "gcpServiceAccount" => Ok(__FieldTag::__gcp_service_account),
                                "gcp_service_account" => Ok(__FieldTag::__gcp_service_account),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AzureEventHubs;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AzureEventHubs")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map.next_value::<std::option::Option<crate::model::ingestion_data_source_settings::azure_event_hubs::State>>()?.unwrap_or_default();
                            }
                            __FieldTag::__resource_group => {
                                if !fields.insert(__FieldTag::__resource_group) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource_group",
                                    ));
                                }
                                result.resource_group = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__namespace => {
                                if !fields.insert(__FieldTag::__namespace) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for namespace",
                                    ));
                                }
                                result.namespace = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__event_hub => {
                                if !fields.insert(__FieldTag::__event_hub) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for event_hub",
                                    ));
                                }
                                result.event_hub = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__client_id => {
                                if !fields.insert(__FieldTag::__client_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for client_id",
                                    ));
                                }
                                result.client_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__tenant_id => {
                                if !fields.insert(__FieldTag::__tenant_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tenant_id",
                                    ));
                                }
                                result.tenant_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__subscription_id => {
                                if !fields.insert(__FieldTag::__subscription_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for subscription_id",
                                    ));
                                }
                                result.subscription_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__gcp_service_account => {
                                if !fields.insert(__FieldTag::__gcp_service_account) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gcp_service_account",
                                    ));
                                }
                                result.gcp_service_account = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AzureEventHubs {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.resource_group.is_empty() {
                state.serialize_entry("resourceGroup", &self.resource_group)?;
            }
            if !self.namespace.is_empty() {
                state.serialize_entry("namespace", &self.namespace)?;
            }
            if !self.event_hub.is_empty() {
                state.serialize_entry("eventHub", &self.event_hub)?;
            }
            if !self.client_id.is_empty() {
                state.serialize_entry("clientId", &self.client_id)?;
            }
            if !self.tenant_id.is_empty() {
                state.serialize_entry("tenantId", &self.tenant_id)?;
            }
            if !self.subscription_id.is_empty() {
                state.serialize_entry("subscriptionId", &self.subscription_id)?;
            }
            if !self.gcp_service_account.is_empty() {
                state.serialize_entry("gcpServiceAccount", &self.gcp_service_account)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AzureEventHubs {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AzureEventHubs");
            debug_struct.field("state", &self.state);
            debug_struct.field("resource_group", &self.resource_group);
            debug_struct.field("namespace", &self.namespace);
            debug_struct.field("event_hub", &self.event_hub);
            debug_struct.field("client_id", &self.client_id);
            debug_struct.field("tenant_id", &self.tenant_id);
            debug_struct.field("subscription_id", &self.subscription_id);
            debug_struct.field("gcp_service_account", &self.gcp_service_account);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [AzureEventHubs].
    pub mod azure_event_hubs {
        #[allow(unused_imports)]
        use super::*;

        /// Possible states for managed ingestion from Event Hubs.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Default value. This value is unused.
            Unspecified,
            /// Ingestion is active.
            Active,
            /// Permission denied encountered while consuming data from Event Hubs.
            /// This can happen when `client_id`, or `tenant_id` are invalid. Or the
            /// right permissions haven't been granted.
            EventHubsPermissionDenied,
            /// Permission denied encountered while publishing to the topic.
            PublishPermissionDenied,
            /// The provided Event Hubs namespace couldn't be found.
            NamespaceNotFound,
            /// The provided Event Hub couldn't be found.
            EventHubNotFound,
            /// The provided Event Hubs subscription couldn't be found.
            SubscriptionNotFound,
            /// The provided Event Hubs resource group couldn't be found.
            ResourceGroupNotFound,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Active => std::option::Option::Some(1),
                    Self::EventHubsPermissionDenied => std::option::Option::Some(2),
                    Self::PublishPermissionDenied => std::option::Option::Some(3),
                    Self::NamespaceNotFound => std::option::Option::Some(4),
                    Self::EventHubNotFound => std::option::Option::Some(5),
                    Self::SubscriptionNotFound => std::option::Option::Some(6),
                    Self::ResourceGroupNotFound => std::option::Option::Some(7),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Active => std::option::Option::Some("ACTIVE"),
                    Self::EventHubsPermissionDenied => {
                        std::option::Option::Some("EVENT_HUBS_PERMISSION_DENIED")
                    }
                    Self::PublishPermissionDenied => {
                        std::option::Option::Some("PUBLISH_PERMISSION_DENIED")
                    }
                    Self::NamespaceNotFound => std::option::Option::Some("NAMESPACE_NOT_FOUND"),
                    Self::EventHubNotFound => std::option::Option::Some("EVENT_HUB_NOT_FOUND"),
                    Self::SubscriptionNotFound => {
                        std::option::Option::Some("SUBSCRIPTION_NOT_FOUND")
                    }
                    Self::ResourceGroupNotFound => {
                        std::option::Option::Some("RESOURCE_GROUP_NOT_FOUND")
                    }
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Active,
                    2 => Self::EventHubsPermissionDenied,
                    3 => Self::PublishPermissionDenied,
                    4 => Self::NamespaceNotFound,
                    5 => Self::EventHubNotFound,
                    6 => Self::SubscriptionNotFound,
                    7 => Self::ResourceGroupNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "ACTIVE" => Self::Active,
                    "EVENT_HUBS_PERMISSION_DENIED" => Self::EventHubsPermissionDenied,
                    "PUBLISH_PERMISSION_DENIED" => Self::PublishPermissionDenied,
                    "NAMESPACE_NOT_FOUND" => Self::NamespaceNotFound,
                    "EVENT_HUB_NOT_FOUND" => Self::EventHubNotFound,
                    "SUBSCRIPTION_NOT_FOUND" => Self::SubscriptionNotFound,
                    "RESOURCE_GROUP_NOT_FOUND" => Self::ResourceGroupNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Active => serializer.serialize_i32(1),
                    Self::EventHubsPermissionDenied => serializer.serialize_i32(2),
                    Self::PublishPermissionDenied => serializer.serialize_i32(3),
                    Self::NamespaceNotFound => serializer.serialize_i32(4),
                    Self::EventHubNotFound => serializer.serialize_i32(5),
                    Self::SubscriptionNotFound => serializer.serialize_i32(6),
                    Self::ResourceGroupNotFound => serializer.serialize_i32(7),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.pubsub.v1.IngestionDataSourceSettings.AzureEventHubs.State",
                ))
            }
        }
    }

    /// Ingestion settings for Amazon MSK.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AwsMsk {
        /// Output only. An output-only field that indicates the state of the Amazon
        /// MSK ingestion source.
        pub state: crate::model::ingestion_data_source_settings::aws_msk::State,

        /// Required. The Amazon Resource Name (ARN) that uniquely identifies the
        /// cluster.
        pub cluster_arn: std::string::String,

        /// Required. The name of the topic in the Amazon MSK cluster that Pub/Sub
        /// will import from.
        pub topic: std::string::String,

        /// Required. AWS role ARN to be used for Federated Identity authentication
        /// with Amazon MSK. Check the Pub/Sub docs for how to set up this role and
        /// the required permissions that need to be attached to it.
        pub aws_role_arn: std::string::String,

        /// Required. The GCP service account to be used for Federated Identity
        /// authentication with Amazon MSK (via a `AssumeRoleWithWebIdentity` call
        /// for the provided role). The `aws_role_arn` must be set up with
        /// `accounts.google.com:sub` equals to this service account number.
        pub gcp_service_account: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AwsMsk {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::ingestion_data_source_settings::AwsMsk::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::ingestion_data_source_settings::aws_msk::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [cluster_arn][crate::model::ingestion_data_source_settings::AwsMsk::cluster_arn].
        pub fn set_cluster_arn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cluster_arn = v.into();
            self
        }

        /// Sets the value of [topic][crate::model::ingestion_data_source_settings::AwsMsk::topic].
        pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.topic = v.into();
            self
        }

        /// Sets the value of [aws_role_arn][crate::model::ingestion_data_source_settings::AwsMsk::aws_role_arn].
        pub fn set_aws_role_arn<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.aws_role_arn = v.into();
            self
        }

        /// Sets the value of [gcp_service_account][crate::model::ingestion_data_source_settings::AwsMsk::gcp_service_account].
        pub fn set_gcp_service_account<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gcp_service_account = v.into();
            self
        }
    }

    impl wkt::message::Message for AwsMsk {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.AwsMsk"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AwsMsk {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __cluster_arn,
                __topic,
                __aws_role_arn,
                __gcp_service_account,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AwsMsk")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "clusterArn" => Ok(__FieldTag::__cluster_arn),
                                "cluster_arn" => Ok(__FieldTag::__cluster_arn),
                                "topic" => Ok(__FieldTag::__topic),
                                "awsRoleArn" => Ok(__FieldTag::__aws_role_arn),
                                "aws_role_arn" => Ok(__FieldTag::__aws_role_arn),
                                "gcpServiceAccount" => Ok(__FieldTag::__gcp_service_account),
                                "gcp_service_account" => Ok(__FieldTag::__gcp_service_account),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AwsMsk;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AwsMsk")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map.next_value::<std::option::Option<crate::model::ingestion_data_source_settings::aws_msk::State>>()?.unwrap_or_default();
                            }
                            __FieldTag::__cluster_arn => {
                                if !fields.insert(__FieldTag::__cluster_arn) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cluster_arn",
                                    ));
                                }
                                result.cluster_arn = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__topic => {
                                if !fields.insert(__FieldTag::__topic) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for topic",
                                    ));
                                }
                                result.topic = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__aws_role_arn => {
                                if !fields.insert(__FieldTag::__aws_role_arn) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for aws_role_arn",
                                    ));
                                }
                                result.aws_role_arn = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__gcp_service_account => {
                                if !fields.insert(__FieldTag::__gcp_service_account) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gcp_service_account",
                                    ));
                                }
                                result.gcp_service_account = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AwsMsk {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.cluster_arn.is_empty() {
                state.serialize_entry("clusterArn", &self.cluster_arn)?;
            }
            if !self.topic.is_empty() {
                state.serialize_entry("topic", &self.topic)?;
            }
            if !self.aws_role_arn.is_empty() {
                state.serialize_entry("awsRoleArn", &self.aws_role_arn)?;
            }
            if !self.gcp_service_account.is_empty() {
                state.serialize_entry("gcpServiceAccount", &self.gcp_service_account)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AwsMsk {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AwsMsk");
            debug_struct.field("state", &self.state);
            debug_struct.field("cluster_arn", &self.cluster_arn);
            debug_struct.field("topic", &self.topic);
            debug_struct.field("aws_role_arn", &self.aws_role_arn);
            debug_struct.field("gcp_service_account", &self.gcp_service_account);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [AwsMsk].
    pub mod aws_msk {
        #[allow(unused_imports)]
        use super::*;

        /// Possible states for managed ingestion from Amazon MSK.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Default value. This value is unused.
            Unspecified,
            /// Ingestion is active.
            Active,
            /// Permission denied encountered while consuming data from Amazon MSK.
            MskPermissionDenied,
            /// Permission denied encountered while publishing to the topic.
            PublishPermissionDenied,
            /// The provided MSK cluster wasn't found.
            ClusterNotFound,
            /// The provided topic wasn't found.
            TopicNotFound,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Active => std::option::Option::Some(1),
                    Self::MskPermissionDenied => std::option::Option::Some(2),
                    Self::PublishPermissionDenied => std::option::Option::Some(3),
                    Self::ClusterNotFound => std::option::Option::Some(4),
                    Self::TopicNotFound => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Active => std::option::Option::Some("ACTIVE"),
                    Self::MskPermissionDenied => std::option::Option::Some("MSK_PERMISSION_DENIED"),
                    Self::PublishPermissionDenied => {
                        std::option::Option::Some("PUBLISH_PERMISSION_DENIED")
                    }
                    Self::ClusterNotFound => std::option::Option::Some("CLUSTER_NOT_FOUND"),
                    Self::TopicNotFound => std::option::Option::Some("TOPIC_NOT_FOUND"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Active,
                    2 => Self::MskPermissionDenied,
                    3 => Self::PublishPermissionDenied,
                    4 => Self::ClusterNotFound,
                    5 => Self::TopicNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "ACTIVE" => Self::Active,
                    "MSK_PERMISSION_DENIED" => Self::MskPermissionDenied,
                    "PUBLISH_PERMISSION_DENIED" => Self::PublishPermissionDenied,
                    "CLUSTER_NOT_FOUND" => Self::ClusterNotFound,
                    "TOPIC_NOT_FOUND" => Self::TopicNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Active => serializer.serialize_i32(1),
                    Self::MskPermissionDenied => serializer.serialize_i32(2),
                    Self::PublishPermissionDenied => serializer.serialize_i32(3),
                    Self::ClusterNotFound => serializer.serialize_i32(4),
                    Self::TopicNotFound => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.pubsub.v1.IngestionDataSourceSettings.AwsMsk.State",
                ))
            }
        }
    }

    /// Ingestion settings for Confluent Cloud.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConfluentCloud {
        /// Output only. An output-only field that indicates the state of the
        /// Confluent Cloud ingestion source.
        pub state: crate::model::ingestion_data_source_settings::confluent_cloud::State,

        /// Required. The address of the bootstrap server. The format is url:port.
        pub bootstrap_server: std::string::String,

        /// Required. The id of the cluster.
        pub cluster_id: std::string::String,

        /// Required. The name of the topic in the Confluent Cloud cluster that
        /// Pub/Sub will import from.
        pub topic: std::string::String,

        /// Required. The id of the identity pool to be used for Federated Identity
        /// authentication with Confluent Cloud. See
        /// <https://docs.confluent.io/cloud/current/security/authenticate/workload-identities/identity-providers/oauth/identity-pools.html#add-oauth-identity-pools>.
        pub identity_pool_id: std::string::String,

        /// Required. The GCP service account to be used for Federated Identity
        /// authentication with `identity_pool_id`.
        pub gcp_service_account: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConfluentCloud {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::ingestion_data_source_settings::ConfluentCloud::state].
        pub fn set_state<
            T: std::convert::Into<
                    crate::model::ingestion_data_source_settings::confluent_cloud::State,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [bootstrap_server][crate::model::ingestion_data_source_settings::ConfluentCloud::bootstrap_server].
        pub fn set_bootstrap_server<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.bootstrap_server = v.into();
            self
        }

        /// Sets the value of [cluster_id][crate::model::ingestion_data_source_settings::ConfluentCloud::cluster_id].
        pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cluster_id = v.into();
            self
        }

        /// Sets the value of [topic][crate::model::ingestion_data_source_settings::ConfluentCloud::topic].
        pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.topic = v.into();
            self
        }

        /// Sets the value of [identity_pool_id][crate::model::ingestion_data_source_settings::ConfluentCloud::identity_pool_id].
        pub fn set_identity_pool_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.identity_pool_id = v.into();
            self
        }

        /// Sets the value of [gcp_service_account][crate::model::ingestion_data_source_settings::ConfluentCloud::gcp_service_account].
        pub fn set_gcp_service_account<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gcp_service_account = v.into();
            self
        }
    }

    impl wkt::message::Message for ConfluentCloud {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.ConfluentCloud"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConfluentCloud {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __bootstrap_server,
                __cluster_id,
                __topic,
                __identity_pool_id,
                __gcp_service_account,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConfluentCloud")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "bootstrapServer" => Ok(__FieldTag::__bootstrap_server),
                                "bootstrap_server" => Ok(__FieldTag::__bootstrap_server),
                                "clusterId" => Ok(__FieldTag::__cluster_id),
                                "cluster_id" => Ok(__FieldTag::__cluster_id),
                                "topic" => Ok(__FieldTag::__topic),
                                "identityPoolId" => Ok(__FieldTag::__identity_pool_id),
                                "identity_pool_id" => Ok(__FieldTag::__identity_pool_id),
                                "gcpServiceAccount" => Ok(__FieldTag::__gcp_service_account),
                                "gcp_service_account" => Ok(__FieldTag::__gcp_service_account),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConfluentCloud;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConfluentCloud")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map.next_value::<std::option::Option<crate::model::ingestion_data_source_settings::confluent_cloud::State>>()?.unwrap_or_default();
                            }
                            __FieldTag::__bootstrap_server => {
                                if !fields.insert(__FieldTag::__bootstrap_server) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bootstrap_server",
                                    ));
                                }
                                result.bootstrap_server = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cluster_id => {
                                if !fields.insert(__FieldTag::__cluster_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cluster_id",
                                    ));
                                }
                                result.cluster_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__topic => {
                                if !fields.insert(__FieldTag::__topic) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for topic",
                                    ));
                                }
                                result.topic = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__identity_pool_id => {
                                if !fields.insert(__FieldTag::__identity_pool_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for identity_pool_id",
                                    ));
                                }
                                result.identity_pool_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__gcp_service_account => {
                                if !fields.insert(__FieldTag::__gcp_service_account) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gcp_service_account",
                                    ));
                                }
                                result.gcp_service_account = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ConfluentCloud {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.bootstrap_server.is_empty() {
                state.serialize_entry("bootstrapServer", &self.bootstrap_server)?;
            }
            if !self.cluster_id.is_empty() {
                state.serialize_entry("clusterId", &self.cluster_id)?;
            }
            if !self.topic.is_empty() {
                state.serialize_entry("topic", &self.topic)?;
            }
            if !self.identity_pool_id.is_empty() {
                state.serialize_entry("identityPoolId", &self.identity_pool_id)?;
            }
            if !self.gcp_service_account.is_empty() {
                state.serialize_entry("gcpServiceAccount", &self.gcp_service_account)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ConfluentCloud {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ConfluentCloud");
            debug_struct.field("state", &self.state);
            debug_struct.field("bootstrap_server", &self.bootstrap_server);
            debug_struct.field("cluster_id", &self.cluster_id);
            debug_struct.field("topic", &self.topic);
            debug_struct.field("identity_pool_id", &self.identity_pool_id);
            debug_struct.field("gcp_service_account", &self.gcp_service_account);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ConfluentCloud].
    pub mod confluent_cloud {
        #[allow(unused_imports)]
        use super::*;

        /// Possible states for managed ingestion from Confluent Cloud.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Default value. This value is unused.
            Unspecified,
            /// Ingestion is active.
            Active,
            /// Permission denied encountered while consuming data from Confluent
            /// Cloud.
            ConfluentCloudPermissionDenied,
            /// Permission denied encountered while publishing to the topic.
            PublishPermissionDenied,
            /// The provided bootstrap server address is unreachable.
            UnreachableBootstrapServer,
            /// The provided cluster wasn't found.
            ClusterNotFound,
            /// The provided topic wasn't found.
            TopicNotFound,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Active => std::option::Option::Some(1),
                    Self::ConfluentCloudPermissionDenied => std::option::Option::Some(2),
                    Self::PublishPermissionDenied => std::option::Option::Some(3),
                    Self::UnreachableBootstrapServer => std::option::Option::Some(4),
                    Self::ClusterNotFound => std::option::Option::Some(5),
                    Self::TopicNotFound => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Active => std::option::Option::Some("ACTIVE"),
                    Self::ConfluentCloudPermissionDenied => {
                        std::option::Option::Some("CONFLUENT_CLOUD_PERMISSION_DENIED")
                    }
                    Self::PublishPermissionDenied => {
                        std::option::Option::Some("PUBLISH_PERMISSION_DENIED")
                    }
                    Self::UnreachableBootstrapServer => {
                        std::option::Option::Some("UNREACHABLE_BOOTSTRAP_SERVER")
                    }
                    Self::ClusterNotFound => std::option::Option::Some("CLUSTER_NOT_FOUND"),
                    Self::TopicNotFound => std::option::Option::Some("TOPIC_NOT_FOUND"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Active,
                    2 => Self::ConfluentCloudPermissionDenied,
                    3 => Self::PublishPermissionDenied,
                    4 => Self::UnreachableBootstrapServer,
                    5 => Self::ClusterNotFound,
                    6 => Self::TopicNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "ACTIVE" => Self::Active,
                    "CONFLUENT_CLOUD_PERMISSION_DENIED" => Self::ConfluentCloudPermissionDenied,
                    "PUBLISH_PERMISSION_DENIED" => Self::PublishPermissionDenied,
                    "UNREACHABLE_BOOTSTRAP_SERVER" => Self::UnreachableBootstrapServer,
                    "CLUSTER_NOT_FOUND" => Self::ClusterNotFound,
                    "TOPIC_NOT_FOUND" => Self::TopicNotFound,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Active => serializer.serialize_i32(1),
                    Self::ConfluentCloudPermissionDenied => serializer.serialize_i32(2),
                    Self::PublishPermissionDenied => serializer.serialize_i32(3),
                    Self::UnreachableBootstrapServer => serializer.serialize_i32(4),
                    Self::ClusterNotFound => serializer.serialize_i32(5),
                    Self::TopicNotFound => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.pubsub.v1.IngestionDataSourceSettings.ConfluentCloud.State",
                ))
            }
        }
    }

    /// Only one source type can have settings set.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Optional. Amazon Kinesis Data Streams.
        AwsKinesis(std::boxed::Box<crate::model::ingestion_data_source_settings::AwsKinesis>),
        /// Optional. Cloud Storage.
        CloudStorage(std::boxed::Box<crate::model::ingestion_data_source_settings::CloudStorage>),
        /// Optional. Azure Event Hubs.
        AzureEventHubs(
            std::boxed::Box<crate::model::ingestion_data_source_settings::AzureEventHubs>,
        ),
        /// Optional. Amazon MSK.
        AwsMsk(std::boxed::Box<crate::model::ingestion_data_source_settings::AwsMsk>),
        /// Optional. Confluent Cloud.
        ConfluentCloud(
            std::boxed::Box<crate::model::ingestion_data_source_settings::ConfluentCloud>,
        ),
    }
}

/// Settings for Platform Logs produced by Pub/Sub.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PlatformLogsSettings {
    /// Optional. The minimum severity level of Platform Logs that will be written.
    pub severity: crate::model::platform_logs_settings::Severity,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PlatformLogsSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [severity][crate::model::PlatformLogsSettings::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::platform_logs_settings::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }
}

impl wkt::message::Message for PlatformLogsSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.PlatformLogsSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PlatformLogsSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __severity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PlatformLogsSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "severity" => Ok(__FieldTag::__severity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PlatformLogsSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PlatformLogsSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity =
                                map.next_value::<std::option::Option<
                                    crate::model::platform_logs_settings::Severity,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PlatformLogsSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PlatformLogsSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PlatformLogsSettings");
        debug_struct.field("severity", &self.severity);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PlatformLogsSettings].
pub mod platform_logs_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Severity levels of Platform Logs.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// Default value. Logs level is unspecified. Logs will be disabled.
        Unspecified,
        /// Logs will be disabled.
        Disabled,
        /// Debug logs and higher-severity logs will be written.
        Debug,
        /// Info logs and higher-severity logs will be written.
        Info,
        /// Warning logs and higher-severity logs will be written.
        Warning,
        /// Only error logs will be written.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Debug => std::option::Option::Some(2),
                Self::Info => std::option::Option::Some(3),
                Self::Warning => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Debug => std::option::Option::Some("DEBUG"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::Debug,
                3 => Self::Info,
                4 => Self::Warning,
                5 => Self::Error,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "DEBUG" => Self::Debug,
                "INFO" => Self::Info,
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Debug => serializer.serialize_i32(2),
                Self::Info => serializer.serialize_i32(3),
                Self::Warning => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.pubsub.v1.PlatformLogsSettings.Severity",
            ))
        }
    }
}

/// User-defined JavaScript function that can transform or filter a Pub/Sub
/// message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct JavaScriptUDF {
    /// Required. Name of the JavasScript function that should applied to Pub/Sub
    /// messages.
    pub function_name: std::string::String,

    /// Required. JavaScript code that contains a function `function_name` with the
    /// below signature:
    ///
    /// ```norust
    ///   /**
    ///   * Transforms a Pub/Sub message.
    ///
    ///   * @return {(Object<string, (string | Object<string, string>)>|null)} - To
    ///   * filter a message, return `null`. To transform a message return a map
    ///   * with the following keys:
    ///   *   - (required) 'data' : {string}
    ///   *   - (optional) 'attributes' : {Object<string, string>}
    ///   * Returning empty `attributes` will remove all attributes from the
    ///   * message.
    ///   *
    ///   * @param  {(Object<string, (string | Object<string, string>)>} Pub/Sub
    ///   * message. Keys:
    ///   *   - (required) 'data' : {string}
    ///   *   - (required) 'attributes' : {Object<string, string>}
    ///   *
    ///   * @param  {Object<string, any>} metadata - Pub/Sub message metadata.
    ///   * Keys:
    ///   *   - (optional) 'message_id'  : {string}
    ///   *   - (optional) 'publish_time': {string} YYYY-MM-DDTHH:MM:SSZ format
    ///   *   - (optional) 'ordering_key': {string}
    ///   */
    ///
    ///   function <function_name>(message, metadata) {
    ///   }
    /// ```
    pub code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JavaScriptUDF {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [function_name][crate::model::JavaScriptUDF::function_name].
    pub fn set_function_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.function_name = v.into();
        self
    }

    /// Sets the value of [code][crate::model::JavaScriptUDF::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }
}

impl wkt::message::Message for JavaScriptUDF {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.JavaScriptUDF"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JavaScriptUDF {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __function_name,
            __code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JavaScriptUDF")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "functionName" => Ok(__FieldTag::__function_name),
                            "function_name" => Ok(__FieldTag::__function_name),
                            "code" => Ok(__FieldTag::__code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JavaScriptUDF;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JavaScriptUDF")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__function_name => {
                            if !fields.insert(__FieldTag::__function_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for function_name",
                                ));
                            }
                            result.function_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JavaScriptUDF {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.function_name.is_empty() {
            state.serialize_entry("functionName", &self.function_name)?;
        }
        if !self.code.is_empty() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for JavaScriptUDF {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JavaScriptUDF");
        debug_struct.field("function_name", &self.function_name);
        debug_struct.field("code", &self.code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// All supported message transforms types.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MessageTransform {
    /// Optional. This field is deprecated, use the `disabled` field to disable
    /// transforms.
    #[deprecated]
    pub enabled: bool,

    /// Optional. If true, the transform is disabled and will not be applied to
    /// messages. Defaults to `false`.
    pub disabled: bool,

    /// The type of transform to apply to messages.
    pub transform: std::option::Option<crate::model::message_transform::Transform>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MessageTransform {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::MessageTransform::enabled].
    #[deprecated]
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::MessageTransform::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [transform][crate::model::MessageTransform::transform].
    ///
    /// Note that all the setters affecting `transform` are mutually
    /// exclusive.
    pub fn set_transform<
        T: std::convert::Into<std::option::Option<crate::model::message_transform::Transform>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transform = v.into();
        self
    }

    /// The value of [transform][crate::model::MessageTransform::transform]
    /// if it holds a `JavascriptUdf`, `None` if the field is not set or
    /// holds a different branch.
    pub fn javascript_udf(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::JavaScriptUDF>> {
        #[allow(unreachable_patterns)]
        self.transform.as_ref().and_then(|v| match v {
            crate::model::message_transform::Transform::JavascriptUdf(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transform][crate::model::MessageTransform::transform]
    /// to hold a `JavascriptUdf`.
    ///
    /// Note that all the setters affecting `transform` are
    /// mutually exclusive.
    pub fn set_javascript_udf<
        T: std::convert::Into<std::boxed::Box<crate::model::JavaScriptUDF>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transform = std::option::Option::Some(
            crate::model::message_transform::Transform::JavascriptUdf(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MessageTransform {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.MessageTransform"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MessageTransform {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __javascript_udf,
            __enabled,
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageTransform")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "javascriptUdf" => Ok(__FieldTag::__javascript_udf),
                            "javascript_udf" => Ok(__FieldTag::__javascript_udf),
                            "enabled" => Ok(__FieldTag::__enabled),
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MessageTransform;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageTransform")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__javascript_udf => {
                            if !fields.insert(__FieldTag::__javascript_udf) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for javascript_udf",
                                ));
                            }
                            if result.transform.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transform`, a oneof with full ID .google.pubsub.v1.MessageTransform.javascript_udf, latest field was javascriptUdf",
                                ));
                            }
                            result.transform = std::option::Option::Some(
                                crate::model::message_transform::Transform::JavascriptUdf(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::JavaScriptUDF>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MessageTransform {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.javascript_udf() {
            state.serialize_entry("javascriptUdf", value)?;
        }
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MessageTransform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MessageTransform");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("disabled", &self.disabled);
        debug_struct.field("transform", &self.transform);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MessageTransform].
pub mod message_transform {
    #[allow(unused_imports)]
    use super::*;

    /// The type of transform to apply to messages.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Transform {
        /// Optional. JavaScript User Defined Function. If multiple JavaScriptUDF's
        /// are specified on a resource, each must have a unique `function_name`.
        JavascriptUdf(std::boxed::Box<crate::model::JavaScriptUDF>),
    }
}

/// A topic resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Topic {
    /// Required. The name of the topic. It must have the format
    /// `"projects/{project}/topics/{topic}"`. `{topic}` must start with a letter,
    /// and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`),
    /// underscores (`_`), periods (`.`), tildes (`~`), plus (`+`) or percent
    /// signs (`%`). It must be between 3 and 255 characters in length, and it
    /// must not start with `"goog"`.
    pub name: std::string::String,

    /// Optional. See [Creating and managing labels]
    /// (<https://cloud.google.com/pubsub/docs/labels>).
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Policy constraining the set of Google Cloud Platform regions
    /// where messages published to the topic may be stored. If not present, then
    /// no constraints are in effect.
    pub message_storage_policy: std::option::Option<crate::model::MessageStoragePolicy>,

    /// Optional. The resource name of the Cloud KMS CryptoKey to be used to
    /// protect access to messages published on this topic.
    ///
    /// The expected format is `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    pub kms_key_name: std::string::String,

    /// Optional. Settings for validating messages published against a schema.
    pub schema_settings: std::option::Option<crate::model::SchemaSettings>,

    /// Optional. Reserved for future use. This field is set only in responses from
    /// the server; it is ignored if it is set in any requests.
    pub satisfies_pzs: bool,

    /// Optional. Indicates the minimum duration to retain a message after it is
    /// published to the topic. If this field is set, messages published to the
    /// topic in the last `message_retention_duration` are always available to
    /// subscribers. For instance, it allows any attached subscription to [seek to
    /// a
    /// timestamp](https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time)
    /// that is up to `message_retention_duration` in the past. If this field is
    /// not set, message retention is controlled by settings on individual
    /// subscriptions. Cannot be more than 31 days or less than 10 minutes.
    pub message_retention_duration: std::option::Option<wkt::Duration>,

    /// Output only. An output-only field indicating the state of the topic.
    pub state: crate::model::topic::State,

    /// Optional. Settings for ingestion from a data source into this topic.
    pub ingestion_data_source_settings:
        std::option::Option<crate::model::IngestionDataSourceSettings>,

    /// Optional. Transforms to be applied to messages published to the topic.
    /// Transforms are applied in the order specified.
    pub message_transforms: std::vec::Vec<crate::model::MessageTransform>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Topic {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Topic::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Topic::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [message_storage_policy][crate::model::Topic::message_storage_policy].
    pub fn set_message_storage_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MessageStoragePolicy>,
    {
        self.message_storage_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message_storage_policy][crate::model::Topic::message_storage_policy].
    pub fn set_or_clear_message_storage_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MessageStoragePolicy>,
    {
        self.message_storage_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Topic::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [schema_settings][crate::model::Topic::schema_settings].
    pub fn set_schema_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SchemaSettings>,
    {
        self.schema_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema_settings][crate::model::Topic::schema_settings].
    pub fn set_or_clear_schema_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SchemaSettings>,
    {
        self.schema_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Topic::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [message_retention_duration][crate::model::Topic::message_retention_duration].
    pub fn set_message_retention_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.message_retention_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message_retention_duration][crate::model::Topic::message_retention_duration].
    pub fn set_or_clear_message_retention_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.message_retention_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Topic::state].
    pub fn set_state<T: std::convert::Into<crate::model::topic::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [ingestion_data_source_settings][crate::model::Topic::ingestion_data_source_settings].
    pub fn set_ingestion_data_source_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IngestionDataSourceSettings>,
    {
        self.ingestion_data_source_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ingestion_data_source_settings][crate::model::Topic::ingestion_data_source_settings].
    pub fn set_or_clear_ingestion_data_source_settings<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::IngestionDataSourceSettings>,
    {
        self.ingestion_data_source_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message_transforms][crate::model::Topic::message_transforms].
    pub fn set_message_transforms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageTransform>,
    {
        use std::iter::Iterator;
        self.message_transforms = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Topic {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.Topic"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Topic {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __labels,
            __message_storage_policy,
            __kms_key_name,
            __schema_settings,
            __satisfies_pzs,
            __message_retention_duration,
            __state,
            __ingestion_data_source_settings,
            __message_transforms,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Topic")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "labels" => Ok(__FieldTag::__labels),
                            "messageStoragePolicy" => Ok(__FieldTag::__message_storage_policy),
                            "message_storage_policy" => Ok(__FieldTag::__message_storage_policy),
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "schemaSettings" => Ok(__FieldTag::__schema_settings),
                            "schema_settings" => Ok(__FieldTag::__schema_settings),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "messageRetentionDuration" => {
                                Ok(__FieldTag::__message_retention_duration)
                            }
                            "message_retention_duration" => {
                                Ok(__FieldTag::__message_retention_duration)
                            }
                            "state" => Ok(__FieldTag::__state),
                            "ingestionDataSourceSettings" => {
                                Ok(__FieldTag::__ingestion_data_source_settings)
                            }
                            "ingestion_data_source_settings" => {
                                Ok(__FieldTag::__ingestion_data_source_settings)
                            }
                            "messageTransforms" => Ok(__FieldTag::__message_transforms),
                            "message_transforms" => Ok(__FieldTag::__message_transforms),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Topic;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Topic")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message_storage_policy => {
                            if !fields.insert(__FieldTag::__message_storage_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_storage_policy",
                                ));
                            }
                            result.message_storage_policy = map.next_value::<std::option::Option<crate::model::MessageStoragePolicy>>()?
                                ;
                        }
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema_settings => {
                            if !fields.insert(__FieldTag::__schema_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_settings",
                                ));
                            }
                            result.schema_settings = map
                                .next_value::<std::option::Option<crate::model::SchemaSettings>>(
                                )?;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message_retention_duration => {
                            if !fields.insert(__FieldTag::__message_retention_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_retention_duration",
                                ));
                            }
                            result.message_retention_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::topic::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ingestion_data_source_settings => {
                            if !fields.insert(__FieldTag::__ingestion_data_source_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ingestion_data_source_settings",
                                ));
                            }
                            result.ingestion_data_source_settings = map.next_value::<std::option::Option<crate::model::IngestionDataSourceSettings>>()?
                                ;
                        }
                        __FieldTag::__message_transforms => {
                            if !fields.insert(__FieldTag::__message_transforms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_transforms",
                                ));
                            }
                            result.message_transforms =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::MessageTransform>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Topic {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.message_storage_policy.is_some() {
            state.serialize_entry("messageStoragePolicy", &self.message_storage_policy)?;
        }
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if self.schema_settings.is_some() {
            state.serialize_entry("schemaSettings", &self.schema_settings)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.message_retention_duration.is_some() {
            state.serialize_entry("messageRetentionDuration", &self.message_retention_duration)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.ingestion_data_source_settings.is_some() {
            state.serialize_entry(
                "ingestionDataSourceSettings",
                &self.ingestion_data_source_settings,
            )?;
        }
        if !self.message_transforms.is_empty() {
            state.serialize_entry("messageTransforms", &self.message_transforms)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Topic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Topic");
        debug_struct.field("name", &self.name);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("message_storage_policy", &self.message_storage_policy);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("schema_settings", &self.schema_settings);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field(
            "message_retention_duration",
            &self.message_retention_duration,
        );
        debug_struct.field("state", &self.state);
        debug_struct.field(
            "ingestion_data_source_settings",
            &self.ingestion_data_source_settings,
        );
        debug_struct.field("message_transforms", &self.message_transforms);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Topic].
pub mod topic {
    #[allow(unused_imports)]
    use super::*;

    /// The state of the topic.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// The topic does not have any persistent errors.
        Active,
        /// Ingestion from the data source has encountered a permanent error.
        /// See the more detailed error state in the corresponding ingestion
        /// source configuration.
        IngestionResourceError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::IngestionResourceError => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::IngestionResourceError => {
                    std::option::Option::Some("INGESTION_RESOURCE_ERROR")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::IngestionResourceError,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "INGESTION_RESOURCE_ERROR" => Self::IngestionResourceError,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::IngestionResourceError => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.pubsub.v1.Topic.State",
            ))
        }
    }
}

/// Request for the GetTopic method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTopicRequest {
    /// Required. The name of the topic to get.
    /// Format is `projects/{project}/topics/{topic}`.
    pub topic: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTopicRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic][crate::model::GetTopicRequest::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }
}

impl wkt::message::Message for GetTopicRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.GetTopicRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTopicRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __topic,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTopicRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "topic" => Ok(__FieldTag::__topic),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTopicRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTopicRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__topic => {
                            if !fields.insert(__FieldTag::__topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic",
                                ));
                            }
                            result.topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTopicRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.topic.is_empty() {
            state.serialize_entry("topic", &self.topic)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetTopicRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTopicRequest");
        debug_struct.field("topic", &self.topic);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the UpdateTopic method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTopicRequest {
    /// Required. The updated topic object.
    pub topic: std::option::Option<crate::model::Topic>,

    /// Required. Indicates which fields in the provided topic to update. Must be
    /// specified and non-empty. Note that if `update_mask` contains
    /// "message_storage_policy" but the `message_storage_policy` is not set in
    /// the `topic` provided above, then the updated value is determined by the
    /// policy configured at the project or organization level.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTopicRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic][crate::model::UpdateTopicRequest::topic].
    pub fn set_topic<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Topic>,
    {
        self.topic = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [topic][crate::model::UpdateTopicRequest::topic].
    pub fn set_or_clear_topic<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Topic>,
    {
        self.topic = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTopicRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTopicRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTopicRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.UpdateTopicRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTopicRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __topic,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTopicRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "topic" => Ok(__FieldTag::__topic),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTopicRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTopicRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__topic => {
                            if !fields.insert(__FieldTag::__topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic",
                                ));
                            }
                            result.topic =
                                map.next_value::<std::option::Option<crate::model::Topic>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTopicRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.topic.is_some() {
            state.serialize_entry("topic", &self.topic)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateTopicRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateTopicRequest");
        debug_struct.field("topic", &self.topic);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `ListTopics` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTopicsRequest {
    /// Required. The name of the project in which to list topics.
    /// Format is `projects/{project-id}`.
    pub project: std::string::String,

    /// Optional. Maximum number of topics to return.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListTopicsResponse`; indicates
    /// that this is a continuation of a prior `ListTopics` call, and that the
    /// system should return the next page of data.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTopicsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::ListTopicsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTopicsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTopicsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTopicsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListTopicsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTopicsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTopicsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "project" => Ok(__FieldTag::__project),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTopicsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTopicsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTopicsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTopicsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTopicsRequest");
        debug_struct.field("project", &self.project);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for the `ListTopics` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTopicsResponse {
    /// Optional. The resulting topics.
    pub topics: std::vec::Vec<crate::model::Topic>,

    /// Optional. If not empty, indicates that there may be more topics that match
    /// the request; this value should be passed in a new `ListTopicsRequest`.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTopicsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topics][crate::model::ListTopicsResponse::topics].
    pub fn set_topics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Topic>,
    {
        use std::iter::Iterator;
        self.topics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTopicsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTopicsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListTopicsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTopicsResponse {
    type PageItem = crate::model::Topic;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.topics
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTopicsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __topics,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTopicsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "topics" => Ok(__FieldTag::__topics),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTopicsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTopicsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__topics => {
                            if !fields.insert(__FieldTag::__topics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topics",
                                ));
                            }
                            result.topics = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Topic>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTopicsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.topics.is_empty() {
            state.serialize_entry("topics", &self.topics)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTopicsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTopicsResponse");
        debug_struct.field("topics", &self.topics);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `ListTopicSubscriptions` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTopicSubscriptionsRequest {
    /// Required. The name of the topic that subscriptions are attached to.
    /// Format is `projects/{project}/topics/{topic}`.
    pub topic: std::string::String,

    /// Optional. Maximum number of subscription names to return.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListTopicSubscriptionsResponse`;
    /// indicates that this is a continuation of a prior `ListTopicSubscriptions`
    /// call, and that the system should return the next page of data.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTopicSubscriptionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic][crate::model::ListTopicSubscriptionsRequest::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTopicSubscriptionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTopicSubscriptionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTopicSubscriptionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListTopicSubscriptionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTopicSubscriptionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __topic,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTopicSubscriptionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "topic" => Ok(__FieldTag::__topic),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTopicSubscriptionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTopicSubscriptionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__topic => {
                            if !fields.insert(__FieldTag::__topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic",
                                ));
                            }
                            result.topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTopicSubscriptionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.topic.is_empty() {
            state.serialize_entry("topic", &self.topic)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTopicSubscriptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTopicSubscriptionsRequest");
        debug_struct.field("topic", &self.topic);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for the `ListTopicSubscriptions` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTopicSubscriptionsResponse {
    /// Optional. The names of subscriptions attached to the topic specified in the
    /// request.
    pub subscriptions: std::vec::Vec<std::string::String>,

    /// Optional. If not empty, indicates that there may be more subscriptions that
    /// match the request; this value should be passed in a new
    /// `ListTopicSubscriptionsRequest` to get more subscriptions.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTopicSubscriptionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscriptions][crate::model::ListTopicSubscriptionsResponse::subscriptions].
    pub fn set_subscriptions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subscriptions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTopicSubscriptionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTopicSubscriptionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListTopicSubscriptionsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTopicSubscriptionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subscriptions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTopicSubscriptionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subscriptions" => Ok(__FieldTag::__subscriptions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTopicSubscriptionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTopicSubscriptionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subscriptions => {
                            if !fields.insert(__FieldTag::__subscriptions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscriptions",
                                ));
                            }
                            result.subscriptions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTopicSubscriptionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subscriptions.is_empty() {
            state.serialize_entry("subscriptions", &self.subscriptions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTopicSubscriptionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTopicSubscriptionsResponse");
        debug_struct.field("subscriptions", &self.subscriptions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `ListTopicSnapshots` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTopicSnapshotsRequest {
    /// Required. The name of the topic that snapshots are attached to.
    /// Format is `projects/{project}/topics/{topic}`.
    pub topic: std::string::String,

    /// Optional. Maximum number of snapshot names to return.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListTopicSnapshotsResponse`;
    /// indicates that this is a continuation of a prior `ListTopicSnapshots` call,
    /// and that the system should return the next page of data.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTopicSnapshotsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic][crate::model::ListTopicSnapshotsRequest::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTopicSnapshotsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTopicSnapshotsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTopicSnapshotsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListTopicSnapshotsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTopicSnapshotsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __topic,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTopicSnapshotsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "topic" => Ok(__FieldTag::__topic),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTopicSnapshotsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTopicSnapshotsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__topic => {
                            if !fields.insert(__FieldTag::__topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic",
                                ));
                            }
                            result.topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTopicSnapshotsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.topic.is_empty() {
            state.serialize_entry("topic", &self.topic)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTopicSnapshotsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTopicSnapshotsRequest");
        debug_struct.field("topic", &self.topic);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for the `ListTopicSnapshots` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTopicSnapshotsResponse {
    /// Optional. The names of the snapshots that match the request.
    pub snapshots: std::vec::Vec<std::string::String>,

    /// Optional. If not empty, indicates that there may be more snapshots that
    /// match the request; this value should be passed in a new
    /// `ListTopicSnapshotsRequest` to get more snapshots.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTopicSnapshotsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots][crate::model::ListTopicSnapshotsResponse::snapshots].
    pub fn set_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTopicSnapshotsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTopicSnapshotsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListTopicSnapshotsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTopicSnapshotsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snapshots,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTopicSnapshotsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snapshots" => Ok(__FieldTag::__snapshots),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTopicSnapshotsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTopicSnapshotsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snapshots => {
                            if !fields.insert(__FieldTag::__snapshots) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshots",
                                ));
                            }
                            result.snapshots = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTopicSnapshotsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.snapshots.is_empty() {
            state.serialize_entry("snapshots", &self.snapshots)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTopicSnapshotsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTopicSnapshotsResponse");
        debug_struct.field("snapshots", &self.snapshots);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `DeleteTopic` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTopicRequest {
    /// Required. Name of the topic to delete.
    /// Format is `projects/{project}/topics/{topic}`.
    pub topic: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTopicRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic][crate::model::DeleteTopicRequest::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTopicRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DeleteTopicRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTopicRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __topic,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTopicRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "topic" => Ok(__FieldTag::__topic),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTopicRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTopicRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__topic => {
                            if !fields.insert(__FieldTag::__topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic",
                                ));
                            }
                            result.topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTopicRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.topic.is_empty() {
            state.serialize_entry("topic", &self.topic)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteTopicRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteTopicRequest");
        debug_struct.field("topic", &self.topic);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the DetachSubscription method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DetachSubscriptionRequest {
    /// Required. The subscription to detach.
    /// Format is `projects/{project}/subscriptions/{subscription}`.
    pub subscription: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DetachSubscriptionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::DetachSubscriptionRequest::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }
}

impl wkt::message::Message for DetachSubscriptionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DetachSubscriptionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DetachSubscriptionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subscription,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DetachSubscriptionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subscription" => Ok(__FieldTag::__subscription),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DetachSubscriptionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DetachSubscriptionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subscription => {
                            if !fields.insert(__FieldTag::__subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscription",
                                ));
                            }
                            result.subscription = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DetachSubscriptionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subscription.is_empty() {
            state.serialize_entry("subscription", &self.subscription)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DetachSubscriptionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DetachSubscriptionRequest");
        debug_struct.field("subscription", &self.subscription);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for the DetachSubscription method.
/// Reserved for future use.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DetachSubscriptionResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DetachSubscriptionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DetachSubscriptionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DetachSubscriptionResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DetachSubscriptionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DetachSubscriptionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DetachSubscriptionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DetachSubscriptionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DetachSubscriptionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DetachSubscriptionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DetachSubscriptionResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A subscription resource. If none of `push_config`, `bigquery_config`, or
/// `cloud_storage_config` is set, then the subscriber will pull and ack messages
/// using API methods. At most one of these fields may be set.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Subscription {
    /// Required. The name of the subscription. It must have the format
    /// `"projects/{project}/subscriptions/{subscription}"`. `{subscription}` must
    /// start with a letter, and contain only letters (`[A-Za-z]`), numbers
    /// (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),
    /// plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters
    /// in length, and it must not start with `"goog"`.
    pub name: std::string::String,

    /// Required. The name of the topic from which this subscription is receiving
    /// messages. Format is `projects/{project}/topics/{topic}`. The value of this
    /// field will be `_deleted-topic_` if the topic has been deleted.
    pub topic: std::string::String,

    /// Optional. If push delivery is used with this subscription, this field is
    /// used to configure it.
    pub push_config: std::option::Option<crate::model::PushConfig>,

    /// Optional. If delivery to BigQuery is used with this subscription, this
    /// field is used to configure it.
    pub bigquery_config: std::option::Option<crate::model::BigQueryConfig>,

    /// Optional. If delivery to Google Cloud Storage is used with this
    /// subscription, this field is used to configure it.
    pub cloud_storage_config: std::option::Option<crate::model::CloudStorageConfig>,

    /// Optional. The approximate amount of time (on a best-effort basis) Pub/Sub
    /// waits for the subscriber to acknowledge receipt before resending the
    /// message. In the interval after the message is delivered and before it is
    /// acknowledged, it is considered to be _outstanding_. During that time
    /// period, the message will not be redelivered (on a best-effort basis).
    ///
    /// For pull subscriptions, this value is used as the initial value for the ack
    /// deadline. To override this value for a given message, call
    /// `ModifyAckDeadline` with the corresponding `ack_id` if using
    /// non-streaming pull or send the `ack_id` in a
    /// `StreamingModifyAckDeadlineRequest` if using streaming pull.
    /// The minimum custom deadline you can specify is 10 seconds.
    /// The maximum custom deadline you can specify is 600 seconds (10 minutes).
    /// If this parameter is 0, a default value of 10 seconds is used.
    ///
    /// For push delivery, this value is also used to set the request timeout for
    /// the call to the push endpoint.
    ///
    /// If the subscriber never acknowledges the message, the Pub/Sub
    /// system will eventually redeliver the message.
    pub ack_deadline_seconds: i32,

    /// Optional. Indicates whether to retain acknowledged messages. If true, then
    /// messages are not expunged from the subscription's backlog, even if they are
    /// acknowledged, until they fall out of the `message_retention_duration`
    /// window. This must be true if you would like to [`Seek` to a timestamp]
    /// (<https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time>) in
    /// the past to replay previously-acknowledged messages.
    pub retain_acked_messages: bool,

    /// Optional. How long to retain unacknowledged messages in the subscription's
    /// backlog, from the moment a message is published. If `retain_acked_messages`
    /// is true, then this also configures the retention of acknowledged messages,
    /// and thus configures how far back in time a `Seek` can be done. Defaults to
    /// 7 days. Cannot be more than 31 days or less than 10 minutes.
    pub message_retention_duration: std::option::Option<wkt::Duration>,

    /// Optional. See [Creating and managing
    /// labels](https://cloud.google.com/pubsub/docs/labels).
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. If true, messages published with the same `ordering_key` in
    /// `PubsubMessage` will be delivered to the subscribers in the order in which
    /// they are received by the Pub/Sub system. Otherwise, they may be delivered
    /// in any order.
    pub enable_message_ordering: bool,

    /// Optional. A policy that specifies the conditions for this subscription's
    /// expiration. A subscription is considered active as long as any connected
    /// subscriber is successfully consuming messages from the subscription or is
    /// issuing operations on the subscription. If `expiration_policy` is not set,
    /// a *default policy* with `ttl` of 31 days will be used. The minimum allowed
    /// value for `expiration_policy.ttl` is 1 day. If `expiration_policy` is set,
    /// but `expiration_policy.ttl` is not set, the subscription never expires.
    pub expiration_policy: std::option::Option<crate::model::ExpirationPolicy>,

    /// Optional. An expression written in the Pub/Sub [filter
    /// language](https://cloud.google.com/pubsub/docs/filtering). If non-empty,
    /// then only `PubsubMessage`s whose `attributes` field matches the filter are
    /// delivered on this subscription. If empty, then no messages are filtered
    /// out.
    pub filter: std::string::String,

    /// Optional. A policy that specifies the conditions for dead lettering
    /// messages in this subscription. If dead_letter_policy is not set, dead
    /// lettering is disabled.
    ///
    /// The Pub/Sub service account associated with this subscriptions's
    /// parent project (i.e.,
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
    /// permission to Acknowledge() messages on this subscription.
    pub dead_letter_policy: std::option::Option<crate::model::DeadLetterPolicy>,

    /// Optional. A policy that specifies how Pub/Sub retries message delivery for
    /// this subscription.
    ///
    /// If not set, the default retry policy is applied. This generally implies
    /// that messages will be retried as soon as possible for healthy subscribers.
    /// RetryPolicy will be triggered on NACKs or acknowledgment deadline exceeded
    /// events for a given message.
    pub retry_policy: std::option::Option<crate::model::RetryPolicy>,

    /// Optional. Indicates whether the subscription is detached from its topic.
    /// Detached subscriptions don't receive messages from their topic and don't
    /// retain any backlog. `Pull` and `StreamingPull` requests will return
    /// FAILED_PRECONDITION. If the subscription is a push subscription, pushes to
    /// the endpoint will not be made.
    pub detached: bool,

    /// Optional. If true, Pub/Sub provides the following guarantees for the
    /// delivery of a message with a given value of `message_id` on this
    /// subscription:
    ///
    /// * The message sent to a subscriber is guaranteed not to be resent
    ///   before the message's acknowledgment deadline expires.
    /// * An acknowledged message will not be resent to a subscriber.
    ///
    /// Note that subscribers may still receive multiple copies of a message
    /// when `enable_exactly_once_delivery` is true if the message was published
    /// multiple times by a publisher client. These copies are  considered distinct
    /// by Pub/Sub and have distinct `message_id` values.
    pub enable_exactly_once_delivery: bool,

    /// Output only. Indicates the minimum duration for which a message is retained
    /// after it is published to the subscription's topic. If this field is set,
    /// messages published to the subscription's topic in the last
    /// `topic_message_retention_duration` are always available to subscribers. See
    /// the `message_retention_duration` field in `Topic`. This field is set only
    /// in responses from the server; it is ignored if it is set in any requests.
    pub topic_message_retention_duration: std::option::Option<wkt::Duration>,

    /// Output only. An output-only field indicating whether or not the
    /// subscription can receive messages.
    pub state: crate::model::subscription::State,

    /// Output only. Information about the associated Analytics Hub subscription.
    /// Only set if the subscritpion is created by Analytics Hub.
    pub analytics_hub_subscription_info:
        std::option::Option<crate::model::subscription::AnalyticsHubSubscriptionInfo>,

    /// Optional. Transforms to be applied to messages before they are delivered to
    /// subscribers. Transforms are applied in the order specified.
    pub message_transforms: std::vec::Vec<crate::model::MessageTransform>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Subscription {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Subscription::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [topic][crate::model::Subscription::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }

    /// Sets the value of [push_config][crate::model::Subscription::push_config].
    pub fn set_push_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PushConfig>,
    {
        self.push_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [push_config][crate::model::Subscription::push_config].
    pub fn set_or_clear_push_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PushConfig>,
    {
        self.push_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [bigquery_config][crate::model::Subscription::bigquery_config].
    pub fn set_bigquery_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryConfig>,
    {
        self.bigquery_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bigquery_config][crate::model::Subscription::bigquery_config].
    pub fn set_or_clear_bigquery_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryConfig>,
    {
        self.bigquery_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cloud_storage_config][crate::model::Subscription::cloud_storage_config].
    pub fn set_cloud_storage_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudStorageConfig>,
    {
        self.cloud_storage_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_storage_config][crate::model::Subscription::cloud_storage_config].
    pub fn set_or_clear_cloud_storage_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudStorageConfig>,
    {
        self.cloud_storage_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ack_deadline_seconds][crate::model::Subscription::ack_deadline_seconds].
    pub fn set_ack_deadline_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ack_deadline_seconds = v.into();
        self
    }

    /// Sets the value of [retain_acked_messages][crate::model::Subscription::retain_acked_messages].
    pub fn set_retain_acked_messages<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.retain_acked_messages = v.into();
        self
    }

    /// Sets the value of [message_retention_duration][crate::model::Subscription::message_retention_duration].
    pub fn set_message_retention_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.message_retention_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message_retention_duration][crate::model::Subscription::message_retention_duration].
    pub fn set_or_clear_message_retention_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.message_retention_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Subscription::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [enable_message_ordering][crate::model::Subscription::enable_message_ordering].
    pub fn set_enable_message_ordering<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_message_ordering = v.into();
        self
    }

    /// Sets the value of [expiration_policy][crate::model::Subscription::expiration_policy].
    pub fn set_expiration_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExpirationPolicy>,
    {
        self.expiration_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_policy][crate::model::Subscription::expiration_policy].
    pub fn set_or_clear_expiration_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExpirationPolicy>,
    {
        self.expiration_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [filter][crate::model::Subscription::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [dead_letter_policy][crate::model::Subscription::dead_letter_policy].
    pub fn set_dead_letter_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeadLetterPolicy>,
    {
        self.dead_letter_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dead_letter_policy][crate::model::Subscription::dead_letter_policy].
    pub fn set_or_clear_dead_letter_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeadLetterPolicy>,
    {
        self.dead_letter_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [retry_policy][crate::model::Subscription::retry_policy].
    pub fn set_retry_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RetryPolicy>,
    {
        self.retry_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retry_policy][crate::model::Subscription::retry_policy].
    pub fn set_or_clear_retry_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RetryPolicy>,
    {
        self.retry_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [detached][crate::model::Subscription::detached].
    pub fn set_detached<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.detached = v.into();
        self
    }

    /// Sets the value of [enable_exactly_once_delivery][crate::model::Subscription::enable_exactly_once_delivery].
    pub fn set_enable_exactly_once_delivery<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_exactly_once_delivery = v.into();
        self
    }

    /// Sets the value of [topic_message_retention_duration][crate::model::Subscription::topic_message_retention_duration].
    pub fn set_topic_message_retention_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.topic_message_retention_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [topic_message_retention_duration][crate::model::Subscription::topic_message_retention_duration].
    pub fn set_or_clear_topic_message_retention_duration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.topic_message_retention_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Subscription::state].
    pub fn set_state<T: std::convert::Into<crate::model::subscription::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [analytics_hub_subscription_info][crate::model::Subscription::analytics_hub_subscription_info].
    pub fn set_analytics_hub_subscription_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::subscription::AnalyticsHubSubscriptionInfo>,
    {
        self.analytics_hub_subscription_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [analytics_hub_subscription_info][crate::model::Subscription::analytics_hub_subscription_info].
    pub fn set_or_clear_analytics_hub_subscription_info<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::subscription::AnalyticsHubSubscriptionInfo>,
    {
        self.analytics_hub_subscription_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message_transforms][crate::model::Subscription::message_transforms].
    pub fn set_message_transforms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageTransform>,
    {
        use std::iter::Iterator;
        self.message_transforms = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Subscription {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.Subscription"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Subscription {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __topic,
            __push_config,
            __bigquery_config,
            __cloud_storage_config,
            __ack_deadline_seconds,
            __retain_acked_messages,
            __message_retention_duration,
            __labels,
            __enable_message_ordering,
            __expiration_policy,
            __filter,
            __dead_letter_policy,
            __retry_policy,
            __detached,
            __enable_exactly_once_delivery,
            __topic_message_retention_duration,
            __state,
            __analytics_hub_subscription_info,
            __message_transforms,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Subscription")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "topic" => Ok(__FieldTag::__topic),
                            "pushConfig" => Ok(__FieldTag::__push_config),
                            "push_config" => Ok(__FieldTag::__push_config),
                            "bigqueryConfig" => Ok(__FieldTag::__bigquery_config),
                            "bigquery_config" => Ok(__FieldTag::__bigquery_config),
                            "cloudStorageConfig" => Ok(__FieldTag::__cloud_storage_config),
                            "cloud_storage_config" => Ok(__FieldTag::__cloud_storage_config),
                            "ackDeadlineSeconds" => Ok(__FieldTag::__ack_deadline_seconds),
                            "ack_deadline_seconds" => Ok(__FieldTag::__ack_deadline_seconds),
                            "retainAckedMessages" => Ok(__FieldTag::__retain_acked_messages),
                            "retain_acked_messages" => Ok(__FieldTag::__retain_acked_messages),
                            "messageRetentionDuration" => {
                                Ok(__FieldTag::__message_retention_duration)
                            }
                            "message_retention_duration" => {
                                Ok(__FieldTag::__message_retention_duration)
                            }
                            "labels" => Ok(__FieldTag::__labels),
                            "enableMessageOrdering" => Ok(__FieldTag::__enable_message_ordering),
                            "enable_message_ordering" => Ok(__FieldTag::__enable_message_ordering),
                            "expirationPolicy" => Ok(__FieldTag::__expiration_policy),
                            "expiration_policy" => Ok(__FieldTag::__expiration_policy),
                            "filter" => Ok(__FieldTag::__filter),
                            "deadLetterPolicy" => Ok(__FieldTag::__dead_letter_policy),
                            "dead_letter_policy" => Ok(__FieldTag::__dead_letter_policy),
                            "retryPolicy" => Ok(__FieldTag::__retry_policy),
                            "retry_policy" => Ok(__FieldTag::__retry_policy),
                            "detached" => Ok(__FieldTag::__detached),
                            "enableExactlyOnceDelivery" => {
                                Ok(__FieldTag::__enable_exactly_once_delivery)
                            }
                            "enable_exactly_once_delivery" => {
                                Ok(__FieldTag::__enable_exactly_once_delivery)
                            }
                            "topicMessageRetentionDuration" => {
                                Ok(__FieldTag::__topic_message_retention_duration)
                            }
                            "topic_message_retention_duration" => {
                                Ok(__FieldTag::__topic_message_retention_duration)
                            }
                            "state" => Ok(__FieldTag::__state),
                            "analyticsHubSubscriptionInfo" => {
                                Ok(__FieldTag::__analytics_hub_subscription_info)
                            }
                            "analytics_hub_subscription_info" => {
                                Ok(__FieldTag::__analytics_hub_subscription_info)
                            }
                            "messageTransforms" => Ok(__FieldTag::__message_transforms),
                            "message_transforms" => Ok(__FieldTag::__message_transforms),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Subscription;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Subscription")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__topic => {
                            if !fields.insert(__FieldTag::__topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic",
                                ));
                            }
                            result.topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__push_config => {
                            if !fields.insert(__FieldTag::__push_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push_config",
                                ));
                            }
                            result.push_config =
                                map.next_value::<std::option::Option<crate::model::PushConfig>>()?;
                        }
                        __FieldTag::__bigquery_config => {
                            if !fields.insert(__FieldTag::__bigquery_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_config",
                                ));
                            }
                            result.bigquery_config = map
                                .next_value::<std::option::Option<crate::model::BigQueryConfig>>(
                                )?;
                        }
                        __FieldTag::__cloud_storage_config => {
                            if !fields.insert(__FieldTag::__cloud_storage_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_storage_config",
                                ));
                            }
                            result.cloud_storage_config = map.next_value::<std::option::Option<crate::model::CloudStorageConfig>>()?
                                ;
                        }
                        __FieldTag::__ack_deadline_seconds => {
                            if !fields.insert(__FieldTag::__ack_deadline_seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ack_deadline_seconds",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ack_deadline_seconds =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__retain_acked_messages => {
                            if !fields.insert(__FieldTag::__retain_acked_messages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retain_acked_messages",
                                ));
                            }
                            result.retain_acked_messages = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message_retention_duration => {
                            if !fields.insert(__FieldTag::__message_retention_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_retention_duration",
                                ));
                            }
                            result.message_retention_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_message_ordering => {
                            if !fields.insert(__FieldTag::__enable_message_ordering) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_message_ordering",
                                ));
                            }
                            result.enable_message_ordering = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expiration_policy => {
                            if !fields.insert(__FieldTag::__expiration_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_policy",
                                ));
                            }
                            result.expiration_policy = map
                                .next_value::<std::option::Option<crate::model::ExpirationPolicy>>(
                                )?;
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dead_letter_policy => {
                            if !fields.insert(__FieldTag::__dead_letter_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dead_letter_policy",
                                ));
                            }
                            result.dead_letter_policy = map
                                .next_value::<std::option::Option<crate::model::DeadLetterPolicy>>(
                                )?;
                        }
                        __FieldTag::__retry_policy => {
                            if !fields.insert(__FieldTag::__retry_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retry_policy",
                                ));
                            }
                            result.retry_policy =
                                map.next_value::<std::option::Option<crate::model::RetryPolicy>>()?;
                        }
                        __FieldTag::__detached => {
                            if !fields.insert(__FieldTag::__detached) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detached",
                                ));
                            }
                            result.detached = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_exactly_once_delivery => {
                            if !fields.insert(__FieldTag::__enable_exactly_once_delivery) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_exactly_once_delivery",
                                ));
                            }
                            result.enable_exactly_once_delivery = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__topic_message_retention_duration => {
                            if !fields.insert(__FieldTag::__topic_message_retention_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic_message_retention_duration",
                                ));
                            }
                            result.topic_message_retention_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::subscription::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__analytics_hub_subscription_info => {
                            if !fields.insert(__FieldTag::__analytics_hub_subscription_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analytics_hub_subscription_info",
                                ));
                            }
                            result.analytics_hub_subscription_info = map
                                .next_value::<std::option::Option<
                                    crate::model::subscription::AnalyticsHubSubscriptionInfo,
                                >>()?;
                        }
                        __FieldTag::__message_transforms => {
                            if !fields.insert(__FieldTag::__message_transforms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_transforms",
                                ));
                            }
                            result.message_transforms =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::MessageTransform>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Subscription {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.topic.is_empty() {
            state.serialize_entry("topic", &self.topic)?;
        }
        if self.push_config.is_some() {
            state.serialize_entry("pushConfig", &self.push_config)?;
        }
        if self.bigquery_config.is_some() {
            state.serialize_entry("bigqueryConfig", &self.bigquery_config)?;
        }
        if self.cloud_storage_config.is_some() {
            state.serialize_entry("cloudStorageConfig", &self.cloud_storage_config)?;
        }
        if !wkt::internal::is_default(&self.ack_deadline_seconds) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ackDeadlineSeconds", &__With(&self.ack_deadline_seconds))?;
        }
        if !wkt::internal::is_default(&self.retain_acked_messages) {
            state.serialize_entry("retainAckedMessages", &self.retain_acked_messages)?;
        }
        if self.message_retention_duration.is_some() {
            state.serialize_entry("messageRetentionDuration", &self.message_retention_duration)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.enable_message_ordering) {
            state.serialize_entry("enableMessageOrdering", &self.enable_message_ordering)?;
        }
        if self.expiration_policy.is_some() {
            state.serialize_entry("expirationPolicy", &self.expiration_policy)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.dead_letter_policy.is_some() {
            state.serialize_entry("deadLetterPolicy", &self.dead_letter_policy)?;
        }
        if self.retry_policy.is_some() {
            state.serialize_entry("retryPolicy", &self.retry_policy)?;
        }
        if !wkt::internal::is_default(&self.detached) {
            state.serialize_entry("detached", &self.detached)?;
        }
        if !wkt::internal::is_default(&self.enable_exactly_once_delivery) {
            state.serialize_entry(
                "enableExactlyOnceDelivery",
                &self.enable_exactly_once_delivery,
            )?;
        }
        if self.topic_message_retention_duration.is_some() {
            state.serialize_entry(
                "topicMessageRetentionDuration",
                &self.topic_message_retention_duration,
            )?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.analytics_hub_subscription_info.is_some() {
            state.serialize_entry(
                "analyticsHubSubscriptionInfo",
                &self.analytics_hub_subscription_info,
            )?;
        }
        if !self.message_transforms.is_empty() {
            state.serialize_entry("messageTransforms", &self.message_transforms)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Subscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Subscription");
        debug_struct.field("name", &self.name);
        debug_struct.field("topic", &self.topic);
        debug_struct.field("push_config", &self.push_config);
        debug_struct.field("bigquery_config", &self.bigquery_config);
        debug_struct.field("cloud_storage_config", &self.cloud_storage_config);
        debug_struct.field("ack_deadline_seconds", &self.ack_deadline_seconds);
        debug_struct.field("retain_acked_messages", &self.retain_acked_messages);
        debug_struct.field(
            "message_retention_duration",
            &self.message_retention_duration,
        );
        debug_struct.field("labels", &self.labels);
        debug_struct.field("enable_message_ordering", &self.enable_message_ordering);
        debug_struct.field("expiration_policy", &self.expiration_policy);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("dead_letter_policy", &self.dead_letter_policy);
        debug_struct.field("retry_policy", &self.retry_policy);
        debug_struct.field("detached", &self.detached);
        debug_struct.field(
            "enable_exactly_once_delivery",
            &self.enable_exactly_once_delivery,
        );
        debug_struct.field(
            "topic_message_retention_duration",
            &self.topic_message_retention_duration,
        );
        debug_struct.field("state", &self.state);
        debug_struct.field(
            "analytics_hub_subscription_info",
            &self.analytics_hub_subscription_info,
        );
        debug_struct.field("message_transforms", &self.message_transforms);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Subscription].
pub mod subscription {
    #[allow(unused_imports)]
    use super::*;

    /// Information about an associated [Analytics Hub
    /// subscription](https://cloud.google.com/bigquery/docs/analytics-hub-manage-subscriptions).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AnalyticsHubSubscriptionInfo {
        /// Optional. The name of the associated Analytics Hub listing resource.
        /// Pattern:
        /// "projects/{project}/locations/{location}/dataExchanges/{data_exchange}/listings/{listing}"
        pub listing: std::string::String,

        /// Optional. The name of the associated Analytics Hub subscription resource.
        /// Pattern:
        /// "projects/{project}/locations/{location}/subscriptions/{subscription}"
        pub subscription: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AnalyticsHubSubscriptionInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [listing][crate::model::subscription::AnalyticsHubSubscriptionInfo::listing].
        pub fn set_listing<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.listing = v.into();
            self
        }

        /// Sets the value of [subscription][crate::model::subscription::AnalyticsHubSubscriptionInfo::subscription].
        pub fn set_subscription<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.subscription = v.into();
            self
        }
    }

    impl wkt::message::Message for AnalyticsHubSubscriptionInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.Subscription.AnalyticsHubSubscriptionInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AnalyticsHubSubscriptionInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __listing,
                __subscription,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AnalyticsHubSubscriptionInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "listing" => Ok(__FieldTag::__listing),
                                "subscription" => Ok(__FieldTag::__subscription),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AnalyticsHubSubscriptionInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AnalyticsHubSubscriptionInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__listing => {
                                if !fields.insert(__FieldTag::__listing) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for listing",
                                    ));
                                }
                                result.listing = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__subscription => {
                                if !fields.insert(__FieldTag::__subscription) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for subscription",
                                    ));
                                }
                                result.subscription = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AnalyticsHubSubscriptionInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.listing.is_empty() {
                state.serialize_entry("listing", &self.listing)?;
            }
            if !self.subscription.is_empty() {
                state.serialize_entry("subscription", &self.subscription)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AnalyticsHubSubscriptionInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AnalyticsHubSubscriptionInfo");
            debug_struct.field("listing", &self.listing);
            debug_struct.field("subscription", &self.subscription);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Possible states for a subscription.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// The subscription can actively receive messages
        Active,
        /// The subscription cannot receive messages because of an error with the
        /// resource to which it pushes messages. See the more detailed error state
        /// in the corresponding configuration.
        ResourceError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::ResourceError => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::ResourceError => std::option::Option::Some("RESOURCE_ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::ResourceError,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "RESOURCE_ERROR" => Self::ResourceError,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::ResourceError => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.pubsub.v1.Subscription.State",
            ))
        }
    }
}

/// A policy that specifies how Pub/Sub retries message delivery.
///
/// Retry delay will be exponential based on provided minimum and maximum
/// backoffs. <https://en.wikipedia.org/wiki/Exponential_backoff>.
///
/// RetryPolicy will be triggered on NACKs or acknowledgment deadline exceeded
/// events for a given message.
///
/// Retry Policy is implemented on a best effort basis. At times, the delay
/// between consecutive deliveries may not match the configuration. That is,
/// delay can be more or less than configured backoff.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RetryPolicy {
    /// Optional. The minimum delay between consecutive deliveries of a given
    /// message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
    pub minimum_backoff: std::option::Option<wkt::Duration>,

    /// Optional. The maximum delay between consecutive deliveries of a given
    /// message. Value should be between 0 and 600 seconds. Defaults to 600
    /// seconds.
    pub maximum_backoff: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetryPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [minimum_backoff][crate::model::RetryPolicy::minimum_backoff].
    pub fn set_minimum_backoff<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.minimum_backoff = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [minimum_backoff][crate::model::RetryPolicy::minimum_backoff].
    pub fn set_or_clear_minimum_backoff<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.minimum_backoff = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maximum_backoff][crate::model::RetryPolicy::maximum_backoff].
    pub fn set_maximum_backoff<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.maximum_backoff = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maximum_backoff][crate::model::RetryPolicy::maximum_backoff].
    pub fn set_or_clear_maximum_backoff<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.maximum_backoff = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RetryPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.RetryPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RetryPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __minimum_backoff,
            __maximum_backoff,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetryPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minimumBackoff" => Ok(__FieldTag::__minimum_backoff),
                            "minimum_backoff" => Ok(__FieldTag::__minimum_backoff),
                            "maximumBackoff" => Ok(__FieldTag::__maximum_backoff),
                            "maximum_backoff" => Ok(__FieldTag::__maximum_backoff),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RetryPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetryPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__minimum_backoff => {
                            if !fields.insert(__FieldTag::__minimum_backoff) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minimum_backoff",
                                ));
                            }
                            result.minimum_backoff =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__maximum_backoff => {
                            if !fields.insert(__FieldTag::__maximum_backoff) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maximum_backoff",
                                ));
                            }
                            result.maximum_backoff =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RetryPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.minimum_backoff.is_some() {
            state.serialize_entry("minimumBackoff", &self.minimum_backoff)?;
        }
        if self.maximum_backoff.is_some() {
            state.serialize_entry("maximumBackoff", &self.maximum_backoff)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RetryPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RetryPolicy");
        debug_struct.field("minimum_backoff", &self.minimum_backoff);
        debug_struct.field("maximum_backoff", &self.maximum_backoff);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Dead lettering is done on a best effort basis. The same message might be
/// dead lettered multiple times.
///
/// If validation on any of the fields fails at subscription creation/updation,
/// the create/update subscription request will fail.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeadLetterPolicy {
    /// Optional. The name of the topic to which dead letter messages should be
    /// published. Format is `projects/{project}/topics/{topic}`.The Pub/Sub
    /// service account associated with the enclosing subscription's parent project
    /// (i.e., service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must
    /// have permission to Publish() to this topic.
    ///
    /// The operation will fail if the topic does not exist.
    /// Users should ensure that there is a subscription attached to this topic
    /// since messages published to a topic with no subscriptions are lost.
    pub dead_letter_topic: std::string::String,

    /// Optional. The maximum number of delivery attempts for any message. The
    /// value must be between 5 and 100.
    ///
    /// The number of delivery attempts is defined as 1 + (the sum of number of
    /// NACKs and number of times the acknowledgment deadline has been exceeded
    /// for the message).
    ///
    /// A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
    /// client libraries may automatically extend ack_deadlines.
    ///
    /// This field will be honored on a best effort basis.
    ///
    /// If this parameter is 0, a default value of 5 is used.
    pub max_delivery_attempts: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeadLetterPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dead_letter_topic][crate::model::DeadLetterPolicy::dead_letter_topic].
    pub fn set_dead_letter_topic<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dead_letter_topic = v.into();
        self
    }

    /// Sets the value of [max_delivery_attempts][crate::model::DeadLetterPolicy::max_delivery_attempts].
    pub fn set_max_delivery_attempts<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_delivery_attempts = v.into();
        self
    }
}

impl wkt::message::Message for DeadLetterPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DeadLetterPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeadLetterPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dead_letter_topic,
            __max_delivery_attempts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeadLetterPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deadLetterTopic" => Ok(__FieldTag::__dead_letter_topic),
                            "dead_letter_topic" => Ok(__FieldTag::__dead_letter_topic),
                            "maxDeliveryAttempts" => Ok(__FieldTag::__max_delivery_attempts),
                            "max_delivery_attempts" => Ok(__FieldTag::__max_delivery_attempts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeadLetterPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeadLetterPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dead_letter_topic => {
                            if !fields.insert(__FieldTag::__dead_letter_topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dead_letter_topic",
                                ));
                            }
                            result.dead_letter_topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_delivery_attempts => {
                            if !fields.insert(__FieldTag::__max_delivery_attempts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_delivery_attempts",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_delivery_attempts =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeadLetterPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dead_letter_topic.is_empty() {
            state.serialize_entry("deadLetterTopic", &self.dead_letter_topic)?;
        }
        if !wkt::internal::is_default(&self.max_delivery_attempts) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxDeliveryAttempts", &__With(&self.max_delivery_attempts))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeadLetterPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeadLetterPolicy");
        debug_struct.field("dead_letter_topic", &self.dead_letter_topic);
        debug_struct.field("max_delivery_attempts", &self.max_delivery_attempts);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A policy that specifies the conditions for resource expiration (i.e.,
/// automatic resource deletion).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExpirationPolicy {
    /// Optional. Specifies the "time-to-live" duration for an associated resource.
    /// The resource expires if it is not active for a period of `ttl`. The
    /// definition of "activity" depends on the type of the associated resource.
    /// The minimum and maximum allowed values for `ttl` depend on the type of the
    /// associated resource, as well. If `ttl` is not set, the associated resource
    /// never expires.
    pub ttl: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExpirationPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ttl][crate::model::ExpirationPolicy::ttl].
    pub fn set_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ttl][crate::model::ExpirationPolicy::ttl].
    pub fn set_or_clear_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExpirationPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ExpirationPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExpirationPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ttl,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExpirationPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ttl" => Ok(__FieldTag::__ttl),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExpirationPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExpirationPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ttl => {
                            if !fields.insert(__FieldTag::__ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl",
                                ));
                            }
                            result.ttl = map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExpirationPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ttl.is_some() {
            state.serialize_entry("ttl", &self.ttl)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExpirationPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExpirationPolicy");
        debug_struct.field("ttl", &self.ttl);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for a push delivery endpoint.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PushConfig {
    /// Optional. A URL locating the endpoint to which messages should be pushed.
    /// For example, a Webhook endpoint might use `<https://example.com/push>`.
    pub push_endpoint: std::string::String,

    /// Optional. Endpoint configuration attributes that can be used to control
    /// different aspects of the message delivery.
    ///
    /// The only currently supported attribute is `x-goog-version`, which you can
    /// use to change the format of the pushed message. This attribute
    /// indicates the version of the data expected by the endpoint. This
    /// controls the shape of the pushed message (i.e., its fields and metadata).
    ///
    /// If not present during the `CreateSubscription` call, it will default to
    /// the version of the Pub/Sub API used to make such call. If not present in a
    /// `ModifyPushConfig` call, its value will not be changed. `GetSubscription`
    /// calls will always return a valid version, even if the subscription was
    /// created without this attribute.
    ///
    /// The only supported values for the `x-goog-version` attribute are:
    ///
    /// * `v1beta1`: uses the push format defined in the v1beta1 Pub/Sub API.
    /// * `v1` or `v1beta2`: uses the push format defined in the v1 Pub/Sub API.
    ///
    /// For example:
    /// `attributes { "x-goog-version": "v1" }`
    pub attributes: std::collections::HashMap<std::string::String, std::string::String>,

    /// An authentication method used by push endpoints to verify the source of
    /// push requests. This can be used with push endpoints that are private by
    /// default to allow requests only from the Pub/Sub system, for example.
    /// This field is optional and should be set only by users interested in
    /// authenticated push.
    pub authentication_method: std::option::Option<crate::model::push_config::AuthenticationMethod>,

    /// The format of the delivered message to the push endpoint is defined by
    /// the chosen wrapper. When unset, `PubsubWrapper` is used.
    pub wrapper: std::option::Option<crate::model::push_config::Wrapper>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PushConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [push_endpoint][crate::model::PushConfig::push_endpoint].
    pub fn set_push_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.push_endpoint = v.into();
        self
    }

    /// Sets the value of [attributes][crate::model::PushConfig::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [authentication_method][crate::model::PushConfig::authentication_method].
    ///
    /// Note that all the setters affecting `authentication_method` are mutually
    /// exclusive.
    pub fn set_authentication_method<
        T: std::convert::Into<std::option::Option<crate::model::push_config::AuthenticationMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = v.into();
        self
    }

    /// The value of [authentication_method][crate::model::PushConfig::authentication_method]
    /// if it holds a `OidcToken`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oidc_token(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::push_config::OidcToken>> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::push_config::AuthenticationMethod::OidcToken(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::PushConfig::authentication_method]
    /// to hold a `OidcToken`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    pub fn set_oidc_token<
        T: std::convert::Into<std::boxed::Box<crate::model::push_config::OidcToken>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::push_config::AuthenticationMethod::OidcToken(v.into()),
        );
        self
    }

    /// Sets the value of [wrapper][crate::model::PushConfig::wrapper].
    ///
    /// Note that all the setters affecting `wrapper` are mutually
    /// exclusive.
    pub fn set_wrapper<
        T: std::convert::Into<std::option::Option<crate::model::push_config::Wrapper>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.wrapper = v.into();
        self
    }

    /// The value of [wrapper][crate::model::PushConfig::wrapper]
    /// if it holds a `PubsubWrapper`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pubsub_wrapper(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::push_config::PubsubWrapper>> {
        #[allow(unreachable_patterns)]
        self.wrapper.as_ref().and_then(|v| match v {
            crate::model::push_config::Wrapper::PubsubWrapper(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [wrapper][crate::model::PushConfig::wrapper]
    /// to hold a `PubsubWrapper`.
    ///
    /// Note that all the setters affecting `wrapper` are
    /// mutually exclusive.
    pub fn set_pubsub_wrapper<
        T: std::convert::Into<std::boxed::Box<crate::model::push_config::PubsubWrapper>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.wrapper =
            std::option::Option::Some(crate::model::push_config::Wrapper::PubsubWrapper(v.into()));
        self
    }

    /// The value of [wrapper][crate::model::PushConfig::wrapper]
    /// if it holds a `NoWrapper`, `None` if the field is not set or
    /// holds a different branch.
    pub fn no_wrapper(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::push_config::NoWrapper>> {
        #[allow(unreachable_patterns)]
        self.wrapper.as_ref().and_then(|v| match v {
            crate::model::push_config::Wrapper::NoWrapper(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [wrapper][crate::model::PushConfig::wrapper]
    /// to hold a `NoWrapper`.
    ///
    /// Note that all the setters affecting `wrapper` are
    /// mutually exclusive.
    pub fn set_no_wrapper<
        T: std::convert::Into<std::boxed::Box<crate::model::push_config::NoWrapper>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.wrapper =
            std::option::Option::Some(crate::model::push_config::Wrapper::NoWrapper(v.into()));
        self
    }
}

impl wkt::message::Message for PushConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.PushConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PushConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __push_endpoint,
            __attributes,
            __oidc_token,
            __pubsub_wrapper,
            __no_wrapper,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PushConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pushEndpoint" => Ok(__FieldTag::__push_endpoint),
                            "push_endpoint" => Ok(__FieldTag::__push_endpoint),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "oidcToken" => Ok(__FieldTag::__oidc_token),
                            "oidc_token" => Ok(__FieldTag::__oidc_token),
                            "pubsubWrapper" => Ok(__FieldTag::__pubsub_wrapper),
                            "pubsub_wrapper" => Ok(__FieldTag::__pubsub_wrapper),
                            "noWrapper" => Ok(__FieldTag::__no_wrapper),
                            "no_wrapper" => Ok(__FieldTag::__no_wrapper),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PushConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PushConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__push_endpoint => {
                            if !fields.insert(__FieldTag::__push_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push_endpoint",
                                ));
                            }
                            result.push_endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oidc_token => {
                            if !fields.insert(__FieldTag::__oidc_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oidc_token",
                                ));
                            }
                            if result.authentication_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `authentication_method`, a oneof with full ID .google.pubsub.v1.PushConfig.oidc_token, latest field was oidcToken",
                                ));
                            }
                            result.authentication_method = std::option::Option::Some(
                                crate::model::push_config::AuthenticationMethod::OidcToken(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::push_config::OidcToken>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__pubsub_wrapper => {
                            if !fields.insert(__FieldTag::__pubsub_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pubsub_wrapper",
                                ));
                            }
                            if result.wrapper.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `wrapper`, a oneof with full ID .google.pubsub.v1.PushConfig.pubsub_wrapper, latest field was pubsubWrapper",
                                ));
                            }
                            result.wrapper = std::option::Option::Some(
                                crate::model::push_config::Wrapper::PubsubWrapper(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::push_config::PubsubWrapper>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__no_wrapper => {
                            if !fields.insert(__FieldTag::__no_wrapper) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for no_wrapper",
                                ));
                            }
                            if result.wrapper.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `wrapper`, a oneof with full ID .google.pubsub.v1.PushConfig.no_wrapper, latest field was noWrapper",
                                ));
                            }
                            result.wrapper = std::option::Option::Some(
                                crate::model::push_config::Wrapper::NoWrapper(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::push_config::NoWrapper>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PushConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.push_endpoint.is_empty() {
            state.serialize_entry("pushEndpoint", &self.push_endpoint)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if let Some(value) = self.oidc_token() {
            state.serialize_entry("oidcToken", value)?;
        }
        if let Some(value) = self.pubsub_wrapper() {
            state.serialize_entry("pubsubWrapper", value)?;
        }
        if let Some(value) = self.no_wrapper() {
            state.serialize_entry("noWrapper", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PushConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PushConfig");
        debug_struct.field("push_endpoint", &self.push_endpoint);
        debug_struct.field("attributes", &self.attributes);
        debug_struct.field("authentication_method", &self.authentication_method);
        debug_struct.field("wrapper", &self.wrapper);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PushConfig].
pub mod push_config {
    #[allow(unused_imports)]
    use super::*;

    /// Contains information needed for generating an
    /// [OpenID Connect
    /// token](https://developers.google.com/identity/protocols/OpenIDConnect).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OidcToken {
        /// Optional. [Service account
        /// email](https://cloud.google.com/iam/docs/service-accounts)
        /// used for generating the OIDC token. For more information
        /// on setting up authentication, see
        /// [Push subscriptions](https://cloud.google.com/pubsub/docs/push).
        pub service_account_email: std::string::String,

        /// Optional. Audience to be used when generating OIDC token. The audience
        /// claim identifies the recipients that the JWT is intended for. The
        /// audience value is a single case-sensitive string. Having multiple values
        /// (array) for the audience field is not supported. More info about the OIDC
        /// JWT token audience here:
        /// <https://tools.ietf.org/html/rfc7519#section-4.1.3> Note: if not specified,
        /// the Push endpoint URL will be used.
        pub audience: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OidcToken {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service_account_email][crate::model::push_config::OidcToken::service_account_email].
        pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_account_email = v.into();
            self
        }

        /// Sets the value of [audience][crate::model::push_config::OidcToken::audience].
        pub fn set_audience<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.audience = v.into();
            self
        }
    }

    impl wkt::message::Message for OidcToken {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.PushConfig.OidcToken"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for OidcToken {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __service_account_email,
                __audience,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for OidcToken")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "serviceAccountEmail" => Ok(__FieldTag::__service_account_email),
                                "service_account_email" => Ok(__FieldTag::__service_account_email),
                                "audience" => Ok(__FieldTag::__audience),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = OidcToken;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct OidcToken")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__service_account_email => {
                                if !fields.insert(__FieldTag::__service_account_email) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_account_email",
                                    ));
                                }
                                result.service_account_email = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__audience => {
                                if !fields.insert(__FieldTag::__audience) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for audience",
                                    ));
                                }
                                result.audience = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for OidcToken {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.service_account_email.is_empty() {
                state.serialize_entry("serviceAccountEmail", &self.service_account_email)?;
            }
            if !self.audience.is_empty() {
                state.serialize_entry("audience", &self.audience)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for OidcToken {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("OidcToken");
            debug_struct.field("service_account_email", &self.service_account_email);
            debug_struct.field("audience", &self.audience);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The payload to the push endpoint is in the form of the JSON representation
    /// of a PubsubMessage
    /// (<https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#pubsubmessage>).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PubsubWrapper {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PubsubWrapper {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for PubsubWrapper {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.PushConfig.PubsubWrapper"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PubsubWrapper {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PubsubWrapper")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PubsubWrapper;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PubsubWrapper")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PubsubWrapper {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PubsubWrapper {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PubsubWrapper");
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Sets the `data` field as the HTTP body for delivery.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NoWrapper {
        /// Optional. When true, writes the Pub/Sub message metadata to
        /// `x-goog-pubsub-<KEY>:<VAL>` headers of the HTTP request. Writes the
        /// Pub/Sub message attributes to `<KEY>:<VAL>` headers of the HTTP request.
        pub write_metadata: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NoWrapper {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [write_metadata][crate::model::push_config::NoWrapper::write_metadata].
        pub fn set_write_metadata<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.write_metadata = v.into();
            self
        }
    }

    impl wkt::message::Message for NoWrapper {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.PushConfig.NoWrapper"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NoWrapper {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __write_metadata,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NoWrapper")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "writeMetadata" => Ok(__FieldTag::__write_metadata),
                                "write_metadata" => Ok(__FieldTag::__write_metadata),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NoWrapper;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NoWrapper")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__write_metadata => {
                                if !fields.insert(__FieldTag::__write_metadata) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for write_metadata",
                                    ));
                                }
                                result.write_metadata = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NoWrapper {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.write_metadata) {
                state.serialize_entry("writeMetadata", &self.write_metadata)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for NoWrapper {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("NoWrapper");
            debug_struct.field("write_metadata", &self.write_metadata);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// An authentication method used by push endpoints to verify the source of
    /// push requests. This can be used with push endpoints that are private by
    /// default to allow requests only from the Pub/Sub system, for example.
    /// This field is optional and should be set only by users interested in
    /// authenticated push.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthenticationMethod {
        /// Optional. If specified, Pub/Sub will generate and attach an OIDC JWT
        /// token as an `Authorization` header in the HTTP request for every pushed
        /// message.
        OidcToken(std::boxed::Box<crate::model::push_config::OidcToken>),
    }

    /// The format of the delivered message to the push endpoint is defined by
    /// the chosen wrapper. When unset, `PubsubWrapper` is used.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Wrapper {
        /// Optional. When set, the payload to the push endpoint is in the form of
        /// the JSON representation of a PubsubMessage
        /// (<https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#pubsubmessage>).
        PubsubWrapper(std::boxed::Box<crate::model::push_config::PubsubWrapper>),
        /// Optional. When set, the payload to the push endpoint is not wrapped.
        NoWrapper(std::boxed::Box<crate::model::push_config::NoWrapper>),
    }
}

/// Configuration for a BigQuery subscription.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryConfig {
    /// Optional. The name of the table to which to write data, of the form
    /// {projectId}.{datasetId}.{tableId}
    pub table: std::string::String,

    /// Optional. When true, use the topic's schema as the columns to write to in
    /// BigQuery, if it exists. `use_topic_schema` and `use_table_schema` cannot be
    /// enabled at the same time.
    pub use_topic_schema: bool,

    /// Optional. When true, write the subscription name, message_id, publish_time,
    /// attributes, and ordering_key to additional columns in the table. The
    /// subscription name, message_id, and publish_time fields are put in their own
    /// columns while all other message properties (other than data) are written to
    /// a JSON object in the attributes column.
    pub write_metadata: bool,

    /// Optional. When true and use_topic_schema is true, any fields that are a
    /// part of the topic schema that are not part of the BigQuery table schema are
    /// dropped when writing to BigQuery. Otherwise, the schemas must be kept in
    /// sync and any messages with extra fields are not written and remain in the
    /// subscription's backlog.
    pub drop_unknown_fields: bool,

    /// Output only. An output-only field that indicates whether or not the
    /// subscription can receive messages.
    pub state: crate::model::big_query_config::State,

    /// Optional. When true, use the BigQuery table's schema as the columns to
    /// write to in BigQuery. `use_table_schema` and `use_topic_schema` cannot be
    /// enabled at the same time.
    pub use_table_schema: bool,

    /// Optional. The service account to use to write to BigQuery. The subscription
    /// creator or updater that specifies this field must have
    /// `iam.serviceAccounts.actAs` permission on the service account. If not
    /// specified, the Pub/Sub [service
    /// agent](https://cloud.google.com/iam/docs/service-agents),
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
    pub service_account_email: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::BigQueryConfig::table].
    pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [use_topic_schema][crate::model::BigQueryConfig::use_topic_schema].
    pub fn set_use_topic_schema<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_topic_schema = v.into();
        self
    }

    /// Sets the value of [write_metadata][crate::model::BigQueryConfig::write_metadata].
    pub fn set_write_metadata<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.write_metadata = v.into();
        self
    }

    /// Sets the value of [drop_unknown_fields][crate::model::BigQueryConfig::drop_unknown_fields].
    pub fn set_drop_unknown_fields<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.drop_unknown_fields = v.into();
        self
    }

    /// Sets the value of [state][crate::model::BigQueryConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::big_query_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [use_table_schema][crate::model::BigQueryConfig::use_table_schema].
    pub fn set_use_table_schema<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_table_schema = v.into();
        self
    }

    /// Sets the value of [service_account_email][crate::model::BigQueryConfig::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.BigQueryConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table,
            __use_topic_schema,
            __write_metadata,
            __drop_unknown_fields,
            __state,
            __use_table_schema,
            __service_account_email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "table" => Ok(__FieldTag::__table),
                            "useTopicSchema" => Ok(__FieldTag::__use_topic_schema),
                            "use_topic_schema" => Ok(__FieldTag::__use_topic_schema),
                            "writeMetadata" => Ok(__FieldTag::__write_metadata),
                            "write_metadata" => Ok(__FieldTag::__write_metadata),
                            "dropUnknownFields" => Ok(__FieldTag::__drop_unknown_fields),
                            "drop_unknown_fields" => Ok(__FieldTag::__drop_unknown_fields),
                            "state" => Ok(__FieldTag::__state),
                            "useTableSchema" => Ok(__FieldTag::__use_table_schema),
                            "use_table_schema" => Ok(__FieldTag::__use_table_schema),
                            "serviceAccountEmail" => Ok(__FieldTag::__service_account_email),
                            "service_account_email" => Ok(__FieldTag::__service_account_email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            result.table = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use_topic_schema => {
                            if !fields.insert(__FieldTag::__use_topic_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_topic_schema",
                                ));
                            }
                            result.use_topic_schema = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__write_metadata => {
                            if !fields.insert(__FieldTag::__write_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_metadata",
                                ));
                            }
                            result.write_metadata = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__drop_unknown_fields => {
                            if !fields.insert(__FieldTag::__drop_unknown_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for drop_unknown_fields",
                                ));
                            }
                            result.drop_unknown_fields = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::big_query_config::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__use_table_schema => {
                            if !fields.insert(__FieldTag::__use_table_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_table_schema",
                                ));
                            }
                            result.use_table_schema = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account_email => {
                            if !fields.insert(__FieldTag::__service_account_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_email",
                                ));
                            }
                            result.service_account_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.table.is_empty() {
            state.serialize_entry("table", &self.table)?;
        }
        if !wkt::internal::is_default(&self.use_topic_schema) {
            state.serialize_entry("useTopicSchema", &self.use_topic_schema)?;
        }
        if !wkt::internal::is_default(&self.write_metadata) {
            state.serialize_entry("writeMetadata", &self.write_metadata)?;
        }
        if !wkt::internal::is_default(&self.drop_unknown_fields) {
            state.serialize_entry("dropUnknownFields", &self.drop_unknown_fields)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.use_table_schema) {
            state.serialize_entry("useTableSchema", &self.use_table_schema)?;
        }
        if !self.service_account_email.is_empty() {
            state.serialize_entry("serviceAccountEmail", &self.service_account_email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BigQueryConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BigQueryConfig");
        debug_struct.field("table", &self.table);
        debug_struct.field("use_topic_schema", &self.use_topic_schema);
        debug_struct.field("write_metadata", &self.write_metadata);
        debug_struct.field("drop_unknown_fields", &self.drop_unknown_fields);
        debug_struct.field("state", &self.state);
        debug_struct.field("use_table_schema", &self.use_table_schema);
        debug_struct.field("service_account_email", &self.service_account_email);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BigQueryConfig].
pub mod big_query_config {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states for a BigQuery subscription.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// The subscription can actively send messages to BigQuery
        Active,
        /// Cannot write to the BigQuery table because of permission denied errors.
        /// This can happen if
        ///
        /// - Pub/Sub SA has not been granted the [appropriate BigQuery IAM
        ///   permissions](https://cloud.google.com/pubsub/docs/create-subscription#assign_bigquery_service_account)
        /// - bigquery.googleapis.com API is not enabled for the project
        ///   ([instructions](https://cloud.google.com/service-usage/docs/enable-disable))
        PermissionDenied,
        /// Cannot write to the BigQuery table because it does not exist.
        NotFound,
        /// Cannot write to the BigQuery table due to a schema mismatch.
        SchemaMismatch,
        /// Cannot write to the destination because enforce_in_transit is set to true
        /// and the destination locations are not in the allowed regions.
        InTransitLocationRestriction,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::PermissionDenied => std::option::Option::Some(2),
                Self::NotFound => std::option::Option::Some(3),
                Self::SchemaMismatch => std::option::Option::Some(4),
                Self::InTransitLocationRestriction => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::NotFound => std::option::Option::Some("NOT_FOUND"),
                Self::SchemaMismatch => std::option::Option::Some("SCHEMA_MISMATCH"),
                Self::InTransitLocationRestriction => {
                    std::option::Option::Some("IN_TRANSIT_LOCATION_RESTRICTION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::PermissionDenied,
                3 => Self::NotFound,
                4 => Self::SchemaMismatch,
                5 => Self::InTransitLocationRestriction,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "PERMISSION_DENIED" => Self::PermissionDenied,
                "NOT_FOUND" => Self::NotFound,
                "SCHEMA_MISMATCH" => Self::SchemaMismatch,
                "IN_TRANSIT_LOCATION_RESTRICTION" => Self::InTransitLocationRestriction,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::PermissionDenied => serializer.serialize_i32(2),
                Self::NotFound => serializer.serialize_i32(3),
                Self::SchemaMismatch => serializer.serialize_i32(4),
                Self::InTransitLocationRestriction => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.pubsub.v1.BigQueryConfig.State",
            ))
        }
    }
}

/// Configuration for a Cloud Storage subscription.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudStorageConfig {
    /// Required. User-provided name for the Cloud Storage bucket.
    /// The bucket must be created by the user. The bucket name must be without
    /// any prefix like "gs://". See the [bucket naming
    /// requirements] (<https://cloud.google.com/storage/docs/buckets#naming>).
    pub bucket: std::string::String,

    /// Optional. User-provided prefix for Cloud Storage filename. See the [object
    /// naming requirements](https://cloud.google.com/storage/docs/objects#naming).
    pub filename_prefix: std::string::String,

    /// Optional. User-provided suffix for Cloud Storage filename. See the [object
    /// naming requirements](https://cloud.google.com/storage/docs/objects#naming).
    /// Must not end in "/".
    pub filename_suffix: std::string::String,

    /// Optional. User-provided format string specifying how to represent datetimes
    /// in Cloud Storage filenames. See the [datetime format
    /// guidance](https://cloud.google.com/pubsub/docs/create-cloudstorage-subscription#file_names).
    pub filename_datetime_format: std::string::String,

    /// Optional. The maximum duration that can elapse before a new Cloud Storage
    /// file is created. Min 1 minute, max 10 minutes, default 5 minutes. May not
    /// exceed the subscription's acknowledgment deadline.
    pub max_duration: std::option::Option<wkt::Duration>,

    /// Optional. The maximum bytes that can be written to a Cloud Storage file
    /// before a new file is created. Min 1 KB, max 10 GiB. The max_bytes limit may
    /// be exceeded in cases where messages are larger than the limit.
    pub max_bytes: i64,

    /// Optional. The maximum number of messages that can be written to a Cloud
    /// Storage file before a new file is created. Min 1000 messages.
    pub max_messages: i64,

    /// Output only. An output-only field that indicates whether or not the
    /// subscription can receive messages.
    pub state: crate::model::cloud_storage_config::State,

    /// Optional. The service account to use to write to Cloud Storage. The
    /// subscription creator or updater that specifies this field must have
    /// `iam.serviceAccounts.actAs` permission on the service account. If not
    /// specified, the Pub/Sub
    /// [service agent](https://cloud.google.com/iam/docs/service-agents),
    /// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
    pub service_account_email: std::string::String,

    /// Defaults to text format.
    pub output_format: std::option::Option<crate::model::cloud_storage_config::OutputFormat>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::CloudStorageConfig::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [filename_prefix][crate::model::CloudStorageConfig::filename_prefix].
    pub fn set_filename_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filename_prefix = v.into();
        self
    }

    /// Sets the value of [filename_suffix][crate::model::CloudStorageConfig::filename_suffix].
    pub fn set_filename_suffix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filename_suffix = v.into();
        self
    }

    /// Sets the value of [filename_datetime_format][crate::model::CloudStorageConfig::filename_datetime_format].
    pub fn set_filename_datetime_format<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.filename_datetime_format = v.into();
        self
    }

    /// Sets the value of [max_duration][crate::model::CloudStorageConfig::max_duration].
    pub fn set_max_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_duration][crate::model::CloudStorageConfig::max_duration].
    pub fn set_or_clear_max_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_bytes][crate::model::CloudStorageConfig::max_bytes].
    pub fn set_max_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_bytes = v.into();
        self
    }

    /// Sets the value of [max_messages][crate::model::CloudStorageConfig::max_messages].
    pub fn set_max_messages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_messages = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CloudStorageConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::cloud_storage_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [service_account_email][crate::model::CloudStorageConfig::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [output_format][crate::model::CloudStorageConfig::output_format].
    ///
    /// Note that all the setters affecting `output_format` are mutually
    /// exclusive.
    pub fn set_output_format<
        T: std::convert::Into<std::option::Option<crate::model::cloud_storage_config::OutputFormat>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_format = v.into();
        self
    }

    /// The value of [output_format][crate::model::CloudStorageConfig::output_format]
    /// if it holds a `TextConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cloud_storage_config::TextConfig>> {
        #[allow(unreachable_patterns)]
        self.output_format.as_ref().and_then(|v| match v {
            crate::model::cloud_storage_config::OutputFormat::TextConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_format][crate::model::CloudStorageConfig::output_format]
    /// to hold a `TextConfig`.
    ///
    /// Note that all the setters affecting `output_format` are
    /// mutually exclusive.
    pub fn set_text_config<
        T: std::convert::Into<std::boxed::Box<crate::model::cloud_storage_config::TextConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_format = std::option::Option::Some(
            crate::model::cloud_storage_config::OutputFormat::TextConfig(v.into()),
        );
        self
    }

    /// The value of [output_format][crate::model::CloudStorageConfig::output_format]
    /// if it holds a `AvroConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn avro_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cloud_storage_config::AvroConfig>> {
        #[allow(unreachable_patterns)]
        self.output_format.as_ref().and_then(|v| match v {
            crate::model::cloud_storage_config::OutputFormat::AvroConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output_format][crate::model::CloudStorageConfig::output_format]
    /// to hold a `AvroConfig`.
    ///
    /// Note that all the setters affecting `output_format` are
    /// mutually exclusive.
    pub fn set_avro_config<
        T: std::convert::Into<std::boxed::Box<crate::model::cloud_storage_config::AvroConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_format = std::option::Option::Some(
            crate::model::cloud_storage_config::OutputFormat::AvroConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloudStorageConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.CloudStorageConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudStorageConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __filename_prefix,
            __filename_suffix,
            __filename_datetime_format,
            __text_config,
            __avro_config,
            __max_duration,
            __max_bytes,
            __max_messages,
            __state,
            __service_account_email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudStorageConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "filenamePrefix" => Ok(__FieldTag::__filename_prefix),
                            "filename_prefix" => Ok(__FieldTag::__filename_prefix),
                            "filenameSuffix" => Ok(__FieldTag::__filename_suffix),
                            "filename_suffix" => Ok(__FieldTag::__filename_suffix),
                            "filenameDatetimeFormat" => Ok(__FieldTag::__filename_datetime_format),
                            "filename_datetime_format" => {
                                Ok(__FieldTag::__filename_datetime_format)
                            }
                            "textConfig" => Ok(__FieldTag::__text_config),
                            "text_config" => Ok(__FieldTag::__text_config),
                            "avroConfig" => Ok(__FieldTag::__avro_config),
                            "avro_config" => Ok(__FieldTag::__avro_config),
                            "maxDuration" => Ok(__FieldTag::__max_duration),
                            "max_duration" => Ok(__FieldTag::__max_duration),
                            "maxBytes" => Ok(__FieldTag::__max_bytes),
                            "max_bytes" => Ok(__FieldTag::__max_bytes),
                            "maxMessages" => Ok(__FieldTag::__max_messages),
                            "max_messages" => Ok(__FieldTag::__max_messages),
                            "state" => Ok(__FieldTag::__state),
                            "serviceAccountEmail" => Ok(__FieldTag::__service_account_email),
                            "service_account_email" => Ok(__FieldTag::__service_account_email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudStorageConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudStorageConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filename_prefix => {
                            if !fields.insert(__FieldTag::__filename_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filename_prefix",
                                ));
                            }
                            result.filename_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filename_suffix => {
                            if !fields.insert(__FieldTag::__filename_suffix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filename_suffix",
                                ));
                            }
                            result.filename_suffix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filename_datetime_format => {
                            if !fields.insert(__FieldTag::__filename_datetime_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filename_datetime_format",
                                ));
                            }
                            result.filename_datetime_format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text_config => {
                            if !fields.insert(__FieldTag::__text_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_config",
                                ));
                            }
                            if result.output_format.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `output_format`, a oneof with full ID .google.pubsub.v1.CloudStorageConfig.text_config, latest field was textConfig",
                                ));
                            }
                            result.output_format = std::option::Option::Some(
                                crate::model::cloud_storage_config::OutputFormat::TextConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::cloud_storage_config::TextConfig,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__avro_config => {
                            if !fields.insert(__FieldTag::__avro_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for avro_config",
                                ));
                            }
                            if result.output_format.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `output_format`, a oneof with full ID .google.pubsub.v1.CloudStorageConfig.avro_config, latest field was avroConfig",
                                ));
                            }
                            result.output_format = std::option::Option::Some(
                                crate::model::cloud_storage_config::OutputFormat::AvroConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::cloud_storage_config::AvroConfig,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__max_duration => {
                            if !fields.insert(__FieldTag::__max_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_duration",
                                ));
                            }
                            result.max_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__max_bytes => {
                            if !fields.insert(__FieldTag::__max_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_messages => {
                            if !fields.insert(__FieldTag::__max_messages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_messages",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_messages = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::cloud_storage_config::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_account_email => {
                            if !fields.insert(__FieldTag::__service_account_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_email",
                                ));
                            }
                            result.service_account_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudStorageConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.filename_prefix.is_empty() {
            state.serialize_entry("filenamePrefix", &self.filename_prefix)?;
        }
        if !self.filename_suffix.is_empty() {
            state.serialize_entry("filenameSuffix", &self.filename_suffix)?;
        }
        if !self.filename_datetime_format.is_empty() {
            state.serialize_entry("filenameDatetimeFormat", &self.filename_datetime_format)?;
        }
        if let Some(value) = self.text_config() {
            state.serialize_entry("textConfig", value)?;
        }
        if let Some(value) = self.avro_config() {
            state.serialize_entry("avroConfig", value)?;
        }
        if self.max_duration.is_some() {
            state.serialize_entry("maxDuration", &self.max_duration)?;
        }
        if !wkt::internal::is_default(&self.max_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxBytes", &__With(&self.max_bytes))?;
        }
        if !wkt::internal::is_default(&self.max_messages) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxMessages", &__With(&self.max_messages))?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.service_account_email.is_empty() {
            state.serialize_entry("serviceAccountEmail", &self.service_account_email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudStorageConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudStorageConfig");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("filename_prefix", &self.filename_prefix);
        debug_struct.field("filename_suffix", &self.filename_suffix);
        debug_struct.field("filename_datetime_format", &self.filename_datetime_format);
        debug_struct.field("max_duration", &self.max_duration);
        debug_struct.field("max_bytes", &self.max_bytes);
        debug_struct.field("max_messages", &self.max_messages);
        debug_struct.field("state", &self.state);
        debug_struct.field("service_account_email", &self.service_account_email);
        debug_struct.field("output_format", &self.output_format);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CloudStorageConfig].
pub mod cloud_storage_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for writing message data in text format.
    /// Message payloads will be written to files as raw text, separated by a
    /// newline.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TextConfig {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TextConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for TextConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.CloudStorageConfig.TextConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TextConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TextConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TextConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TextConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TextConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TextConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TextConfig");
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Configuration for writing message data in Avro format.
    /// Message payloads and metadata will be written to files as an Avro binary.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AvroConfig {
        /// Optional. When true, write the subscription name, message_id,
        /// publish_time, attributes, and ordering_key as additional fields in the
        /// output. The subscription name, message_id, and publish_time fields are
        /// put in their own fields while all other message properties other than
        /// data (for example, an ordering_key, if present) are added as entries in
        /// the attributes map.
        pub write_metadata: bool,

        /// Optional. When true, the output Cloud Storage file will be serialized
        /// using the topic schema, if it exists.
        pub use_topic_schema: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AvroConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [write_metadata][crate::model::cloud_storage_config::AvroConfig::write_metadata].
        pub fn set_write_metadata<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.write_metadata = v.into();
            self
        }

        /// Sets the value of [use_topic_schema][crate::model::cloud_storage_config::AvroConfig::use_topic_schema].
        pub fn set_use_topic_schema<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.use_topic_schema = v.into();
            self
        }
    }

    impl wkt::message::Message for AvroConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.pubsub.v1.CloudStorageConfig.AvroConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AvroConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __write_metadata,
                __use_topic_schema,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AvroConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "writeMetadata" => Ok(__FieldTag::__write_metadata),
                                "write_metadata" => Ok(__FieldTag::__write_metadata),
                                "useTopicSchema" => Ok(__FieldTag::__use_topic_schema),
                                "use_topic_schema" => Ok(__FieldTag::__use_topic_schema),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AvroConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AvroConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__write_metadata => {
                                if !fields.insert(__FieldTag::__write_metadata) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for write_metadata",
                                    ));
                                }
                                result.write_metadata = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__use_topic_schema => {
                                if !fields.insert(__FieldTag::__use_topic_schema) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for use_topic_schema",
                                    ));
                                }
                                result.use_topic_schema = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AvroConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.write_metadata) {
                state.serialize_entry("writeMetadata", &self.write_metadata)?;
            }
            if !wkt::internal::is_default(&self.use_topic_schema) {
                state.serialize_entry("useTopicSchema", &self.use_topic_schema)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AvroConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AvroConfig");
            debug_struct.field("write_metadata", &self.write_metadata);
            debug_struct.field("use_topic_schema", &self.use_topic_schema);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Possible states for a Cloud Storage subscription.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// The subscription can actively send messages to Cloud Storage.
        Active,
        /// Cannot write to the Cloud Storage bucket because of permission denied
        /// errors.
        PermissionDenied,
        /// Cannot write to the Cloud Storage bucket because it does not exist.
        NotFound,
        /// Cannot write to the destination because enforce_in_transit is set to true
        /// and the destination locations are not in the allowed regions.
        InTransitLocationRestriction,
        /// Cannot write to the Cloud Storage bucket due to an incompatibility
        /// between the topic schema and subscription settings.
        SchemaMismatch,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::PermissionDenied => std::option::Option::Some(2),
                Self::NotFound => std::option::Option::Some(3),
                Self::InTransitLocationRestriction => std::option::Option::Some(4),
                Self::SchemaMismatch => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::NotFound => std::option::Option::Some("NOT_FOUND"),
                Self::InTransitLocationRestriction => {
                    std::option::Option::Some("IN_TRANSIT_LOCATION_RESTRICTION")
                }
                Self::SchemaMismatch => std::option::Option::Some("SCHEMA_MISMATCH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::PermissionDenied,
                3 => Self::NotFound,
                4 => Self::InTransitLocationRestriction,
                5 => Self::SchemaMismatch,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "PERMISSION_DENIED" => Self::PermissionDenied,
                "NOT_FOUND" => Self::NotFound,
                "IN_TRANSIT_LOCATION_RESTRICTION" => Self::InTransitLocationRestriction,
                "SCHEMA_MISMATCH" => Self::SchemaMismatch,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::PermissionDenied => serializer.serialize_i32(2),
                Self::NotFound => serializer.serialize_i32(3),
                Self::InTransitLocationRestriction => serializer.serialize_i32(4),
                Self::SchemaMismatch => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.pubsub.v1.CloudStorageConfig.State",
            ))
        }
    }

    /// Defaults to text format.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OutputFormat {
        /// Optional. If set, message data will be written to Cloud Storage in text
        /// format.
        TextConfig(std::boxed::Box<crate::model::cloud_storage_config::TextConfig>),
        /// Optional. If set, message data will be written to Cloud Storage in Avro
        /// format.
        AvroConfig(std::boxed::Box<crate::model::cloud_storage_config::AvroConfig>),
    }
}

/// Request for the GetSubscription method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSubscriptionRequest {
    /// Required. The name of the subscription to get.
    /// Format is `projects/{project}/subscriptions/{sub}`.
    pub subscription: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSubscriptionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::GetSubscriptionRequest::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }
}

impl wkt::message::Message for GetSubscriptionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.GetSubscriptionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSubscriptionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subscription,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSubscriptionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subscription" => Ok(__FieldTag::__subscription),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSubscriptionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSubscriptionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subscription => {
                            if !fields.insert(__FieldTag::__subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscription",
                                ));
                            }
                            result.subscription = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSubscriptionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subscription.is_empty() {
            state.serialize_entry("subscription", &self.subscription)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSubscriptionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSubscriptionRequest");
        debug_struct.field("subscription", &self.subscription);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the UpdateSubscription method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSubscriptionRequest {
    /// Required. The updated subscription object.
    pub subscription: std::option::Option<crate::model::Subscription>,

    /// Required. Indicates which fields in the provided subscription to update.
    /// Must be specified and non-empty.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSubscriptionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::UpdateSubscriptionRequest::subscription].
    pub fn set_subscription<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Subscription>,
    {
        self.subscription = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subscription][crate::model::UpdateSubscriptionRequest::subscription].
    pub fn set_or_clear_subscription<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Subscription>,
    {
        self.subscription = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSubscriptionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSubscriptionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSubscriptionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.UpdateSubscriptionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSubscriptionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subscription,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSubscriptionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subscription" => Ok(__FieldTag::__subscription),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSubscriptionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSubscriptionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subscription => {
                            if !fields.insert(__FieldTag::__subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscription",
                                ));
                            }
                            result.subscription = map
                                .next_value::<std::option::Option<crate::model::Subscription>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSubscriptionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.subscription.is_some() {
            state.serialize_entry("subscription", &self.subscription)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateSubscriptionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSubscriptionRequest");
        debug_struct.field("subscription", &self.subscription);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `ListSubscriptions` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSubscriptionsRequest {
    /// Required. The name of the project in which to list subscriptions.
    /// Format is `projects/{project-id}`.
    pub project: std::string::String,

    /// Optional. Maximum number of subscriptions to return.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListSubscriptionsResponse`;
    /// indicates that this is a continuation of a prior `ListSubscriptions` call,
    /// and that the system should return the next page of data.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSubscriptionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::ListSubscriptionsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSubscriptionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSubscriptionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSubscriptionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSubscriptionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSubscriptionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSubscriptionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "project" => Ok(__FieldTag::__project),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSubscriptionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSubscriptionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSubscriptionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSubscriptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSubscriptionsRequest");
        debug_struct.field("project", &self.project);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for the `ListSubscriptions` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSubscriptionsResponse {
    /// Optional. The subscriptions that match the request.
    pub subscriptions: std::vec::Vec<crate::model::Subscription>,

    /// Optional. If not empty, indicates that there may be more subscriptions that
    /// match the request; this value should be passed in a new
    /// `ListSubscriptionsRequest` to get more subscriptions.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSubscriptionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscriptions][crate::model::ListSubscriptionsResponse::subscriptions].
    pub fn set_subscriptions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Subscription>,
    {
        use std::iter::Iterator;
        self.subscriptions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSubscriptionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSubscriptionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSubscriptionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSubscriptionsResponse {
    type PageItem = crate::model::Subscription;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.subscriptions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSubscriptionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subscriptions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSubscriptionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subscriptions" => Ok(__FieldTag::__subscriptions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSubscriptionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSubscriptionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subscriptions => {
                            if !fields.insert(__FieldTag::__subscriptions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscriptions",
                                ));
                            }
                            result.subscriptions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Subscription>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSubscriptionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subscriptions.is_empty() {
            state.serialize_entry("subscriptions", &self.subscriptions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSubscriptionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSubscriptionsResponse");
        debug_struct.field("subscriptions", &self.subscriptions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the DeleteSubscription method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSubscriptionRequest {
    /// Required. The subscription to delete.
    /// Format is `projects/{project}/subscriptions/{sub}`.
    pub subscription: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSubscriptionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::DeleteSubscriptionRequest::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSubscriptionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DeleteSubscriptionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSubscriptionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subscription,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSubscriptionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subscription" => Ok(__FieldTag::__subscription),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSubscriptionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSubscriptionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subscription => {
                            if !fields.insert(__FieldTag::__subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscription",
                                ));
                            }
                            result.subscription = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSubscriptionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subscription.is_empty() {
            state.serialize_entry("subscription", &self.subscription)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteSubscriptionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSubscriptionRequest");
        debug_struct.field("subscription", &self.subscription);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the ModifyPushConfig method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ModifyPushConfigRequest {
    /// Required. The name of the subscription.
    /// Format is `projects/{project}/subscriptions/{sub}`.
    pub subscription: std::string::String,

    /// Required. The push configuration for future deliveries.
    ///
    /// An empty `pushConfig` indicates that the Pub/Sub system should
    /// stop pushing messages from the given subscription and allow
    /// messages to be pulled and acknowledged - effectively pausing
    /// the subscription if `Pull` or `StreamingPull` is not called.
    pub push_config: std::option::Option<crate::model::PushConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModifyPushConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::ModifyPushConfigRequest::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }

    /// Sets the value of [push_config][crate::model::ModifyPushConfigRequest::push_config].
    pub fn set_push_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PushConfig>,
    {
        self.push_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [push_config][crate::model::ModifyPushConfigRequest::push_config].
    pub fn set_or_clear_push_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PushConfig>,
    {
        self.push_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ModifyPushConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ModifyPushConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ModifyPushConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subscription,
            __push_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModifyPushConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subscription" => Ok(__FieldTag::__subscription),
                            "pushConfig" => Ok(__FieldTag::__push_config),
                            "push_config" => Ok(__FieldTag::__push_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ModifyPushConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModifyPushConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subscription => {
                            if !fields.insert(__FieldTag::__subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscription",
                                ));
                            }
                            result.subscription = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__push_config => {
                            if !fields.insert(__FieldTag::__push_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for push_config",
                                ));
                            }
                            result.push_config =
                                map.next_value::<std::option::Option<crate::model::PushConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ModifyPushConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subscription.is_empty() {
            state.serialize_entry("subscription", &self.subscription)?;
        }
        if self.push_config.is_some() {
            state.serialize_entry("pushConfig", &self.push_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ModifyPushConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ModifyPushConfigRequest");
        debug_struct.field("subscription", &self.subscription);
        debug_struct.field("push_config", &self.push_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `CreateSnapshot` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSnapshotRequest {
    /// Required. User-provided name for this snapshot. If the name is not provided
    /// in the request, the server will assign a random name for this snapshot on
    /// the same project as the subscription. Note that for REST API requests, you
    /// must specify a name.  See the [resource name
    /// rules](https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names).
    /// Format is `projects/{project}/snapshots/{snap}`.
    pub name: std::string::String,

    /// Required. The subscription whose backlog the snapshot retains.
    /// Specifically, the created snapshot is guaranteed to retain:
    /// (a) The existing backlog on the subscription. More precisely, this is
    /// defined as the messages in the subscription's backlog that are
    /// unacknowledged upon the successful completion of the
    /// `CreateSnapshot` request; as well as:
    /// (b) Any messages published to the subscription's topic following the
    /// successful completion of the CreateSnapshot request.
    /// Format is `projects/{project}/subscriptions/{sub}`.
    pub subscription: std::string::String,

    /// Optional. See [Creating and managing
    /// labels](https://cloud.google.com/pubsub/docs/labels).
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CreateSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [subscription][crate::model::CreateSnapshotRequest::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::CreateSnapshotRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CreateSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.CreateSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __subscription,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "subscription" => Ok(__FieldTag::__subscription),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subscription => {
                            if !fields.insert(__FieldTag::__subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscription",
                                ));
                            }
                            result.subscription = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.subscription.is_empty() {
            state.serialize_entry("subscription", &self.subscription)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateSnapshotRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateSnapshotRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("subscription", &self.subscription);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the UpdateSnapshot method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSnapshotRequest {
    /// Required. The updated snapshot object.
    pub snapshot: std::option::Option<crate::model::Snapshot>,

    /// Required. Indicates which fields in the provided snapshot to update.
    /// Must be specified and non-empty.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshot][crate::model::UpdateSnapshotRequest::snapshot].
    pub fn set_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Snapshot>,
    {
        self.snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot][crate::model::UpdateSnapshotRequest::snapshot].
    pub fn set_or_clear_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Snapshot>,
    {
        self.snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSnapshotRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSnapshotRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.UpdateSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snapshot,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snapshot" => Ok(__FieldTag::__snapshot),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snapshot => {
                            if !fields.insert(__FieldTag::__snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot",
                                ));
                            }
                            result.snapshot =
                                map.next_value::<std::option::Option<crate::model::Snapshot>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.snapshot.is_some() {
            state.serialize_entry("snapshot", &self.snapshot)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateSnapshotRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSnapshotRequest");
        debug_struct.field("snapshot", &self.snapshot);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A snapshot resource. Snapshots are used in
/// [Seek](https://cloud.google.com/pubsub/docs/replay-overview)
/// operations, which allow you to manage message acknowledgments in bulk. That
/// is, you can set the acknowledgment state of messages in an existing
/// subscription to the state captured by a snapshot.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Snapshot {
    /// Optional. The name of the snapshot.
    pub name: std::string::String,

    /// Optional. The name of the topic from which this snapshot is retaining
    /// messages.
    pub topic: std::string::String,

    /// Optional. The snapshot is guaranteed to exist up until this time.
    /// A newly-created snapshot expires no later than 7 days from the time of its
    /// creation. Its exact lifetime is determined at creation by the existing
    /// backlog in the source subscription. Specifically, the lifetime of the
    /// snapshot is `7 days - (age of oldest unacked message in the subscription)`.
    /// For example, consider a subscription whose oldest unacked message is 3 days
    /// old. If a snapshot is created from this subscription, the snapshot -- which
    /// will always capture this 3-day-old backlog as long as the snapshot
    /// exists -- will expire in 4 days. The service will refuse to create a
    /// snapshot that would expire in less than 1 hour after creation.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Optional. See [Creating and managing labels]
    /// (<https://cloud.google.com/pubsub/docs/labels>).
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Snapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Snapshot::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [topic][crate::model::Snapshot::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Snapshot::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Snapshot::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Snapshot::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Snapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.Snapshot"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Snapshot {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __topic,
            __expire_time,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Snapshot")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "topic" => Ok(__FieldTag::__topic),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Snapshot;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Snapshot")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__topic => {
                            if !fields.insert(__FieldTag::__topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic",
                                ));
                            }
                            result.topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Snapshot {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.topic.is_empty() {
            state.serialize_entry("topic", &self.topic)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Snapshot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Snapshot");
        debug_struct.field("name", &self.name);
        debug_struct.field("topic", &self.topic);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the GetSnapshot method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSnapshotRequest {
    /// Required. The name of the snapshot to get.
    /// Format is `projects/{project}/snapshots/{snap}`.
    pub snapshot: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshot][crate::model::GetSnapshotRequest::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot = v.into();
        self
    }
}

impl wkt::message::Message for GetSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.GetSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snapshot,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snapshot" => Ok(__FieldTag::__snapshot),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snapshot => {
                            if !fields.insert(__FieldTag::__snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot",
                                ));
                            }
                            result.snapshot = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.snapshot.is_empty() {
            state.serialize_entry("snapshot", &self.snapshot)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSnapshotRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSnapshotRequest");
        debug_struct.field("snapshot", &self.snapshot);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `ListSnapshots` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSnapshotsRequest {
    /// Required. The name of the project in which to list snapshots.
    /// Format is `projects/{project-id}`.
    pub project: std::string::String,

    /// Optional. Maximum number of snapshots to return.
    pub page_size: i32,

    /// Optional. The value returned by the last `ListSnapshotsResponse`; indicates
    /// that this is a continuation of a prior `ListSnapshots` call, and that the
    /// system should return the next page of data.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSnapshotsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::ListSnapshotsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSnapshotsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSnapshotsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSnapshotsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSnapshotsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSnapshotsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSnapshotsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "project" => Ok(__FieldTag::__project),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSnapshotsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSnapshotsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSnapshotsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSnapshotsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSnapshotsRequest");
        debug_struct.field("project", &self.project);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for the `ListSnapshots` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSnapshotsResponse {
    /// Optional. The resulting snapshots.
    pub snapshots: std::vec::Vec<crate::model::Snapshot>,

    /// Optional. If not empty, indicates that there may be more snapshot that
    /// match the request; this value should be passed in a new
    /// `ListSnapshotsRequest`.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSnapshotsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots][crate::model::ListSnapshotsResponse::snapshots].
    pub fn set_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Snapshot>,
    {
        use std::iter::Iterator;
        self.snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSnapshotsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSnapshotsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSnapshotsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSnapshotsResponse {
    type PageItem = crate::model::Snapshot;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.snapshots
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSnapshotsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snapshots,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSnapshotsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snapshots" => Ok(__FieldTag::__snapshots),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSnapshotsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSnapshotsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snapshots => {
                            if !fields.insert(__FieldTag::__snapshots) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshots",
                                ));
                            }
                            result.snapshots = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Snapshot>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSnapshotsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.snapshots.is_empty() {
            state.serialize_entry("snapshots", &self.snapshots)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSnapshotsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSnapshotsResponse");
        debug_struct.field("snapshots", &self.snapshots);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `DeleteSnapshot` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSnapshotRequest {
    /// Required. The name of the snapshot to delete.
    /// Format is `projects/{project}/snapshots/{snap}`.
    pub snapshot: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshot][crate::model::DeleteSnapshotRequest::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DeleteSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snapshot,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snapshot" => Ok(__FieldTag::__snapshot),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snapshot => {
                            if !fields.insert(__FieldTag::__snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot",
                                ));
                            }
                            result.snapshot = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.snapshot.is_empty() {
            state.serialize_entry("snapshot", &self.snapshot)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteSnapshotRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSnapshotRequest");
        debug_struct.field("snapshot", &self.snapshot);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `Seek` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SeekRequest {
    /// Required. The subscription to affect.
    pub subscription: std::string::String,

    pub target: std::option::Option<crate::model::seek_request::Target>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SeekRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription][crate::model::SeekRequest::subscription].
    pub fn set_subscription<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription = v.into();
        self
    }

    /// Sets the value of [target][crate::model::SeekRequest::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::seek_request::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::SeekRequest::target]
    /// if it holds a `Time`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::seek_request::Target::Time(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::SeekRequest::target]
    /// to hold a `Time`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(crate::model::seek_request::Target::Time(v.into()));
        self
    }

    /// The value of [target][crate::model::SeekRequest::target]
    /// if it holds a `Snapshot`, `None` if the field is not set or
    /// holds a different branch.
    pub fn snapshot(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::seek_request::Target::Snapshot(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::SeekRequest::target]
    /// to hold a `Snapshot`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target =
            std::option::Option::Some(crate::model::seek_request::Target::Snapshot(v.into()));
        self
    }
}

impl wkt::message::Message for SeekRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.SeekRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SeekRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subscription,
            __time,
            __snapshot,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SeekRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subscription" => Ok(__FieldTag::__subscription),
                            "time" => Ok(__FieldTag::__time),
                            "snapshot" => Ok(__FieldTag::__snapshot),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SeekRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SeekRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subscription => {
                            if !fields.insert(__FieldTag::__subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscription",
                                ));
                            }
                            result.subscription = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time => {
                            if !fields.insert(__FieldTag::__time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.pubsub.v1.SeekRequest.time, latest field was time",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::seek_request::Target::Time(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__snapshot => {
                            if !fields.insert(__FieldTag::__snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.pubsub.v1.SeekRequest.snapshot, latest field was snapshot",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::seek_request::Target::Snapshot(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SeekRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subscription.is_empty() {
            state.serialize_entry("subscription", &self.subscription)?;
        }
        if let Some(value) = self.time() {
            state.serialize_entry("time", value)?;
        }
        if let Some(value) = self.snapshot() {
            state.serialize_entry("snapshot", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SeekRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SeekRequest");
        debug_struct.field("subscription", &self.subscription);
        debug_struct.field("target", &self.target);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SeekRequest].
pub mod seek_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Target {
        /// Optional. The time to seek to.
        /// Messages retained in the subscription that were published before this
        /// time are marked as acknowledged, and messages retained in the
        /// subscription that were published after this time are marked as
        /// unacknowledged. Note that this operation affects only those messages
        /// retained in the subscription (configured by the combination of
        /// `message_retention_duration` and `retain_acked_messages`). For example,
        /// if `time` corresponds to a point before the message retention
        /// window (or to a point before the system's notion of the subscription
        /// creation time), only retained messages will be marked as unacknowledged,
        /// and already-expunged messages will not be restored.
        Time(std::boxed::Box<wkt::Timestamp>),
        /// Optional. The snapshot to seek to. The snapshot's topic must be the same
        /// as that of the provided subscription. Format is
        /// `projects/{project}/snapshots/{snap}`.
        Snapshot(std::string::String),
    }
}

/// Response for the `Seek` method (this response is empty).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SeekResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SeekResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SeekResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.SeekResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SeekResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SeekResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SeekResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SeekResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SeekResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SeekResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SeekResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A schema resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Schema {
    /// Required. Name of the schema.
    /// Format is `projects/{project}/schemas/{schema}`.
    pub name: std::string::String,

    /// The type of the schema definition.
    pub r#type: crate::model::schema::Type,

    /// The definition of the schema. This should contain a string representing
    /// the full definition of the schema that is a valid schema definition of
    /// the type specified in `type`.
    pub definition: std::string::String,

    /// Output only. Immutable. The revision ID of the schema.
    pub revision_id: std::string::String,

    /// Output only. The timestamp that the revision was created.
    pub revision_create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Schema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Schema::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Schema::type].
    pub fn set_type<T: std::convert::Into<crate::model::schema::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [definition][crate::model::Schema::definition].
    pub fn set_definition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.definition = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::Schema::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [revision_create_time][crate::model::Schema::revision_create_time].
    pub fn set_revision_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.revision_create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [revision_create_time][crate::model::Schema::revision_create_time].
    pub fn set_or_clear_revision_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.revision_create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Schema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.Schema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Schema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __definition,
            __revision_id,
            __revision_create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Schema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "definition" => Ok(__FieldTag::__definition),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            "revisionCreateTime" => Ok(__FieldTag::__revision_create_time),
                            "revision_create_time" => Ok(__FieldTag::__revision_create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Schema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Schema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::schema::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__definition => {
                            if !fields.insert(__FieldTag::__definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for definition",
                                ));
                            }
                            result.definition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_create_time => {
                            if !fields.insert(__FieldTag::__revision_create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_create_time",
                                ));
                            }
                            result.revision_create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Schema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.definition.is_empty() {
            state.serialize_entry("definition", &self.definition)?;
        }
        if !self.revision_id.is_empty() {
            state.serialize_entry("revisionId", &self.revision_id)?;
        }
        if self.revision_create_time.is_some() {
            state.serialize_entry("revisionCreateTime", &self.revision_create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Schema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Schema");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("definition", &self.definition);
        debug_struct.field("revision_id", &self.revision_id);
        debug_struct.field("revision_create_time", &self.revision_create_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Schema].
pub mod schema {
    #[allow(unused_imports)]
    use super::*;

    /// Possible schema definition types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default value. This value is unused.
        Unspecified,
        /// A Protocol Buffer schema definition.
        ProtocolBuffer,
        /// An Avro schema definition.
        Avro,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ProtocolBuffer => std::option::Option::Some(1),
                Self::Avro => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::ProtocolBuffer => std::option::Option::Some("PROTOCOL_BUFFER"),
                Self::Avro => std::option::Option::Some("AVRO"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ProtocolBuffer,
                2 => Self::Avro,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "PROTOCOL_BUFFER" => Self::ProtocolBuffer,
                "AVRO" => Self::Avro,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ProtocolBuffer => serializer.serialize_i32(1),
                Self::Avro => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.pubsub.v1.Schema.Type",
            ))
        }
    }
}

/// Request for the CreateSchema method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSchemaRequest {
    /// Required. The name of the project in which to create the schema.
    /// Format is `projects/{project-id}`.
    pub parent: std::string::String,

    /// Required. The schema object to create.
    ///
    /// This schema's `name` parameter is ignored. The schema object returned
    /// by CreateSchema will have a `name` made using the given `parent` and
    /// `schema_id`.
    pub schema: std::option::Option<crate::model::Schema>,

    /// The ID to use for the schema, which will become the final component of
    /// the schema's resource name.
    ///
    /// See <https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names> for
    /// resource name constraints.
    pub schema_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSchemaRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::CreateSchemaRequest::schema].
    pub fn set_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema][crate::model::CreateSchemaRequest::schema].
    pub fn set_or_clear_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schema_id][crate::model::CreateSchemaRequest::schema_id].
    pub fn set_schema_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.CreateSchemaRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSchemaRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __schema,
            __schema_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSchemaRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "schema" => Ok(__FieldTag::__schema),
                            "schemaId" => Ok(__FieldTag::__schema_id),
                            "schema_id" => Ok(__FieldTag::__schema_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSchemaRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSchemaRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema =
                                map.next_value::<std::option::Option<crate::model::Schema>>()?;
                        }
                        __FieldTag::__schema_id => {
                            if !fields.insert(__FieldTag::__schema_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_id",
                                ));
                            }
                            result.schema_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSchemaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.schema.is_some() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self.schema_id.is_empty() {
            state.serialize_entry("schemaId", &self.schema_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateSchemaRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateSchemaRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("schema", &self.schema);
        debug_struct.field("schema_id", &self.schema_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the GetSchema method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSchemaRequest {
    /// Required. The name of the schema to get.
    /// Format is `projects/{project}/schemas/{schema}`.
    pub name: std::string::String,

    /// The set of fields to return in the response. If not set, returns a Schema
    /// with all fields filled out. Set to `BASIC` to omit the `definition`.
    pub view: crate::model::SchemaView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSchemaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetSchemaRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::SchemaView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.GetSchemaRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSchemaRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSchemaRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSchemaRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSchemaRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::SchemaView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSchemaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSchemaRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSchemaRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `ListSchemas` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemasRequest {
    /// Required. The name of the project in which to list schemas.
    /// Format is `projects/{project-id}`.
    pub parent: std::string::String,

    /// The set of Schema fields to return in the response. If not set, returns
    /// Schemas with `name` and `type`, but not `definition`. Set to `FULL` to
    /// retrieve all fields.
    pub view: crate::model::SchemaView,

    /// Maximum number of schemas to return.
    pub page_size: i32,

    /// The value returned by the last `ListSchemasResponse`; indicates that
    /// this is a continuation of a prior `ListSchemas` call, and that the
    /// system should return the next page of data.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSchemasRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListSchemasRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::SchemaView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSchemasRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSchemasRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSchemasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSchemasRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSchemasRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __view,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSchemasRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "view" => Ok(__FieldTag::__view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSchemasRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSchemasRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::SchemaView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSchemasRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSchemasRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSchemasRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("view", &self.view);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for the `ListSchemas` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemasResponse {
    /// The resulting schemas.
    pub schemas: std::vec::Vec<crate::model::Schema>,

    /// If not empty, indicates that there may be more schemas that match the
    /// request; this value should be passed in a new `ListSchemasRequest`.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schemas][crate::model::ListSchemasResponse::schemas].
    pub fn set_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Schema>,
    {
        use std::iter::Iterator;
        self.schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSchemasResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSchemasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSchemasResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSchemasResponse {
    type PageItem = crate::model::Schema;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.schemas
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSchemasResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schemas,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSchemasResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "schemas" => Ok(__FieldTag::__schemas),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSchemasResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSchemasResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schemas => {
                            if !fields.insert(__FieldTag::__schemas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schemas",
                                ));
                            }
                            result.schemas = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Schema>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSchemasResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.schemas.is_empty() {
            state.serialize_entry("schemas", &self.schemas)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSchemasResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSchemasResponse");
        debug_struct.field("schemas", &self.schemas);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `ListSchemaRevisions` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemaRevisionsRequest {
    /// Required. The name of the schema to list revisions for.
    pub name: std::string::String,

    /// The set of Schema fields to return in the response. If not set, returns
    /// Schemas with `name` and `type`, but not `definition`. Set to `FULL` to
    /// retrieve all fields.
    pub view: crate::model::SchemaView,

    /// The maximum number of revisions to return per page.
    pub page_size: i32,

    /// The page token, received from a previous ListSchemaRevisions call.
    /// Provide this to retrieve the subsequent page.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemaRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListSchemaRevisionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListSchemaRevisionsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::SchemaView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSchemaRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSchemaRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSchemaRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSchemaRevisionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSchemaRevisionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSchemaRevisionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSchemaRevisionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSchemaRevisionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::SchemaView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSchemaRevisionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSchemaRevisionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSchemaRevisionsRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for the `ListSchemaRevisions` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSchemaRevisionsResponse {
    /// The revisions of the schema.
    pub schemas: std::vec::Vec<crate::model::Schema>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is empty, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemaRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schemas][crate::model::ListSchemaRevisionsResponse::schemas].
    pub fn set_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Schema>,
    {
        use std::iter::Iterator;
        self.schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSchemaRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSchemaRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ListSchemaRevisionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSchemaRevisionsResponse {
    type PageItem = crate::model::Schema;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.schemas
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSchemaRevisionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schemas,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSchemaRevisionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "schemas" => Ok(__FieldTag::__schemas),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSchemaRevisionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSchemaRevisionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schemas => {
                            if !fields.insert(__FieldTag::__schemas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schemas",
                                ));
                            }
                            result.schemas = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Schema>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSchemaRevisionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.schemas.is_empty() {
            state.serialize_entry("schemas", &self.schemas)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSchemaRevisionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSchemaRevisionsResponse");
        debug_struct.field("schemas", &self.schemas);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for CommitSchema method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CommitSchemaRequest {
    /// Required. The name of the schema we are revising.
    /// Format is `projects/{project}/schemas/{schema}`.
    pub name: std::string::String,

    /// Required. The schema revision to commit.
    pub schema: std::option::Option<crate::model::Schema>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommitSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CommitSchemaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::CommitSchemaRequest::schema].
    pub fn set_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema][crate::model::CommitSchemaRequest::schema].
    pub fn set_or_clear_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CommitSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.CommitSchemaRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CommitSchemaRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __schema,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommitSchemaRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "schema" => Ok(__FieldTag::__schema),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CommitSchemaRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommitSchemaRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema =
                                map.next_value::<std::option::Option<crate::model::Schema>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CommitSchemaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.schema.is_some() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CommitSchemaRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CommitSchemaRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("schema", &self.schema);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `RollbackSchema` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RollbackSchemaRequest {
    /// Required. The schema being rolled back with revision id.
    pub name: std::string::String,

    /// Required. The revision ID to roll back to.
    /// It must be a revision of the same schema.
    ///
    /// Example: c7cfa2a8
    pub revision_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RollbackSchemaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::RollbackSchemaRequest::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }
}

impl wkt::message::Message for RollbackSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.RollbackSchemaRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RollbackSchemaRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __revision_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RollbackSchemaRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RollbackSchemaRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RollbackSchemaRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RollbackSchemaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.revision_id.is_empty() {
            state.serialize_entry("revisionId", &self.revision_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RollbackSchemaRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RollbackSchemaRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("revision_id", &self.revision_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `DeleteSchemaRevision` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSchemaRevisionRequest {
    /// Required. The name of the schema revision to be deleted, with a revision ID
    /// explicitly included.
    ///
    /// Example: `projects/123/schemas/my-schema@c7cfa2a8`
    pub name: std::string::String,

    /// Optional. This field is deprecated and should not be used for specifying
    /// the revision ID. The revision ID should be specified via the `name`
    /// parameter.
    #[deprecated]
    pub revision_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSchemaRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSchemaRevisionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::DeleteSchemaRevisionRequest::revision_id].
    #[deprecated]
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSchemaRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DeleteSchemaRevisionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSchemaRevisionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __revision_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSchemaRevisionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSchemaRevisionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSchemaRevisionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSchemaRevisionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.revision_id.is_empty() {
            state.serialize_entry("revisionId", &self.revision_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteSchemaRevisionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSchemaRevisionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("revision_id", &self.revision_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `DeleteSchema` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSchemaRequest {
    /// Required. Name of the schema to delete.
    /// Format is `projects/{project}/schemas/{schema}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSchemaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.DeleteSchemaRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSchemaRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSchemaRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSchemaRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSchemaRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSchemaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteSchemaRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSchemaRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `ValidateSchema` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateSchemaRequest {
    /// Required. The name of the project in which to validate schemas.
    /// Format is `projects/{project-id}`.
    pub parent: std::string::String,

    /// Required. The schema object to validate.
    pub schema: std::option::Option<crate::model::Schema>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ValidateSchemaRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::ValidateSchemaRequest::schema].
    pub fn set_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema][crate::model::ValidateSchemaRequest::schema].
    pub fn set_or_clear_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ValidateSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ValidateSchemaRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidateSchemaRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __schema,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidateSchemaRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "schema" => Ok(__FieldTag::__schema),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidateSchemaRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidateSchemaRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema =
                                map.next_value::<std::option::Option<crate::model::Schema>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValidateSchemaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.schema.is_some() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ValidateSchemaRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValidateSchemaRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("schema", &self.schema);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for the `ValidateSchema` method.
/// Empty for now.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateSchemaResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateSchemaResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ValidateSchemaResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ValidateSchemaResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidateSchemaResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidateSchemaResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidateSchemaResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidateSchemaResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValidateSchemaResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ValidateSchemaResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValidateSchemaResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `ValidateMessage` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateMessageRequest {
    /// Required. The name of the project in which to validate schemas.
    /// Format is `projects/{project-id}`.
    pub parent: std::string::String,

    /// Message to validate against the provided `schema_spec`.
    pub message: ::bytes::Bytes,

    /// The encoding expected for messages
    pub encoding: crate::model::Encoding,

    pub schema_spec: std::option::Option<crate::model::validate_message_request::SchemaSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateMessageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ValidateMessageRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [message][crate::model::ValidateMessageRequest::message].
    pub fn set_message<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [encoding][crate::model::ValidateMessageRequest::encoding].
    pub fn set_encoding<T: std::convert::Into<crate::model::Encoding>>(mut self, v: T) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [schema_spec][crate::model::ValidateMessageRequest::schema_spec].
    ///
    /// Note that all the setters affecting `schema_spec` are mutually
    /// exclusive.
    pub fn set_schema_spec<
        T: std::convert::Into<std::option::Option<crate::model::validate_message_request::SchemaSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schema_spec = v.into();
        self
    }

    /// The value of [schema_spec][crate::model::ValidateMessageRequest::schema_spec]
    /// if it holds a `Name`, `None` if the field is not set or
    /// holds a different branch.
    pub fn name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.schema_spec.as_ref().and_then(|v| match v {
            crate::model::validate_message_request::SchemaSpec::Name(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema_spec][crate::model::ValidateMessageRequest::schema_spec]
    /// to hold a `Name`.
    ///
    /// Note that all the setters affecting `schema_spec` are
    /// mutually exclusive.
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_spec = std::option::Option::Some(
            crate::model::validate_message_request::SchemaSpec::Name(v.into()),
        );
        self
    }

    /// The value of [schema_spec][crate::model::ValidateMessageRequest::schema_spec]
    /// if it holds a `Schema`, `None` if the field is not set or
    /// holds a different branch.
    pub fn schema(&self) -> std::option::Option<&std::boxed::Box<crate::model::Schema>> {
        #[allow(unreachable_patterns)]
        self.schema_spec.as_ref().and_then(|v| match v {
            crate::model::validate_message_request::SchemaSpec::Schema(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema_spec][crate::model::ValidateMessageRequest::schema_spec]
    /// to hold a `Schema`.
    ///
    /// Note that all the setters affecting `schema_spec` are
    /// mutually exclusive.
    pub fn set_schema<T: std::convert::Into<std::boxed::Box<crate::model::Schema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema_spec = std::option::Option::Some(
            crate::model::validate_message_request::SchemaSpec::Schema(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ValidateMessageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ValidateMessageRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidateMessageRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __name,
            __schema,
            __message,
            __encoding,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidateMessageRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "name" => Ok(__FieldTag::__name),
                            "schema" => Ok(__FieldTag::__schema),
                            "message" => Ok(__FieldTag::__message),
                            "encoding" => Ok(__FieldTag::__encoding),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidateMessageRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidateMessageRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            if result.schema_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schema_spec`, a oneof with full ID .google.pubsub.v1.ValidateMessageRequest.name, latest field was name",
                                ));
                            }
                            result.schema_spec = std::option::Option::Some(
                                crate::model::validate_message_request::SchemaSpec::Name(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            if result.schema_spec.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schema_spec`, a oneof with full ID .google.pubsub.v1.ValidateMessageRequest.schema, latest field was schema",
                                ));
                            }
                            result.schema_spec =
                                std::option::Option::Some(
                                    crate::model::validate_message_request::SchemaSpec::Schema(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Schema>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.message = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__encoding => {
                            if !fields.insert(__FieldTag::__encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding",
                                ));
                            }
                            result.encoding = map
                                .next_value::<std::option::Option<crate::model::Encoding>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValidateMessageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.name() {
            state.serialize_entry("name", value)?;
        }
        if let Some(value) = self.schema() {
            state.serialize_entry("schema", value)?;
        }
        if !self.message.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("message", &__With(&self.message))?;
        }
        if !wkt::internal::is_default(&self.encoding) {
            state.serialize_entry("encoding", &self.encoding)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ValidateMessageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValidateMessageRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("message", &self.message);
        debug_struct.field("encoding", &self.encoding);
        debug_struct.field("schema_spec", &self.schema_spec);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ValidateMessageRequest].
pub mod validate_message_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SchemaSpec {
        /// Name of the schema against which to validate.
        ///
        /// Format is `projects/{project}/schemas/{schema}`.
        Name(std::string::String),
        /// Ad-hoc schema against which to validate
        Schema(std::boxed::Box<crate::model::Schema>),
    }
}

/// Response for the `ValidateMessage` method.
/// Empty for now.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateMessageResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateMessageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ValidateMessageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.pubsub.v1.ValidateMessageResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidateMessageResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidateMessageResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidateMessageResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidateMessageResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValidateMessageResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ValidateMessageResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValidateMessageResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// View of Schema object fields to be returned by GetSchema and ListSchemas.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SchemaView {
    /// The default / unset value.
    /// The API will default to the BASIC view.
    Unspecified,
    /// Include the name and type of the schema, but not the definition.
    Basic,
    /// Include all Schema object fields.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SchemaView::value] or
    /// [SchemaView::name].
    UnknownValue(schema_view::UnknownValue),
}

#[doc(hidden)]
pub mod schema_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SchemaView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SCHEMA_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SchemaView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SchemaView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SchemaView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(schema_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SchemaView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SCHEMA_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BASIC" => Self::Basic,
            "FULL" => Self::Full,
            _ => Self::UnknownValue(schema_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SchemaView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SchemaView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SchemaView>::new(
            ".google.pubsub.v1.SchemaView",
        ))
    }
}

/// Possible encoding types for messages.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Encoding {
    /// Unspecified
    Unspecified,
    /// JSON encoding
    Json,
    /// Binary encoding, as defined by the schema type. For some schema types,
    /// binary encoding may not be available.
    Binary,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Encoding::value] or
    /// [Encoding::name].
    UnknownValue(encoding::UnknownValue),
}

#[doc(hidden)]
pub mod encoding {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Encoding {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Json => std::option::Option::Some(1),
            Self::Binary => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ENCODING_UNSPECIFIED"),
            Self::Json => std::option::Option::Some("JSON"),
            Self::Binary => std::option::Option::Some("BINARY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Encoding {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Encoding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Encoding {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Json,
            2 => Self::Binary,
            _ => Self::UnknownValue(encoding::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Encoding {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENCODING_UNSPECIFIED" => Self::Unspecified,
            "JSON" => Self::Json,
            "BINARY" => Self::Binary,
            _ => Self::UnknownValue(encoding::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Encoding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Json => serializer.serialize_i32(1),
            Self::Binary => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Encoding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Encoding>::new(
            ".google.pubsub.v1.Encoding",
        ))
    }
}
