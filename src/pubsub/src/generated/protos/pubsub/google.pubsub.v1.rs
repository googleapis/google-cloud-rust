// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "schema::Type", tag = "2")]
    pub r#type: i32,
    #[prost(string, tag = "3")]
    pub definition: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub revision_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub revision_create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Schema`.
pub mod schema {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        ProtocolBuffer = 1,
        Avro = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::ProtocolBuffer => "PROTOCOL_BUFFER",
                Self::Avro => "AVRO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROTOCOL_BUFFER" => Some(Self::ProtocolBuffer),
                "AVRO" => Some(Self::Avro),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Schema {
    const NAME: &'static str = "Schema";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.Schema".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.Schema".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSchemaRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub schema: ::core::option::Option<Schema>,
    #[prost(string, tag = "3")]
    pub schema_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateSchemaRequest {
    const NAME: &'static str = "CreateSchemaRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.CreateSchemaRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.CreateSchemaRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "SchemaView", tag = "2")]
    pub view: i32,
}
impl ::prost::Name for GetSchemaRequest {
    const NAME: &'static str = "GetSchemaRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.GetSchemaRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.GetSchemaRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemasRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(enumeration = "SchemaView", tag = "2")]
    pub view: i32,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListSchemasRequest {
    const NAME: &'static str = "ListSchemasRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ListSchemasRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ListSchemasRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemasResponse {
    #[prost(message, repeated, tag = "1")]
    pub schemas: ::prost::alloc::vec::Vec<Schema>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListSchemasResponse {
    const NAME: &'static str = "ListSchemasResponse";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ListSchemasResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ListSchemasResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemaRevisionsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "SchemaView", tag = "2")]
    pub view: i32,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListSchemaRevisionsRequest {
    const NAME: &'static str = "ListSchemaRevisionsRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ListSchemaRevisionsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ListSchemaRevisionsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemaRevisionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub schemas: ::prost::alloc::vec::Vec<Schema>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListSchemaRevisionsResponse {
    const NAME: &'static str = "ListSchemaRevisionsResponse";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ListSchemaRevisionsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ListSchemaRevisionsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub schema: ::core::option::Option<Schema>,
}
impl ::prost::Name for CommitSchemaRequest {
    const NAME: &'static str = "CommitSchemaRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.CommitSchemaRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.CommitSchemaRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub revision_id: ::prost::alloc::string::String,
}
impl ::prost::Name for RollbackSchemaRequest {
    const NAME: &'static str = "RollbackSchemaRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.RollbackSchemaRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.RollbackSchemaRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSchemaRevisionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "2")]
    pub revision_id: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteSchemaRevisionRequest {
    const NAME: &'static str = "DeleteSchemaRevisionRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.DeleteSchemaRevisionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.DeleteSchemaRevisionRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteSchemaRequest {
    const NAME: &'static str = "DeleteSchemaRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.DeleteSchemaRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.DeleteSchemaRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateSchemaRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub schema: ::core::option::Option<Schema>,
}
impl ::prost::Name for ValidateSchemaRequest {
    const NAME: &'static str = "ValidateSchemaRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ValidateSchemaRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ValidateSchemaRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValidateSchemaResponse {}
impl ::prost::Name for ValidateSchemaResponse {
    const NAME: &'static str = "ValidateSchemaResponse";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ValidateSchemaResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ValidateSchemaResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateMessageRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "4")]
    pub message: ::prost::bytes::Bytes,
    #[prost(enumeration = "Encoding", tag = "5")]
    pub encoding: i32,
    #[prost(oneof = "validate_message_request::SchemaSpec", tags = "2, 3")]
    pub schema_spec: ::core::option::Option<validate_message_request::SchemaSpec>,
}
/// Nested message and enum types in `ValidateMessageRequest`.
pub mod validate_message_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SchemaSpec {
        #[prost(string, tag = "2")]
        Name(::prost::alloc::string::String),
        #[prost(message, tag = "3")]
        Schema(super::Schema),
    }
}
impl ::prost::Name for ValidateMessageRequest {
    const NAME: &'static str = "ValidateMessageRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ValidateMessageRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ValidateMessageRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValidateMessageResponse {}
impl ::prost::Name for ValidateMessageResponse {
    const NAME: &'static str = "ValidateMessageResponse";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ValidateMessageResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ValidateMessageResponse".into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SchemaView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
}
impl SchemaView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SCHEMA_VIEW_UNSPECIFIED",
            Self::Basic => "BASIC",
            Self::Full => "FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCHEMA_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "BASIC" => Some(Self::Basic),
            "FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Encoding {
    Unspecified = 0,
    Json = 1,
    Binary = 2,
}
impl Encoding {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENCODING_UNSPECIFIED",
            Self::Json => "JSON",
            Self::Binary => "BINARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENCODING_UNSPECIFIED" => Some(Self::Unspecified),
            "JSON" => Some(Self::Json),
            "BINARY" => Some(Self::Binary),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageStoragePolicy {
    #[prost(string, repeated, tag = "1")]
    pub allowed_persistence_regions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "2")]
    pub enforce_in_transit: bool,
}
impl ::prost::Name for MessageStoragePolicy {
    const NAME: &'static str = "MessageStoragePolicy";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.MessageStoragePolicy".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.MessageStoragePolicy".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchemaSettings {
    #[prost(string, tag = "1")]
    pub schema: ::prost::alloc::string::String,
    #[prost(enumeration = "Encoding", tag = "2")]
    pub encoding: i32,
    #[prost(string, tag = "3")]
    pub first_revision_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub last_revision_id: ::prost::alloc::string::String,
}
impl ::prost::Name for SchemaSettings {
    const NAME: &'static str = "SchemaSettings";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.SchemaSettings".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.SchemaSettings".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngestionDataSourceSettings {
    #[prost(message, optional, tag = "4")]
    pub platform_logs_settings: ::core::option::Option<PlatformLogsSettings>,
    #[prost(oneof = "ingestion_data_source_settings::Source", tags = "1, 2, 3, 5, 6")]
    pub source: ::core::option::Option<ingestion_data_source_settings::Source>,
}
/// Nested message and enum types in `IngestionDataSourceSettings`.
pub mod ingestion_data_source_settings {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AwsKinesis {
        #[prost(enumeration = "aws_kinesis::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub stream_arn: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub consumer_arn: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub aws_role_arn: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub gcp_service_account: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `AwsKinesis`.
    pub mod aws_kinesis {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Active = 1,
            KinesisPermissionDenied = 2,
            PublishPermissionDenied = 3,
            StreamNotFound = 4,
            ConsumerNotFound = 5,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::KinesisPermissionDenied => "KINESIS_PERMISSION_DENIED",
                    Self::PublishPermissionDenied => "PUBLISH_PERMISSION_DENIED",
                    Self::StreamNotFound => "STREAM_NOT_FOUND",
                    Self::ConsumerNotFound => "CONSUMER_NOT_FOUND",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "KINESIS_PERMISSION_DENIED" => Some(Self::KinesisPermissionDenied),
                    "PUBLISH_PERMISSION_DENIED" => Some(Self::PublishPermissionDenied),
                    "STREAM_NOT_FOUND" => Some(Self::StreamNotFound),
                    "CONSUMER_NOT_FOUND" => Some(Self::ConsumerNotFound),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for AwsKinesis {
        const NAME: &'static str = "AwsKinesis";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.IngestionDataSourceSettings.AwsKinesis".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.AwsKinesis"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CloudStorage {
        #[prost(enumeration = "cloud_storage::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub bucket: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "6")]
        pub minimum_object_create_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(string, tag = "9")]
        pub match_glob: ::prost::alloc::string::String,
        #[prost(oneof = "cloud_storage::InputFormat", tags = "3, 4, 5")]
        pub input_format: ::core::option::Option<cloud_storage::InputFormat>,
    }
    /// Nested message and enum types in `CloudStorage`.
    pub mod cloud_storage {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TextFormat {
            #[prost(string, optional, tag = "1")]
            pub delimiter: ::core::option::Option<::prost::alloc::string::String>,
        }
        impl ::prost::Name for TextFormat {
            const NAME: &'static str = "TextFormat";
            const PACKAGE: &'static str = "google.pubsub.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.TextFormat"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.TextFormat"
                    .into()
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct AvroFormat {}
        impl ::prost::Name for AvroFormat {
            const NAME: &'static str = "AvroFormat";
            const PACKAGE: &'static str = "google.pubsub.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.AvroFormat"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.AvroFormat"
                    .into()
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct PubSubAvroFormat {}
        impl ::prost::Name for PubSubAvroFormat {
            const NAME: &'static str = "PubSubAvroFormat";
            const PACKAGE: &'static str = "google.pubsub.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.PubSubAvroFormat"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.PubSubAvroFormat"
                    .into()
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Active = 1,
            CloudStoragePermissionDenied = 2,
            PublishPermissionDenied = 3,
            BucketNotFound = 4,
            TooManyObjects = 5,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::CloudStoragePermissionDenied => {
                        "CLOUD_STORAGE_PERMISSION_DENIED"
                    }
                    Self::PublishPermissionDenied => "PUBLISH_PERMISSION_DENIED",
                    Self::BucketNotFound => "BUCKET_NOT_FOUND",
                    Self::TooManyObjects => "TOO_MANY_OBJECTS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "CLOUD_STORAGE_PERMISSION_DENIED" => {
                        Some(Self::CloudStoragePermissionDenied)
                    }
                    "PUBLISH_PERMISSION_DENIED" => Some(Self::PublishPermissionDenied),
                    "BUCKET_NOT_FOUND" => Some(Self::BucketNotFound),
                    "TOO_MANY_OBJECTS" => Some(Self::TooManyObjects),
                    _ => None,
                }
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum InputFormat {
            #[prost(message, tag = "3")]
            TextFormat(TextFormat),
            #[prost(message, tag = "4")]
            AvroFormat(AvroFormat),
            #[prost(message, tag = "5")]
            PubsubAvroFormat(PubSubAvroFormat),
        }
    }
    impl ::prost::Name for CloudStorage {
        const NAME: &'static str = "CloudStorage";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.IngestionDataSourceSettings.CloudStorage".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.CloudStorage"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AzureEventHubs {
        #[prost(enumeration = "azure_event_hubs::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub resource_group: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub namespace: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub event_hub: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub client_id: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub tenant_id: ::prost::alloc::string::String,
        #[prost(string, tag = "7")]
        pub subscription_id: ::prost::alloc::string::String,
        #[prost(string, tag = "8")]
        pub gcp_service_account: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `AzureEventHubs`.
    pub mod azure_event_hubs {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Active = 1,
            EventHubsPermissionDenied = 2,
            PublishPermissionDenied = 3,
            NamespaceNotFound = 4,
            EventHubNotFound = 5,
            SubscriptionNotFound = 6,
            ResourceGroupNotFound = 7,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::EventHubsPermissionDenied => "EVENT_HUBS_PERMISSION_DENIED",
                    Self::PublishPermissionDenied => "PUBLISH_PERMISSION_DENIED",
                    Self::NamespaceNotFound => "NAMESPACE_NOT_FOUND",
                    Self::EventHubNotFound => "EVENT_HUB_NOT_FOUND",
                    Self::SubscriptionNotFound => "SUBSCRIPTION_NOT_FOUND",
                    Self::ResourceGroupNotFound => "RESOURCE_GROUP_NOT_FOUND",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "EVENT_HUBS_PERMISSION_DENIED" => {
                        Some(Self::EventHubsPermissionDenied)
                    }
                    "PUBLISH_PERMISSION_DENIED" => Some(Self::PublishPermissionDenied),
                    "NAMESPACE_NOT_FOUND" => Some(Self::NamespaceNotFound),
                    "EVENT_HUB_NOT_FOUND" => Some(Self::EventHubNotFound),
                    "SUBSCRIPTION_NOT_FOUND" => Some(Self::SubscriptionNotFound),
                    "RESOURCE_GROUP_NOT_FOUND" => Some(Self::ResourceGroupNotFound),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for AzureEventHubs {
        const NAME: &'static str = "AzureEventHubs";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.IngestionDataSourceSettings.AzureEventHubs".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.AzureEventHubs"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AwsMsk {
        #[prost(enumeration = "aws_msk::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub cluster_arn: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub topic: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub aws_role_arn: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub gcp_service_account: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `AwsMsk`.
    pub mod aws_msk {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Active = 1,
            MskPermissionDenied = 2,
            PublishPermissionDenied = 3,
            ClusterNotFound = 4,
            TopicNotFound = 5,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::MskPermissionDenied => "MSK_PERMISSION_DENIED",
                    Self::PublishPermissionDenied => "PUBLISH_PERMISSION_DENIED",
                    Self::ClusterNotFound => "CLUSTER_NOT_FOUND",
                    Self::TopicNotFound => "TOPIC_NOT_FOUND",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "MSK_PERMISSION_DENIED" => Some(Self::MskPermissionDenied),
                    "PUBLISH_PERMISSION_DENIED" => Some(Self::PublishPermissionDenied),
                    "CLUSTER_NOT_FOUND" => Some(Self::ClusterNotFound),
                    "TOPIC_NOT_FOUND" => Some(Self::TopicNotFound),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for AwsMsk {
        const NAME: &'static str = "AwsMsk";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.IngestionDataSourceSettings.AwsMsk".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.AwsMsk"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConfluentCloud {
        #[prost(enumeration = "confluent_cloud::State", tag = "1")]
        pub state: i32,
        #[prost(string, tag = "2")]
        pub bootstrap_server: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub cluster_id: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub topic: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub identity_pool_id: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub gcp_service_account: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `ConfluentCloud`.
    pub mod confluent_cloud {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Active = 1,
            ConfluentCloudPermissionDenied = 2,
            PublishPermissionDenied = 3,
            UnreachableBootstrapServer = 4,
            ClusterNotFound = 5,
            TopicNotFound = 6,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::ConfluentCloudPermissionDenied => {
                        "CONFLUENT_CLOUD_PERMISSION_DENIED"
                    }
                    Self::PublishPermissionDenied => "PUBLISH_PERMISSION_DENIED",
                    Self::UnreachableBootstrapServer => "UNREACHABLE_BOOTSTRAP_SERVER",
                    Self::ClusterNotFound => "CLUSTER_NOT_FOUND",
                    Self::TopicNotFound => "TOPIC_NOT_FOUND",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "CONFLUENT_CLOUD_PERMISSION_DENIED" => {
                        Some(Self::ConfluentCloudPermissionDenied)
                    }
                    "PUBLISH_PERMISSION_DENIED" => Some(Self::PublishPermissionDenied),
                    "UNREACHABLE_BOOTSTRAP_SERVER" => {
                        Some(Self::UnreachableBootstrapServer)
                    }
                    "CLUSTER_NOT_FOUND" => Some(Self::ClusterNotFound),
                    "TOPIC_NOT_FOUND" => Some(Self::TopicNotFound),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for ConfluentCloud {
        const NAME: &'static str = "ConfluentCloud";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.IngestionDataSourceSettings.ConfluentCloud".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings.ConfluentCloud"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "1")]
        AwsKinesis(AwsKinesis),
        #[prost(message, tag = "2")]
        CloudStorage(CloudStorage),
        #[prost(message, tag = "3")]
        AzureEventHubs(AzureEventHubs),
        #[prost(message, tag = "5")]
        AwsMsk(AwsMsk),
        #[prost(message, tag = "6")]
        ConfluentCloud(ConfluentCloud),
    }
}
impl ::prost::Name for IngestionDataSourceSettings {
    const NAME: &'static str = "IngestionDataSourceSettings";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.IngestionDataSourceSettings".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.IngestionDataSourceSettings".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlatformLogsSettings {
    #[prost(enumeration = "platform_logs_settings::Severity", tag = "1")]
    pub severity: i32,
}
/// Nested message and enum types in `PlatformLogsSettings`.
pub mod platform_logs_settings {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Severity {
        Unspecified = 0,
        Disabled = 1,
        Debug = 2,
        Info = 3,
        Warning = 4,
        Error = 5,
    }
    impl Severity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SEVERITY_UNSPECIFIED",
                Self::Disabled => "DISABLED",
                Self::Debug => "DEBUG",
                Self::Info => "INFO",
                Self::Warning => "WARNING",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
                "DISABLED" => Some(Self::Disabled),
                "DEBUG" => Some(Self::Debug),
                "INFO" => Some(Self::Info),
                "WARNING" => Some(Self::Warning),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for PlatformLogsSettings {
    const NAME: &'static str = "PlatformLogsSettings";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.PlatformLogsSettings".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.PlatformLogsSettings".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngestionFailureEvent {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(oneof = "ingestion_failure_event::Failure", tags = "3, 4, 5, 6, 7")]
    pub failure: ::core::option::Option<ingestion_failure_event::Failure>,
}
/// Nested message and enum types in `IngestionFailureEvent`.
pub mod ingestion_failure_event {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ApiViolationReason {}
    impl ::prost::Name for ApiViolationReason {
        const NAME: &'static str = "ApiViolationReason";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.IngestionFailureEvent.ApiViolationReason".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.IngestionFailureEvent.ApiViolationReason"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AvroFailureReason {}
    impl ::prost::Name for AvroFailureReason {
        const NAME: &'static str = "AvroFailureReason";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.IngestionFailureEvent.AvroFailureReason".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.IngestionFailureEvent.AvroFailureReason"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SchemaViolationReason {}
    impl ::prost::Name for SchemaViolationReason {
        const NAME: &'static str = "SchemaViolationReason";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.IngestionFailureEvent.SchemaViolationReason".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.IngestionFailureEvent.SchemaViolationReason"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MessageTransformationFailureReason {}
    impl ::prost::Name for MessageTransformationFailureReason {
        const NAME: &'static str = "MessageTransformationFailureReason";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.IngestionFailureEvent.MessageTransformationFailureReason"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.IngestionFailureEvent.MessageTransformationFailureReason"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CloudStorageFailure {
        #[prost(string, tag = "1")]
        pub bucket: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub object_name: ::prost::alloc::string::String,
        #[prost(int64, tag = "3")]
        pub object_generation: i64,
        #[prost(oneof = "cloud_storage_failure::Reason", tags = "5, 6, 7, 8")]
        pub reason: ::core::option::Option<cloud_storage_failure::Reason>,
    }
    /// Nested message and enum types in `CloudStorageFailure`.
    pub mod cloud_storage_failure {
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "5")]
            AvroFailureReason(super::AvroFailureReason),
            #[prost(message, tag = "6")]
            ApiViolationReason(super::ApiViolationReason),
            #[prost(message, tag = "7")]
            SchemaViolationReason(super::SchemaViolationReason),
            #[prost(message, tag = "8")]
            MessageTransformationFailureReason(
                super::MessageTransformationFailureReason,
            ),
        }
    }
    impl ::prost::Name for CloudStorageFailure {
        const NAME: &'static str = "CloudStorageFailure";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.IngestionFailureEvent.CloudStorageFailure".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.IngestionFailureEvent.CloudStorageFailure"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AwsMskFailureReason {
        #[prost(string, tag = "1")]
        pub cluster_arn: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub kafka_topic: ::prost::alloc::string::String,
        #[prost(int64, tag = "3")]
        pub partition_id: i64,
        #[prost(int64, tag = "4")]
        pub offset: i64,
        #[prost(oneof = "aws_msk_failure_reason::Reason", tags = "5, 6, 7")]
        pub reason: ::core::option::Option<aws_msk_failure_reason::Reason>,
    }
    /// Nested message and enum types in `AwsMskFailureReason`.
    pub mod aws_msk_failure_reason {
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "5")]
            ApiViolationReason(super::ApiViolationReason),
            #[prost(message, tag = "6")]
            SchemaViolationReason(super::SchemaViolationReason),
            #[prost(message, tag = "7")]
            MessageTransformationFailureReason(
                super::MessageTransformationFailureReason,
            ),
        }
    }
    impl ::prost::Name for AwsMskFailureReason {
        const NAME: &'static str = "AwsMskFailureReason";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.IngestionFailureEvent.AwsMskFailureReason".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.IngestionFailureEvent.AwsMskFailureReason"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AzureEventHubsFailureReason {
        #[prost(string, tag = "1")]
        pub namespace: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub event_hub: ::prost::alloc::string::String,
        #[prost(int64, tag = "3")]
        pub partition_id: i64,
        #[prost(int64, tag = "4")]
        pub offset: i64,
        #[prost(oneof = "azure_event_hubs_failure_reason::Reason", tags = "5, 6, 7")]
        pub reason: ::core::option::Option<azure_event_hubs_failure_reason::Reason>,
    }
    /// Nested message and enum types in `AzureEventHubsFailureReason`.
    pub mod azure_event_hubs_failure_reason {
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "5")]
            ApiViolationReason(super::ApiViolationReason),
            #[prost(message, tag = "6")]
            SchemaViolationReason(super::SchemaViolationReason),
            #[prost(message, tag = "7")]
            MessageTransformationFailureReason(
                super::MessageTransformationFailureReason,
            ),
        }
    }
    impl ::prost::Name for AzureEventHubsFailureReason {
        const NAME: &'static str = "AzureEventHubsFailureReason";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.IngestionFailureEvent.AzureEventHubsFailureReason".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.IngestionFailureEvent.AzureEventHubsFailureReason"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConfluentCloudFailureReason {
        #[prost(string, tag = "1")]
        pub cluster_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub kafka_topic: ::prost::alloc::string::String,
        #[prost(int64, tag = "3")]
        pub partition_id: i64,
        #[prost(int64, tag = "4")]
        pub offset: i64,
        #[prost(oneof = "confluent_cloud_failure_reason::Reason", tags = "5, 6, 7")]
        pub reason: ::core::option::Option<confluent_cloud_failure_reason::Reason>,
    }
    /// Nested message and enum types in `ConfluentCloudFailureReason`.
    pub mod confluent_cloud_failure_reason {
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "5")]
            ApiViolationReason(super::ApiViolationReason),
            #[prost(message, tag = "6")]
            SchemaViolationReason(super::SchemaViolationReason),
            #[prost(message, tag = "7")]
            MessageTransformationFailureReason(
                super::MessageTransformationFailureReason,
            ),
        }
    }
    impl ::prost::Name for ConfluentCloudFailureReason {
        const NAME: &'static str = "ConfluentCloudFailureReason";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.IngestionFailureEvent.ConfluentCloudFailureReason".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.IngestionFailureEvent.ConfluentCloudFailureReason"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AwsKinesisFailureReason {
        #[prost(string, tag = "1")]
        pub stream_arn: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub partition_key: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub sequence_number: ::prost::alloc::string::String,
        #[prost(oneof = "aws_kinesis_failure_reason::Reason", tags = "4, 5")]
        pub reason: ::core::option::Option<aws_kinesis_failure_reason::Reason>,
    }
    /// Nested message and enum types in `AwsKinesisFailureReason`.
    pub mod aws_kinesis_failure_reason {
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "4")]
            SchemaViolationReason(super::SchemaViolationReason),
            #[prost(message, tag = "5")]
            MessageTransformationFailureReason(
                super::MessageTransformationFailureReason,
            ),
        }
    }
    impl ::prost::Name for AwsKinesisFailureReason {
        const NAME: &'static str = "AwsKinesisFailureReason";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.IngestionFailureEvent.AwsKinesisFailureReason".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.IngestionFailureEvent.AwsKinesisFailureReason"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Failure {
        #[prost(message, tag = "3")]
        CloudStorageFailure(CloudStorageFailure),
        #[prost(message, tag = "4")]
        AwsMskFailure(AwsMskFailureReason),
        #[prost(message, tag = "5")]
        AzureEventHubsFailure(AzureEventHubsFailureReason),
        #[prost(message, tag = "6")]
        ConfluentCloudFailure(ConfluentCloudFailureReason),
        #[prost(message, tag = "7")]
        AwsKinesisFailure(AwsKinesisFailureReason),
    }
}
impl ::prost::Name for IngestionFailureEvent {
    const NAME: &'static str = "IngestionFailureEvent";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.IngestionFailureEvent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.IngestionFailureEvent".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JavaScriptUdf {
    #[prost(string, tag = "1")]
    pub function_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
}
impl ::prost::Name for JavaScriptUdf {
    const NAME: &'static str = "JavaScriptUDF";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.JavaScriptUDF".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.JavaScriptUDF".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageTransform {
    #[deprecated]
    #[prost(bool, tag = "3")]
    pub enabled: bool,
    #[prost(bool, tag = "4")]
    pub disabled: bool,
    #[prost(oneof = "message_transform::Transform", tags = "2")]
    pub transform: ::core::option::Option<message_transform::Transform>,
}
/// Nested message and enum types in `MessageTransform`.
pub mod message_transform {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Transform {
        #[prost(message, tag = "2")]
        JavascriptUdf(super::JavaScriptUdf),
    }
}
impl ::prost::Name for MessageTransform {
    const NAME: &'static str = "MessageTransform";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.MessageTransform".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.MessageTransform".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Topic {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "2")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "3")]
    pub message_storage_policy: ::core::option::Option<MessageStoragePolicy>,
    #[prost(string, tag = "5")]
    pub kms_key_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub schema_settings: ::core::option::Option<SchemaSettings>,
    #[prost(bool, tag = "7")]
    pub satisfies_pzs: bool,
    #[prost(message, optional, tag = "8")]
    pub message_retention_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(enumeration = "topic::State", tag = "9")]
    pub state: i32,
    #[prost(message, optional, tag = "10")]
    pub ingestion_data_source_settings: ::core::option::Option<
        IngestionDataSourceSettings,
    >,
    #[prost(message, repeated, tag = "13")]
    pub message_transforms: ::prost::alloc::vec::Vec<MessageTransform>,
}
/// Nested message and enum types in `Topic`.
pub mod topic {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        IngestionResourceError = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::IngestionResourceError => "INGESTION_RESOURCE_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INGESTION_RESOURCE_ERROR" => Some(Self::IngestionResourceError),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Topic {
    const NAME: &'static str = "Topic";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.Topic".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.Topic".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PubsubMessage {
    #[prost(bytes = "bytes", tag = "1")]
    pub data: ::prost::bytes::Bytes,
    #[prost(map = "string, string", tag = "2")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "3")]
    pub message_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub publish_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub ordering_key: ::prost::alloc::string::String,
}
impl ::prost::Name for PubsubMessage {
    const NAME: &'static str = "PubsubMessage";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.PubsubMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.PubsubMessage".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTopicRequest {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
}
impl ::prost::Name for GetTopicRequest {
    const NAME: &'static str = "GetTopicRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.GetTopicRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.GetTopicRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTopicRequest {
    #[prost(message, optional, tag = "1")]
    pub topic: ::core::option::Option<Topic>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateTopicRequest {
    const NAME: &'static str = "UpdateTopicRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.UpdateTopicRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.UpdateTopicRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishRequest {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub messages: ::prost::alloc::vec::Vec<PubsubMessage>,
}
impl ::prost::Name for PublishRequest {
    const NAME: &'static str = "PublishRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.PublishRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.PublishRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishResponse {
    #[prost(string, repeated, tag = "1")]
    pub message_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for PublishResponse {
    const NAME: &'static str = "PublishResponse";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.PublishResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.PublishResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTopicsRequest {
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListTopicsRequest {
    const NAME: &'static str = "ListTopicsRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ListTopicsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ListTopicsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTopicsResponse {
    #[prost(message, repeated, tag = "1")]
    pub topics: ::prost::alloc::vec::Vec<Topic>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListTopicsResponse {
    const NAME: &'static str = "ListTopicsResponse";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ListTopicsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ListTopicsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTopicSubscriptionsRequest {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListTopicSubscriptionsRequest {
    const NAME: &'static str = "ListTopicSubscriptionsRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ListTopicSubscriptionsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ListTopicSubscriptionsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTopicSubscriptionsResponse {
    #[prost(string, repeated, tag = "1")]
    pub subscriptions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListTopicSubscriptionsResponse {
    const NAME: &'static str = "ListTopicSubscriptionsResponse";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ListTopicSubscriptionsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ListTopicSubscriptionsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTopicSnapshotsRequest {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListTopicSnapshotsRequest {
    const NAME: &'static str = "ListTopicSnapshotsRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ListTopicSnapshotsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ListTopicSnapshotsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTopicSnapshotsResponse {
    #[prost(string, repeated, tag = "1")]
    pub snapshots: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListTopicSnapshotsResponse {
    const NAME: &'static str = "ListTopicSnapshotsResponse";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ListTopicSnapshotsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ListTopicSnapshotsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTopicRequest {
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteTopicRequest {
    const NAME: &'static str = "DeleteTopicRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.DeleteTopicRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.DeleteTopicRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetachSubscriptionRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
}
impl ::prost::Name for DetachSubscriptionRequest {
    const NAME: &'static str = "DetachSubscriptionRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.DetachSubscriptionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.DetachSubscriptionRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DetachSubscriptionResponse {}
impl ::prost::Name for DetachSubscriptionResponse {
    const NAME: &'static str = "DetachSubscriptionResponse";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.DetachSubscriptionResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.DetachSubscriptionResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subscription {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub push_config: ::core::option::Option<PushConfig>,
    #[prost(message, optional, tag = "18")]
    pub bigquery_config: ::core::option::Option<BigQueryConfig>,
    #[prost(message, optional, tag = "22")]
    pub cloud_storage_config: ::core::option::Option<CloudStorageConfig>,
    #[prost(int32, tag = "5")]
    pub ack_deadline_seconds: i32,
    #[prost(bool, tag = "7")]
    pub retain_acked_messages: bool,
    #[prost(message, optional, tag = "8")]
    pub message_retention_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(map = "string, string", tag = "9")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "10")]
    pub enable_message_ordering: bool,
    #[prost(message, optional, tag = "11")]
    pub expiration_policy: ::core::option::Option<ExpirationPolicy>,
    #[prost(string, tag = "12")]
    pub filter: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "13")]
    pub dead_letter_policy: ::core::option::Option<DeadLetterPolicy>,
    #[prost(message, optional, tag = "14")]
    pub retry_policy: ::core::option::Option<RetryPolicy>,
    #[prost(bool, tag = "15")]
    pub detached: bool,
    #[prost(bool, tag = "16")]
    pub enable_exactly_once_delivery: bool,
    #[prost(message, optional, tag = "17")]
    pub topic_message_retention_duration: ::core::option::Option<
        ::prost_types::Duration,
    >,
    #[prost(enumeration = "subscription::State", tag = "19")]
    pub state: i32,
    #[prost(message, optional, tag = "23")]
    pub analytics_hub_subscription_info: ::core::option::Option<
        subscription::AnalyticsHubSubscriptionInfo,
    >,
    #[prost(message, repeated, tag = "25")]
    pub message_transforms: ::prost::alloc::vec::Vec<MessageTransform>,
}
/// Nested message and enum types in `Subscription`.
pub mod subscription {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AnalyticsHubSubscriptionInfo {
        #[prost(string, tag = "1")]
        pub listing: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub subscription: ::prost::alloc::string::String,
    }
    impl ::prost::Name for AnalyticsHubSubscriptionInfo {
        const NAME: &'static str = "AnalyticsHubSubscriptionInfo";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.Subscription.AnalyticsHubSubscriptionInfo".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.Subscription.AnalyticsHubSubscriptionInfo"
                .into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        ResourceError = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::ResourceError => "RESOURCE_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "RESOURCE_ERROR" => Some(Self::ResourceError),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Subscription {
    const NAME: &'static str = "Subscription";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.Subscription".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.Subscription".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RetryPolicy {
    #[prost(message, optional, tag = "1")]
    pub minimum_backoff: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "2")]
    pub maximum_backoff: ::core::option::Option<::prost_types::Duration>,
}
impl ::prost::Name for RetryPolicy {
    const NAME: &'static str = "RetryPolicy";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.RetryPolicy".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.RetryPolicy".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeadLetterPolicy {
    #[prost(string, tag = "1")]
    pub dead_letter_topic: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub max_delivery_attempts: i32,
}
impl ::prost::Name for DeadLetterPolicy {
    const NAME: &'static str = "DeadLetterPolicy";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.DeadLetterPolicy".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.DeadLetterPolicy".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExpirationPolicy {
    #[prost(message, optional, tag = "1")]
    pub ttl: ::core::option::Option<::prost_types::Duration>,
}
impl ::prost::Name for ExpirationPolicy {
    const NAME: &'static str = "ExpirationPolicy";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ExpirationPolicy".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ExpirationPolicy".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushConfig {
    #[prost(string, tag = "1")]
    pub push_endpoint: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "2")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(oneof = "push_config::AuthenticationMethod", tags = "3")]
    pub authentication_method: ::core::option::Option<push_config::AuthenticationMethod>,
    #[prost(oneof = "push_config::Wrapper", tags = "4, 5")]
    pub wrapper: ::core::option::Option<push_config::Wrapper>,
}
/// Nested message and enum types in `PushConfig`.
pub mod push_config {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OidcToken {
        #[prost(string, tag = "1")]
        pub service_account_email: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub audience: ::prost::alloc::string::String,
    }
    impl ::prost::Name for OidcToken {
        const NAME: &'static str = "OidcToken";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.PushConfig.OidcToken".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.PushConfig.OidcToken".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PubsubWrapper {}
    impl ::prost::Name for PubsubWrapper {
        const NAME: &'static str = "PubsubWrapper";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.PushConfig.PubsubWrapper".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.PushConfig.PubsubWrapper".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NoWrapper {
        #[prost(bool, tag = "1")]
        pub write_metadata: bool,
    }
    impl ::prost::Name for NoWrapper {
        const NAME: &'static str = "NoWrapper";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.PushConfig.NoWrapper".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.PushConfig.NoWrapper".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AuthenticationMethod {
        #[prost(message, tag = "3")]
        OidcToken(OidcToken),
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Wrapper {
        #[prost(message, tag = "4")]
        PubsubWrapper(PubsubWrapper),
        #[prost(message, tag = "5")]
        NoWrapper(NoWrapper),
    }
}
impl ::prost::Name for PushConfig {
    const NAME: &'static str = "PushConfig";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.PushConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.PushConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQueryConfig {
    #[prost(string, tag = "1")]
    pub table: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub use_topic_schema: bool,
    #[prost(bool, tag = "3")]
    pub write_metadata: bool,
    #[prost(bool, tag = "4")]
    pub drop_unknown_fields: bool,
    #[prost(enumeration = "big_query_config::State", tag = "5")]
    pub state: i32,
    #[prost(bool, tag = "6")]
    pub use_table_schema: bool,
    #[prost(string, tag = "7")]
    pub service_account_email: ::prost::alloc::string::String,
}
/// Nested message and enum types in `BigQueryConfig`.
pub mod big_query_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        PermissionDenied = 2,
        NotFound = 3,
        SchemaMismatch = 4,
        InTransitLocationRestriction = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::PermissionDenied => "PERMISSION_DENIED",
                Self::NotFound => "NOT_FOUND",
                Self::SchemaMismatch => "SCHEMA_MISMATCH",
                Self::InTransitLocationRestriction => "IN_TRANSIT_LOCATION_RESTRICTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                "NOT_FOUND" => Some(Self::NotFound),
                "SCHEMA_MISMATCH" => Some(Self::SchemaMismatch),
                "IN_TRANSIT_LOCATION_RESTRICTION" => {
                    Some(Self::InTransitLocationRestriction)
                }
                _ => None,
            }
        }
    }
}
impl ::prost::Name for BigQueryConfig {
    const NAME: &'static str = "BigQueryConfig";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.BigQueryConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.BigQueryConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudStorageConfig {
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filename_prefix: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub filename_suffix: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub filename_datetime_format: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub max_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(int64, tag = "7")]
    pub max_bytes: i64,
    #[prost(int64, tag = "8")]
    pub max_messages: i64,
    #[prost(enumeration = "cloud_storage_config::State", tag = "9")]
    pub state: i32,
    #[prost(string, tag = "11")]
    pub service_account_email: ::prost::alloc::string::String,
    #[prost(oneof = "cloud_storage_config::OutputFormat", tags = "4, 5")]
    pub output_format: ::core::option::Option<cloud_storage_config::OutputFormat>,
}
/// Nested message and enum types in `CloudStorageConfig`.
pub mod cloud_storage_config {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TextConfig {}
    impl ::prost::Name for TextConfig {
        const NAME: &'static str = "TextConfig";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.CloudStorageConfig.TextConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.CloudStorageConfig.TextConfig".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AvroConfig {
        #[prost(bool, tag = "1")]
        pub write_metadata: bool,
        #[prost(bool, tag = "2")]
        pub use_topic_schema: bool,
    }
    impl ::prost::Name for AvroConfig {
        const NAME: &'static str = "AvroConfig";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.CloudStorageConfig.AvroConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.CloudStorageConfig.AvroConfig".into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        PermissionDenied = 2,
        NotFound = 3,
        InTransitLocationRestriction = 4,
        SchemaMismatch = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::PermissionDenied => "PERMISSION_DENIED",
                Self::NotFound => "NOT_FOUND",
                Self::InTransitLocationRestriction => "IN_TRANSIT_LOCATION_RESTRICTION",
                Self::SchemaMismatch => "SCHEMA_MISMATCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                "NOT_FOUND" => Some(Self::NotFound),
                "IN_TRANSIT_LOCATION_RESTRICTION" => {
                    Some(Self::InTransitLocationRestriction)
                }
                "SCHEMA_MISMATCH" => Some(Self::SchemaMismatch),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum OutputFormat {
        #[prost(message, tag = "4")]
        TextConfig(TextConfig),
        #[prost(message, tag = "5")]
        AvroConfig(AvroConfig),
    }
}
impl ::prost::Name for CloudStorageConfig {
    const NAME: &'static str = "CloudStorageConfig";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.CloudStorageConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.CloudStorageConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceivedMessage {
    #[prost(string, tag = "1")]
    pub ack_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub message: ::core::option::Option<PubsubMessage>,
    #[prost(int32, tag = "3")]
    pub delivery_attempt: i32,
}
impl ::prost::Name for ReceivedMessage {
    const NAME: &'static str = "ReceivedMessage";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ReceivedMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ReceivedMessage".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubscriptionRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
}
impl ::prost::Name for GetSubscriptionRequest {
    const NAME: &'static str = "GetSubscriptionRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.GetSubscriptionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.GetSubscriptionRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSubscriptionRequest {
    #[prost(message, optional, tag = "1")]
    pub subscription: ::core::option::Option<Subscription>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateSubscriptionRequest {
    const NAME: &'static str = "UpdateSubscriptionRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.UpdateSubscriptionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.UpdateSubscriptionRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubscriptionsRequest {
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListSubscriptionsRequest {
    const NAME: &'static str = "ListSubscriptionsRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ListSubscriptionsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ListSubscriptionsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubscriptionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub subscriptions: ::prost::alloc::vec::Vec<Subscription>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListSubscriptionsResponse {
    const NAME: &'static str = "ListSubscriptionsResponse";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ListSubscriptionsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ListSubscriptionsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSubscriptionRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteSubscriptionRequest {
    const NAME: &'static str = "DeleteSubscriptionRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.DeleteSubscriptionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.DeleteSubscriptionRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModifyPushConfigRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub push_config: ::core::option::Option<PushConfig>,
}
impl ::prost::Name for ModifyPushConfigRequest {
    const NAME: &'static str = "ModifyPushConfigRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ModifyPushConfigRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ModifyPushConfigRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(bool, tag = "2")]
    pub return_immediately: bool,
    #[prost(int32, tag = "3")]
    pub max_messages: i32,
}
impl ::prost::Name for PullRequest {
    const NAME: &'static str = "PullRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.PullRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.PullRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullResponse {
    #[prost(message, repeated, tag = "1")]
    pub received_messages: ::prost::alloc::vec::Vec<ReceivedMessage>,
}
impl ::prost::Name for PullResponse {
    const NAME: &'static str = "PullResponse";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.PullResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.PullResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModifyAckDeadlineRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub ack_deadline_seconds: i32,
}
impl ::prost::Name for ModifyAckDeadlineRequest {
    const NAME: &'static str = "ModifyAckDeadlineRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ModifyAckDeadlineRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ModifyAckDeadlineRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcknowledgeRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for AcknowledgeRequest {
    const NAME: &'static str = "AcknowledgeRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.AcknowledgeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.AcknowledgeRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingPullRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub modify_deadline_seconds: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag = "4")]
    pub modify_deadline_ack_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(int32, tag = "5")]
    pub stream_ack_deadline_seconds: i32,
    #[prost(string, tag = "6")]
    pub client_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "7")]
    pub max_outstanding_messages: i64,
    #[prost(int64, tag = "8")]
    pub max_outstanding_bytes: i64,
    #[prost(int64, tag = "10")]
    pub protocol_version: i64,
}
impl ::prost::Name for StreamingPullRequest {
    const NAME: &'static str = "StreamingPullRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.StreamingPullRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.StreamingPullRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingPullResponse {
    #[prost(message, repeated, tag = "1")]
    pub received_messages: ::prost::alloc::vec::Vec<ReceivedMessage>,
    #[prost(message, optional, tag = "5")]
    pub acknowledge_confirmation: ::core::option::Option<
        streaming_pull_response::AcknowledgeConfirmation,
    >,
    #[prost(message, optional, tag = "3")]
    pub modify_ack_deadline_confirmation: ::core::option::Option<
        streaming_pull_response::ModifyAckDeadlineConfirmation,
    >,
    #[prost(message, optional, tag = "4")]
    pub subscription_properties: ::core::option::Option<
        streaming_pull_response::SubscriptionProperties,
    >,
}
/// Nested message and enum types in `StreamingPullResponse`.
pub mod streaming_pull_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AcknowledgeConfirmation {
        #[prost(string, repeated, tag = "1")]
        pub ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "2")]
        pub invalid_ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub unordered_ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "4")]
        pub temporary_failed_ack_ids: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    impl ::prost::Name for AcknowledgeConfirmation {
        const NAME: &'static str = "AcknowledgeConfirmation";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.StreamingPullResponse.AcknowledgeConfirmation".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.StreamingPullResponse.AcknowledgeConfirmation"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ModifyAckDeadlineConfirmation {
        #[prost(string, repeated, tag = "1")]
        pub ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "2")]
        pub invalid_ack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub temporary_failed_ack_ids: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    impl ::prost::Name for ModifyAckDeadlineConfirmation {
        const NAME: &'static str = "ModifyAckDeadlineConfirmation";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.StreamingPullResponse.ModifyAckDeadlineConfirmation".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.StreamingPullResponse.ModifyAckDeadlineConfirmation"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SubscriptionProperties {
        #[prost(bool, tag = "1")]
        pub exactly_once_delivery_enabled: bool,
        #[prost(bool, tag = "2")]
        pub message_ordering_enabled: bool,
    }
    impl ::prost::Name for SubscriptionProperties {
        const NAME: &'static str = "SubscriptionProperties";
        const PACKAGE: &'static str = "google.pubsub.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.pubsub.v1.StreamingPullResponse.SubscriptionProperties".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.pubsub.v1.StreamingPullResponse.SubscriptionProperties"
                .into()
        }
    }
}
impl ::prost::Name for StreamingPullResponse {
    const NAME: &'static str = "StreamingPullResponse";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.StreamingPullResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.StreamingPullResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSnapshotRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for CreateSnapshotRequest {
    const NAME: &'static str = "CreateSnapshotRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.CreateSnapshotRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.CreateSnapshotRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSnapshotRequest {
    #[prost(message, optional, tag = "1")]
    pub snapshot: ::core::option::Option<Snapshot>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateSnapshotRequest {
    const NAME: &'static str = "UpdateSnapshotRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.UpdateSnapshotRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.UpdateSnapshotRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Snapshot {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub expire_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for Snapshot {
    const NAME: &'static str = "Snapshot";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.Snapshot".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.Snapshot".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSnapshotRequest {
    #[prost(string, tag = "1")]
    pub snapshot: ::prost::alloc::string::String,
}
impl ::prost::Name for GetSnapshotRequest {
    const NAME: &'static str = "GetSnapshotRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.GetSnapshotRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.GetSnapshotRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSnapshotsRequest {
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListSnapshotsRequest {
    const NAME: &'static str = "ListSnapshotsRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ListSnapshotsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ListSnapshotsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSnapshotsResponse {
    #[prost(message, repeated, tag = "1")]
    pub snapshots: ::prost::alloc::vec::Vec<Snapshot>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListSnapshotsResponse {
    const NAME: &'static str = "ListSnapshotsResponse";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.ListSnapshotsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.ListSnapshotsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSnapshotRequest {
    #[prost(string, tag = "1")]
    pub snapshot: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteSnapshotRequest {
    const NAME: &'static str = "DeleteSnapshotRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.DeleteSnapshotRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.DeleteSnapshotRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeekRequest {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(oneof = "seek_request::Target", tags = "2, 3")]
    pub target: ::core::option::Option<seek_request::Target>,
}
/// Nested message and enum types in `SeekRequest`.
pub mod seek_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        #[prost(message, tag = "2")]
        Time(::prost_types::Timestamp),
        #[prost(string, tag = "3")]
        Snapshot(::prost::alloc::string::String),
    }
}
impl ::prost::Name for SeekRequest {
    const NAME: &'static str = "SeekRequest";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.SeekRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.SeekRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeekResponse {}
impl ::prost::Name for SeekResponse {
    const NAME: &'static str = "SeekResponse";
    const PACKAGE: &'static str = "google.pubsub.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.pubsub.v1.SeekResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.pubsub.v1.SeekResponse".into()
    }
}
