// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate bytes;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate wkt;

/// This message defines the standard attribute vocabulary for Google APIs.
///
/// An attribute is a piece of metadata that describes an activity on a network
/// service. For example, the size of an HTTP request, or the status code of
/// an HTTP response.
///
/// Each attribute has a type and a name, which is logically defined as
/// a proto message field in `AttributeContext`. The field type becomes the
/// attribute type, and the field path becomes the attribute name. For example,
/// the attribute `source.ip` maps to field `AttributeContext.source.ip`.
///
/// This message definition is guaranteed not to have any wire breaking change.
/// So you can use it directly for passing attributes across different systems.
///
/// NOTE: Different system may generate different subset of attributes. Please
/// verify the system specification before relying on an attribute generated
/// a system.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttributeContext {
    /// The origin of a network activity. In a multi hop network activity,
    /// the origin represents the sender of the first hop. For the first hop,
    /// the `source` and the `origin` must have the same content.
    pub origin: std::option::Option<crate::model::attribute_context::Peer>,

    /// The source of a network activity, such as starting a TCP connection.
    /// In a multi hop network activity, the source represents the sender of the
    /// last hop.
    pub source: std::option::Option<crate::model::attribute_context::Peer>,

    /// The destination of a network activity, such as accepting a TCP connection.
    /// In a multi hop network activity, the destination represents the receiver of
    /// the last hop.
    pub destination: std::option::Option<crate::model::attribute_context::Peer>,

    /// Represents a network request, such as an HTTP request.
    pub request: std::option::Option<crate::model::attribute_context::Request>,

    /// Represents a network response, such as an HTTP response.
    pub response: std::option::Option<crate::model::attribute_context::Response>,

    /// Represents a target resource that is involved with a network activity.
    /// If multiple resources are involved with an activity, this must be the
    /// primary one.
    pub resource: std::option::Option<crate::model::attribute_context::Resource>,

    /// Represents an API operation that is involved to a network activity.
    pub api: std::option::Option<crate::model::attribute_context::Api>,

    /// Supports extensions for advanced use cases, such as logs and metrics.
    pub extensions: std::vec::Vec<wkt::Any>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttributeContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [origin][crate::model::AttributeContext::origin].
    pub fn set_origin<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attribute_context::Peer>,
    {
        self.origin = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [origin][crate::model::AttributeContext::origin].
    pub fn set_or_clear_origin<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attribute_context::Peer>,
    {
        self.origin = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::AttributeContext::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attribute_context::Peer>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::AttributeContext::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attribute_context::Peer>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination][crate::model::AttributeContext::destination].
    pub fn set_destination<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attribute_context::Peer>,
    {
        self.destination = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destination][crate::model::AttributeContext::destination].
    pub fn set_or_clear_destination<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attribute_context::Peer>,
    {
        self.destination = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request][crate::model::AttributeContext::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attribute_context::Request>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::AttributeContext::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attribute_context::Request>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [response][crate::model::AttributeContext::response].
    pub fn set_response<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attribute_context::Response>,
    {
        self.response = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [response][crate::model::AttributeContext::response].
    pub fn set_or_clear_response<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attribute_context::Response>,
    {
        self.response = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource][crate::model::AttributeContext::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attribute_context::Resource>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::AttributeContext::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attribute_context::Resource>,
    {
        self.resource = v.map(|x| x.into());
        self
    }

    /// Sets the value of [api][crate::model::AttributeContext::api].
    pub fn set_api<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attribute_context::Api>,
    {
        self.api = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api][crate::model::AttributeContext::api].
    pub fn set_or_clear_api<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attribute_context::Api>,
    {
        self.api = v.map(|x| x.into());
        self
    }

    /// Sets the value of [extensions][crate::model::AttributeContext::extensions].
    pub fn set_extensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Any>,
    {
        use std::iter::Iterator;
        self.extensions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AttributeContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.rpc.context.AttributeContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttributeContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __origin,
            __source,
            __destination,
            __request,
            __response,
            __resource,
            __api,
            __extensions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttributeContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "origin" => Ok(__FieldTag::__origin),
                            "source" => Ok(__FieldTag::__source),
                            "destination" => Ok(__FieldTag::__destination),
                            "request" => Ok(__FieldTag::__request),
                            "response" => Ok(__FieldTag::__response),
                            "resource" => Ok(__FieldTag::__resource),
                            "api" => Ok(__FieldTag::__api),
                            "extensions" => Ok(__FieldTag::__extensions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttributeContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttributeContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__origin => {
                            if !fields.insert(__FieldTag::__origin) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for origin",
                                ));
                            }
                            result.origin = map.next_value::<std::option::Option<crate::model::attribute_context::Peer>>()?
                                ;
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map.next_value::<std::option::Option<crate::model::attribute_context::Peer>>()?
                                ;
                        }
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination",
                                ));
                            }
                            result.destination = map.next_value::<std::option::Option<crate::model::attribute_context::Peer>>()?
                                ;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::attribute_context::Request>>()?
                                ;
                        }
                        __FieldTag::__response => {
                            if !fields.insert(__FieldTag::__response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response",
                                ));
                            }
                            result.response = map.next_value::<std::option::Option<crate::model::attribute_context::Response>>()?
                                ;
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map.next_value::<std::option::Option<crate::model::attribute_context::Resource>>()?
                                ;
                        }
                        __FieldTag::__api => {
                            if !fields.insert(__FieldTag::__api) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api",
                                ));
                            }
                            result.api = map.next_value::<std::option::Option<crate::model::attribute_context::Api>>()?
                                ;
                        }
                        __FieldTag::__extensions => {
                            if !fields.insert(__FieldTag::__extensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extensions",
                                ));
                            }
                            result.extensions = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Any>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttributeContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.origin.is_some() {
            state.serialize_entry("origin", &self.origin)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if self.destination.is_some() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if self.response.is_some() {
            state.serialize_entry("response", &self.response)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if self.api.is_some() {
            state.serialize_entry("api", &self.api)?;
        }
        if !self.extensions.is_empty() {
            state.serialize_entry("extensions", &self.extensions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AttributeContext].
pub mod attribute_context {
    #[allow(unused_imports)]
    use super::*;

    /// This message defines attributes for a node that handles a network request.
    /// The node can be either a service or an application that sends, forwards,
    /// or receives the request. Service peers should fill in
    /// `principal` and `labels` as appropriate.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Peer {
        /// The IP address of the peer.
        pub ip: std::string::String,

        /// The network port of the peer.
        pub port: i64,

        /// The labels associated with the peer.
        pub labels: std::collections::HashMap<std::string::String, std::string::String>,

        /// The identity of this peer. Similar to `Request.auth.principal`, but
        /// relative to the peer instead of the request. For example, the
        /// identity associated with a load balancer that forwarded the request.
        pub principal: std::string::String,

        /// The CLDR country/region code associated with the above IP address.
        /// If the IP address is private, the `region_code` should reflect the
        /// physical location where this peer is running.
        pub region_code: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Peer {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ip][crate::model::attribute_context::Peer::ip].
        pub fn set_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ip = v.into();
            self
        }

        /// Sets the value of [port][crate::model::attribute_context::Peer::port].
        pub fn set_port<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.port = v.into();
            self
        }

        /// Sets the value of [labels][crate::model::attribute_context::Peer::labels].
        pub fn set_labels<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [principal][crate::model::attribute_context::Peer::principal].
        pub fn set_principal<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.principal = v.into();
            self
        }

        /// Sets the value of [region_code][crate::model::attribute_context::Peer::region_code].
        pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region_code = v.into();
            self
        }
    }

    impl wkt::message::Message for Peer {
        fn typename() -> &'static str {
            "type.googleapis.com/google.rpc.context.AttributeContext.Peer"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Peer {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __ip,
                __port,
                __labels,
                __principal,
                __region_code,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Peer")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "ip" => Ok(__FieldTag::__ip),
                                "port" => Ok(__FieldTag::__port),
                                "labels" => Ok(__FieldTag::__labels),
                                "principal" => Ok(__FieldTag::__principal),
                                "regionCode" => Ok(__FieldTag::__region_code),
                                "region_code" => Ok(__FieldTag::__region_code),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Peer;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Peer")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__ip => {
                                if !fields.insert(__FieldTag::__ip) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ip",
                                    ));
                                }
                                result.ip = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__port => {
                                if !fields.insert(__FieldTag::__port) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for port",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__labels => {
                                if !fields.insert(__FieldTag::__labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for labels",
                                    ));
                                }
                                result.labels = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__principal => {
                                if !fields.insert(__FieldTag::__principal) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for principal",
                                    ));
                                }
                                result.principal = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__region_code => {
                                if !fields.insert(__FieldTag::__region_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for region_code",
                                    ));
                                }
                                result.region_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Peer {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.ip.is_empty() {
                state.serialize_entry("ip", &self.ip)?;
            }
            if !wkt::internal::is_default(&self.port) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("port", &__With(&self.port))?;
            }
            if !self.labels.is_empty() {
                state.serialize_entry("labels", &self.labels)?;
            }
            if !self.principal.is_empty() {
                state.serialize_entry("principal", &self.principal)?;
            }
            if !self.region_code.is_empty() {
                state.serialize_entry("regionCode", &self.region_code)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// This message defines attributes associated with API operations, such as
    /// a network API request. The terminology is based on the conventions used
    /// by Google APIs, Istio, and OpenAPI.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Api {
        /// The API service name. It is a logical identifier for a networked API,
        /// such as "pubsub.googleapis.com". The naming syntax depends on the
        /// API management system being used for handling the request.
        pub service: std::string::String,

        /// The API operation name. For gRPC requests, it is the fully qualified API
        /// method name, such as "google.pubsub.v1.Publisher.Publish". For OpenAPI
        /// requests, it is the `operationId`, such as "getPet".
        pub operation: std::string::String,

        /// The API protocol used for sending the request, such as "http", "https",
        /// "grpc", or "internal".
        pub protocol: std::string::String,

        /// The API version associated with the API operation above, such as "v1" or
        /// "v1alpha1".
        pub version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Api {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service][crate::model::attribute_context::Api::service].
        pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service = v.into();
            self
        }

        /// Sets the value of [operation][crate::model::attribute_context::Api::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [protocol][crate::model::attribute_context::Api::protocol].
        pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.protocol = v.into();
            self
        }

        /// Sets the value of [version][crate::model::attribute_context::Api::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }
    }

    impl wkt::message::Message for Api {
        fn typename() -> &'static str {
            "type.googleapis.com/google.rpc.context.AttributeContext.Api"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Api {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __service,
                __operation,
                __protocol,
                __version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Api")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "service" => Ok(__FieldTag::__service),
                                "operation" => Ok(__FieldTag::__operation),
                                "protocol" => Ok(__FieldTag::__protocol),
                                "version" => Ok(__FieldTag::__version),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Api;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Api")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__service => {
                                if !fields.insert(__FieldTag::__service) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service",
                                    ));
                                }
                                result.service = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__operation => {
                                if !fields.insert(__FieldTag::__operation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for operation",
                                    ));
                                }
                                result.operation = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__protocol => {
                                if !fields.insert(__FieldTag::__protocol) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for protocol",
                                    ));
                                }
                                result.protocol = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__version => {
                                if !fields.insert(__FieldTag::__version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for version",
                                    ));
                                }
                                result.version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Api {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.service.is_empty() {
                state.serialize_entry("service", &self.service)?;
            }
            if !self.operation.is_empty() {
                state.serialize_entry("operation", &self.operation)?;
            }
            if !self.protocol.is_empty() {
                state.serialize_entry("protocol", &self.protocol)?;
            }
            if !self.version.is_empty() {
                state.serialize_entry("version", &self.version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// This message defines request authentication attributes. Terminology is
    /// based on the JSON Web Token (JWT) standard, but the terms also
    /// correlate to concepts in other standards.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Auth {
        /// The authenticated principal. Reflects the issuer (`iss`) and subject
        /// (`sub`) claims within a JWT. The issuer and subject should be `/`
        /// delimited, with `/` percent-encoded within the subject fragment. For
        /// Google accounts, the principal format is:
        /// `https://accounts.google.com/{id}`
        pub principal: std::string::String,

        /// The intended audience(s) for this authentication information. Reflects
        /// the audience (`aud`) claim within a JWT. The audience
        /// value(s) depends on the `issuer`, but typically include one or more of
        /// the following pieces of information:
        ///
        /// * The services intended to receive the credential. For example,
        ///   [`https://pubsub.googleapis.com/`, `https://storage.googleapis.com/`].
        /// * A set of service-based scopes. For example,
        ///   [`https://www.googleapis.com/auth/cloud-platform`].
        /// * The client id of an app, such as the Firebase project id for JWTs
        ///   from Firebase Auth.
        ///
        /// Consult the documentation for the credential issuer to determine the
        /// information provided.
        pub audiences: std::vec::Vec<std::string::String>,

        /// The authorized presenter of the credential. Reflects the optional
        /// Authorized Presenter (`azp`) claim within a JWT or the
        /// OAuth client id. For example, a Google Cloud Platform client id looks
        /// as follows: "123456789012.apps.googleusercontent.com".
        pub presenter: std::string::String,

        /// Structured claims presented with the credential. JWTs include
        /// `{key: value}` pairs for standard and private claims. The following
        /// is a subset of the standard required and optional claims that would
        /// typically be presented for a Google-based JWT:
        ///
        /// {'iss': 'accounts.google.com',
        /// 'sub': '113289723416554971153',
        /// 'aud': ['123456789012', 'pubsub.googleapis.com'],
        /// 'azp': '123456789012.apps.googleusercontent.com',
        /// 'email': 'jsmith@example.com',
        /// 'iat': 1353601026,
        /// 'exp': 1353604926}
        ///
        /// SAML assertions are similarly specified, but with an identity provider
        /// dependent structure.
        pub claims: std::option::Option<wkt::Struct>,

        /// A list of access level resource names that allow resources to be
        /// accessed by authenticated requester. It is part of Secure GCP processing
        /// for the incoming request. An access level string has the format:
        /// "//{api_service_name}/accessPolicies/{policy_id}/accessLevels/{short_name}"
        ///
        /// Example:
        /// "//accesscontextmanager.googleapis.com/accessPolicies/MY_POLICY_ID/accessLevels/MY_LEVEL"
        pub access_levels: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Auth {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [principal][crate::model::attribute_context::Auth::principal].
        pub fn set_principal<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.principal = v.into();
            self
        }

        /// Sets the value of [audiences][crate::model::attribute_context::Auth::audiences].
        pub fn set_audiences<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.audiences = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [presenter][crate::model::attribute_context::Auth::presenter].
        pub fn set_presenter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.presenter = v.into();
            self
        }

        /// Sets the value of [claims][crate::model::attribute_context::Auth::claims].
        pub fn set_claims<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.claims = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [claims][crate::model::attribute_context::Auth::claims].
        pub fn set_or_clear_claims<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.claims = v.map(|x| x.into());
            self
        }

        /// Sets the value of [access_levels][crate::model::attribute_context::Auth::access_levels].
        pub fn set_access_levels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.access_levels = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Auth {
        fn typename() -> &'static str {
            "type.googleapis.com/google.rpc.context.AttributeContext.Auth"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Auth {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __principal,
                __audiences,
                __presenter,
                __claims,
                __access_levels,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Auth")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "principal" => Ok(__FieldTag::__principal),
                                "audiences" => Ok(__FieldTag::__audiences),
                                "presenter" => Ok(__FieldTag::__presenter),
                                "claims" => Ok(__FieldTag::__claims),
                                "accessLevels" => Ok(__FieldTag::__access_levels),
                                "access_levels" => Ok(__FieldTag::__access_levels),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Auth;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Auth")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__principal => {
                                if !fields.insert(__FieldTag::__principal) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for principal",
                                    ));
                                }
                                result.principal = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__audiences => {
                                if !fields.insert(__FieldTag::__audiences) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for audiences",
                                    ));
                                }
                                result.audiences = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__presenter => {
                                if !fields.insert(__FieldTag::__presenter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for presenter",
                                    ));
                                }
                                result.presenter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__claims => {
                                if !fields.insert(__FieldTag::__claims) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for claims",
                                    ));
                                }
                                result.claims =
                                    map.next_value::<std::option::Option<wkt::Struct>>()?;
                            }
                            __FieldTag::__access_levels => {
                                if !fields.insert(__FieldTag::__access_levels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for access_levels",
                                    ));
                                }
                                result.access_levels = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Auth {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.principal.is_empty() {
                state.serialize_entry("principal", &self.principal)?;
            }
            if !self.audiences.is_empty() {
                state.serialize_entry("audiences", &self.audiences)?;
            }
            if !self.presenter.is_empty() {
                state.serialize_entry("presenter", &self.presenter)?;
            }
            if self.claims.is_some() {
                state.serialize_entry("claims", &self.claims)?;
            }
            if !self.access_levels.is_empty() {
                state.serialize_entry("accessLevels", &self.access_levels)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// This message defines attributes for an HTTP request. If the actual
    /// request is not an HTTP request, the runtime system should try to map
    /// the actual request to an equivalent HTTP request.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Request {
        /// The unique ID for a request, which can be propagated to downstream
        /// systems. The ID should have low probability of collision
        /// within a single day for a specific service.
        pub id: std::string::String,

        /// The HTTP request method, such as `GET`, `POST`.
        pub method: std::string::String,

        /// The HTTP request headers. If multiple headers share the same key, they
        /// must be merged according to the HTTP spec. All header keys must be
        /// lowercased, because HTTP header keys are case-insensitive.
        pub headers: std::collections::HashMap<std::string::String, std::string::String>,

        /// The HTTP URL path, excluding the query parameters.
        pub path: std::string::String,

        /// The HTTP request `Host` header value.
        pub host: std::string::String,

        /// The HTTP URL scheme, such as `http` and `https`.
        pub scheme: std::string::String,

        /// The HTTP URL query in the format of `name1=value1&name2=value2`, as it
        /// appears in the first line of the HTTP request. No decoding is performed.
        pub query: std::string::String,

        /// The timestamp when the `destination` service receives the last byte of
        /// the request.
        pub time: std::option::Option<wkt::Timestamp>,

        /// The HTTP request size in bytes. If unknown, it must be -1.
        pub size: i64,

        /// The network protocol used with the request, such as "http/1.1",
        /// "spdy/3", "h2", "h2c", "webrtc", "tcp", "udp", "quic". See
        /// <https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids>
        /// for details.
        pub protocol: std::string::String,

        /// A special parameter for request reason. It is used by security systems
        /// to associate auditing information with a request.
        pub reason: std::string::String,

        /// The request authentication. May be absent for unauthenticated requests.
        /// Derived from the HTTP request `Authorization` header or equivalent.
        pub auth: std::option::Option<crate::model::attribute_context::Auth>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Request {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::attribute_context::Request::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [method][crate::model::attribute_context::Request::method].
        pub fn set_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.method = v.into();
            self
        }

        /// Sets the value of [headers][crate::model::attribute_context::Request::headers].
        pub fn set_headers<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [path][crate::model::attribute_context::Request::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [host][crate::model::attribute_context::Request::host].
        pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.host = v.into();
            self
        }

        /// Sets the value of [scheme][crate::model::attribute_context::Request::scheme].
        pub fn set_scheme<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.scheme = v.into();
            self
        }

        /// Sets the value of [query][crate::model::attribute_context::Request::query].
        pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.query = v.into();
            self
        }

        /// Sets the value of [time][crate::model::attribute_context::Request::time].
        pub fn set_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [time][crate::model::attribute_context::Request::time].
        pub fn set_or_clear_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [size][crate::model::attribute_context::Request::size].
        pub fn set_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.size = v.into();
            self
        }

        /// Sets the value of [protocol][crate::model::attribute_context::Request::protocol].
        pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.protocol = v.into();
            self
        }

        /// Sets the value of [reason][crate::model::attribute_context::Request::reason].
        pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.reason = v.into();
            self
        }

        /// Sets the value of [auth][crate::model::attribute_context::Request::auth].
        pub fn set_auth<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::attribute_context::Auth>,
        {
            self.auth = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [auth][crate::model::attribute_context::Request::auth].
        pub fn set_or_clear_auth<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::attribute_context::Auth>,
        {
            self.auth = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Request {
        fn typename() -> &'static str {
            "type.googleapis.com/google.rpc.context.AttributeContext.Request"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Request {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __method,
                __headers,
                __path,
                __host,
                __scheme,
                __query,
                __time,
                __size,
                __protocol,
                __reason,
                __auth,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Request")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "method" => Ok(__FieldTag::__method),
                                "headers" => Ok(__FieldTag::__headers),
                                "path" => Ok(__FieldTag::__path),
                                "host" => Ok(__FieldTag::__host),
                                "scheme" => Ok(__FieldTag::__scheme),
                                "query" => Ok(__FieldTag::__query),
                                "time" => Ok(__FieldTag::__time),
                                "size" => Ok(__FieldTag::__size),
                                "protocol" => Ok(__FieldTag::__protocol),
                                "reason" => Ok(__FieldTag::__reason),
                                "auth" => Ok(__FieldTag::__auth),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Request;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Request")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__method => {
                                if !fields.insert(__FieldTag::__method) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for method",
                                    ));
                                }
                                result.method = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__headers => {
                                if !fields.insert(__FieldTag::__headers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for headers",
                                    ));
                                }
                                result.headers = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__path => {
                                if !fields.insert(__FieldTag::__path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for path",
                                    ));
                                }
                                result.path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__host => {
                                if !fields.insert(__FieldTag::__host) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for host",
                                    ));
                                }
                                result.host = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__scheme => {
                                if !fields.insert(__FieldTag::__scheme) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for scheme",
                                    ));
                                }
                                result.scheme = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__query => {
                                if !fields.insert(__FieldTag::__query) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for query",
                                    ));
                                }
                                result.query = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__time => {
                                if !fields.insert(__FieldTag::__time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time",
                                    ));
                                }
                                result.time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__size => {
                                if !fields.insert(__FieldTag::__size) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for size",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.size = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__protocol => {
                                if !fields.insert(__FieldTag::__protocol) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for protocol",
                                    ));
                                }
                                result.protocol = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__reason => {
                                if !fields.insert(__FieldTag::__reason) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for reason",
                                    ));
                                }
                                result.reason = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__auth => {
                                if !fields.insert(__FieldTag::__auth) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for auth",
                                    ));
                                }
                                result.auth = map.next_value::<std::option::Option<crate::model::attribute_context::Auth>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Request {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.method.is_empty() {
                state.serialize_entry("method", &self.method)?;
            }
            if !self.headers.is_empty() {
                state.serialize_entry("headers", &self.headers)?;
            }
            if !self.path.is_empty() {
                state.serialize_entry("path", &self.path)?;
            }
            if !self.host.is_empty() {
                state.serialize_entry("host", &self.host)?;
            }
            if !self.scheme.is_empty() {
                state.serialize_entry("scheme", &self.scheme)?;
            }
            if !self.query.is_empty() {
                state.serialize_entry("query", &self.query)?;
            }
            if self.time.is_some() {
                state.serialize_entry("time", &self.time)?;
            }
            if !wkt::internal::is_default(&self.size) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("size", &__With(&self.size))?;
            }
            if !self.protocol.is_empty() {
                state.serialize_entry("protocol", &self.protocol)?;
            }
            if !self.reason.is_empty() {
                state.serialize_entry("reason", &self.reason)?;
            }
            if self.auth.is_some() {
                state.serialize_entry("auth", &self.auth)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// This message defines attributes for a typical network response. It
    /// generally models semantics of an HTTP response.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Response {
        /// The HTTP response status code, such as `200` and `404`.
        pub code: i64,

        /// The HTTP response size in bytes. If unknown, it must be -1.
        pub size: i64,

        /// The HTTP response headers. If multiple headers share the same key, they
        /// must be merged according to HTTP spec. All header keys must be
        /// lowercased, because HTTP header keys are case-insensitive.
        pub headers: std::collections::HashMap<std::string::String, std::string::String>,

        /// The timestamp when the `destination` service sends the last byte of
        /// the response.
        pub time: std::option::Option<wkt::Timestamp>,

        /// The amount of time it takes the backend service to fully respond to a
        /// request. Measured from when the destination service starts to send the
        /// request to the backend until when the destination service receives the
        /// complete response from the backend.
        pub backend_latency: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Response {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::attribute_context::Response::code].
        pub fn set_code<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.code = v.into();
            self
        }

        /// Sets the value of [size][crate::model::attribute_context::Response::size].
        pub fn set_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.size = v.into();
            self
        }

        /// Sets the value of [headers][crate::model::attribute_context::Response::headers].
        pub fn set_headers<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [time][crate::model::attribute_context::Response::time].
        pub fn set_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [time][crate::model::attribute_context::Response::time].
        pub fn set_or_clear_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [backend_latency][crate::model::attribute_context::Response::backend_latency].
        pub fn set_backend_latency<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.backend_latency = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [backend_latency][crate::model::attribute_context::Response::backend_latency].
        pub fn set_or_clear_backend_latency<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.backend_latency = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Response {
        fn typename() -> &'static str {
            "type.googleapis.com/google.rpc.context.AttributeContext.Response"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Response {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __code,
                __size,
                __headers,
                __time,
                __backend_latency,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Response")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "code" => Ok(__FieldTag::__code),
                                "size" => Ok(__FieldTag::__size),
                                "headers" => Ok(__FieldTag::__headers),
                                "time" => Ok(__FieldTag::__time),
                                "backendLatency" => Ok(__FieldTag::__backend_latency),
                                "backend_latency" => Ok(__FieldTag::__backend_latency),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Response;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Response")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__code => {
                                if !fields.insert(__FieldTag::__code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for code",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.code = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__size => {
                                if !fields.insert(__FieldTag::__size) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for size",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.size = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__headers => {
                                if !fields.insert(__FieldTag::__headers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for headers",
                                    ));
                                }
                                result.headers = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__time => {
                                if !fields.insert(__FieldTag::__time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time",
                                    ));
                                }
                                result.time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__backend_latency => {
                                if !fields.insert(__FieldTag::__backend_latency) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for backend_latency",
                                    ));
                                }
                                result.backend_latency =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Response {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.code) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("code", &__With(&self.code))?;
            }
            if !wkt::internal::is_default(&self.size) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("size", &__With(&self.size))?;
            }
            if !self.headers.is_empty() {
                state.serialize_entry("headers", &self.headers)?;
            }
            if self.time.is_some() {
                state.serialize_entry("time", &self.time)?;
            }
            if self.backend_latency.is_some() {
                state.serialize_entry("backendLatency", &self.backend_latency)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// This message defines core attributes for a resource. A resource is an
    /// addressable (named) entity provided by the destination service. For
    /// example, a file stored on a network storage service.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Resource {
        /// The name of the service that this resource belongs to, such as
        /// `pubsub.googleapis.com`. The service may be different from the DNS
        /// hostname that actually serves the request.
        pub service: std::string::String,

        /// The stable identifier (name) of a resource on the `service`. A resource
        /// can be logically identified as "//{resource.service}/{resource.name}".
        /// The differences between a resource name and a URI are:
        ///
        /// * Resource name is a logical identifier, independent of network
        ///   protocol and API version. For example,
        ///   `//pubsub.googleapis.com/projects/123/topics/news-feed`.
        /// * URI often includes protocol and version information, so it can
        ///   be used directly by applications. For example,
        ///   `<https://pubsub.googleapis.com/v1/projects/123/topics/news-feed>`.
        ///
        /// See <https://cloud.google.com/apis/design/resource_names> for details.
        pub name: std::string::String,

        /// The type of the resource. The syntax is platform-specific because
        /// different platforms define their resources differently.
        ///
        /// For Google APIs, the type format must be "{service}/{kind}", such as
        /// "pubsub.googleapis.com/Topic".
        pub r#type: std::string::String,

        /// The labels or tags on the resource, such as AWS resource tags and
        /// Kubernetes resource labels.
        pub labels: std::collections::HashMap<std::string::String, std::string::String>,

        /// The unique identifier of the resource. UID is unique in the time
        /// and space for this resource within the scope of the service. It is
        /// typically generated by the server on successful creation of a resource
        /// and must not be changed. UID is used to uniquely identify resources
        /// with resource name reuses. This should be a UUID4.
        pub uid: std::string::String,

        /// Annotations is an unstructured key-value map stored with a resource that
        /// may be set by external tools to store and retrieve arbitrary metadata.
        /// They are not queryable and should be preserved when modifying objects.
        ///
        /// More info:
        /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/>
        pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

        /// Mutable. The display name set by clients. Must be <= 63 characters.
        pub display_name: std::string::String,

        /// Output only. The timestamp when the resource was created. This may
        /// be either the time creation was initiated or when it was completed.
        pub create_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The timestamp when the resource was last updated. Any
        /// change to the resource made by users must refresh this value.
        /// Changes to a resource made by the service should refresh this value.
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The timestamp when the resource was deleted.
        /// If the resource is not deleted, this must be empty.
        pub delete_time: std::option::Option<wkt::Timestamp>,

        /// Output only. An opaque value that uniquely identifies a version or
        /// generation of a resource. It can be used to confirm that the client
        /// and server agree on the ordering of a resource being written.
        pub etag: std::string::String,

        /// Immutable. The location of the resource. The location encoding is
        /// specific to the service provider, and new encoding may be introduced
        /// as the service evolves.
        ///
        /// For Google Cloud products, the encoding is what is used by Google Cloud
        /// APIs, such as `us-east1`, `aws-us-east-1`, and `azure-eastus2`. The
        /// semantics of `location` is identical to the
        /// `cloud.googleapis.com/location` label used by some Google Cloud APIs.
        pub location: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Resource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service][crate::model::attribute_context::Resource::service].
        pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service = v.into();
            self
        }

        /// Sets the value of [name][crate::model::attribute_context::Resource::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::attribute_context::Resource::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [labels][crate::model::attribute_context::Resource::labels].
        pub fn set_labels<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [uid][crate::model::attribute_context::Resource::uid].
        pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uid = v.into();
            self
        }

        /// Sets the value of [annotations][crate::model::attribute_context::Resource::annotations].
        pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [display_name][crate::model::attribute_context::Resource::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [create_time][crate::model::attribute_context::Resource::create_time].
        pub fn set_create_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.create_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [create_time][crate::model::attribute_context::Resource::create_time].
        pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.create_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [update_time][crate::model::attribute_context::Resource::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::attribute_context::Resource::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [delete_time][crate::model::attribute_context::Resource::delete_time].
        pub fn set_delete_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.delete_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [delete_time][crate::model::attribute_context::Resource::delete_time].
        pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.delete_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [etag][crate::model::attribute_context::Resource::etag].
        pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.etag = v.into();
            self
        }

        /// Sets the value of [location][crate::model::attribute_context::Resource::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }
    }

    impl wkt::message::Message for Resource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.rpc.context.AttributeContext.Resource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Resource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __service,
                __name,
                __type,
                __labels,
                __uid,
                __annotations,
                __display_name,
                __create_time,
                __update_time,
                __delete_time,
                __etag,
                __location,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Resource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "service" => Ok(__FieldTag::__service),
                                "name" => Ok(__FieldTag::__name),
                                "type" => Ok(__FieldTag::__type),
                                "labels" => Ok(__FieldTag::__labels),
                                "uid" => Ok(__FieldTag::__uid),
                                "annotations" => Ok(__FieldTag::__annotations),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "createTime" => Ok(__FieldTag::__create_time),
                                "create_time" => Ok(__FieldTag::__create_time),
                                "updateTime" => Ok(__FieldTag::__update_time),
                                "update_time" => Ok(__FieldTag::__update_time),
                                "deleteTime" => Ok(__FieldTag::__delete_time),
                                "delete_time" => Ok(__FieldTag::__delete_time),
                                "etag" => Ok(__FieldTag::__etag),
                                "location" => Ok(__FieldTag::__location),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Resource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Resource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__service => {
                                if !fields.insert(__FieldTag::__service) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service",
                                    ));
                                }
                                result.service = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__labels => {
                                if !fields.insert(__FieldTag::__labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for labels",
                                    ));
                                }
                                result.labels = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__uid => {
                                if !fields.insert(__FieldTag::__uid) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uid",
                                    ));
                                }
                                result.uid = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__annotations => {
                                if !fields.insert(__FieldTag::__annotations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for annotations",
                                    ));
                                }
                                result.annotations = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__create_time => {
                                if !fields.insert(__FieldTag::__create_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for create_time",
                                    ));
                                }
                                result.create_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__update_time => {
                                if !fields.insert(__FieldTag::__update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_time",
                                    ));
                                }
                                result.update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__delete_time => {
                                if !fields.insert(__FieldTag::__delete_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for delete_time",
                                    ));
                                }
                                result.delete_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__etag => {
                                if !fields.insert(__FieldTag::__etag) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for etag",
                                    ));
                                }
                                result.etag = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__location => {
                                if !fields.insert(__FieldTag::__location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for location",
                                    ));
                                }
                                result.location = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Resource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.service.is_empty() {
                state.serialize_entry("service", &self.service)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.r#type.is_empty() {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self.labels.is_empty() {
                state.serialize_entry("labels", &self.labels)?;
            }
            if !self.uid.is_empty() {
                state.serialize_entry("uid", &self.uid)?;
            }
            if !self.annotations.is_empty() {
                state.serialize_entry("annotations", &self.annotations)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if self.create_time.is_some() {
                state.serialize_entry("createTime", &self.create_time)?;
            }
            if self.update_time.is_some() {
                state.serialize_entry("updateTime", &self.update_time)?;
            }
            if self.delete_time.is_some() {
                state.serialize_entry("deleteTime", &self.delete_time)?;
            }
            if !self.etag.is_empty() {
                state.serialize_entry("etag", &self.etag)?;
            }
            if !self.location.is_empty() {
                state.serialize_entry("location", &self.location)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// `AuditContext` provides information that is needed for audit logging.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AuditContext {
    /// Serialized audit log.
    pub audit_log: ::bytes::Bytes,

    /// An API request message that is scrubbed based on the method annotation.
    /// This field should only be filled if audit_log field is present.
    /// Service Control will use this to assemble a complete log for Cloud Audit
    /// Logs and Google internal audit logs.
    pub scrubbed_request: std::option::Option<wkt::Struct>,

    /// An API response message that is scrubbed based on the method annotation.
    /// This field should only be filled if audit_log field is present.
    /// Service Control will use this to assemble a complete log for Cloud Audit
    /// Logs and Google internal audit logs.
    pub scrubbed_response: std::option::Option<wkt::Struct>,

    /// Number of scrubbed response items.
    pub scrubbed_response_item_count: i32,

    /// Audit resource name which is scrubbed.
    pub target_resource: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuditContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audit_log][crate::model::AuditContext::audit_log].
    pub fn set_audit_log<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.audit_log = v.into();
        self
    }

    /// Sets the value of [scrubbed_request][crate::model::AuditContext::scrubbed_request].
    pub fn set_scrubbed_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.scrubbed_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scrubbed_request][crate::model::AuditContext::scrubbed_request].
    pub fn set_or_clear_scrubbed_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.scrubbed_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scrubbed_response][crate::model::AuditContext::scrubbed_response].
    pub fn set_scrubbed_response<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.scrubbed_response = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scrubbed_response][crate::model::AuditContext::scrubbed_response].
    pub fn set_or_clear_scrubbed_response<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.scrubbed_response = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scrubbed_response_item_count][crate::model::AuditContext::scrubbed_response_item_count].
    pub fn set_scrubbed_response_item_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scrubbed_response_item_count = v.into();
        self
    }

    /// Sets the value of [target_resource][crate::model::AuditContext::target_resource].
    pub fn set_target_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_resource = v.into();
        self
    }
}

impl wkt::message::Message for AuditContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.rpc.context.AuditContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AuditContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audit_log,
            __scrubbed_request,
            __scrubbed_response,
            __scrubbed_response_item_count,
            __target_resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuditContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "auditLog" => Ok(__FieldTag::__audit_log),
                            "audit_log" => Ok(__FieldTag::__audit_log),
                            "scrubbedRequest" => Ok(__FieldTag::__scrubbed_request),
                            "scrubbed_request" => Ok(__FieldTag::__scrubbed_request),
                            "scrubbedResponse" => Ok(__FieldTag::__scrubbed_response),
                            "scrubbed_response" => Ok(__FieldTag::__scrubbed_response),
                            "scrubbedResponseItemCount" => {
                                Ok(__FieldTag::__scrubbed_response_item_count)
                            }
                            "scrubbed_response_item_count" => {
                                Ok(__FieldTag::__scrubbed_response_item_count)
                            }
                            "targetResource" => Ok(__FieldTag::__target_resource),
                            "target_resource" => Ok(__FieldTag::__target_resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AuditContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuditContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audit_log => {
                            if !fields.insert(__FieldTag::__audit_log) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audit_log",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audit_log = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scrubbed_request => {
                            if !fields.insert(__FieldTag::__scrubbed_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scrubbed_request",
                                ));
                            }
                            result.scrubbed_request =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__scrubbed_response => {
                            if !fields.insert(__FieldTag::__scrubbed_response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scrubbed_response",
                                ));
                            }
                            result.scrubbed_response =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__scrubbed_response_item_count => {
                            if !fields.insert(__FieldTag::__scrubbed_response_item_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scrubbed_response_item_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scrubbed_response_item_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__target_resource => {
                            if !fields.insert(__FieldTag::__target_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_resource",
                                ));
                            }
                            result.target_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AuditContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.audit_log.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("auditLog", &__With(&self.audit_log))?;
        }
        if self.scrubbed_request.is_some() {
            state.serialize_entry("scrubbedRequest", &self.scrubbed_request)?;
        }
        if self.scrubbed_response.is_some() {
            state.serialize_entry("scrubbedResponse", &self.scrubbed_response)?;
        }
        if !wkt::internal::is_default(&self.scrubbed_response_item_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "scrubbedResponseItemCount",
                &__With(&self.scrubbed_response_item_count),
            )?;
        }
        if !self.target_resource.is_empty() {
            state.serialize_entry("targetResource", &self.target_resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
