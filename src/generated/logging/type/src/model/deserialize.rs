// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HttpRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __request_method,
            __request_url,
            __request_size,
            __status,
            __response_size,
            __user_agent,
            __remote_ip,
            __server_ip,
            __referer,
            __latency,
            __cache_lookup,
            __cache_hit,
            __cache_validated_with_origin_server,
            __cache_fill_bytes,
            __protocol,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HttpRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requestMethod" => Ok(__FieldTag::__request_method),
                            "request_method" => Ok(__FieldTag::__request_method),
                            "requestUrl" => Ok(__FieldTag::__request_url),
                            "request_url" => Ok(__FieldTag::__request_url),
                            "requestSize" => Ok(__FieldTag::__request_size),
                            "request_size" => Ok(__FieldTag::__request_size),
                            "status" => Ok(__FieldTag::__status),
                            "responseSize" => Ok(__FieldTag::__response_size),
                            "response_size" => Ok(__FieldTag::__response_size),
                            "userAgent" => Ok(__FieldTag::__user_agent),
                            "user_agent" => Ok(__FieldTag::__user_agent),
                            "remoteIp" => Ok(__FieldTag::__remote_ip),
                            "remote_ip" => Ok(__FieldTag::__remote_ip),
                            "serverIp" => Ok(__FieldTag::__server_ip),
                            "server_ip" => Ok(__FieldTag::__server_ip),
                            "referer" => Ok(__FieldTag::__referer),
                            "latency" => Ok(__FieldTag::__latency),
                            "cacheLookup" => Ok(__FieldTag::__cache_lookup),
                            "cache_lookup" => Ok(__FieldTag::__cache_lookup),
                            "cacheHit" => Ok(__FieldTag::__cache_hit),
                            "cache_hit" => Ok(__FieldTag::__cache_hit),
                            "cacheValidatedWithOriginServer" => Ok(__FieldTag::__cache_validated_with_origin_server),
                            "cache_validated_with_origin_server" => Ok(__FieldTag::__cache_validated_with_origin_server),
                            "cacheFillBytes" => Ok(__FieldTag::__cache_fill_bytes),
                            "cache_fill_bytes" => Ok(__FieldTag::__cache_fill_bytes),
                            "protocol" => Ok(__FieldTag::__protocol),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HttpRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HttpRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__request_method => {
                            if !fields.insert(__FieldTag::__request_method) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for request_method"));
                            }
                            result.request_method = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__request_url => {
                            if !fields.insert(__FieldTag::__request_url) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for request_url"));
                            }
                            result.request_url = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__request_size => {
                            if !fields.insert(__FieldTag::__request_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for request_size"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.request_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for status"));
                            }
                            struct __With( std::option::Option<i32> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.status = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__response_size => {
                            if !fields.insert(__FieldTag::__response_size) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for response_size"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.response_size = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__user_agent => {
                            if !fields.insert(__FieldTag::__user_agent) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for user_agent"));
                            }
                            result.user_agent = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__remote_ip => {
                            if !fields.insert(__FieldTag::__remote_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for remote_ip"));
                            }
                            result.remote_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__server_ip => {
                            if !fields.insert(__FieldTag::__server_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for server_ip"));
                            }
                            result.server_ip = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__referer => {
                            if !fields.insert(__FieldTag::__referer) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for referer"));
                            }
                            result.referer = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::__latency => {
                            if !fields.insert(__FieldTag::__latency) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for latency"));
                            }
                            result.latency = map.next_value::<std::option::Option<wkt::Duration>>()?
                                ;
                        },
                        __FieldTag::__cache_lookup => {
                            if !fields.insert(__FieldTag::__cache_lookup) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cache_lookup"));
                            }
                            result.cache_lookup = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__cache_hit => {
                            if !fields.insert(__FieldTag::__cache_hit) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cache_hit"));
                            }
                            result.cache_hit = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__cache_validated_with_origin_server => {
                            if !fields.insert(__FieldTag::__cache_validated_with_origin_server) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cache_validated_with_origin_server"));
                            }
                            result.cache_validated_with_origin_server = map.next_value::<std::option::Option<bool>>()?.unwrap_or_default();
                        },
                        __FieldTag::__cache_fill_bytes => {
                            if !fields.insert(__FieldTag::__cache_fill_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for cache_fill_bytes"));
                            }
                            struct __With( std::option::Option<i64> );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cache_fill_bytes = map.next_value::< __With >()?.0.unwrap_or_default();
                        },
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for protocol"));
                            }
                            result.protocol = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
