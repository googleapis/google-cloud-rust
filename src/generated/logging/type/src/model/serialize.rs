// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl serde::ser::Serialize for super::HttpRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.request_method.is_empty() {
            state.serialize_entry("requestMethod", &self.request_method)?;
        }
        if !self.request_url.is_empty() {
            state.serialize_entry("requestUrl", &self.request_url)?;
        }
        if !wkt::internal::is_default(&self.request_size) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("requestSize", &__With(&self.request_size))?;
        }
        if !wkt::internal::is_default(&self.status) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("status", &__With(&self.status))?;
        }
        if !wkt::internal::is_default(&self.response_size) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("responseSize", &__With(&self.response_size))?;
        }
        if !self.user_agent.is_empty() {
            state.serialize_entry("userAgent", &self.user_agent)?;
        }
        if !self.remote_ip.is_empty() {
            state.serialize_entry("remoteIp", &self.remote_ip)?;
        }
        if !self.server_ip.is_empty() {
            state.serialize_entry("serverIp", &self.server_ip)?;
        }
        if !self.referer.is_empty() {
            state.serialize_entry("referer", &self.referer)?;
        }
        if self.latency.is_some() {
            state.serialize_entry("latency", &self.latency)?;
        }
        if !wkt::internal::is_default(&self.cache_lookup) {
            state.serialize_entry("cacheLookup", &self.cache_lookup)?;
        }
        if !wkt::internal::is_default(&self.cache_hit) {
            state.serialize_entry("cacheHit", &self.cache_hit)?;
        }
        if !wkt::internal::is_default(&self.cache_validated_with_origin_server) {
            state.serialize_entry(
                "cacheValidatedWithOriginServer",
                &self.cache_validated_with_origin_server,
            )?;
        }
        if !wkt::internal::is_default(&self.cache_fill_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cacheFillBytes", &__With(&self.cache_fill_bytes))?;
        }
        if !self.protocol.is_empty() {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
