// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate logging_type;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// An individual entry in a log.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogEntry {
    /// Required. The resource name of the log to which this log entry belongs:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/logs/[LOG_ID]"
    /// "organizations/[ORGANIZATION_ID]/logs/[LOG_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]"
    /// "folders/[FOLDER_ID]/logs/[LOG_ID]"
    /// ```
    ///
    /// A project number may be used in place of PROJECT_ID. The project number is
    /// translated to its corresponding PROJECT_ID internally and the `log_name`
    /// field will contain PROJECT_ID in queries and exports.
    ///
    /// `[LOG_ID]` must be URL-encoded within `log_name`. Example:
    /// `"organizations/1234567890/logs/cloudresourcemanager.googleapis.com%2Factivity"`.
    ///
    /// `[LOG_ID]` must be less than 512 characters long and can only include the
    /// following characters: upper and lower case alphanumeric characters,
    /// forward-slash, underscore, hyphen, and period.
    ///
    /// For backward compatibility, if `log_name` begins with a forward-slash, such
    /// as `/projects/...`, then the log entry is ingested as usual, but the
    /// forward-slash is removed. Listing the log entry will not show the leading
    /// slash and filtering for a log name with a leading slash will never return
    /// any results.
    pub log_name: std::string::String,

    /// Required. The monitored resource that produced this log entry.
    ///
    /// Example: a log entry that reports a database error would be associated with
    /// the monitored resource designating the particular database that reported
    /// the error.
    pub resource: std::option::Option<api::model::MonitoredResource>,

    /// Optional. The time the event described by the log entry occurred. This time
    /// is used to compute the log entry's age and to enforce the logs retention
    /// period. If this field is omitted in a new log entry, then Logging assigns
    /// it the current time. Timestamps have nanosecond accuracy, but trailing
    /// zeros in the fractional seconds might be omitted when the timestamp is
    /// displayed.
    ///
    /// Incoming log entries must have timestamps that don't exceed the
    /// [logs retention
    /// period](https://cloud.google.com/logging/quotas#logs_retention_periods) in
    /// the past, and that don't exceed 24 hours in the future. Log entries outside
    /// those time boundaries aren't ingested by Logging.
    pub timestamp: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the log entry was received by Logging.
    pub receive_timestamp: std::option::Option<wkt::Timestamp>,

    /// Optional. The severity of the log entry. The default value is
    /// `LogSeverity.DEFAULT`.
    pub severity: logging_type::model::LogSeverity,

    /// Optional. A unique identifier for the log entry. If you provide a value,
    /// then Logging considers other log entries in the same project, with the same
    /// `timestamp`, and with the same `insert_id` to be duplicates which are
    /// removed in a single query result. However, there are no guarantees of
    /// de-duplication in the export of logs.
    ///
    /// If the `insert_id` is omitted when writing a log entry, the Logging API
    /// assigns its own unique identifier in this field.
    ///
    /// In queries, the `insert_id` is also used to order log entries that have
    /// the same `log_name` and `timestamp` values.
    pub insert_id: std::string::String,

    /// Optional. Information about the HTTP request associated with this log
    /// entry, if applicable.
    pub http_request: std::option::Option<logging_type::model::HttpRequest>,

    /// Optional. A map of key, value pairs that provides additional information
    /// about the log entry. The labels can be user-defined or system-defined.
    ///
    /// User-defined labels are arbitrary key, value pairs that you can use to
    /// classify logs.
    ///
    /// System-defined labels are defined by GCP services for platform logs.
    /// They have two components - a service namespace component and the
    /// attribute name. For example: `compute.googleapis.com/resource_name`.
    ///
    /// Cloud Logging truncates label keys that exceed 512 B and label
    /// values that exceed 64 KB upon their associated log entry being
    /// written. The truncation is indicated by an ellipsis at the
    /// end of the character string.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Information about an operation associated with the log entry, if
    /// applicable.
    pub operation: std::option::Option<crate::model::LogEntryOperation>,

    /// Optional. The REST resource name of the trace being written to
    /// [Cloud Trace](https://cloud.google.com/trace) in
    /// association with this log entry. For example, if your trace data is stored
    /// in the Cloud project "my-trace-project" and if the service that is creating
    /// the log entry receives a trace header that includes the trace ID "12345",
    /// then the service should use "projects/my-tracing-project/traces/12345".
    ///
    /// The `trace` field provides the link between logs and traces. By using
    /// this field, you can navigate from a log entry to a trace.
    pub trace: std::string::String,

    /// Optional. The ID of the [Cloud Trace](https://cloud.google.com/trace) span
    /// associated with the current operation in which the log is being written.
    /// For example, if a span has the REST resource name of
    /// "projects/some-project/traces/some-trace/spans/some-span-id", then the
    /// `span_id` field is "some-span-id".
    ///
    /// A
    /// [Span](https://cloud.google.com/trace/docs/reference/v2/rest/v2/projects.traces/batchWrite#Span)
    /// represents a single operation within a trace. Whereas a trace may involve
    /// multiple different microservices running on multiple different machines,
    /// a span generally corresponds to a single logical operation being performed
    /// in a single instance of a microservice on one specific machine. Spans
    /// are the nodes within the tree that is a trace.
    ///
    /// Applications that are [instrumented for
    /// tracing](https://cloud.google.com/trace/docs/setup) will generally assign a
    /// new, unique span ID on each incoming request. It is also common to create
    /// and record additional spans corresponding to internal processing elements
    /// as well as issuing requests to dependencies.
    ///
    /// The span ID is expected to be a 16-character, hexadecimal encoding of an
    /// 8-byte array and should not be zero. It should be unique within the trace
    /// and should, ideally, be generated in a manner that is uniformly random.
    ///
    /// Example values:
    ///
    /// - `000000000000004a`
    /// - `7a2190356c3fc94b`
    /// - `0000f00300090021`
    /// - `d39223e101960076`
    pub span_id: std::string::String,

    /// Optional. The sampling decision of the trace associated with the log entry.
    ///
    /// True means that the trace resource name in the `trace` field was sampled
    /// for storage in a trace backend. False means that the trace was not sampled
    /// for storage when this log entry was written, or the sampling decision was
    /// unknown at the time. A non-sampled `trace` value is still useful as a
    /// request correlation identifier. The default is False.
    pub trace_sampled: bool,

    /// Optional. Source code location information associated with the log entry,
    /// if any.
    pub source_location: std::option::Option<crate::model::LogEntrySourceLocation>,

    /// Optional. Information indicating this LogEntry is part of a sequence of
    /// multiple log entries split from a single LogEntry.
    pub split: std::option::Option<crate::model::LogSplit>,

    /// The log entry payload, which can be one of multiple types.
    pub payload: std::option::Option<crate::model::log_entry::Payload>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_name][crate::model::LogEntry::log_name].
    pub fn set_log_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_name = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::LogEntry::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::MonitoredResource>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::LogEntry::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::MonitoredResource>,
    {
        self.resource = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timestamp][crate::model::LogEntry::timestamp].
    pub fn set_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timestamp][crate::model::LogEntry::timestamp].
    pub fn set_or_clear_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [receive_timestamp][crate::model::LogEntry::receive_timestamp].
    pub fn set_receive_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.receive_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [receive_timestamp][crate::model::LogEntry::receive_timestamp].
    pub fn set_or_clear_receive_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.receive_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [severity][crate::model::LogEntry::severity].
    pub fn set_severity<T: std::convert::Into<logging_type::model::LogSeverity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [insert_id][crate::model::LogEntry::insert_id].
    pub fn set_insert_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.insert_id = v.into();
        self
    }

    /// Sets the value of [http_request][crate::model::LogEntry::http_request].
    pub fn set_http_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<logging_type::model::HttpRequest>,
    {
        self.http_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [http_request][crate::model::LogEntry::http_request].
    pub fn set_or_clear_http_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<logging_type::model::HttpRequest>,
    {
        self.http_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::LogEntry::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [operation][crate::model::LogEntry::operation].
    pub fn set_operation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogEntryOperation>,
    {
        self.operation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [operation][crate::model::LogEntry::operation].
    pub fn set_or_clear_operation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogEntryOperation>,
    {
        self.operation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [trace][crate::model::LogEntry::trace].
    pub fn set_trace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace = v.into();
        self
    }

    /// Sets the value of [span_id][crate::model::LogEntry::span_id].
    pub fn set_span_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.span_id = v.into();
        self
    }

    /// Sets the value of [trace_sampled][crate::model::LogEntry::trace_sampled].
    pub fn set_trace_sampled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.trace_sampled = v.into();
        self
    }

    /// Sets the value of [source_location][crate::model::LogEntry::source_location].
    pub fn set_source_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogEntrySourceLocation>,
    {
        self.source_location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_location][crate::model::LogEntry::source_location].
    pub fn set_or_clear_source_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogEntrySourceLocation>,
    {
        self.source_location = v.map(|x| x.into());
        self
    }

    /// Sets the value of [split][crate::model::LogEntry::split].
    pub fn set_split<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogSplit>,
    {
        self.split = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [split][crate::model::LogEntry::split].
    pub fn set_or_clear_split<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogSplit>,
    {
        self.split = v.map(|x| x.into());
        self
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload].
    ///
    /// Note that all the setters affecting `payload` are mutually
    /// exclusive.
    pub fn set_payload<
        T: std::convert::Into<std::option::Option<crate::model::log_entry::Payload>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }

    /// The value of [payload][crate::model::LogEntry::payload]
    /// if it holds a `ProtoPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn proto_payload(&self) -> std::option::Option<&std::boxed::Box<wkt::Any>> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::model::log_entry::Payload::ProtoPayload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload]
    /// to hold a `ProtoPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_proto_payload<T: std::convert::Into<std::boxed::Box<wkt::Any>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload =
            std::option::Option::Some(crate::model::log_entry::Payload::ProtoPayload(v.into()));
        self
    }

    /// The value of [payload][crate::model::LogEntry::payload]
    /// if it holds a `TextPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::model::log_entry::Payload::TextPayload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload]
    /// to hold a `TextPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_text_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload =
            std::option::Option::Some(crate::model::log_entry::Payload::TextPayload(v.into()));
        self
    }

    /// The value of [payload][crate::model::LogEntry::payload]
    /// if it holds a `JsonPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json_payload(&self) -> std::option::Option<&std::boxed::Box<wkt::Struct>> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::model::log_entry::Payload::JsonPayload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload]
    /// to hold a `JsonPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_json_payload<T: std::convert::Into<std::boxed::Box<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload =
            std::option::Option::Some(crate::model::log_entry::Payload::JsonPayload(v.into()));
        self
    }
}

impl wkt::message::Message for LogEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_name,
            __resource,
            __proto_payload,
            __text_payload,
            __json_payload,
            __timestamp,
            __receive_timestamp,
            __severity,
            __insert_id,
            __http_request,
            __labels,
            __operation,
            __trace,
            __span_id,
            __trace_sampled,
            __source_location,
            __split,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logName" => Ok(__FieldTag::__log_name),
                            "log_name" => Ok(__FieldTag::__log_name),
                            "resource" => Ok(__FieldTag::__resource),
                            "protoPayload" => Ok(__FieldTag::__proto_payload),
                            "proto_payload" => Ok(__FieldTag::__proto_payload),
                            "textPayload" => Ok(__FieldTag::__text_payload),
                            "text_payload" => Ok(__FieldTag::__text_payload),
                            "jsonPayload" => Ok(__FieldTag::__json_payload),
                            "json_payload" => Ok(__FieldTag::__json_payload),
                            "timestamp" => Ok(__FieldTag::__timestamp),
                            "receiveTimestamp" => Ok(__FieldTag::__receive_timestamp),
                            "receive_timestamp" => Ok(__FieldTag::__receive_timestamp),
                            "severity" => Ok(__FieldTag::__severity),
                            "insertId" => Ok(__FieldTag::__insert_id),
                            "insert_id" => Ok(__FieldTag::__insert_id),
                            "httpRequest" => Ok(__FieldTag::__http_request),
                            "http_request" => Ok(__FieldTag::__http_request),
                            "labels" => Ok(__FieldTag::__labels),
                            "operation" => Ok(__FieldTag::__operation),
                            "trace" => Ok(__FieldTag::__trace),
                            "spanId" => Ok(__FieldTag::__span_id),
                            "span_id" => Ok(__FieldTag::__span_id),
                            "traceSampled" => Ok(__FieldTag::__trace_sampled),
                            "trace_sampled" => Ok(__FieldTag::__trace_sampled),
                            "sourceLocation" => Ok(__FieldTag::__source_location),
                            "source_location" => Ok(__FieldTag::__source_location),
                            "split" => Ok(__FieldTag::__split),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_name => {
                            if !fields.insert(__FieldTag::__log_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_name",
                                ));
                            }
                            result.log_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<api::model::MonitoredResource>>(
                                )?;
                        }
                        __FieldTag::__proto_payload => {
                            if !fields.insert(__FieldTag::__proto_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proto_payload",
                                ));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .google.logging.v2.LogEntry.proto_payload, latest field was protoPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::model::log_entry::Payload::ProtoPayload(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Any>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__text_payload => {
                            if !fields.insert(__FieldTag::__text_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_payload",
                                ));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .google.logging.v2.LogEntry.text_payload, latest field was textPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::model::log_entry::Payload::TextPayload(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__json_payload => {
                            if !fields.insert(__FieldTag::__json_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for json_payload",
                                ));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .google.logging.v2.LogEntry.json_payload, latest field was jsonPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::model::log_entry::Payload::JsonPayload(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Struct>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__timestamp => {
                            if !fields.insert(__FieldTag::__timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp",
                                ));
                            }
                            result.timestamp =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__receive_timestamp => {
                            if !fields.insert(__FieldTag::__receive_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for receive_timestamp",
                                ));
                            }
                            result.receive_timestamp =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map.next_value::<std::option::Option<logging_type::model::LogSeverity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__insert_id => {
                            if !fields.insert(__FieldTag::__insert_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insert_id",
                                ));
                            }
                            result.insert_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__http_request => {
                            if !fields.insert(__FieldTag::__http_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_request",
                                ));
                            }
                            result.http_request = map.next_value::<std::option::Option<logging_type::model::HttpRequest>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation = map
                                .next_value::<std::option::Option<crate::model::LogEntryOperation>>(
                                )?;
                        }
                        __FieldTag::__trace => {
                            if !fields.insert(__FieldTag::__trace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trace",
                                ));
                            }
                            result.trace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__span_id => {
                            if !fields.insert(__FieldTag::__span_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for span_id",
                                ));
                            }
                            result.span_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trace_sampled => {
                            if !fields.insert(__FieldTag::__trace_sampled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trace_sampled",
                                ));
                            }
                            result.trace_sampled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_location => {
                            if !fields.insert(__FieldTag::__source_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_location",
                                ));
                            }
                            result.source_location = map.next_value::<std::option::Option<crate::model::LogEntrySourceLocation>>()?
                                ;
                        }
                        __FieldTag::__split => {
                            if !fields.insert(__FieldTag::__split) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for split",
                                ));
                            }
                            result.split =
                                map.next_value::<std::option::Option<crate::model::LogSplit>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.log_name.is_empty() {
            state.serialize_entry("logName", &self.log_name)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if let Some(value) = self.proto_payload() {
            state.serialize_entry("protoPayload", value)?;
        }
        if let Some(value) = self.text_payload() {
            state.serialize_entry("textPayload", value)?;
        }
        if let Some(value) = self.json_payload() {
            state.serialize_entry("jsonPayload", value)?;
        }
        if self.timestamp.is_some() {
            state.serialize_entry("timestamp", &self.timestamp)?;
        }
        if self.receive_timestamp.is_some() {
            state.serialize_entry("receiveTimestamp", &self.receive_timestamp)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.insert_id.is_empty() {
            state.serialize_entry("insertId", &self.insert_id)?;
        }
        if self.http_request.is_some() {
            state.serialize_entry("httpRequest", &self.http_request)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.operation.is_some() {
            state.serialize_entry("operation", &self.operation)?;
        }
        if !self.trace.is_empty() {
            state.serialize_entry("trace", &self.trace)?;
        }
        if !self.span_id.is_empty() {
            state.serialize_entry("spanId", &self.span_id)?;
        }
        if !wkt::internal::is_default(&self.trace_sampled) {
            state.serialize_entry("traceSampled", &self.trace_sampled)?;
        }
        if self.source_location.is_some() {
            state.serialize_entry("sourceLocation", &self.source_location)?;
        }
        if self.split.is_some() {
            state.serialize_entry("split", &self.split)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LogEntry].
pub mod log_entry {
    #[allow(unused_imports)]
    use super::*;

    /// The log entry payload, which can be one of multiple types.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Payload {
        /// The log entry payload, represented as a protocol buffer. Some Google
        /// Cloud Platform services use this field for their log entry payloads.
        ///
        /// The following protocol buffer types are supported; user-defined types
        /// are not supported:
        ///
        /// "type.googleapis.com/google.cloud.audit.AuditLog"
        /// "type.googleapis.com/google.appengine.logging.v1.RequestLog"
        ProtoPayload(std::boxed::Box<wkt::Any>),
        /// The log entry payload, represented as a Unicode string (UTF-8).
        TextPayload(std::string::String),
        /// The log entry payload, represented as a structure that is
        /// expressed as a JSON object.
        JsonPayload(std::boxed::Box<wkt::Struct>),
    }
}

/// Additional information about a potentially long-running operation with which
/// a log entry is associated.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogEntryOperation {
    /// Optional. An arbitrary operation identifier. Log entries with the same
    /// identifier are assumed to be part of the same operation.
    pub id: std::string::String,

    /// Optional. An arbitrary producer identifier. The combination of `id` and
    /// `producer` must be globally unique. Examples for `producer`:
    /// `"MyDivision.MyBigCompany.com"`, `"github.com/MyProject/MyApplication"`.
    pub producer: std::string::String,

    /// Optional. Set this to True if this is the first log entry in the operation.
    pub first: bool,

    /// Optional. Set this to True if this is the last log entry in the operation.
    pub last: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogEntryOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::LogEntryOperation::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [producer][crate::model::LogEntryOperation::producer].
    pub fn set_producer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.producer = v.into();
        self
    }

    /// Sets the value of [first][crate::model::LogEntryOperation::first].
    pub fn set_first<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.first = v.into();
        self
    }

    /// Sets the value of [last][crate::model::LogEntryOperation::last].
    pub fn set_last<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.last = v.into();
        self
    }
}

impl wkt::message::Message for LogEntryOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogEntryOperation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogEntryOperation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __producer,
            __first,
            __last,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogEntryOperation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "producer" => Ok(__FieldTag::__producer),
                            "first" => Ok(__FieldTag::__first),
                            "last" => Ok(__FieldTag::__last),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogEntryOperation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogEntryOperation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__producer => {
                            if !fields.insert(__FieldTag::__producer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for producer",
                                ));
                            }
                            result.producer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__first => {
                            if !fields.insert(__FieldTag::__first) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for first",
                                ));
                            }
                            result.first = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last => {
                            if !fields.insert(__FieldTag::__last) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last",
                                ));
                            }
                            result.last = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogEntryOperation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.producer.is_empty() {
            state.serialize_entry("producer", &self.producer)?;
        }
        if !wkt::internal::is_default(&self.first) {
            state.serialize_entry("first", &self.first)?;
        }
        if !wkt::internal::is_default(&self.last) {
            state.serialize_entry("last", &self.last)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Additional information about the source code location that produced the log
/// entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogEntrySourceLocation {
    /// Optional. Source file name. Depending on the runtime environment, this
    /// might be a simple name or a fully-qualified name.
    pub file: std::string::String,

    /// Optional. Line within the source file. 1-based; 0 indicates no line number
    /// available.
    pub line: i64,

    /// Optional. Human-readable name of the function or method being invoked, with
    /// optional context such as the class or package name. This information may be
    /// used in contexts such as the logs viewer, where a file and line number are
    /// less meaningful. The format can vary by language. For example:
    /// `qual.if.ied.Class.method` (Java), `dir/package.func` (Go), `function`
    /// (Python).
    pub function: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogEntrySourceLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file][crate::model::LogEntrySourceLocation::file].
    pub fn set_file<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file = v.into();
        self
    }

    /// Sets the value of [line][crate::model::LogEntrySourceLocation::line].
    pub fn set_line<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.line = v.into();
        self
    }

    /// Sets the value of [function][crate::model::LogEntrySourceLocation::function].
    pub fn set_function<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.function = v.into();
        self
    }
}

impl wkt::message::Message for LogEntrySourceLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogEntrySourceLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogEntrySourceLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file,
            __line,
            __function,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogEntrySourceLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "file" => Ok(__FieldTag::__file),
                            "line" => Ok(__FieldTag::__line),
                            "function" => Ok(__FieldTag::__function),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogEntrySourceLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogEntrySourceLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file => {
                            if !fields.insert(__FieldTag::__file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file",
                                ));
                            }
                            result.file = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__line => {
                            if !fields.insert(__FieldTag::__line) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for line",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.line = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__function => {
                            if !fields.insert(__FieldTag::__function) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for function",
                                ));
                            }
                            result.function = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogEntrySourceLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file.is_empty() {
            state.serialize_entry("file", &self.file)?;
        }
        if !wkt::internal::is_default(&self.line) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("line", &__With(&self.line))?;
        }
        if !self.function.is_empty() {
            state.serialize_entry("function", &self.function)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Additional information used to correlate multiple log entries. Used when a
/// single LogEntry would exceed the Google Cloud Logging size limit and is
/// split across multiple log entries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogSplit {
    /// A globally unique identifier for all log entries in a sequence of split log
    /// entries. All log entries with the same |LogSplit.uid| are assumed to be
    /// part of the same sequence of split log entries.
    pub uid: std::string::String,

    /// The index of this LogEntry in the sequence of split log entries. Log
    /// entries are given |index| values 0, 1, ..., n-1 for a sequence of n log
    /// entries.
    pub index: i32,

    /// The total number of log entries that the original LogEntry was split into.
    pub total_splits: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uid][crate::model::LogSplit::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [index][crate::model::LogSplit::index].
    pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [total_splits][crate::model::LogSplit::total_splits].
    pub fn set_total_splits<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_splits = v.into();
        self
    }
}

impl wkt::message::Message for LogSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogSplit"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogSplit {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uid,
            __index,
            __total_splits,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogSplit")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uid" => Ok(__FieldTag::__uid),
                            "index" => Ok(__FieldTag::__index),
                            "totalSplits" => Ok(__FieldTag::__total_splits),
                            "total_splits" => Ok(__FieldTag::__total_splits),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogSplit;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogSplit")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__index => {
                            if !fields.insert(__FieldTag::__index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.index = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_splits => {
                            if !fields.insert(__FieldTag::__total_splits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_splits",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_splits = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogSplit {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("index", &__With(&self.index))?;
        }
        if !wkt::internal::is_default(&self.total_splits) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSplits", &__With(&self.total_splits))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to DeleteLog.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteLogRequest {
    /// Required. The resource name of the log to delete:
    ///
    /// * `projects/[PROJECT_ID]/logs/[LOG_ID]`
    /// * `organizations/[ORGANIZATION_ID]/logs/[LOG_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]`
    /// * `folders/[FOLDER_ID]/logs/[LOG_ID]`
    ///
    /// `[LOG_ID]` must be URL-encoded. For example,
    /// `"projects/my-project-id/logs/syslog"`,
    /// `"organizations/123/logs/cloudaudit.googleapis.com%2Factivity"`.
    ///
    /// For more information about log names, see
    /// [LogEntry][google.logging.v2.LogEntry].
    ///
    /// [google.logging.v2.LogEntry]: crate::model::LogEntry
    pub log_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteLogRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_name][crate::model::DeleteLogRequest::log_name].
    pub fn set_log_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteLogRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.DeleteLogRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteLogRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteLogRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logName" => Ok(__FieldTag::__log_name),
                            "log_name" => Ok(__FieldTag::__log_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteLogRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteLogRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_name => {
                            if !fields.insert(__FieldTag::__log_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_name",
                                ));
                            }
                            result.log_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteLogRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.log_name.is_empty() {
            state.serialize_entry("logName", &self.log_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to WriteLogEntries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WriteLogEntriesRequest {
    /// Optional. A default log resource name that is assigned to all log entries
    /// in `entries` that do not specify a value for `log_name`:
    ///
    /// * `projects/[PROJECT_ID]/logs/[LOG_ID]`
    /// * `organizations/[ORGANIZATION_ID]/logs/[LOG_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]`
    /// * `folders/[FOLDER_ID]/logs/[LOG_ID]`
    ///
    /// `[LOG_ID]` must be URL-encoded. For example:
    ///
    /// ```norust
    /// "projects/my-project-id/logs/syslog"
    /// "organizations/123/logs/cloudaudit.googleapis.com%2Factivity"
    /// ```
    ///
    /// The permission `logging.logEntries.create` is needed on each project,
    /// organization, billing account, or folder that is receiving new log
    /// entries, whether the resource is specified in `logName` or in an
    /// individual log entry.
    pub log_name: std::string::String,

    /// Optional. A default monitored resource object that is assigned to all log
    /// entries in `entries` that do not specify a value for `resource`. Example:
    ///
    /// ```norust
    /// { "type": "gce_instance",
    ///   "labels": {
    ///     "zone": "us-central1-a", "instance_id": "00000000000000000000" }}
    /// ```
    ///
    /// See [LogEntry][google.logging.v2.LogEntry].
    ///
    /// [google.logging.v2.LogEntry]: crate::model::LogEntry
    pub resource: std::option::Option<api::model::MonitoredResource>,

    /// Optional. Default labels that are added to the `labels` field of all log
    /// entries in `entries`. If a log entry already has a label with the same key
    /// as a label in this parameter, then the log entry's label is not changed.
    /// See [LogEntry][google.logging.v2.LogEntry].
    ///
    /// [google.logging.v2.LogEntry]: crate::model::LogEntry
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The log entries to send to Logging. The order of log
    /// entries in this list does not matter. Values supplied in this method's
    /// `log_name`, `resource`, and `labels` fields are copied into those log
    /// entries in this list that do not include values for their corresponding
    /// fields. For more information, see the
    /// [LogEntry][google.logging.v2.LogEntry] type.
    ///
    /// If the `timestamp` or `insert_id` fields are missing in log entries, then
    /// this method supplies the current time or a unique identifier, respectively.
    /// The supplied values are chosen so that, among the log entries that did not
    /// supply their own values, the entries earlier in the list will sort before
    /// the entries later in the list. See the `entries.list` method.
    ///
    /// Log entries with timestamps that are more than the
    /// [logs retention period](https://cloud.google.com/logging/quotas) in
    /// the past or more than 24 hours in the future will not be available when
    /// calling `entries.list`. However, those log entries can still be [exported
    /// with
    /// LogSinks](https://cloud.google.com/logging/docs/api/tasks/exporting-logs).
    ///
    /// To improve throughput and to avoid exceeding the
    /// [quota limit](https://cloud.google.com/logging/quotas) for calls to
    /// `entries.write`, you should try to include several log entries in this
    /// list, rather than calling this method for each individual log entry.
    ///
    /// [google.logging.v2.LogEntry]: crate::model::LogEntry
    pub entries: std::vec::Vec<crate::model::LogEntry>,

    /// Optional. Whether a batch's valid entries should be written even if some
    /// other entry failed due to a permanent error such as INVALID_ARGUMENT or
    /// PERMISSION_DENIED. If any entry failed, then the response status is the
    /// response status of one of the failed entries. The response will include
    /// error details in `WriteLogEntriesPartialErrors.log_entry_errors` keyed by
    /// the entries' zero-based index in the `entries`. Failed requests for which
    /// no entries are written will not include per-entry errors.
    pub partial_success: bool,

    /// Optional. If true, the request should expect normal response, but the
    /// entries won't be persisted nor exported. Useful for checking whether the
    /// logging API endpoints are working properly before sending valuable data.
    pub dry_run: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WriteLogEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_name][crate::model::WriteLogEntriesRequest::log_name].
    pub fn set_log_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_name = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::WriteLogEntriesRequest::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::MonitoredResource>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::WriteLogEntriesRequest::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::MonitoredResource>,
    {
        self.resource = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::WriteLogEntriesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [entries][crate::model::WriteLogEntriesRequest::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogEntry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [partial_success][crate::model::WriteLogEntriesRequest::partial_success].
    pub fn set_partial_success<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.partial_success = v.into();
        self
    }

    /// Sets the value of [dry_run][crate::model::WriteLogEntriesRequest::dry_run].
    pub fn set_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dry_run = v.into();
        self
    }
}

impl wkt::message::Message for WriteLogEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.WriteLogEntriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WriteLogEntriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_name,
            __resource,
            __labels,
            __entries,
            __partial_success,
            __dry_run,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WriteLogEntriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logName" => Ok(__FieldTag::__log_name),
                            "log_name" => Ok(__FieldTag::__log_name),
                            "resource" => Ok(__FieldTag::__resource),
                            "labels" => Ok(__FieldTag::__labels),
                            "entries" => Ok(__FieldTag::__entries),
                            "partialSuccess" => Ok(__FieldTag::__partial_success),
                            "partial_success" => Ok(__FieldTag::__partial_success),
                            "dryRun" => Ok(__FieldTag::__dry_run),
                            "dry_run" => Ok(__FieldTag::__dry_run),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WriteLogEntriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WriteLogEntriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_name => {
                            if !fields.insert(__FieldTag::__log_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_name",
                                ));
                            }
                            result.log_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<api::model::MonitoredResource>>(
                                )?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LogEntry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__partial_success => {
                            if !fields.insert(__FieldTag::__partial_success) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_success",
                                ));
                            }
                            result.partial_success = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dry_run => {
                            if !fields.insert(__FieldTag::__dry_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dry_run",
                                ));
                            }
                            result.dry_run = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WriteLogEntriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.log_name.is_empty() {
            state.serialize_entry("logName", &self.log_name)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !wkt::internal::is_default(&self.partial_success) {
            state.serialize_entry("partialSuccess", &self.partial_success)?;
        }
        if !wkt::internal::is_default(&self.dry_run) {
            state.serialize_entry("dryRun", &self.dry_run)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Result returned from WriteLogEntries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WriteLogEntriesResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WriteLogEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for WriteLogEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.WriteLogEntriesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WriteLogEntriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WriteLogEntriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WriteLogEntriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WriteLogEntriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WriteLogEntriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Error details for WriteLogEntries with partial success.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WriteLogEntriesPartialErrors {
    /// When `WriteLogEntriesRequest.partial_success` is true, records the error
    /// status for entries that were not written due to a permanent error, keyed
    /// by the entry's zero-based index in `WriteLogEntriesRequest.entries`.
    ///
    /// Failed requests for which no entries are written will not include
    /// per-entry errors.
    pub log_entry_errors: std::collections::HashMap<i32, rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WriteLogEntriesPartialErrors {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_entry_errors][crate::model::WriteLogEntriesPartialErrors::log_entry_errors].
    pub fn set_log_entry_errors<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i32>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.log_entry_errors = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for WriteLogEntriesPartialErrors {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.WriteLogEntriesPartialErrors"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WriteLogEntriesPartialErrors {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_entry_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WriteLogEntriesPartialErrors")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logEntryErrors" => Ok(__FieldTag::__log_entry_errors),
                            "log_entry_errors" => Ok(__FieldTag::__log_entry_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WriteLogEntriesPartialErrors;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WriteLogEntriesPartialErrors")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_entry_errors => {
                            if !fields.insert(__FieldTag::__log_entry_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_entry_errors",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<i32, rpc::model::Status>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I32,
                                                serde_with::Same,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.log_entry_errors =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WriteLogEntriesPartialErrors {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.log_entry_errors.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<i32, rpc::model::Status>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<wkt::internal::I32, serde_with::Same> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("logEntryErrors", &__With(&self.log_entry_errors))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `ListLogEntries`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLogEntriesRequest {
    /// Required. Names of one or more parent resources from which to
    /// retrieve log entries:
    ///
    /// * `projects/[PROJECT_ID]`
    /// * `organizations/[ORGANIZATION_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]`
    /// * `folders/[FOLDER_ID]`
    ///
    /// May alternatively be one or more views:
    ///
    /// * `projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    ///
    /// Projects listed in the `project_ids` field are added to this list.
    /// A maximum of 100 resources may be specified in a single request.
    pub resource_names: std::vec::Vec<std::string::String>,

    /// Optional. Only log entries that match the filter are returned.  An empty
    /// filter matches all log entries in the resources listed in `resource_names`.
    /// Referencing a parent resource that is not listed in `resource_names` will
    /// cause the filter to return no results. The maximum length of a filter is
    /// 20,000 characters.
    pub filter: std::string::String,

    /// Optional. How the results should be sorted.  Presently, the only permitted
    /// values are `"timestamp asc"` (default) and `"timestamp desc"`. The first
    /// option returns entries in order of increasing values of
    /// `LogEntry.timestamp` (oldest first), and the second option returns entries
    /// in order of decreasing timestamps (newest first).  Entries with equal
    /// timestamps are returned in order of their `insert_id` values.
    pub order_by: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    /// Default is 50. If the value is negative or exceeds 1000, the request is
    /// rejected. The presence of `next_page_token` in the response indicates that
    /// more results might be available.
    pub page_size: i32,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method.  `page_token` must be the value of
    /// `next_page_token` from the previous response.  The values of other method
    /// parameters should be identical to those in the previous call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLogEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_names][crate::model::ListLogEntriesRequest::resource_names].
    pub fn set_resource_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filter][crate::model::ListLogEntriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListLogEntriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLogEntriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLogEntriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLogEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLogEntriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLogEntriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_names,
            __filter,
            __order_by,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLogEntriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceNames" => Ok(__FieldTag::__resource_names),
                            "resource_names" => Ok(__FieldTag::__resource_names),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLogEntriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLogEntriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_names => {
                            if !fields.insert(__FieldTag::__resource_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_names",
                                ));
                            }
                            result.resource_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLogEntriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_names.is_empty() {
            state.serialize_entry("resourceNames", &self.resource_names)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Result returned from `ListLogEntries`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLogEntriesResponse {
    /// A list of log entries.  If `entries` is empty, `nextPageToken` may still be
    /// returned, indicating that more entries may exist.  See `nextPageToken` for
    /// more information.
    pub entries: std::vec::Vec<crate::model::LogEntry>,

    /// If there might be more results than those appearing in this response, then
    /// `nextPageToken` is included.  To get the next set of results, call this
    /// method again using the value of `nextPageToken` as `pageToken`.
    ///
    /// If a value for `next_page_token` appears and the `entries` field is empty,
    /// it means that the search found no log entries so far but it did not have
    /// time to search all the possible log entries.  Retry the method with this
    /// value for `page_token` to continue the search.  Alternatively, consider
    /// speeding up the search by changing your filter to specify a single log name
    /// or resource type, or to narrow the time range of the search.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLogEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::ListLogEntriesResponse::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogEntry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLogEntriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLogEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLogEntriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLogEntriesResponse {
    type PageItem = crate::model::LogEntry;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entries
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLogEntriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLogEntriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLogEntriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLogEntriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LogEntry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLogEntriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to ListMonitoredResourceDescriptors
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMonitoredResourceDescriptorsRequest {
    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored.  The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    pub page_size: i32,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method.  `pageToken` must be the value of
    /// `nextPageToken` from the previous response.  The values of other method
    /// parameters should be identical to those in the previous call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMonitoredResourceDescriptorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [page_size][crate::model::ListMonitoredResourceDescriptorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMonitoredResourceDescriptorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMonitoredResourceDescriptorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListMonitoredResourceDescriptorsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMonitoredResourceDescriptorsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListMonitoredResourceDescriptorsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMonitoredResourceDescriptorsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMonitoredResourceDescriptorsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMonitoredResourceDescriptorsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Result returned from ListMonitoredResourceDescriptors.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMonitoredResourceDescriptorsResponse {
    /// A list of resource descriptors.
    pub resource_descriptors: std::vec::Vec<api::model::MonitoredResourceDescriptor>,

    /// If there might be more results than those appearing in this response, then
    /// `nextPageToken` is included.  To get the next set of results, call this
    /// method again using the value of `nextPageToken` as `pageToken`.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMonitoredResourceDescriptorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_descriptors][crate::model::ListMonitoredResourceDescriptorsResponse::resource_descriptors].
    pub fn set_resource_descriptors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::MonitoredResourceDescriptor>,
    {
        use std::iter::Iterator;
        self.resource_descriptors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMonitoredResourceDescriptorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMonitoredResourceDescriptorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListMonitoredResourceDescriptorsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMonitoredResourceDescriptorsResponse {
    type PageItem = api::model::MonitoredResourceDescriptor;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.resource_descriptors
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMonitoredResourceDescriptorsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_descriptors,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListMonitoredResourceDescriptorsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceDescriptors" => Ok(__FieldTag::__resource_descriptors),
                            "resource_descriptors" => Ok(__FieldTag::__resource_descriptors),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMonitoredResourceDescriptorsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMonitoredResourceDescriptorsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_descriptors => {
                            if !fields.insert(__FieldTag::__resource_descriptors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_descriptors",
                                ));
                            }
                            result.resource_descriptors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<api::model::MonitoredResourceDescriptor>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMonitoredResourceDescriptorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_descriptors.is_empty() {
            state.serialize_entry("resourceDescriptors", &self.resource_descriptors)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to ListLogs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLogsRequest {
    /// Required. The resource name to list logs for:
    ///
    /// * `projects/[PROJECT_ID]`
    /// * `organizations/[ORGANIZATION_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]`
    /// * `folders/[FOLDER_ID]`
    pub parent: std::string::String,

    /// Optional. List of resource names to list logs for:
    ///
    /// * `projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    ///
    /// To support legacy queries, it could also be:
    ///
    /// * `projects/[PROJECT_ID]`
    /// * `organizations/[ORGANIZATION_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]`
    /// * `folders/[FOLDER_ID]`
    ///
    /// The resource name in the `parent` field is added to this list.
    pub resource_names: std::vec::Vec<std::string::String>,

    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored.  The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    pub page_size: i32,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method.  `pageToken` must be the value of
    /// `nextPageToken` from the previous response.  The values of other method
    /// parameters should be identical to those in the previous call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLogsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLogsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [resource_names][crate::model::ListLogsRequest::resource_names].
    pub fn set_resource_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLogsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLogsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLogsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLogsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLogsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __resource_names,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLogsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "resourceNames" => Ok(__FieldTag::__resource_names),
                            "resource_names" => Ok(__FieldTag::__resource_names),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLogsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLogsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_names => {
                            if !fields.insert(__FieldTag::__resource_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_names",
                                ));
                            }
                            result.resource_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLogsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.resource_names.is_empty() {
            state.serialize_entry("resourceNames", &self.resource_names)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Result returned from ListLogs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLogsResponse {
    /// A list of log names. For example,
    /// `"projects/my-project/logs/syslog"` or
    /// `"organizations/123/logs/cloudresourcemanager.googleapis.com%2Factivity"`.
    pub log_names: std::vec::Vec<std::string::String>,

    /// If there might be more results than those appearing in this response, then
    /// `nextPageToken` is included.  To get the next set of results, call this
    /// method again using the value of `nextPageToken` as `pageToken`.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLogsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_names][crate::model::ListLogsResponse::log_names].
    pub fn set_log_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.log_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLogsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLogsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLogsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLogsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_names,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLogsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logNames" => Ok(__FieldTag::__log_names),
                            "log_names" => Ok(__FieldTag::__log_names),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLogsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLogsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_names => {
                            if !fields.insert(__FieldTag::__log_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_names",
                                ));
                            }
                            result.log_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLogsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.log_names.is_empty() {
            state.serialize_entry("logNames", &self.log_names)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `TailLogEntries`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TailLogEntriesRequest {
    /// Required. Name of a parent resource from which to retrieve log entries:
    ///
    /// * `projects/[PROJECT_ID]`
    /// * `organizations/[ORGANIZATION_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]`
    /// * `folders/[FOLDER_ID]`
    ///
    /// May alternatively be one or more views:
    ///
    /// * `projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    pub resource_names: std::vec::Vec<std::string::String>,

    /// Optional. Only log entries that match the filter are returned.  An empty
    /// filter matches all log entries in the resources listed in `resource_names`.
    /// Referencing a parent resource that is not listed in `resource_names` will
    /// cause the filter to return no results. The maximum length of a filter is
    /// 20,000 characters.
    pub filter: std::string::String,

    /// Optional. The amount of time to buffer log entries at the server before
    /// being returned to prevent out of order results due to late arriving log
    /// entries. Valid values are between 0-60000 milliseconds. Defaults to 2000
    /// milliseconds.
    pub buffer_window: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TailLogEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_names][crate::model::TailLogEntriesRequest::resource_names].
    pub fn set_resource_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filter][crate::model::TailLogEntriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [buffer_window][crate::model::TailLogEntriesRequest::buffer_window].
    pub fn set_buffer_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.buffer_window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [buffer_window][crate::model::TailLogEntriesRequest::buffer_window].
    pub fn set_or_clear_buffer_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.buffer_window = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TailLogEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.TailLogEntriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TailLogEntriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_names,
            __filter,
            __buffer_window,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TailLogEntriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceNames" => Ok(__FieldTag::__resource_names),
                            "resource_names" => Ok(__FieldTag::__resource_names),
                            "filter" => Ok(__FieldTag::__filter),
                            "bufferWindow" => Ok(__FieldTag::__buffer_window),
                            "buffer_window" => Ok(__FieldTag::__buffer_window),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TailLogEntriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TailLogEntriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_names => {
                            if !fields.insert(__FieldTag::__resource_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_names",
                                ));
                            }
                            result.resource_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__buffer_window => {
                            if !fields.insert(__FieldTag::__buffer_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for buffer_window",
                                ));
                            }
                            result.buffer_window =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TailLogEntriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_names.is_empty() {
            state.serialize_entry("resourceNames", &self.resource_names)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.buffer_window.is_some() {
            state.serialize_entry("bufferWindow", &self.buffer_window)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Result returned from `TailLogEntries`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TailLogEntriesResponse {
    /// A list of log entries. Each response in the stream will order entries with
    /// increasing values of `LogEntry.timestamp`. Ordering is not guaranteed
    /// between separate responses.
    pub entries: std::vec::Vec<crate::model::LogEntry>,

    /// If entries that otherwise would have been included in the session were not
    /// sent back to the client, counts of relevant entries omitted from the
    /// session with the reason that they were not included. There will be at most
    /// one of each reason per response. The counts represent the number of
    /// suppressed entries since the last streamed response.
    pub suppression_info: std::vec::Vec<crate::model::tail_log_entries_response::SuppressionInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TailLogEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::TailLogEntriesResponse::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogEntry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [suppression_info][crate::model::TailLogEntriesResponse::suppression_info].
    pub fn set_suppression_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::tail_log_entries_response::SuppressionInfo>,
    {
        use std::iter::Iterator;
        self.suppression_info = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TailLogEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.TailLogEntriesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TailLogEntriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            __suppression_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TailLogEntriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            "suppressionInfo" => Ok(__FieldTag::__suppression_info),
                            "suppression_info" => Ok(__FieldTag::__suppression_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TailLogEntriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TailLogEntriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LogEntry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__suppression_info => {
                            if !fields.insert(__FieldTag::__suppression_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suppression_info",
                                ));
                            }
                            result.suppression_info = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::tail_log_entries_response::SuppressionInfo,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TailLogEntriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self.suppression_info.is_empty() {
            state.serialize_entry("suppressionInfo", &self.suppression_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TailLogEntriesResponse].
pub mod tail_log_entries_response {
    #[allow(unused_imports)]
    use super::*;

    /// Information about entries that were omitted from the session.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SuppressionInfo {
        /// The reason that entries were omitted from the session.
        pub reason: crate::model::tail_log_entries_response::suppression_info::Reason,

        /// A lower bound on the count of entries omitted due to `reason`.
        pub suppressed_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SuppressionInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [reason][crate::model::tail_log_entries_response::SuppressionInfo::reason].
        pub fn set_reason<
            T: std::convert::Into<crate::model::tail_log_entries_response::suppression_info::Reason>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.reason = v.into();
            self
        }

        /// Sets the value of [suppressed_count][crate::model::tail_log_entries_response::SuppressionInfo::suppressed_count].
        pub fn set_suppressed_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.suppressed_count = v.into();
            self
        }
    }

    impl wkt::message::Message for SuppressionInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.logging.v2.TailLogEntriesResponse.SuppressionInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SuppressionInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __reason,
                __suppressed_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SuppressionInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "reason" => Ok(__FieldTag::__reason),
                                "suppressedCount" => Ok(__FieldTag::__suppressed_count),
                                "suppressed_count" => Ok(__FieldTag::__suppressed_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SuppressionInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SuppressionInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__reason => {
                                if !fields.insert(__FieldTag::__reason) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for reason",
                                    ));
                                }
                                result.reason = map.next_value::<std::option::Option<crate::model::tail_log_entries_response::suppression_info::Reason>>()?.unwrap_or_default();
                            }
                            __FieldTag::__suppressed_count => {
                                if !fields.insert(__FieldTag::__suppressed_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for suppressed_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.suppressed_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SuppressionInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.reason) {
                state.serialize_entry("reason", &self.reason)?;
            }
            if !wkt::internal::is_default(&self.suppressed_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("suppressedCount", &__With(&self.suppressed_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SuppressionInfo].
    pub mod suppression_info {
        #[allow(unused_imports)]
        use super::*;

        /// An indicator of why entries were omitted.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Reason {
            /// Unexpected default.
            Unspecified,
            /// Indicates suppression occurred due to relevant entries being
            /// received in excess of rate limits. For quotas and limits, see
            /// [Logging API quotas and
            /// limits](https://cloud.google.com/logging/quotas#api-limits).
            RateLimit,
            /// Indicates suppression occurred due to the client not consuming
            /// responses quickly enough.
            NotConsumed,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Reason::value] or
            /// [Reason::name].
            UnknownValue(reason::UnknownValue),
        }

        #[doc(hidden)]
        pub mod reason {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Reason {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::RateLimit => std::option::Option::Some(1),
                    Self::NotConsumed => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("REASON_UNSPECIFIED"),
                    Self::RateLimit => std::option::Option::Some("RATE_LIMIT"),
                    Self::NotConsumed => std::option::Option::Some("NOT_CONSUMED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Reason {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Reason {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Reason {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::RateLimit,
                    2 => Self::NotConsumed,
                    _ => Self::UnknownValue(reason::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Reason {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "REASON_UNSPECIFIED" => Self::Unspecified,
                    "RATE_LIMIT" => Self::RateLimit,
                    "NOT_CONSUMED" => Self::NotConsumed,
                    _ => Self::UnknownValue(reason::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Reason {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::RateLimit => serializer.serialize_i32(1),
                    Self::NotConsumed => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Reason {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Reason>::new(
                    ".google.logging.v2.TailLogEntriesResponse.SuppressionInfo.Reason",
                ))
            }
        }
    }
}

/// Configuration for an indexed field.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IndexConfig {
    /// Required. The LogEntry field path to index.
    ///
    /// Note that some paths are automatically indexed, and other paths are not
    /// eligible for indexing. See [indexing documentation](
    /// <https://cloud.google.com/logging/docs/view/advanced-queries#indexed-fields>)
    /// for details.
    ///
    /// For example: `jsonPayload.request.status`
    pub field_path: std::string::String,

    /// Required. The type of data in this index.
    pub r#type: crate::model::IndexType,

    /// Output only. The timestamp when the index was last modified.
    ///
    /// This is used to return the timestamp, and will be ignored if supplied
    /// during update.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IndexConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field_path][crate::model::IndexConfig::field_path].
    pub fn set_field_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field_path = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::IndexConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::IndexType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::IndexConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::IndexConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for IndexConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.IndexConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IndexConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __field_path,
            __type,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IndexConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fieldPath" => Ok(__FieldTag::__field_path),
                            "field_path" => Ok(__FieldTag::__field_path),
                            "type" => Ok(__FieldTag::__type),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IndexConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IndexConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__field_path => {
                            if !fields.insert(__FieldTag::__field_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_path",
                                ));
                            }
                            result.field_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::IndexType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IndexConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.field_path.is_empty() {
            state.serialize_entry("fieldPath", &self.field_path)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes a repository in which log entries are stored.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogBucket {
    /// Output only. The resource name of the bucket.
    ///
    /// For example:
    ///
    /// `projects/my-project/locations/global/buckets/my-bucket`
    ///
    /// For a list of supported locations, see [Supported
    /// Regions](https://cloud.google.com/logging/docs/region-support)
    ///
    /// For the location of `global` it is unspecified where log entries are
    /// actually stored.
    ///
    /// After a bucket has been created, the location cannot be changed.
    pub name: std::string::String,

    /// Describes this bucket.
    pub description: std::string::String,

    /// Output only. The creation timestamp of the bucket. This is not set for any
    /// of the default buckets.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of the bucket.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Logs will be retained by default for this amount of time, after which they
    /// will automatically be deleted. The minimum retention period is 1 day. If
    /// this value is set to zero at bucket creation time, the default time of 30
    /// days will be used.
    pub retention_days: i32,

    /// Whether the bucket is locked.
    ///
    /// The retention period on a locked bucket cannot be changed. Locked buckets
    /// may only be deleted if they are empty.
    pub locked: bool,

    /// Output only. The bucket lifecycle state.
    pub lifecycle_state: crate::model::LifecycleState,

    /// Whether log analytics is enabled for this bucket.
    ///
    /// Once enabled, log analytics features cannot be disabled.
    pub analytics_enabled: bool,

    /// Log entry field paths that are denied access in this bucket.
    ///
    /// The following fields and their children are eligible: `textPayload`,
    /// `jsonPayload`, `protoPayload`, `httpRequest`, `labels`, `sourceLocation`.
    ///
    /// Restricting a repeated field will restrict all values. Adding a parent will
    /// block all child fields. (e.g. `foo.bar` will block `foo.bar.baz`)
    pub restricted_fields: std::vec::Vec<std::string::String>,

    /// A list of indexed fields and related configuration data.
    pub index_configs: std::vec::Vec<crate::model::IndexConfig>,

    /// The CMEK settings of the log bucket. If present, new log entries written to
    /// this log bucket are encrypted using the CMEK key provided in this
    /// configuration. If a log bucket has CMEK settings, the CMEK settings cannot
    /// be disabled later by updating the log bucket. Changing the KMS key is
    /// allowed.
    pub cmek_settings: std::option::Option<crate::model::CmekSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogBucket {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LogBucket::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::LogBucket::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::LogBucket::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::LogBucket::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::LogBucket::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::LogBucket::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [retention_days][crate::model::LogBucket::retention_days].
    pub fn set_retention_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retention_days = v.into();
        self
    }

    /// Sets the value of [locked][crate::model::LogBucket::locked].
    pub fn set_locked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.locked = v.into();
        self
    }

    /// Sets the value of [lifecycle_state][crate::model::LogBucket::lifecycle_state].
    pub fn set_lifecycle_state<T: std::convert::Into<crate::model::LifecycleState>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_state = v.into();
        self
    }

    /// Sets the value of [analytics_enabled][crate::model::LogBucket::analytics_enabled].
    pub fn set_analytics_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.analytics_enabled = v.into();
        self
    }

    /// Sets the value of [restricted_fields][crate::model::LogBucket::restricted_fields].
    pub fn set_restricted_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.restricted_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [index_configs][crate::model::LogBucket::index_configs].
    pub fn set_index_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IndexConfig>,
    {
        use std::iter::Iterator;
        self.index_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cmek_settings][crate::model::LogBucket::cmek_settings].
    pub fn set_cmek_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CmekSettings>,
    {
        self.cmek_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cmek_settings][crate::model::LogBucket::cmek_settings].
    pub fn set_or_clear_cmek_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CmekSettings>,
    {
        self.cmek_settings = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LogBucket {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogBucket"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogBucket {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __create_time,
            __update_time,
            __retention_days,
            __locked,
            __lifecycle_state,
            __analytics_enabled,
            __restricted_fields,
            __index_configs,
            __cmek_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogBucket")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "retentionDays" => Ok(__FieldTag::__retention_days),
                            "retention_days" => Ok(__FieldTag::__retention_days),
                            "locked" => Ok(__FieldTag::__locked),
                            "lifecycleState" => Ok(__FieldTag::__lifecycle_state),
                            "lifecycle_state" => Ok(__FieldTag::__lifecycle_state),
                            "analyticsEnabled" => Ok(__FieldTag::__analytics_enabled),
                            "analytics_enabled" => Ok(__FieldTag::__analytics_enabled),
                            "restrictedFields" => Ok(__FieldTag::__restricted_fields),
                            "restricted_fields" => Ok(__FieldTag::__restricted_fields),
                            "indexConfigs" => Ok(__FieldTag::__index_configs),
                            "index_configs" => Ok(__FieldTag::__index_configs),
                            "cmekSettings" => Ok(__FieldTag::__cmek_settings),
                            "cmek_settings" => Ok(__FieldTag::__cmek_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogBucket;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogBucket")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__retention_days => {
                            if !fields.insert(__FieldTag::__retention_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.retention_days =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__locked => {
                            if !fields.insert(__FieldTag::__locked) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locked",
                                ));
                            }
                            result.locked = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lifecycle_state => {
                            if !fields.insert(__FieldTag::__lifecycle_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifecycle_state",
                                ));
                            }
                            result.lifecycle_state = map
                                .next_value::<std::option::Option<crate::model::LifecycleState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__analytics_enabled => {
                            if !fields.insert(__FieldTag::__analytics_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analytics_enabled",
                                ));
                            }
                            result.analytics_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__restricted_fields => {
                            if !fields.insert(__FieldTag::__restricted_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restricted_fields",
                                ));
                            }
                            result.restricted_fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__index_configs => {
                            if !fields.insert(__FieldTag::__index_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_configs",
                                ));
                            }
                            result.index_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::IndexConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cmek_settings => {
                            if !fields.insert(__FieldTag::__cmek_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cmek_settings",
                                ));
                            }
                            result.cmek_settings = map
                                .next_value::<std::option::Option<crate::model::CmekSettings>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogBucket {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.retention_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("retentionDays", &__With(&self.retention_days))?;
        }
        if !wkt::internal::is_default(&self.locked) {
            state.serialize_entry("locked", &self.locked)?;
        }
        if !wkt::internal::is_default(&self.lifecycle_state) {
            state.serialize_entry("lifecycleState", &self.lifecycle_state)?;
        }
        if !wkt::internal::is_default(&self.analytics_enabled) {
            state.serialize_entry("analyticsEnabled", &self.analytics_enabled)?;
        }
        if !self.restricted_fields.is_empty() {
            state.serialize_entry("restrictedFields", &self.restricted_fields)?;
        }
        if !self.index_configs.is_empty() {
            state.serialize_entry("indexConfigs", &self.index_configs)?;
        }
        if self.cmek_settings.is_some() {
            state.serialize_entry("cmekSettings", &self.cmek_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes a view over log entries in a bucket.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogView {
    /// The resource name of the view.
    ///
    /// For example:
    ///
    /// `projects/my-project/locations/global/buckets/my-bucket/views/my-view`
    pub name: std::string::String,

    /// Describes this view.
    pub description: std::string::String,

    /// Output only. The creation timestamp of the view.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of the view.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Filter that restricts which log entries in a bucket are visible in this
    /// view.
    ///
    /// Filters are restricted to be a logical AND of ==/!= of any of the
    /// following:
    ///
    /// - originating project/folder/organization/billing account.
    /// - resource type
    /// - log id
    ///
    /// For example:
    ///
    /// SOURCE("projects/myproject") AND resource.type = "gce_instance"
    /// AND LOG_ID("stdout")
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogView {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LogView::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::LogView::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::LogView::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::LogView::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::LogView::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::LogView::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [filter][crate::model::LogView::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for LogView {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogView"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __create_time,
            __update_time,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogView")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogView;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogView")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes a sink used to export log entries to one of the following
/// destinations in any project: a Cloud Storage bucket, a BigQuery dataset, a
/// Pub/Sub topic or a Cloud Logging log bucket. A logs filter controls which log
/// entries are exported. The sink must be created within a project,
/// organization, billing account, or folder.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogSink {
    /// Required. The client-assigned sink identifier, unique within the project.
    ///
    /// For example: `"my-syslog-errors-to-pubsub"`. Sink identifiers are limited
    /// to 100 characters and can include only the following characters: upper and
    /// lower-case alphanumeric characters, underscores, hyphens, and periods.
    /// First character has to be alphanumeric.
    pub name: std::string::String,

    /// Required. The export destination:
    ///
    /// ```norust
    /// "storage.googleapis.com/[GCS_BUCKET]"
    /// "bigquery.googleapis.com/projects/[PROJECT_ID]/datasets/[DATASET]"
    /// "pubsub.googleapis.com/projects/[PROJECT_ID]/topics/[TOPIC_ID]"
    /// ```
    ///
    /// The sink's `writer_identity`, set when the sink is created, must have
    /// permission to write to the destination or else the log entries are not
    /// exported. For more information, see
    /// [Exporting Logs with
    /// Sinks](https://cloud.google.com/logging/docs/api/tasks/exporting-logs).
    pub destination: std::string::String,

    /// Optional. An [advanced logs
    /// filter](https://cloud.google.com/logging/docs/view/advanced-queries). The
    /// only exported log entries are those that are in the resource owning the
    /// sink and that match the filter.
    ///
    /// For example:
    ///
    /// `logName="projects/[PROJECT_ID]/logs/[LOG_ID]" AND severity>=ERROR`
    pub filter: std::string::String,

    /// Optional. A description of this sink.
    ///
    /// The maximum length of the description is 8000 characters.
    pub description: std::string::String,

    /// Optional. If set to true, then this sink is disabled and it does not export
    /// any log entries.
    pub disabled: bool,

    /// Optional. Log entries that match any of these exclusion filters will not be
    /// exported.
    ///
    /// If a log entry is matched by both `filter` and one of `exclusion_filters`
    /// it will not be exported.
    pub exclusions: std::vec::Vec<crate::model::LogExclusion>,

    /// Deprecated. This field is unused.
    #[deprecated]
    pub output_version_format: crate::model::log_sink::VersionFormat,

    /// Output only. An IAM identity&mdash;a service account or group&mdash;under
    /// which Cloud Logging writes the exported log entries to the sink's
    /// destination. This field is either set by specifying
    /// `custom_writer_identity` or set automatically by
    /// [sinks.create][google.logging.v2.ConfigServiceV2.CreateSink] and
    /// [sinks.update][google.logging.v2.ConfigServiceV2.UpdateSink] based on the
    /// value of `unique_writer_identity` in those methods.
    ///
    /// Until you grant this identity write-access to the destination, log entry
    /// exports from this sink will fail. For more information, see [Granting
    /// Access for a
    /// Resource](https://cloud.google.com/iam/docs/granting-roles-to-service-accounts#granting_access_to_a_service_account_for_a_resource).
    /// Consult the destination service's documentation to determine the
    /// appropriate IAM roles to assign to the identity.
    ///
    /// Sinks that have a destination that is a log bucket in the same project as
    /// the sink cannot have a writer_identity and no additional permissions are
    /// required.
    ///
    /// [google.logging.v2.ConfigServiceV2.CreateSink]: crate::client::ConfigServiceV2::create_sink
    /// [google.logging.v2.ConfigServiceV2.UpdateSink]: crate::client::ConfigServiceV2::update_sink
    pub writer_identity: std::string::String,

    /// Optional. This field applies only to sinks owned by organizations and
    /// folders. If the field is false, the default, only the logs owned by the
    /// sink's parent resource are available for export. If the field is true, then
    /// log entries from all the projects, folders, and billing accounts contained
    /// in the sink's parent resource are also available for export. Whether a
    /// particular log entry from the children is exported depends on the sink's
    /// filter expression.
    ///
    /// For example, if this field is true, then the filter
    /// `resource.type=gce_instance` would export all Compute Engine VM instance
    /// log entries from all projects in the sink's parent.
    ///
    /// To only export entries from certain child projects, filter on the project
    /// part of the log name:
    ///
    /// logName:("projects/test-project1/" OR "projects/test-project2/") AND
    /// resource.type=gce_instance
    pub include_children: bool,

    /// Output only. The creation timestamp of the sink.
    ///
    /// This field may not be present for older sinks.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of the sink.
    ///
    /// This field may not be present for older sinks.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Destination dependent options.
    pub options: std::option::Option<crate::model::log_sink::Options>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogSink {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LogSink::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::LogSink::destination].
    pub fn set_destination<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::LogSink::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [description][crate::model::LogSink::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::LogSink::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [exclusions][crate::model::LogSink::exclusions].
    pub fn set_exclusions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogExclusion>,
    {
        use std::iter::Iterator;
        self.exclusions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [output_version_format][crate::model::LogSink::output_version_format].
    #[deprecated]
    pub fn set_output_version_format<
        T: std::convert::Into<crate::model::log_sink::VersionFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_version_format = v.into();
        self
    }

    /// Sets the value of [writer_identity][crate::model::LogSink::writer_identity].
    pub fn set_writer_identity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.writer_identity = v.into();
        self
    }

    /// Sets the value of [include_children][crate::model::LogSink::include_children].
    pub fn set_include_children<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_children = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::LogSink::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::LogSink::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::LogSink::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::LogSink::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [options][crate::model::LogSink::options].
    ///
    /// Note that all the setters affecting `options` are mutually
    /// exclusive.
    pub fn set_options<
        T: std::convert::Into<std::option::Option<crate::model::log_sink::Options>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options = v.into();
        self
    }

    /// The value of [options][crate::model::LogSink::options]
    /// if it holds a `BigqueryOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryOptions>> {
        #[allow(unreachable_patterns)]
        self.options.as_ref().and_then(|v| match v {
            crate::model::log_sink::Options::BigqueryOptions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [options][crate::model::LogSink::options]
    /// to hold a `BigqueryOptions`.
    ///
    /// Note that all the setters affecting `options` are
    /// mutually exclusive.
    pub fn set_bigquery_options<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options =
            std::option::Option::Some(crate::model::log_sink::Options::BigqueryOptions(v.into()));
        self
    }
}

impl wkt::message::Message for LogSink {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogSink"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogSink {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __destination,
            __filter,
            __description,
            __disabled,
            __exclusions,
            __output_version_format,
            __writer_identity,
            __include_children,
            __bigquery_options,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogSink")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "destination" => Ok(__FieldTag::__destination),
                            "filter" => Ok(__FieldTag::__filter),
                            "description" => Ok(__FieldTag::__description),
                            "disabled" => Ok(__FieldTag::__disabled),
                            "exclusions" => Ok(__FieldTag::__exclusions),
                            "outputVersionFormat" => Ok(__FieldTag::__output_version_format),
                            "output_version_format" => Ok(__FieldTag::__output_version_format),
                            "writerIdentity" => Ok(__FieldTag::__writer_identity),
                            "writer_identity" => Ok(__FieldTag::__writer_identity),
                            "includeChildren" => Ok(__FieldTag::__include_children),
                            "include_children" => Ok(__FieldTag::__include_children),
                            "bigqueryOptions" => Ok(__FieldTag::__bigquery_options),
                            "bigquery_options" => Ok(__FieldTag::__bigquery_options),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogSink;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogSink")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination",
                                ));
                            }
                            result.destination = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exclusions => {
                            if !fields.insert(__FieldTag::__exclusions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusions",
                                ));
                            }
                            result.exclusions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LogExclusion>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__output_version_format => {
                            if !fields.insert(__FieldTag::__output_version_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_version_format",
                                ));
                            }
                            result.output_version_format = map.next_value::<std::option::Option<crate::model::log_sink::VersionFormat>>()?.unwrap_or_default();
                        }
                        __FieldTag::__writer_identity => {
                            if !fields.insert(__FieldTag::__writer_identity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for writer_identity",
                                ));
                            }
                            result.writer_identity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__include_children => {
                            if !fields.insert(__FieldTag::__include_children) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_children",
                                ));
                            }
                            result.include_children = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bigquery_options => {
                            if !fields.insert(__FieldTag::__bigquery_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_options",
                                ));
                            }
                            if result.options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `options`, a oneof with full ID .google.logging.v2.LogSink.bigquery_options, latest field was bigqueryOptions",
                                ));
                            }
                            result.options = std::option::Option::Some(
                                crate::model::log_sink::Options::BigqueryOptions(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQueryOptions>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogSink {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.destination.is_empty() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self.exclusions.is_empty() {
            state.serialize_entry("exclusions", &self.exclusions)?;
        }
        if !wkt::internal::is_default(&self.output_version_format) {
            state.serialize_entry("outputVersionFormat", &self.output_version_format)?;
        }
        if !self.writer_identity.is_empty() {
            state.serialize_entry("writerIdentity", &self.writer_identity)?;
        }
        if !wkt::internal::is_default(&self.include_children) {
            state.serialize_entry("includeChildren", &self.include_children)?;
        }
        if let Some(value) = self.bigquery_options() {
            state.serialize_entry("bigqueryOptions", value)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LogSink].
pub mod log_sink {
    #[allow(unused_imports)]
    use super::*;

    /// Deprecated. This is unused.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VersionFormat {
        /// An unspecified format version that will default to V2.
        Unspecified,
        /// `LogEntry` version 2 format.
        V2,
        /// `LogEntry` version 1 format.
        V1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VersionFormat::value] or
        /// [VersionFormat::name].
        UnknownValue(version_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod version_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VersionFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::V2 => std::option::Option::Some(1),
                Self::V1 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VERSION_FORMAT_UNSPECIFIED"),
                Self::V2 => std::option::Option::Some("V2"),
                Self::V1 => std::option::Option::Some("V1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VersionFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VersionFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VersionFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::V2,
                2 => Self::V1,
                _ => Self::UnknownValue(version_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VersionFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VERSION_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "V2" => Self::V2,
                "V1" => Self::V1,
                _ => Self::UnknownValue(version_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VersionFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::V2 => serializer.serialize_i32(1),
                Self::V1 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VersionFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VersionFormat>::new(
                ".google.logging.v2.LogSink.VersionFormat",
            ))
        }
    }

    /// Destination dependent options.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Options {
        /// Optional. Options that affect sinks exporting data to BigQuery.
        BigqueryOptions(std::boxed::Box<crate::model::BigQueryOptions>),
    }
}

/// Describes a BigQuery dataset that was created by a link.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryDataset {
    /// Output only. The full resource name of the BigQuery dataset. The DATASET_ID
    /// will match the ID of the link, so the link must match the naming
    /// restrictions of BigQuery datasets (alphanumeric characters and underscores
    /// only).
    ///
    /// The dataset will have a resource path of
    /// "bigquery.googleapis.com/projects/[PROJECT_ID]/datasets/[DATASET_ID]"
    pub dataset_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryDataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_id][crate::model::BigQueryDataset::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryDataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.BigQueryDataset"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryDataset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryDataset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryDataset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryDataset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryDataset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes a link connected to an analytics enabled bucket.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Link {
    /// The resource name of the link. The name can have up to 100 characters.
    /// A valid link id (at the end of the link name) must only have alphanumeric
    /// characters and underscores within it.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `projects/my-project/locations/global/buckets/my-bucket/links/my_link
    pub name: std::string::String,

    /// Describes this link.
    ///
    /// The maximum length of the description is 8000 characters.
    pub description: std::string::String,

    /// Output only. The creation timestamp of the link.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The resource lifecycle state.
    pub lifecycle_state: crate::model::LifecycleState,

    /// The information of a BigQuery Dataset. When a link is created, a BigQuery
    /// dataset is created along with it, in the same project as the LogBucket it's
    /// linked to. This dataset will also have BigQuery Views corresponding to the
    /// LogViews in the bucket.
    pub bigquery_dataset: std::option::Option<crate::model::BigQueryDataset>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Link {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Link::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Link::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Link::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Link::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lifecycle_state][crate::model::Link::lifecycle_state].
    pub fn set_lifecycle_state<T: std::convert::Into<crate::model::LifecycleState>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_state = v.into();
        self
    }

    /// Sets the value of [bigquery_dataset][crate::model::Link::bigquery_dataset].
    pub fn set_bigquery_dataset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryDataset>,
    {
        self.bigquery_dataset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bigquery_dataset][crate::model::Link::bigquery_dataset].
    pub fn set_or_clear_bigquery_dataset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryDataset>,
    {
        self.bigquery_dataset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Link {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.Link"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Link {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __create_time,
            __lifecycle_state,
            __bigquery_dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Link")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "lifecycleState" => Ok(__FieldTag::__lifecycle_state),
                            "lifecycle_state" => Ok(__FieldTag::__lifecycle_state),
                            "bigqueryDataset" => Ok(__FieldTag::__bigquery_dataset),
                            "bigquery_dataset" => Ok(__FieldTag::__bigquery_dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Link;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Link")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__lifecycle_state => {
                            if !fields.insert(__FieldTag::__lifecycle_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifecycle_state",
                                ));
                            }
                            result.lifecycle_state = map
                                .next_value::<std::option::Option<crate::model::LifecycleState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bigquery_dataset => {
                            if !fields.insert(__FieldTag::__bigquery_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_dataset",
                                ));
                            }
                            result.bigquery_dataset = map
                                .next_value::<std::option::Option<crate::model::BigQueryDataset>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Link {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.lifecycle_state) {
            state.serialize_entry("lifecycleState", &self.lifecycle_state)?;
        }
        if self.bigquery_dataset.is_some() {
            state.serialize_entry("bigqueryDataset", &self.bigquery_dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options that change functionality of a sink exporting data to BigQuery.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryOptions {
    /// Optional. Whether to use [BigQuery's partition
    /// tables](https://cloud.google.com/bigquery/docs/partitioned-tables). By
    /// default, Cloud Logging creates dated tables based on the log entries'
    /// timestamps, e.g. syslog_20170523. With partitioned tables the date suffix
    /// is no longer present and [special query
    /// syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
    /// has to be used instead. In both cases, tables are sharded based on UTC
    /// timezone.
    pub use_partitioned_tables: bool,

    /// Output only. True if new timestamp column based partitioning is in use,
    /// false if legacy ingestion-time partitioning is in use.
    ///
    /// All new sinks will have this field set true and will use timestamp column
    /// based partitioning. If use_partitioned_tables is false, this value has no
    /// meaning and will be false. Legacy sinks using partitioned tables will have
    /// this field set to false.
    pub uses_timestamp_column_partitioning: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_partitioned_tables][crate::model::BigQueryOptions::use_partitioned_tables].
    pub fn set_use_partitioned_tables<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_partitioned_tables = v.into();
        self
    }

    /// Sets the value of [uses_timestamp_column_partitioning][crate::model::BigQueryOptions::uses_timestamp_column_partitioning].
    pub fn set_uses_timestamp_column_partitioning<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.uses_timestamp_column_partitioning = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.BigQueryOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __use_partitioned_tables,
            __uses_timestamp_column_partitioning,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "usePartitionedTables" => Ok(__FieldTag::__use_partitioned_tables),
                            "use_partitioned_tables" => Ok(__FieldTag::__use_partitioned_tables),
                            "usesTimestampColumnPartitioning" => {
                                Ok(__FieldTag::__uses_timestamp_column_partitioning)
                            }
                            "uses_timestamp_column_partitioning" => {
                                Ok(__FieldTag::__uses_timestamp_column_partitioning)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__use_partitioned_tables => {
                            if !fields.insert(__FieldTag::__use_partitioned_tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_partitioned_tables",
                                ));
                            }
                            result.use_partitioned_tables = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uses_timestamp_column_partitioning => {
                            if !fields.insert(__FieldTag::__uses_timestamp_column_partitioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uses_timestamp_column_partitioning",
                                ));
                            }
                            result.uses_timestamp_column_partitioning = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.use_partitioned_tables) {
            state.serialize_entry("usePartitionedTables", &self.use_partitioned_tables)?;
        }
        if !wkt::internal::is_default(&self.uses_timestamp_column_partitioning) {
            state.serialize_entry(
                "usesTimestampColumnPartitioning",
                &self.uses_timestamp_column_partitioning,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `ListBuckets`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBucketsRequest {
    /// Required. The parent resource whose buckets are to be listed:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]"
    /// ```
    ///
    /// Note: The locations portion of the resource must be specified, but
    /// supplying the character `-` in place of [LOCATION_ID] will return all
    /// buckets.
    pub parent: std::string::String,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method. `pageToken` must be the value of
    /// `nextPageToken` from the previous response. The values of other method
    /// parameters should be identical to those in the previous call.
    pub page_token: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored. The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBucketsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBucketsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBucketsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBucketsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListBucketsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListBucketsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBucketsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBucketsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBucketsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBucketsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBucketsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response from ListBuckets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBucketsResponse {
    /// A list of buckets.
    pub buckets: std::vec::Vec<crate::model::LogBucket>,

    /// If there might be more results than appear in this response, then
    /// `nextPageToken` is included. To get the next set of results, call the same
    /// method again using the value of `nextPageToken` as `pageToken`.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBucketsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [buckets][crate::model::ListBucketsResponse::buckets].
    pub fn set_buckets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogBucket>,
    {
        use std::iter::Iterator;
        self.buckets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBucketsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBucketsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListBucketsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBucketsResponse {
    type PageItem = crate::model::LogBucket;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.buckets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBucketsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __buckets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBucketsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "buckets" => Ok(__FieldTag::__buckets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBucketsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBucketsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__buckets => {
                            if !fields.insert(__FieldTag::__buckets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for buckets",
                                ));
                            }
                            result.buckets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LogBucket>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBucketsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.buckets.is_empty() {
            state.serialize_entry("buckets", &self.buckets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `CreateBucket`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBucketRequest {
    /// Required. The resource in which to create the log bucket:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global"`
    pub parent: std::string::String,

    /// Required. A client-assigned identifier such as `"my-bucket"`. Identifiers
    /// are limited to 100 characters and can include only letters, digits,
    /// underscores, hyphens, and periods.
    pub bucket_id: std::string::String,

    /// Required. The new bucket. The region specified in the new bucket must be
    /// compliant with any Location Restriction Org Policy. The name field in the
    /// bucket is ignored.
    pub bucket: std::option::Option<crate::model::LogBucket>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBucketRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [bucket_id][crate::model::CreateBucketRequest::bucket_id].
    pub fn set_bucket_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_id = v.into();
        self
    }

    /// Sets the value of [bucket][crate::model::CreateBucketRequest::bucket].
    pub fn set_bucket<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogBucket>,
    {
        self.bucket = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bucket][crate::model::CreateBucketRequest::bucket].
    pub fn set_or_clear_bucket<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogBucket>,
    {
        self.bucket = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CreateBucketRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBucketRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __bucket_id,
            __bucket,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBucketRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "bucketId" => Ok(__FieldTag::__bucket_id),
                            "bucket_id" => Ok(__FieldTag::__bucket_id),
                            "bucket" => Ok(__FieldTag::__bucket),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBucketRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBucketRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bucket_id => {
                            if !fields.insert(__FieldTag::__bucket_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_id",
                                ));
                            }
                            result.bucket_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket =
                                map.next_value::<std::option::Option<crate::model::LogBucket>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBucketRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.bucket_id.is_empty() {
            state.serialize_entry("bucketId", &self.bucket_id)?;
        }
        if self.bucket.is_some() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `UpdateBucket`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBucketRequest {
    /// Required. The full resource name of the bucket to update.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket"`
    pub name: std::string::String,

    /// Required. The updated bucket.
    pub bucket: std::option::Option<crate::model::LogBucket>,

    /// Required. Field mask that specifies the fields in `bucket` that need an
    /// update. A bucket field will be overwritten if, and only if, it is in the
    /// update mask. `name` and output only fields cannot be updated.
    ///
    /// For a detailed `FieldMask` definition, see:
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask>
    ///
    /// For example: `updateMask=retention_days`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateBucketRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [bucket][crate::model::UpdateBucketRequest::bucket].
    pub fn set_bucket<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogBucket>,
    {
        self.bucket = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bucket][crate::model::UpdateBucketRequest::bucket].
    pub fn set_or_clear_bucket<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogBucket>,
    {
        self.bucket = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBucketRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBucketRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UpdateBucketRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBucketRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __bucket,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBucketRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "bucket" => Ok(__FieldTag::__bucket),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBucketRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBucketRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket =
                                map.next_value::<std::option::Option<crate::model::LogBucket>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBucketRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.bucket.is_some() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `GetBucket`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBucketRequest {
    /// Required. The resource name of the bucket:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket"`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBucketRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetBucketRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBucketRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBucketRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBucketRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBucketRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBucketRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `DeleteBucket`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBucketRequest {
    /// Required. The full resource name of the bucket to delete.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket"`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBucketRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.DeleteBucketRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBucketRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBucketRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBucketRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBucketRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBucketRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `UndeleteBucket`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeleteBucketRequest {
    /// Required. The full resource name of the bucket to undelete.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket"`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeleteBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeleteBucketRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UndeleteBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UndeleteBucketRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeleteBucketRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeleteBucketRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeleteBucketRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeleteBucketRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeleteBucketRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `ListViews`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListViewsRequest {
    /// Required. The bucket whose views are to be listed:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// ```
    pub parent: std::string::String,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method. `pageToken` must be the value of
    /// `nextPageToken` from the previous response. The values of other method
    /// parameters should be identical to those in the previous call.
    pub page_token: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    ///
    /// Non-positive values are ignored. The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListViewsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListViewsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListViewsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListViewsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListViewsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListViewsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListViewsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListViewsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListViewsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListViewsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListViewsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response from ListViews.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListViewsResponse {
    /// A list of views.
    pub views: std::vec::Vec<crate::model::LogView>,

    /// If there might be more results than appear in this response, then
    /// `nextPageToken` is included. To get the next set of results, call the same
    /// method again using the value of `nextPageToken` as `pageToken`.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListViewsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [views][crate::model::ListViewsResponse::views].
    pub fn set_views<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogView>,
    {
        use std::iter::Iterator;
        self.views = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListViewsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListViewsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListViewsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListViewsResponse {
    type PageItem = crate::model::LogView;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.views
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListViewsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __views,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListViewsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "views" => Ok(__FieldTag::__views),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListViewsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListViewsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__views => {
                            if !fields.insert(__FieldTag::__views) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for views",
                                ));
                            }
                            result.views = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LogView>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListViewsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.views.is_empty() {
            state.serialize_entry("views", &self.views)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `CreateView`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateViewRequest {
    /// Required. The bucket in which to create the view
    ///
    /// ```norust
    /// `"projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"`
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket"`
    pub parent: std::string::String,

    /// Required. A client-assigned identifier such as `"my-view"`. Identifiers are
    /// limited to 100 characters and can include only letters, digits,
    /// underscores, hyphens, and periods.
    pub view_id: std::string::String,

    /// Required. The new view.
    pub view: std::option::Option<crate::model::LogView>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateViewRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view_id][crate::model::CreateViewRequest::view_id].
    pub fn set_view_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.view_id = v.into();
        self
    }

    /// Sets the value of [view][crate::model::CreateViewRequest::view].
    pub fn set_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogView>,
    {
        self.view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [view][crate::model::CreateViewRequest::view].
    pub fn set_or_clear_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogView>,
    {
        self.view = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CreateViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __view_id,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "viewId" => Ok(__FieldTag::__view_id),
                            "view_id" => Ok(__FieldTag::__view_id),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view_id => {
                            if !fields.insert(__FieldTag::__view_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view_id",
                                ));
                            }
                            result.view_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view =
                                map.next_value::<std::option::Option<crate::model::LogView>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.view_id.is_empty() {
            state.serialize_entry("viewId", &self.view_id)?;
        }
        if self.view.is_some() {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `UpdateView`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateViewRequest {
    /// Required. The full resource name of the view to update
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket/views/my-view"`
    pub name: std::string::String,

    /// Required. The updated view.
    pub view: std::option::Option<crate::model::LogView>,

    /// Optional. Field mask that specifies the fields in `view` that need
    /// an update. A field will be overwritten if, and only if, it is
    /// in the update mask. `name` and output only fields cannot be updated.
    ///
    /// For a detailed `FieldMask` definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask>
    ///
    /// For example: `updateMask=filter`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::UpdateViewRequest::view].
    pub fn set_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogView>,
    {
        self.view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [view][crate::model::UpdateViewRequest::view].
    pub fn set_or_clear_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogView>,
    {
        self.view = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateViewRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateViewRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UpdateViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view =
                                map.next_value::<std::option::Option<crate::model::LogView>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.view.is_some() {
            state.serialize_entry("view", &self.view)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `GetView`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetViewRequest {
    /// Required. The resource name of the policy:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket/views/my-view"`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `DeleteView`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteViewRequest {
    /// Required. The full resource name of the view to delete:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket/views/my-view"`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.DeleteViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `ListSinks`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSinksRequest {
    /// Required. The parent resource whose sinks are to be listed:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]"
    /// "organizations/[ORGANIZATION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]"
    /// "folders/[FOLDER_ID]"
    /// ```
    pub parent: std::string::String,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method. `pageToken` must be the value of
    /// `nextPageToken` from the previous response. The values of other method
    /// parameters should be identical to those in the previous call.
    pub page_token: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored. The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSinksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSinksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSinksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSinksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListSinksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListSinksRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSinksRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSinksRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSinksRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSinksRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSinksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Result returned from `ListSinks`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSinksResponse {
    /// A list of sinks.
    pub sinks: std::vec::Vec<crate::model::LogSink>,

    /// If there might be more results than appear in this response, then
    /// `nextPageToken` is included. To get the next set of results, call the same
    /// method again using the value of `nextPageToken` as `pageToken`.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSinksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sinks][crate::model::ListSinksResponse::sinks].
    pub fn set_sinks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogSink>,
    {
        use std::iter::Iterator;
        self.sinks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSinksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSinksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListSinksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSinksResponse {
    type PageItem = crate::model::LogSink;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sinks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSinksResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sinks,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSinksResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sinks" => Ok(__FieldTag::__sinks),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSinksResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSinksResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sinks => {
                            if !fields.insert(__FieldTag::__sinks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sinks",
                                ));
                            }
                            result.sinks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LogSink>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSinksResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sinks.is_empty() {
            state.serialize_entry("sinks", &self.sinks)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `GetSink`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSinkRequest {
    /// Required. The resource name of the sink:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/sinks/[SINK_ID]"
    /// "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
    /// "folders/[FOLDER_ID]/sinks/[SINK_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/sinks/my-sink"`
    pub sink_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sink_name][crate::model::GetSinkRequest::sink_name].
    pub fn set_sink_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sink_name = v.into();
        self
    }
}

impl wkt::message::Message for GetSinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetSinkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSinkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sink_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSinkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sinkName" => Ok(__FieldTag::__sink_name),
                            "sink_name" => Ok(__FieldTag::__sink_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSinkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSinkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sink_name => {
                            if !fields.insert(__FieldTag::__sink_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sink_name",
                                ));
                            }
                            result.sink_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSinkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sink_name.is_empty() {
            state.serialize_entry("sinkName", &self.sink_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `CreateSink`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSinkRequest {
    /// Required. The resource in which to create the sink:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]"
    /// "organizations/[ORGANIZATION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]"
    /// "folders/[FOLDER_ID]"
    /// ```
    ///
    /// For examples:
    ///
    /// `"projects/my-project"`
    /// `"organizations/123456789"`
    pub parent: std::string::String,

    /// Required. The new sink, whose `name` parameter is a sink identifier that
    /// is not already in use.
    pub sink: std::option::Option<crate::model::LogSink>,

    /// Optional. Determines the kind of IAM identity returned as `writer_identity`
    /// in the new sink. If this value is omitted or set to false, and if the
    /// sink's parent is a project, then the value returned as `writer_identity` is
    /// the same group or service account used by Cloud Logging before the addition
    /// of writer identities to this API. The sink's destination must be in the
    /// same project as the sink itself.
    ///
    /// If this field is set to true, or if the sink is owned by a non-project
    /// resource such as an organization, then the value of `writer_identity` will
    /// be a unique service account used only for exports from the new sink. For
    /// more information, see `writer_identity` in
    /// [LogSink][google.logging.v2.LogSink].
    ///
    /// [google.logging.v2.LogSink]: crate::model::LogSink
    pub unique_writer_identity: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSinkRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [sink][crate::model::CreateSinkRequest::sink].
    pub fn set_sink<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogSink>,
    {
        self.sink = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sink][crate::model::CreateSinkRequest::sink].
    pub fn set_or_clear_sink<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogSink>,
    {
        self.sink = v.map(|x| x.into());
        self
    }

    /// Sets the value of [unique_writer_identity][crate::model::CreateSinkRequest::unique_writer_identity].
    pub fn set_unique_writer_identity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unique_writer_identity = v.into();
        self
    }
}

impl wkt::message::Message for CreateSinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CreateSinkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSinkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __sink,
            __unique_writer_identity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSinkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sink" => Ok(__FieldTag::__sink),
                            "uniqueWriterIdentity" => Ok(__FieldTag::__unique_writer_identity),
                            "unique_writer_identity" => Ok(__FieldTag::__unique_writer_identity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSinkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSinkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sink => {
                            if !fields.insert(__FieldTag::__sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sink",
                                ));
                            }
                            result.sink =
                                map.next_value::<std::option::Option<crate::model::LogSink>>()?;
                        }
                        __FieldTag::__unique_writer_identity => {
                            if !fields.insert(__FieldTag::__unique_writer_identity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unique_writer_identity",
                                ));
                            }
                            result.unique_writer_identity = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSinkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.sink.is_some() {
            state.serialize_entry("sink", &self.sink)?;
        }
        if !wkt::internal::is_default(&self.unique_writer_identity) {
            state.serialize_entry("uniqueWriterIdentity", &self.unique_writer_identity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `UpdateSink`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSinkRequest {
    /// Required. The full resource name of the sink to update, including the
    /// parent resource and the sink identifier:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/sinks/[SINK_ID]"
    /// "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
    /// "folders/[FOLDER_ID]/sinks/[SINK_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/sinks/my-sink"`
    pub sink_name: std::string::String,

    /// Required. The updated sink, whose name is the same identifier that appears
    /// as part of `sink_name`.
    pub sink: std::option::Option<crate::model::LogSink>,

    /// Optional. See [sinks.create][google.logging.v2.ConfigServiceV2.CreateSink]
    /// for a description of this field. When updating a sink, the effect of this
    /// field on the value of `writer_identity` in the updated sink depends on both
    /// the old and new values of this field:
    ///
    /// + If the old and new values of this field are both false or both true,
    ///   then there is no change to the sink's `writer_identity`.
    /// + If the old value is false and the new value is true, then
    ///   `writer_identity` is changed to a unique service account.
    /// + It is an error if the old value is true and the new value is
    ///   set to false or defaulted to false.
    ///
    /// [google.logging.v2.ConfigServiceV2.CreateSink]: crate::client::ConfigServiceV2::create_sink
    pub unique_writer_identity: bool,

    /// Optional. Field mask that specifies the fields in `sink` that need
    /// an update. A sink field will be overwritten if, and only if, it is
    /// in the update mask. `name` and output only fields cannot be updated.
    ///
    /// An empty `updateMask` is temporarily treated as using the following mask
    /// for backwards compatibility purposes:
    ///
    /// `destination,filter,includeChildren`
    ///
    /// At some point in the future, behavior will be removed and specifying an
    /// empty `updateMask` will be an error.
    ///
    /// For a detailed `FieldMask` definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask>
    ///
    /// For example: `updateMask=filter`
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sink_name][crate::model::UpdateSinkRequest::sink_name].
    pub fn set_sink_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sink_name = v.into();
        self
    }

    /// Sets the value of [sink][crate::model::UpdateSinkRequest::sink].
    pub fn set_sink<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogSink>,
    {
        self.sink = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sink][crate::model::UpdateSinkRequest::sink].
    pub fn set_or_clear_sink<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogSink>,
    {
        self.sink = v.map(|x| x.into());
        self
    }

    /// Sets the value of [unique_writer_identity][crate::model::UpdateSinkRequest::unique_writer_identity].
    pub fn set_unique_writer_identity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unique_writer_identity = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSinkRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSinkRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UpdateSinkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSinkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sink_name,
            __sink,
            __unique_writer_identity,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSinkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sinkName" => Ok(__FieldTag::__sink_name),
                            "sink_name" => Ok(__FieldTag::__sink_name),
                            "sink" => Ok(__FieldTag::__sink),
                            "uniqueWriterIdentity" => Ok(__FieldTag::__unique_writer_identity),
                            "unique_writer_identity" => Ok(__FieldTag::__unique_writer_identity),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSinkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSinkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sink_name => {
                            if !fields.insert(__FieldTag::__sink_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sink_name",
                                ));
                            }
                            result.sink_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sink => {
                            if !fields.insert(__FieldTag::__sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sink",
                                ));
                            }
                            result.sink =
                                map.next_value::<std::option::Option<crate::model::LogSink>>()?;
                        }
                        __FieldTag::__unique_writer_identity => {
                            if !fields.insert(__FieldTag::__unique_writer_identity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unique_writer_identity",
                                ));
                            }
                            result.unique_writer_identity = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSinkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sink_name.is_empty() {
            state.serialize_entry("sinkName", &self.sink_name)?;
        }
        if self.sink.is_some() {
            state.serialize_entry("sink", &self.sink)?;
        }
        if !wkt::internal::is_default(&self.unique_writer_identity) {
            state.serialize_entry("uniqueWriterIdentity", &self.unique_writer_identity)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `DeleteSink`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSinkRequest {
    /// Required. The full resource name of the sink to delete, including the
    /// parent resource and the sink identifier:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/sinks/[SINK_ID]"
    /// "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
    /// "folders/[FOLDER_ID]/sinks/[SINK_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/sinks/my-sink"`
    pub sink_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sink_name][crate::model::DeleteSinkRequest::sink_name].
    pub fn set_sink_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sink_name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.DeleteSinkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSinkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sink_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSinkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sinkName" => Ok(__FieldTag::__sink_name),
                            "sink_name" => Ok(__FieldTag::__sink_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSinkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSinkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sink_name => {
                            if !fields.insert(__FieldTag::__sink_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sink_name",
                                ));
                            }
                            result.sink_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSinkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sink_name.is_empty() {
            state.serialize_entry("sinkName", &self.sink_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to CreateLink.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateLinkRequest {
    /// Required. The full resource name of the bucket to create a link for.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// ```
    pub parent: std::string::String,

    /// Required. The new link.
    pub link: std::option::Option<crate::model::Link>,

    /// Required. The ID to use for the link. The link_id can have up to 100
    /// characters. A valid link_id must only have alphanumeric characters and
    /// underscores within it.
    pub link_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateLinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateLinkRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [link][crate::model::CreateLinkRequest::link].
    pub fn set_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Link>,
    {
        self.link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [link][crate::model::CreateLinkRequest::link].
    pub fn set_or_clear_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Link>,
    {
        self.link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [link_id][crate::model::CreateLinkRequest::link_id].
    pub fn set_link_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.link_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateLinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CreateLinkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateLinkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __link,
            __link_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateLinkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "link" => Ok(__FieldTag::__link),
                            "linkId" => Ok(__FieldTag::__link_id),
                            "link_id" => Ok(__FieldTag::__link_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateLinkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateLinkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__link => {
                            if !fields.insert(__FieldTag::__link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for link",
                                ));
                            }
                            result.link =
                                map.next_value::<std::option::Option<crate::model::Link>>()?;
                        }
                        __FieldTag::__link_id => {
                            if !fields.insert(__FieldTag::__link_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for link_id",
                                ));
                            }
                            result.link_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateLinkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.link.is_some() {
            state.serialize_entry("link", &self.link)?;
        }
        if !self.link_id.is_empty() {
            state.serialize_entry("linkId", &self.link_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to DeleteLink.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteLinkRequest {
    /// Required. The full resource name of the link to delete.
    ///
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteLinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteLinkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteLinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.DeleteLinkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteLinkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteLinkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteLinkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteLinkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteLinkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to ListLinks.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLinksRequest {
    /// Required. The parent resource whose links are to be listed:
    ///
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/
    pub parent: std::string::String,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method. `pageToken` must be the value of
    /// `nextPageToken` from the previous response.
    pub page_token: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLinksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLinksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLinksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLinksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListLinksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLinksRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLinksRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLinksRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLinksRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLinksRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLinksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response from ListLinks.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLinksResponse {
    /// A list of links.
    pub links: std::vec::Vec<crate::model::Link>,

    /// If there might be more results than those appearing in this response, then
    /// `nextPageToken` is included. To get the next set of results, call the same
    /// method again using the value of `nextPageToken` as `pageToken`.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLinksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [links][crate::model::ListLinksResponse::links].
    pub fn set_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Link>,
    {
        use std::iter::Iterator;
        self.links = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLinksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLinksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLinksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLinksResponse {
    type PageItem = crate::model::Link;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.links
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLinksResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __links,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLinksResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "links" => Ok(__FieldTag::__links),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLinksResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLinksResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__links => {
                            if !fields.insert(__FieldTag::__links) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for links",
                                ));
                            }
                            result.links = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Link>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLinksResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.links.is_empty() {
            state.serialize_entry("links", &self.links)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to GetLink.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetLinkRequest {
    /// Required. The resource name of the link:
    ///
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLinkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetLinkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetLinkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetLinkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetLinkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetLinkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetLinkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specifies a set of log entries that are filtered out by a sink. If
/// your Google Cloud resource receives a large volume of log entries, you can
/// use exclusions to reduce your chargeable logs. Note that exclusions on
/// organization-level and folder-level sinks don't apply to child resources.
/// Note also that you cannot modify the _Required sink or exclude logs from it.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogExclusion {
    /// Required. A client-assigned identifier, such as
    /// `"load-balancer-exclusion"`. Identifiers are limited to 100 characters and
    /// can include only letters, digits, underscores, hyphens, and periods. First
    /// character has to be alphanumeric.
    pub name: std::string::String,

    /// Optional. A description of this exclusion.
    pub description: std::string::String,

    /// Required. An [advanced logs
    /// filter](https://cloud.google.com/logging/docs/view/advanced-queries) that
    /// matches the log entries to be excluded. By using the [sample
    /// function](https://cloud.google.com/logging/docs/view/advanced-queries#sample),
    /// you can exclude less than 100% of the matching log entries.
    ///
    /// For example, the following query matches 99% of low-severity log entries
    /// from Google Cloud Storage buckets:
    ///
    /// `resource.type=gcs_bucket severity<ERROR sample(insertId, 0.99)`
    pub filter: std::string::String,

    /// Optional. If set to True, then this exclusion is disabled and it does not
    /// exclude any log entries. You can [update an
    /// exclusion][google.logging.v2.ConfigServiceV2.UpdateExclusion] to change the
    /// value of this field.
    ///
    /// [google.logging.v2.ConfigServiceV2.UpdateExclusion]: crate::client::ConfigServiceV2::update_exclusion
    pub disabled: bool,

    /// Output only. The creation timestamp of the exclusion.
    ///
    /// This field may not be present for older exclusions.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of the exclusion.
    ///
    /// This field may not be present for older exclusions.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogExclusion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LogExclusion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::LogExclusion::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::LogExclusion::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::LogExclusion::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::LogExclusion::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::LogExclusion::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::LogExclusion::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::LogExclusion::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LogExclusion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogExclusion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogExclusion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __filter,
            __disabled,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogExclusion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "filter" => Ok(__FieldTag::__filter),
                            "disabled" => Ok(__FieldTag::__disabled),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogExclusion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogExclusion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogExclusion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `ListExclusions`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListExclusionsRequest {
    /// Required. The parent resource whose exclusions are to be listed.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]"
    /// "organizations/[ORGANIZATION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]"
    /// "folders/[FOLDER_ID]"
    /// ```
    pub parent: std::string::String,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method. `pageToken` must be the value of
    /// `nextPageToken` from the previous response. The values of other method
    /// parameters should be identical to those in the previous call.
    pub page_token: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored. The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExclusionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListExclusionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListExclusionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListExclusionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListExclusionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListExclusionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListExclusionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListExclusionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListExclusionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListExclusionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListExclusionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Result returned from `ListExclusions`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListExclusionsResponse {
    /// A list of exclusions.
    pub exclusions: std::vec::Vec<crate::model::LogExclusion>,

    /// If there might be more results than appear in this response, then
    /// `nextPageToken` is included. To get the next set of results, call the same
    /// method again using the value of `nextPageToken` as `pageToken`.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExclusionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [exclusions][crate::model::ListExclusionsResponse::exclusions].
    pub fn set_exclusions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogExclusion>,
    {
        use std::iter::Iterator;
        self.exclusions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListExclusionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListExclusionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListExclusionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListExclusionsResponse {
    type PageItem = crate::model::LogExclusion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.exclusions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListExclusionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __exclusions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListExclusionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "exclusions" => Ok(__FieldTag::__exclusions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListExclusionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListExclusionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__exclusions => {
                            if !fields.insert(__FieldTag::__exclusions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusions",
                                ));
                            }
                            result.exclusions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LogExclusion>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListExclusionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.exclusions.is_empty() {
            state.serialize_entry("exclusions", &self.exclusions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `GetExclusion`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetExclusionRequest {
    /// Required. The resource name of an existing exclusion:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
    /// "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
    /// "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/exclusions/my-exclusion"`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetExclusionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetExclusionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetExclusionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetExclusionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetExclusionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetExclusionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetExclusionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetExclusionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetExclusionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `CreateExclusion`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateExclusionRequest {
    /// Required. The parent resource in which to create the exclusion:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]"
    /// "organizations/[ORGANIZATION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]"
    /// "folders/[FOLDER_ID]"
    /// ```
    ///
    /// For examples:
    ///
    /// `"projects/my-logging-project"`
    /// `"organizations/123456789"`
    pub parent: std::string::String,

    /// Required. The new exclusion, whose `name` parameter is an exclusion name
    /// that is not already used in the parent resource.
    pub exclusion: std::option::Option<crate::model::LogExclusion>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateExclusionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateExclusionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [exclusion][crate::model::CreateExclusionRequest::exclusion].
    pub fn set_exclusion<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogExclusion>,
    {
        self.exclusion = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclusion][crate::model::CreateExclusionRequest::exclusion].
    pub fn set_or_clear_exclusion<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogExclusion>,
    {
        self.exclusion = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateExclusionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CreateExclusionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateExclusionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __exclusion,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateExclusionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "exclusion" => Ok(__FieldTag::__exclusion),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateExclusionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateExclusionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exclusion => {
                            if !fields.insert(__FieldTag::__exclusion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusion",
                                ));
                            }
                            result.exclusion = map
                                .next_value::<std::option::Option<crate::model::LogExclusion>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateExclusionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.exclusion.is_some() {
            state.serialize_entry("exclusion", &self.exclusion)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `UpdateExclusion`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateExclusionRequest {
    /// Required. The resource name of the exclusion to update:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
    /// "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
    /// "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/exclusions/my-exclusion"`
    pub name: std::string::String,

    /// Required. New values for the existing exclusion. Only the fields specified
    /// in `update_mask` are relevant.
    pub exclusion: std::option::Option<crate::model::LogExclusion>,

    /// Required. A non-empty list of fields to change in the existing exclusion.
    /// New values for the fields are taken from the corresponding fields in the
    /// [LogExclusion][google.logging.v2.LogExclusion] included in this request.
    /// Fields not mentioned in `update_mask` are not changed and are ignored in
    /// the request.
    ///
    /// For example, to change the filter and description of an exclusion,
    /// specify an `update_mask` of `"filter,description"`.
    ///
    /// [google.logging.v2.LogExclusion]: crate::model::LogExclusion
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateExclusionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateExclusionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [exclusion][crate::model::UpdateExclusionRequest::exclusion].
    pub fn set_exclusion<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogExclusion>,
    {
        self.exclusion = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclusion][crate::model::UpdateExclusionRequest::exclusion].
    pub fn set_or_clear_exclusion<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogExclusion>,
    {
        self.exclusion = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateExclusionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateExclusionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateExclusionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UpdateExclusionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateExclusionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __exclusion,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateExclusionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "exclusion" => Ok(__FieldTag::__exclusion),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateExclusionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateExclusionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exclusion => {
                            if !fields.insert(__FieldTag::__exclusion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusion",
                                ));
                            }
                            result.exclusion = map
                                .next_value::<std::option::Option<crate::model::LogExclusion>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateExclusionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.exclusion.is_some() {
            state.serialize_entry("exclusion", &self.exclusion)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to `DeleteExclusion`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteExclusionRequest {
    /// Required. The resource name of an existing exclusion to delete:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
    /// "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
    /// "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/exclusions/my-exclusion"`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteExclusionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteExclusionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteExclusionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.DeleteExclusionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteExclusionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteExclusionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteExclusionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteExclusionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteExclusionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to
/// [GetCmekSettings][google.logging.v2.ConfigServiceV2.GetCmekSettings].
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
///
/// [google.logging.v2.ConfigServiceV2.GetCmekSettings]: crate::client::ConfigServiceV2::get_cmek_settings
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCmekSettingsRequest {
    /// Required. The resource for which to retrieve CMEK settings.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/cmekSettings"
    /// "organizations/[ORGANIZATION_ID]/cmekSettings"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/cmekSettings"
    /// "folders/[FOLDER_ID]/cmekSettings"
    /// ```
    ///
    /// For example:
    ///
    /// `"organizations/12345/cmekSettings"`
    ///
    /// Note: CMEK for the Log Router can be configured for Google Cloud projects,
    /// folders, organizations and billing accounts. Once configured for an
    /// organization, it applies to all projects and folders in the Google Cloud
    /// organization.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCmekSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCmekSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCmekSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetCmekSettingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCmekSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCmekSettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCmekSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCmekSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCmekSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to
/// [UpdateCmekSettings][google.logging.v2.ConfigServiceV2.UpdateCmekSettings].
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
///
/// [google.logging.v2.ConfigServiceV2.UpdateCmekSettings]: crate::client::ConfigServiceV2::update_cmek_settings
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCmekSettingsRequest {
    /// Required. The resource name for the CMEK settings to update.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/cmekSettings"
    /// "organizations/[ORGANIZATION_ID]/cmekSettings"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/cmekSettings"
    /// "folders/[FOLDER_ID]/cmekSettings"
    /// ```
    ///
    /// For example:
    ///
    /// `"organizations/12345/cmekSettings"`
    ///
    /// Note: CMEK for the Log Router can currently only be configured for Google
    /// Cloud organizations. Once configured, it applies to all projects and
    /// folders in the Google Cloud organization.
    pub name: std::string::String,

    /// Required. The CMEK settings to update.
    ///
    /// See [Enabling CMEK for Log
    /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
    /// for more information.
    pub cmek_settings: std::option::Option<crate::model::CmekSettings>,

    /// Optional. Field mask identifying which fields from `cmek_settings` should
    /// be updated. A field will be overwritten if and only if it is in the update
    /// mask. Output only fields cannot be updated.
    ///
    /// See [FieldMask][google.protobuf.FieldMask] for more information.
    ///
    /// For example: `"updateMask=kmsKeyName"`
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCmekSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateCmekSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cmek_settings][crate::model::UpdateCmekSettingsRequest::cmek_settings].
    pub fn set_cmek_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CmekSettings>,
    {
        self.cmek_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cmek_settings][crate::model::UpdateCmekSettingsRequest::cmek_settings].
    pub fn set_or_clear_cmek_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CmekSettings>,
    {
        self.cmek_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCmekSettingsRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCmekSettingsRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCmekSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UpdateCmekSettingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCmekSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __cmek_settings,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCmekSettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "cmekSettings" => Ok(__FieldTag::__cmek_settings),
                            "cmek_settings" => Ok(__FieldTag::__cmek_settings),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCmekSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCmekSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cmek_settings => {
                            if !fields.insert(__FieldTag::__cmek_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cmek_settings",
                                ));
                            }
                            result.cmek_settings = map
                                .next_value::<std::option::Option<crate::model::CmekSettings>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCmekSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.cmek_settings.is_some() {
            state.serialize_entry("cmekSettings", &self.cmek_settings)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes the customer-managed encryption key (CMEK) settings associated with
/// a project, folder, organization, billing account, or flexible resource.
///
/// Note: CMEK for the Log Router can currently only be configured for Google
/// Cloud organizations. Once configured, it applies to all projects and folders
/// in the Google Cloud organization.
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CmekSettings {
    /// Output only. The resource name of the CMEK settings.
    pub name: std::string::String,

    /// The resource name for the configured Cloud KMS key.
    ///
    /// KMS key name format:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key"`
    ///
    /// To enable CMEK for the Log Router, set this field to a valid
    /// `kms_key_name` for which the associated service account has the required
    /// cloudkms.cryptoKeyEncrypterDecrypter roles assigned for the key.
    ///
    /// The Cloud KMS key used by the Log Router can be updated by changing the
    /// `kms_key_name` to a new valid key name or disabled by setting the key name
    /// to an empty string. Encryption operations that are in progress will be
    /// completed with the key that was in use when they started. Decryption
    /// operations will be completed using the key that was used at the time of
    /// encryption unless access to that key has been revoked.
    ///
    /// To disable CMEK for the Log Router, set this field to an empty string.
    ///
    /// See [Enabling CMEK for Log
    /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
    /// for more information.
    pub kms_key_name: std::string::String,

    /// The CryptoKeyVersion resource name for the configured Cloud KMS key.
    ///
    /// KMS key name format:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]/cryptoKeyVersions/[VERSION]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key/cryptoKeyVersions/1"`
    ///
    /// This is a read-only field used to convey the specific configured
    /// CryptoKeyVersion of `kms_key` that has been configured. It will be
    /// populated in cases where the CMEK settings are bound to a single key
    /// version.
    ///
    /// If this field is populated, the `kms_key` is tied to a specific
    /// CryptoKeyVersion.
    pub kms_key_version_name: std::string::String,

    /// Output only. The service account that will be used by the Log Router to
    /// access your Cloud KMS key.
    ///
    /// Before enabling CMEK for Log Router, you must first assign the
    /// cloudkms.cryptoKeyEncrypterDecrypter role to the service account that
    /// the Log Router will use to access your Cloud KMS key. Use
    /// [GetCmekSettings][google.logging.v2.ConfigServiceV2.GetCmekSettings] to
    /// obtain the service account ID.
    ///
    /// See [Enabling CMEK for Log
    /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
    /// for more information.
    ///
    /// [google.logging.v2.ConfigServiceV2.GetCmekSettings]: crate::client::ConfigServiceV2::get_cmek_settings
    pub service_account_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CmekSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CmekSettings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::CmekSettings::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_key_version_name][crate::model::CmekSettings::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }

    /// Sets the value of [service_account_id][crate::model::CmekSettings::service_account_id].
    pub fn set_service_account_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_id = v.into();
        self
    }
}

impl wkt::message::Message for CmekSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CmekSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CmekSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __kms_key_name,
            __kms_key_version_name,
            __service_account_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CmekSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "kmsKeyVersionName" => Ok(__FieldTag::__kms_key_version_name),
                            "kms_key_version_name" => Ok(__FieldTag::__kms_key_version_name),
                            "serviceAccountId" => Ok(__FieldTag::__service_account_id),
                            "service_account_id" => Ok(__FieldTag::__service_account_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CmekSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CmekSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_version_name => {
                            if !fields.insert(__FieldTag::__kms_key_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_version_name",
                                ));
                            }
                            result.kms_key_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account_id => {
                            if !fields.insert(__FieldTag::__service_account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_id",
                                ));
                            }
                            result.service_account_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CmekSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self.kms_key_version_name.is_empty() {
            state.serialize_entry("kmsKeyVersionName", &self.kms_key_version_name)?;
        }
        if !self.service_account_id.is_empty() {
            state.serialize_entry("serviceAccountId", &self.service_account_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to
/// [GetSettings][google.logging.v2.ConfigServiceV2.GetSettings].
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
///
/// [google.logging.v2.ConfigServiceV2.GetSettings]: crate::client::ConfigServiceV2::get_settings
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSettingsRequest {
    /// Required. The resource for which to retrieve settings.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/settings"
    /// "organizations/[ORGANIZATION_ID]/settings"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/settings"
    /// "folders/[FOLDER_ID]/settings"
    /// ```
    ///
    /// For example:
    ///
    /// `"organizations/12345/settings"`
    ///
    /// Note: Settings for the Log Router can be get for Google Cloud projects,
    /// folders, organizations and billing accounts. Currently it can only be
    /// configured for organizations. Once configured for an organization, it
    /// applies to all projects and folders in the Google Cloud organization.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetSettingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to
/// [UpdateSettings][google.logging.v2.ConfigServiceV2.UpdateSettings].
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
///
/// [google.logging.v2.ConfigServiceV2.UpdateSettings]: crate::client::ConfigServiceV2::update_settings
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSettingsRequest {
    /// Required. The resource name for the settings to update.
    ///
    /// ```norust
    /// "organizations/[ORGANIZATION_ID]/settings"
    /// ```
    ///
    /// For example:
    ///
    /// `"organizations/12345/settings"`
    ///
    /// Note: Settings for the Log Router can currently only be configured for
    /// Google Cloud organizations. Once configured, it applies to all projects and
    /// folders in the Google Cloud organization.
    pub name: std::string::String,

    /// Required. The settings to update.
    ///
    /// See [Enabling CMEK for Log
    /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
    /// for more information.
    pub settings: std::option::Option<crate::model::Settings>,

    /// Optional. Field mask identifying which fields from `settings` should
    /// be updated. A field will be overwritten if and only if it is in the update
    /// mask. Output only fields cannot be updated.
    ///
    /// See [FieldMask][google.protobuf.FieldMask] for more information.
    ///
    /// For example: `"updateMask=kmsKeyName"`
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [settings][crate::model::UpdateSettingsRequest::settings].
    pub fn set_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Settings>,
    {
        self.settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [settings][crate::model::UpdateSettingsRequest::settings].
    pub fn set_or_clear_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Settings>,
    {
        self.settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSettingsRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSettingsRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UpdateSettingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __settings,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "settings" => Ok(__FieldTag::__settings),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__settings => {
                            if !fields.insert(__FieldTag::__settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for settings",
                                ));
                            }
                            result.settings =
                                map.next_value::<std::option::Option<crate::model::Settings>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.settings.is_some() {
            state.serialize_entry("settings", &self.settings)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes the settings associated with a project, folder, organization,
/// billing account, or flexible resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Settings {
    /// Output only. The resource name of the settings.
    pub name: std::string::String,

    /// Optional. The resource name for the configured Cloud KMS key.
    ///
    /// KMS key name format:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key"`
    ///
    /// To enable CMEK for the Log Router, set this field to a valid
    /// `kms_key_name` for which the associated service account has the required
    /// `roles/cloudkms.cryptoKeyEncrypterDecrypter` role assigned for the key.
    ///
    /// The Cloud KMS key used by the Log Router can be updated by changing the
    /// `kms_key_name` to a new valid key name. Encryption operations that are in
    /// progress will be completed with the key that was in use when they started.
    /// Decryption operations will be completed using the key that was used at the
    /// time of encryption unless access to that key has been revoked.
    ///
    /// To disable CMEK for the Log Router, set this field to an empty string.
    ///
    /// See [Enabling CMEK for Log
    /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
    /// for more information.
    pub kms_key_name: std::string::String,

    /// Output only. The service account that will be used by the Log Router to
    /// access your Cloud KMS key.
    ///
    /// Before enabling CMEK for Log Router, you must first assign the role
    /// `roles/cloudkms.cryptoKeyEncrypterDecrypter` to the service account that
    /// the Log Router will use to access your Cloud KMS key. Use
    /// [GetSettings][google.logging.v2.ConfigServiceV2.GetSettings] to
    /// obtain the service account ID.
    ///
    /// See [Enabling CMEK for Log
    /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
    /// for more information.
    ///
    /// [google.logging.v2.ConfigServiceV2.GetSettings]: crate::client::ConfigServiceV2::get_settings
    pub kms_service_account_id: std::string::String,

    /// Optional. The Cloud region that will be used for _Default and _Required log
    /// buckets for newly created projects and folders. For example `europe-west1`.
    /// This setting does not affect the location of custom log buckets.
    pub storage_location: std::string::String,

    /// Optional. If set to true, the _Default sink in newly created projects and
    /// folders will created in a disabled state. This can be used to automatically
    /// disable log ingestion if there is already an aggregated sink configured in
    /// the hierarchy. The _Default sink can be re-enabled manually if needed.
    pub disable_default_sink: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Settings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Settings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Settings::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_service_account_id][crate::model::Settings::kms_service_account_id].
    pub fn set_kms_service_account_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_service_account_id = v.into();
        self
    }

    /// Sets the value of [storage_location][crate::model::Settings::storage_location].
    pub fn set_storage_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_location = v.into();
        self
    }

    /// Sets the value of [disable_default_sink][crate::model::Settings::disable_default_sink].
    pub fn set_disable_default_sink<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_default_sink = v.into();
        self
    }
}

impl wkt::message::Message for Settings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.Settings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Settings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __kms_key_name,
            __kms_service_account_id,
            __storage_location,
            __disable_default_sink,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Settings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "kmsServiceAccountId" => Ok(__FieldTag::__kms_service_account_id),
                            "kms_service_account_id" => Ok(__FieldTag::__kms_service_account_id),
                            "storageLocation" => Ok(__FieldTag::__storage_location),
                            "storage_location" => Ok(__FieldTag::__storage_location),
                            "disableDefaultSink" => Ok(__FieldTag::__disable_default_sink),
                            "disable_default_sink" => Ok(__FieldTag::__disable_default_sink),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Settings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Settings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_service_account_id => {
                            if !fields.insert(__FieldTag::__kms_service_account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_service_account_id",
                                ));
                            }
                            result.kms_service_account_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_location => {
                            if !fields.insert(__FieldTag::__storage_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_location",
                                ));
                            }
                            result.storage_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disable_default_sink => {
                            if !fields.insert(__FieldTag::__disable_default_sink) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_default_sink",
                                ));
                            }
                            result.disable_default_sink = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Settings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self.kms_service_account_id.is_empty() {
            state.serialize_entry("kmsServiceAccountId", &self.kms_service_account_id)?;
        }
        if !self.storage_location.is_empty() {
            state.serialize_entry("storageLocation", &self.storage_location)?;
        }
        if !wkt::internal::is_default(&self.disable_default_sink) {
            state.serialize_entry("disableDefaultSink", &self.disable_default_sink)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to CopyLogEntries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CopyLogEntriesRequest {
    /// Required. Log bucket from which to copy log entries.
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-source-bucket"`
    pub name: std::string::String,

    /// Optional. A filter specifying which log entries to copy. The filter must be
    /// no more than 20k characters. An empty filter matches all log entries.
    pub filter: std::string::String,

    /// Required. Destination to which to copy log entries.
    pub destination: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CopyLogEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CopyLogEntriesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::CopyLogEntriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::CopyLogEntriesRequest::destination].
    pub fn set_destination<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = v.into();
        self
    }
}

impl wkt::message::Message for CopyLogEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CopyLogEntriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CopyLogEntriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __filter,
            __destination,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CopyLogEntriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "filter" => Ok(__FieldTag::__filter),
                            "destination" => Ok(__FieldTag::__destination),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CopyLogEntriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CopyLogEntriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination",
                                ));
                            }
                            result.destination = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CopyLogEntriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.destination.is_empty() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for CopyLogEntries long running operations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CopyLogEntriesMetadata {
    /// The create time of an operation.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end time of an operation.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// State of an operation.
    pub state: crate::model::OperationState,

    /// Identifies whether the user has requested cancellation of the operation.
    pub cancellation_requested: bool,

    /// CopyLogEntries RPC request.
    pub request: std::option::Option<crate::model::CopyLogEntriesRequest>,

    /// Estimated progress of the operation (0 - 100%).
    pub progress: i32,

    /// The IAM identity of a service account that must be granted access to the
    /// destination.
    ///
    /// If the service account is not granted permission to the destination within
    /// an hour, the operation will be cancelled.
    ///
    /// For example: `"serviceAccount:foo@bar.com"`
    pub writer_identity: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CopyLogEntriesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::CopyLogEntriesMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CopyLogEntriesMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CopyLogEntriesMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CopyLogEntriesMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::CopyLogEntriesMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [cancellation_requested][crate::model::CopyLogEntriesMetadata::cancellation_requested].
    pub fn set_cancellation_requested<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cancellation_requested = v.into();
        self
    }

    /// Sets the value of [request][crate::model::CopyLogEntriesMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CopyLogEntriesRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::CopyLogEntriesMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CopyLogEntriesRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress][crate::model::CopyLogEntriesMetadata::progress].
    pub fn set_progress<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress = v.into();
        self
    }

    /// Sets the value of [writer_identity][crate::model::CopyLogEntriesMetadata::writer_identity].
    pub fn set_writer_identity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.writer_identity = v.into();
        self
    }
}

impl wkt::message::Message for CopyLogEntriesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CopyLogEntriesMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CopyLogEntriesMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            __state,
            __cancellation_requested,
            __request,
            __progress,
            __writer_identity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CopyLogEntriesMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "state" => Ok(__FieldTag::__state),
                            "cancellationRequested" => Ok(__FieldTag::__cancellation_requested),
                            "cancellation_requested" => Ok(__FieldTag::__cancellation_requested),
                            "request" => Ok(__FieldTag::__request),
                            "progress" => Ok(__FieldTag::__progress),
                            "writerIdentity" => Ok(__FieldTag::__writer_identity),
                            "writer_identity" => Ok(__FieldTag::__writer_identity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CopyLogEntriesMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CopyLogEntriesMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cancellation_requested => {
                            if !fields.insert(__FieldTag::__cancellation_requested) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancellation_requested",
                                ));
                            }
                            result.cancellation_requested = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::CopyLogEntriesRequest>>()?
                                ;
                        }
                        __FieldTag::__progress => {
                            if !fields.insert(__FieldTag::__progress) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.progress = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__writer_identity => {
                            if !fields.insert(__FieldTag::__writer_identity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for writer_identity",
                                ));
                            }
                            result.writer_identity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CopyLogEntriesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.cancellation_requested) {
            state.serialize_entry("cancellationRequested", &self.cancellation_requested)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !wkt::internal::is_default(&self.progress) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("progress", &__With(&self.progress))?;
        }
        if !self.writer_identity.is_empty() {
            state.serialize_entry("writerIdentity", &self.writer_identity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response type for CopyLogEntries long running operations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CopyLogEntriesResponse {
    /// Number of log entries copied.
    pub log_entries_copied_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CopyLogEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_entries_copied_count][crate::model::CopyLogEntriesResponse::log_entries_copied_count].
    pub fn set_log_entries_copied_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.log_entries_copied_count = v.into();
        self
    }
}

impl wkt::message::Message for CopyLogEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CopyLogEntriesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CopyLogEntriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_entries_copied_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CopyLogEntriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logEntriesCopiedCount" => Ok(__FieldTag::__log_entries_copied_count),
                            "log_entries_copied_count" => {
                                Ok(__FieldTag::__log_entries_copied_count)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CopyLogEntriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CopyLogEntriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_entries_copied_count => {
                            if !fields.insert(__FieldTag::__log_entries_copied_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_entries_copied_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.log_entries_copied_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CopyLogEntriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.log_entries_copied_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "logEntriesCopiedCount",
                &__With(&self.log_entries_copied_count),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for LongRunningUpdateBucket Operations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BucketMetadata {
    /// The create time of an operation.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end time of an operation.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// State of an operation.
    pub state: crate::model::OperationState,

    pub request: std::option::Option<crate::model::bucket_metadata::Request>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BucketMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::BucketMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::BucketMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BucketMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BucketMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::BucketMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [request][crate::model::BucketMetadata::request].
    ///
    /// Note that all the setters affecting `request` are mutually
    /// exclusive.
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::bucket_metadata::Request>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// The value of [request][crate::model::BucketMetadata::request]
    /// if it holds a `CreateBucketRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_bucket_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateBucketRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::bucket_metadata::Request::CreateBucketRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::BucketMetadata::request]
    /// to hold a `CreateBucketRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_create_bucket_request<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateBucketRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::bucket_metadata::Request::CreateBucketRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::BucketMetadata::request]
    /// if it holds a `UpdateBucketRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn update_bucket_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpdateBucketRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::bucket_metadata::Request::UpdateBucketRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::BucketMetadata::request]
    /// to hold a `UpdateBucketRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_update_bucket_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UpdateBucketRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::bucket_metadata::Request::UpdateBucketRequest(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BucketMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.BucketMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BucketMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            __state,
            __create_bucket_request,
            __update_bucket_request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BucketMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "state" => Ok(__FieldTag::__state),
                            "createBucketRequest" => Ok(__FieldTag::__create_bucket_request),
                            "create_bucket_request" => Ok(__FieldTag::__create_bucket_request),
                            "updateBucketRequest" => Ok(__FieldTag::__update_bucket_request),
                            "update_bucket_request" => Ok(__FieldTag::__update_bucket_request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BucketMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BucketMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_bucket_request => {
                            if !fields.insert(__FieldTag::__create_bucket_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_bucket_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.logging.v2.BucketMetadata.create_bucket_request, latest field was createBucketRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::bucket_metadata::Request::CreateBucketRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CreateBucketRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__update_bucket_request => {
                            if !fields.insert(__FieldTag::__update_bucket_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_bucket_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.logging.v2.BucketMetadata.update_bucket_request, latest field was updateBucketRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::bucket_metadata::Request::UpdateBucketRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::UpdateBucketRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BucketMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if let Some(value) = self.create_bucket_request() {
            state.serialize_entry("createBucketRequest", value)?;
        }
        if let Some(value) = self.update_bucket_request() {
            state.serialize_entry("updateBucketRequest", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BucketMetadata].
pub mod bucket_metadata {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Request {
        /// LongRunningCreateBucket RPC request.
        CreateBucketRequest(std::boxed::Box<crate::model::CreateBucketRequest>),
        /// LongRunningUpdateBucket RPC request.
        UpdateBucketRequest(std::boxed::Box<crate::model::UpdateBucketRequest>),
    }
}

/// Metadata for long running Link operations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LinkMetadata {
    /// The start time of an operation.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end time of an operation.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// State of an operation.
    pub state: crate::model::OperationState,

    pub request: std::option::Option<crate::model::link_metadata::Request>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LinkMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::LinkMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::LinkMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::LinkMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::LinkMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::LinkMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [request][crate::model::LinkMetadata::request].
    ///
    /// Note that all the setters affecting `request` are mutually
    /// exclusive.
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::link_metadata::Request>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// The value of [request][crate::model::LinkMetadata::request]
    /// if it holds a `CreateLinkRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_link_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateLinkRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::link_metadata::Request::CreateLinkRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::LinkMetadata::request]
    /// to hold a `CreateLinkRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_create_link_request<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateLinkRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::link_metadata::Request::CreateLinkRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::LinkMetadata::request]
    /// if it holds a `DeleteLinkRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delete_link_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeleteLinkRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::link_metadata::Request::DeleteLinkRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::LinkMetadata::request]
    /// to hold a `DeleteLinkRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_delete_link_request<
        T: std::convert::Into<std::boxed::Box<crate::model::DeleteLinkRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::link_metadata::Request::DeleteLinkRequest(v.into()),
        );
        self
    }
}

impl wkt::message::Message for LinkMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LinkMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LinkMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            __state,
            __create_link_request,
            __delete_link_request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LinkMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "state" => Ok(__FieldTag::__state),
                            "createLinkRequest" => Ok(__FieldTag::__create_link_request),
                            "create_link_request" => Ok(__FieldTag::__create_link_request),
                            "deleteLinkRequest" => Ok(__FieldTag::__delete_link_request),
                            "delete_link_request" => Ok(__FieldTag::__delete_link_request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LinkMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LinkMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_link_request => {
                            if !fields.insert(__FieldTag::__create_link_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_link_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.logging.v2.LinkMetadata.create_link_request, latest field was createLinkRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::link_metadata::Request::CreateLinkRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CreateLinkRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__delete_link_request => {
                            if !fields.insert(__FieldTag::__delete_link_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_link_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.logging.v2.LinkMetadata.delete_link_request, latest field was deleteLinkRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::link_metadata::Request::DeleteLinkRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DeleteLinkRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LinkMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if let Some(value) = self.create_link_request() {
            state.serialize_entry("createLinkRequest", value)?;
        }
        if let Some(value) = self.delete_link_request() {
            state.serialize_entry("deleteLinkRequest", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LinkMetadata].
pub mod link_metadata {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Request {
        /// CreateLink RPC request.
        CreateLinkRequest(std::boxed::Box<crate::model::CreateLinkRequest>),
        /// DeleteLink RPC request.
        DeleteLinkRequest(std::boxed::Box<crate::model::DeleteLinkRequest>),
    }
}

/// Cloud Logging specific location metadata.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationMetadata {
    /// Indicates whether or not Log Analytics features are supported in the given
    /// location.
    pub log_analytics_enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_analytics_enabled][crate::model::LocationMetadata::log_analytics_enabled].
    pub fn set_log_analytics_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.log_analytics_enabled = v.into();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LocationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_analytics_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logAnalyticsEnabled" => Ok(__FieldTag::__log_analytics_enabled),
                            "log_analytics_enabled" => Ok(__FieldTag::__log_analytics_enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_analytics_enabled => {
                            if !fields.insert(__FieldTag::__log_analytics_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_analytics_enabled",
                                ));
                            }
                            result.log_analytics_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.log_analytics_enabled) {
            state.serialize_entry("logAnalyticsEnabled", &self.log_analytics_enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes a logs-based metric. The value of the metric is the number of log
/// entries that match a logs filter in a given time interval.
///
/// Logs-based metrics can also be used to extract values from logs and create a
/// distribution of the values. The distribution records the statistics of the
/// extracted values along with an optional histogram of the values as specified
/// by the bucket options.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogMetric {
    /// Required. The client-assigned metric identifier.
    /// Examples: `"error_count"`, `"nginx/requests"`.
    ///
    /// Metric identifiers are limited to 100 characters and can include only the
    /// following characters: `A-Z`, `a-z`, `0-9`, and the special characters
    /// `_-.,+!*',()%/`. The forward-slash character (`/`) denotes a hierarchy of
    /// name pieces, and it cannot be the first character of the name.
    ///
    /// This field is the `[METRIC_ID]` part of a metric resource name in the
    /// format "projects/[PROJECT_ID]/metrics/[METRIC_ID]". Example: If the
    /// resource name of a metric is
    /// `"projects/my-project/metrics/nginx%2Frequests"`, this field's value is
    /// `"nginx/requests"`.
    pub name: std::string::String,

    /// Optional. A description of this metric, which is used in documentation.
    /// The maximum length of the description is 8000 characters.
    pub description: std::string::String,

    /// Required. An [advanced logs
    /// filter](https://cloud.google.com/logging/docs/view/advanced_filters) which
    /// is used to match log entries. Example:
    ///
    /// ```norust
    /// "resource.type=gae_app AND severity>=ERROR"
    /// ```
    ///
    /// The maximum length of the filter is 20000 characters.
    pub filter: std::string::String,

    /// Optional. The resource name of the Log Bucket that owns the Log Metric.
    /// Only Log Buckets in projects are supported. The bucket has to be in the
    /// same project as the metric.
    ///
    /// For example:
    ///
    /// `projects/my-project/locations/global/buckets/my-bucket`
    ///
    /// If empty, then the Log Metric is considered a non-Bucket Log Metric.
    pub bucket_name: std::string::String,

    /// Optional. If set to True, then this metric is disabled and it does not
    /// generate any points.
    pub disabled: bool,

    /// Optional. The metric descriptor associated with the logs-based metric.
    /// If unspecified, it uses a default metric descriptor with a DELTA metric
    /// kind, INT64 value type, with no labels and a unit of "1". Such a metric
    /// counts the number of log entries matching the `filter` expression.
    ///
    /// The `name`, `type`, and `description` fields in the `metric_descriptor`
    /// are output only, and is constructed using the `name` and `description`
    /// field in the LogMetric.
    ///
    /// To create a logs-based metric that records a distribution of log values, a
    /// DELTA metric kind with a DISTRIBUTION value type must be used along with
    /// a `value_extractor` expression in the LogMetric.
    ///
    /// Each label in the metric descriptor must have a matching label
    /// name as the key and an extractor expression as the value in the
    /// `label_extractors` map.
    ///
    /// The `metric_kind` and `value_type` fields in the `metric_descriptor` cannot
    /// be updated once initially configured. New labels can be added in the
    /// `metric_descriptor`, but existing labels cannot be modified except for
    /// their description.
    pub metric_descriptor: std::option::Option<api::model::MetricDescriptor>,

    /// Optional. A `value_extractor` is required when using a distribution
    /// logs-based metric to extract the values to record from a log entry.
    /// Two functions are supported for value extraction: `EXTRACT(field)` or
    /// `REGEXP_EXTRACT(field, regex)`. The arguments are:
    ///
    /// 1. field: The name of the log entry field from which the value is to be
    ///    extracted.
    /// 1. regex: A regular expression using the Google RE2 syntax
    ///    (<https://github.com/google/re2/wiki/Syntax>) with a single capture
    ///    group to extract data from the specified log entry field. The value
    ///    of the field is converted to a string before applying the regex.
    ///    It is an error to specify a regex that does not include exactly one
    ///    capture group.
    ///
    /// The result of the extraction must be convertible to a double type, as the
    /// distribution always records double values. If either the extraction or
    /// the conversion to double fails, then those values are not recorded in the
    /// distribution.
    ///
    /// Example: `REGEXP_EXTRACT(jsonPayload.request, ".*quantity=(\d+).*")`
    pub value_extractor: std::string::String,

    /// Optional. A map from a label key string to an extractor expression which is
    /// used to extract data from a log entry field and assign as the label value.
    /// Each label key specified in the LabelDescriptor must have an associated
    /// extractor expression in this map. The syntax of the extractor expression
    /// is the same as for the `value_extractor` field.
    ///
    /// The extracted value is converted to the type defined in the label
    /// descriptor. If either the extraction or the type conversion fails,
    /// the label will have a default value. The default value for a string
    /// label is an empty string, for an integer label its 0, and for a boolean
    /// label its `false`.
    ///
    /// Note that there are upper bounds on the maximum number of labels and the
    /// number of active time series that are allowed in a project.
    pub label_extractors: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The `bucket_options` are required when the logs-based metric is
    /// using a DISTRIBUTION value type and it describes the bucket boundaries
    /// used to create a histogram of the extracted values.
    pub bucket_options: std::option::Option<api::model::distribution::BucketOptions>,

    /// Output only. The creation timestamp of the metric.
    ///
    /// This field may not be present for older metrics.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of the metric.
    ///
    /// This field may not be present for older metrics.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Deprecated. The API version that created or updated this metric.
    /// The v2 format is used by default and cannot be changed.
    #[deprecated]
    pub version: crate::model::log_metric::ApiVersion,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogMetric {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LogMetric::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::LogMetric::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::LogMetric::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [bucket_name][crate::model::LogMetric::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::LogMetric::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [metric_descriptor][crate::model::LogMetric::metric_descriptor].
    pub fn set_metric_descriptor<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::MetricDescriptor>,
    {
        self.metric_descriptor = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metric_descriptor][crate::model::LogMetric::metric_descriptor].
    pub fn set_or_clear_metric_descriptor<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::MetricDescriptor>,
    {
        self.metric_descriptor = v.map(|x| x.into());
        self
    }

    /// Sets the value of [value_extractor][crate::model::LogMetric::value_extractor].
    pub fn set_value_extractor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value_extractor = v.into();
        self
    }

    /// Sets the value of [label_extractors][crate::model::LogMetric::label_extractors].
    pub fn set_label_extractors<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.label_extractors = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [bucket_options][crate::model::LogMetric::bucket_options].
    pub fn set_bucket_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::distribution::BucketOptions>,
    {
        self.bucket_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bucket_options][crate::model::LogMetric::bucket_options].
    pub fn set_or_clear_bucket_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::distribution::BucketOptions>,
    {
        self.bucket_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::LogMetric::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::LogMetric::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::LogMetric::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::LogMetric::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version][crate::model::LogMetric::version].
    #[deprecated]
    pub fn set_version<T: std::convert::Into<crate::model::log_metric::ApiVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for LogMetric {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogMetric"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogMetric {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __filter,
            __bucket_name,
            __disabled,
            __metric_descriptor,
            __value_extractor,
            __label_extractors,
            __bucket_options,
            __create_time,
            __update_time,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogMetric")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "filter" => Ok(__FieldTag::__filter),
                            "bucketName" => Ok(__FieldTag::__bucket_name),
                            "bucket_name" => Ok(__FieldTag::__bucket_name),
                            "disabled" => Ok(__FieldTag::__disabled),
                            "metricDescriptor" => Ok(__FieldTag::__metric_descriptor),
                            "metric_descriptor" => Ok(__FieldTag::__metric_descriptor),
                            "valueExtractor" => Ok(__FieldTag::__value_extractor),
                            "value_extractor" => Ok(__FieldTag::__value_extractor),
                            "labelExtractors" => Ok(__FieldTag::__label_extractors),
                            "label_extractors" => Ok(__FieldTag::__label_extractors),
                            "bucketOptions" => Ok(__FieldTag::__bucket_options),
                            "bucket_options" => Ok(__FieldTag::__bucket_options),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogMetric;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogMetric")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bucket_name => {
                            if !fields.insert(__FieldTag::__bucket_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_name",
                                ));
                            }
                            result.bucket_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metric_descriptor => {
                            if !fields.insert(__FieldTag::__metric_descriptor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_descriptor",
                                ));
                            }
                            result.metric_descriptor = map
                                .next_value::<std::option::Option<api::model::MetricDescriptor>>(
                                )?;
                        }
                        __FieldTag::__value_extractor => {
                            if !fields.insert(__FieldTag::__value_extractor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_extractor",
                                ));
                            }
                            result.value_extractor = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__label_extractors => {
                            if !fields.insert(__FieldTag::__label_extractors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label_extractors",
                                ));
                            }
                            result.label_extractors = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bucket_options => {
                            if !fields.insert(__FieldTag::__bucket_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_options",
                                ));
                            }
                            result.bucket_options = map.next_value::<std::option::Option<api::model::distribution::BucketOptions>>()?
                                ;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map.next_value::<std::option::Option<crate::model::log_metric::ApiVersion>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogMetric {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.bucket_name.is_empty() {
            state.serialize_entry("bucketName", &self.bucket_name)?;
        }
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if self.metric_descriptor.is_some() {
            state.serialize_entry("metricDescriptor", &self.metric_descriptor)?;
        }
        if !self.value_extractor.is_empty() {
            state.serialize_entry("valueExtractor", &self.value_extractor)?;
        }
        if !self.label_extractors.is_empty() {
            state.serialize_entry("labelExtractors", &self.label_extractors)?;
        }
        if self.bucket_options.is_some() {
            state.serialize_entry("bucketOptions", &self.bucket_options)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.version) {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LogMetric].
pub mod log_metric {
    #[allow(unused_imports)]
    use super::*;

    /// Logging API version.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ApiVersion {
        /// Logging API v2.
        V2,
        /// Logging API v1.
        V1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ApiVersion::value] or
        /// [ApiVersion::name].
        UnknownValue(api_version::UnknownValue),
    }

    #[doc(hidden)]
    pub mod api_version {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ApiVersion {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::V2 => std::option::Option::Some(0),
                Self::V1 => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::V2 => std::option::Option::Some("V2"),
                Self::V1 => std::option::Option::Some("V1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ApiVersion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ApiVersion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ApiVersion {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::V2,
                1 => Self::V1,
                _ => Self::UnknownValue(api_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ApiVersion {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "V2" => Self::V2,
                "V1" => Self::V1,
                _ => Self::UnknownValue(api_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ApiVersion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::V2 => serializer.serialize_i32(0),
                Self::V1 => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ApiVersion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ApiVersion>::new(
                ".google.logging.v2.LogMetric.ApiVersion",
            ))
        }
    }
}

/// The parameters to ListLogMetrics.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLogMetricsRequest {
    /// Required. The name of the project containing the metrics:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]"
    /// ```
    pub parent: std::string::String,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method. `pageToken` must be the value of
    /// `nextPageToken` from the previous response. The values of other method
    /// parameters should be identical to those in the previous call.
    pub page_token: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored. The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLogMetricsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLogMetricsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLogMetricsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLogMetricsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListLogMetricsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLogMetricsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLogMetricsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLogMetricsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLogMetricsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLogMetricsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLogMetricsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Result returned from ListLogMetrics.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLogMetricsResponse {
    /// A list of logs-based metrics.
    pub metrics: std::vec::Vec<crate::model::LogMetric>,

    /// If there might be more results than appear in this response, then
    /// `nextPageToken` is included. To get the next set of results, call this
    /// method again using the value of `nextPageToken` as `pageToken`.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLogMetricsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metrics][crate::model::ListLogMetricsResponse::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogMetric>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLogMetricsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLogMetricsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLogMetricsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLogMetricsResponse {
    type PageItem = crate::model::LogMetric;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.metrics
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLogMetricsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metrics,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLogMetricsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metrics" => Ok(__FieldTag::__metrics),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLogMetricsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLogMetricsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metrics => {
                            if !fields.insert(__FieldTag::__metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metrics",
                                ));
                            }
                            result.metrics = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LogMetric>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLogMetricsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metrics.is_empty() {
            state.serialize_entry("metrics", &self.metrics)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to GetLogMetric.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetLogMetricRequest {
    /// Required. The resource name of the desired metric:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
    /// ```
    pub metric_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLogMetricRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_name][crate::model::GetLogMetricRequest::metric_name].
    pub fn set_metric_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric_name = v.into();
        self
    }
}

impl wkt::message::Message for GetLogMetricRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetLogMetricRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetLogMetricRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metric_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetLogMetricRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metricName" => Ok(__FieldTag::__metric_name),
                            "metric_name" => Ok(__FieldTag::__metric_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetLogMetricRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetLogMetricRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metric_name => {
                            if !fields.insert(__FieldTag::__metric_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_name",
                                ));
                            }
                            result.metric_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetLogMetricRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metric_name.is_empty() {
            state.serialize_entry("metricName", &self.metric_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to CreateLogMetric.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateLogMetricRequest {
    /// Required. The resource name of the project in which to create the metric:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]"
    /// ```
    ///
    /// The new metric must be provided in the request.
    pub parent: std::string::String,

    /// Required. The new logs-based metric, which must not have an identifier that
    /// already exists.
    pub metric: std::option::Option<crate::model::LogMetric>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateLogMetricRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateLogMetricRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [metric][crate::model::CreateLogMetricRequest::metric].
    pub fn set_metric<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogMetric>,
    {
        self.metric = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metric][crate::model::CreateLogMetricRequest::metric].
    pub fn set_or_clear_metric<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogMetric>,
    {
        self.metric = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateLogMetricRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CreateLogMetricRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateLogMetricRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __metric,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateLogMetricRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "metric" => Ok(__FieldTag::__metric),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateLogMetricRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateLogMetricRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metric => {
                            if !fields.insert(__FieldTag::__metric) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric",
                                ));
                            }
                            result.metric =
                                map.next_value::<std::option::Option<crate::model::LogMetric>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateLogMetricRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.metric.is_some() {
            state.serialize_entry("metric", &self.metric)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to UpdateLogMetric.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateLogMetricRequest {
    /// Required. The resource name of the metric to update:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
    /// ```
    ///
    /// The updated metric must be provided in the request and it's
    /// `name` field must be the same as `[METRIC_ID]` If the metric
    /// does not exist in `[PROJECT_ID]`, then a new metric is created.
    pub metric_name: std::string::String,

    /// Required. The updated metric.
    pub metric: std::option::Option<crate::model::LogMetric>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateLogMetricRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_name][crate::model::UpdateLogMetricRequest::metric_name].
    pub fn set_metric_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric_name = v.into();
        self
    }

    /// Sets the value of [metric][crate::model::UpdateLogMetricRequest::metric].
    pub fn set_metric<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogMetric>,
    {
        self.metric = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metric][crate::model::UpdateLogMetricRequest::metric].
    pub fn set_or_clear_metric<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogMetric>,
    {
        self.metric = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateLogMetricRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UpdateLogMetricRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateLogMetricRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metric_name,
            __metric,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateLogMetricRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metricName" => Ok(__FieldTag::__metric_name),
                            "metric_name" => Ok(__FieldTag::__metric_name),
                            "metric" => Ok(__FieldTag::__metric),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateLogMetricRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateLogMetricRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metric_name => {
                            if !fields.insert(__FieldTag::__metric_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_name",
                                ));
                            }
                            result.metric_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metric => {
                            if !fields.insert(__FieldTag::__metric) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric",
                                ));
                            }
                            result.metric =
                                map.next_value::<std::option::Option<crate::model::LogMetric>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateLogMetricRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metric_name.is_empty() {
            state.serialize_entry("metricName", &self.metric_name)?;
        }
        if self.metric.is_some() {
            state.serialize_entry("metric", &self.metric)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The parameters to DeleteLogMetric.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteLogMetricRequest {
    /// Required. The resource name of the metric to delete:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
    /// ```
    pub metric_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteLogMetricRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_name][crate::model::DeleteLogMetricRequest::metric_name].
    pub fn set_metric_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric_name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteLogMetricRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.DeleteLogMetricRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteLogMetricRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metric_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteLogMetricRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metricName" => Ok(__FieldTag::__metric_name),
                            "metric_name" => Ok(__FieldTag::__metric_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteLogMetricRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteLogMetricRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metric_name => {
                            if !fields.insert(__FieldTag::__metric_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_name",
                                ));
                            }
                            result.metric_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteLogMetricRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metric_name.is_empty() {
            state.serialize_entry("metricName", &self.metric_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List of different operation states.
/// High level state of the operation. This is used to report the job's
/// current state to the user. Once a long running operation is created,
/// the current state of the operation can be queried even before the
/// operation is finished and the final result is available.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OperationState {
    /// Should not be used.
    Unspecified,
    /// The operation is scheduled.
    Scheduled,
    /// Waiting for necessary permissions.
    WaitingForPermissions,
    /// The operation is running.
    Running,
    /// The operation was completed successfully.
    Succeeded,
    /// The operation failed.
    Failed,
    /// The operation was cancelled by the user.
    Cancelled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OperationState::value] or
    /// [OperationState::name].
    UnknownValue(operation_state::UnknownValue),
}

#[doc(hidden)]
pub mod operation_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OperationState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Scheduled => std::option::Option::Some(1),
            Self::WaitingForPermissions => std::option::Option::Some(2),
            Self::Running => std::option::Option::Some(3),
            Self::Succeeded => std::option::Option::Some(4),
            Self::Failed => std::option::Option::Some(5),
            Self::Cancelled => std::option::Option::Some(6),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("OPERATION_STATE_UNSPECIFIED"),
            Self::Scheduled => std::option::Option::Some("OPERATION_STATE_SCHEDULED"),
            Self::WaitingForPermissions => {
                std::option::Option::Some("OPERATION_STATE_WAITING_FOR_PERMISSIONS")
            }
            Self::Running => std::option::Option::Some("OPERATION_STATE_RUNNING"),
            Self::Succeeded => std::option::Option::Some("OPERATION_STATE_SUCCEEDED"),
            Self::Failed => std::option::Option::Some("OPERATION_STATE_FAILED"),
            Self::Cancelled => std::option::Option::Some("OPERATION_STATE_CANCELLED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OperationState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OperationState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OperationState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Scheduled,
            2 => Self::WaitingForPermissions,
            3 => Self::Running,
            4 => Self::Succeeded,
            5 => Self::Failed,
            6 => Self::Cancelled,
            _ => Self::UnknownValue(operation_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OperationState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OPERATION_STATE_UNSPECIFIED" => Self::Unspecified,
            "OPERATION_STATE_SCHEDULED" => Self::Scheduled,
            "OPERATION_STATE_WAITING_FOR_PERMISSIONS" => Self::WaitingForPermissions,
            "OPERATION_STATE_RUNNING" => Self::Running,
            "OPERATION_STATE_SUCCEEDED" => Self::Succeeded,
            "OPERATION_STATE_FAILED" => Self::Failed,
            "OPERATION_STATE_CANCELLED" => Self::Cancelled,
            _ => Self::UnknownValue(operation_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OperationState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Scheduled => serializer.serialize_i32(1),
            Self::WaitingForPermissions => serializer.serialize_i32(2),
            Self::Running => serializer.serialize_i32(3),
            Self::Succeeded => serializer.serialize_i32(4),
            Self::Failed => serializer.serialize_i32(5),
            Self::Cancelled => serializer.serialize_i32(6),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OperationState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperationState>::new(
            ".google.logging.v2.OperationState",
        ))
    }
}

/// LogBucket lifecycle states.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LifecycleState {
    /// Unspecified state. This is only used/useful for distinguishing unset
    /// values.
    Unspecified,
    /// The normal and active state.
    Active,
    /// The resource has been marked for deletion by the user. For some resources
    /// (e.g. buckets), this can be reversed by an un-delete operation.
    DeleteRequested,
    /// The resource has been marked for an update by the user. It will remain in
    /// this state until the update is complete.
    Updating,
    /// The resource has been marked for creation by the user. It will remain in
    /// this state until the creation is complete.
    Creating,
    /// The resource is in an INTERNAL error state.
    Failed,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LifecycleState::value] or
    /// [LifecycleState::name].
    UnknownValue(lifecycle_state::UnknownValue),
}

#[doc(hidden)]
pub mod lifecycle_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LifecycleState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Active => std::option::Option::Some(1),
            Self::DeleteRequested => std::option::Option::Some(2),
            Self::Updating => std::option::Option::Some(3),
            Self::Creating => std::option::Option::Some(4),
            Self::Failed => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("LIFECYCLE_STATE_UNSPECIFIED"),
            Self::Active => std::option::Option::Some("ACTIVE"),
            Self::DeleteRequested => std::option::Option::Some("DELETE_REQUESTED"),
            Self::Updating => std::option::Option::Some("UPDATING"),
            Self::Creating => std::option::Option::Some("CREATING"),
            Self::Failed => std::option::Option::Some("FAILED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LifecycleState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LifecycleState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LifecycleState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Active,
            2 => Self::DeleteRequested,
            3 => Self::Updating,
            4 => Self::Creating,
            5 => Self::Failed,
            _ => Self::UnknownValue(lifecycle_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LifecycleState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LIFECYCLE_STATE_UNSPECIFIED" => Self::Unspecified,
            "ACTIVE" => Self::Active,
            "DELETE_REQUESTED" => Self::DeleteRequested,
            "UPDATING" => Self::Updating,
            "CREATING" => Self::Creating,
            "FAILED" => Self::Failed,
            _ => Self::UnknownValue(lifecycle_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LifecycleState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Active => serializer.serialize_i32(1),
            Self::DeleteRequested => serializer.serialize_i32(2),
            Self::Updating => serializer.serialize_i32(3),
            Self::Creating => serializer.serialize_i32(4),
            Self::Failed => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LifecycleState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<LifecycleState>::new(
            ".google.logging.v2.LifecycleState",
        ))
    }
}

/// IndexType is used for custom indexing. It describes the type of an indexed
/// field.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum IndexType {
    /// The index's type is unspecified.
    Unspecified,
    /// The index is a string-type index.
    String,
    /// The index is a integer-type index.
    Integer,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [IndexType::value] or
    /// [IndexType::name].
    UnknownValue(index_type::UnknownValue),
}

#[doc(hidden)]
pub mod index_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl IndexType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::String => std::option::Option::Some(1),
            Self::Integer => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INDEX_TYPE_UNSPECIFIED"),
            Self::String => std::option::Option::Some("INDEX_TYPE_STRING"),
            Self::Integer => std::option::Option::Some("INDEX_TYPE_INTEGER"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for IndexType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for IndexType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for IndexType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::String,
            2 => Self::Integer,
            _ => Self::UnknownValue(index_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for IndexType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INDEX_TYPE_UNSPECIFIED" => Self::Unspecified,
            "INDEX_TYPE_STRING" => Self::String,
            "INDEX_TYPE_INTEGER" => Self::Integer,
            _ => Self::UnknownValue(index_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for IndexType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::String => serializer.serialize_i32(1),
            Self::Integer => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for IndexType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<IndexType>::new(
            ".google.logging.v2.IndexType",
        ))
    }
}
