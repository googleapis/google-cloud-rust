// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate logging_type;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// An individual entry in a log.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogEntry {
    /// Required. The resource name of the log to which this log entry belongs:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/logs/[LOG_ID]"
    /// "organizations/[ORGANIZATION_ID]/logs/[LOG_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]"
    /// "folders/[FOLDER_ID]/logs/[LOG_ID]"
    /// ```
    ///
    /// A project number may be used in place of PROJECT_ID. The project number is
    /// translated to its corresponding PROJECT_ID internally and the `log_name`
    /// field will contain PROJECT_ID in queries and exports.
    ///
    /// `[LOG_ID]` must be URL-encoded within `log_name`. Example:
    /// `"organizations/1234567890/logs/cloudresourcemanager.googleapis.com%2Factivity"`.
    ///
    /// `[LOG_ID]` must be less than 512 characters long and can only include the
    /// following characters: upper and lower case alphanumeric characters,
    /// forward-slash, underscore, hyphen, and period.
    ///
    /// For backward compatibility, if `log_name` begins with a forward-slash, such
    /// as `/projects/...`, then the log entry is ingested as usual, but the
    /// forward-slash is removed. Listing the log entry will not show the leading
    /// slash and filtering for a log name with a leading slash will never return
    /// any results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub log_name: std::string::String,

    /// Required. The monitored resource that produced this log entry.
    ///
    /// Example: a log entry that reports a database error would be associated with
    /// the monitored resource designating the particular database that reported
    /// the error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource: std::option::Option<api::model::MonitoredResource>,

    /// Optional. The time the event described by the log entry occurred. This time
    /// is used to compute the log entry's age and to enforce the logs retention
    /// period. If this field is omitted in a new log entry, then Logging assigns
    /// it the current time. Timestamps have nanosecond accuracy, but trailing
    /// zeros in the fractional seconds might be omitted when the timestamp is
    /// displayed.
    ///
    /// Incoming log entries must have timestamps that don't exceed the
    /// [logs retention
    /// period](https://cloud.google.com/logging/quotas#logs_retention_periods) in
    /// the past, and that don't exceed 24 hours in the future. Log entries outside
    /// those time boundaries aren't ingested by Logging.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timestamp: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the log entry was received by Logging.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub receive_timestamp: std::option::Option<wkt::Timestamp>,

    /// Optional. The severity of the log entry. The default value is
    /// `LogSeverity.DEFAULT`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub severity: logging_type::model::LogSeverity,

    /// Optional. A unique identifier for the log entry. If you provide a value,
    /// then Logging considers other log entries in the same project, with the same
    /// `timestamp`, and with the same `insert_id` to be duplicates which are
    /// removed in a single query result. However, there are no guarantees of
    /// de-duplication in the export of logs.
    ///
    /// If the `insert_id` is omitted when writing a log entry, the Logging API
    /// assigns its own unique identifier in this field.
    ///
    /// In queries, the `insert_id` is also used to order log entries that have
    /// the same `log_name` and `timestamp` values.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub insert_id: std::string::String,

    /// Optional. Information about the HTTP request associated with this log
    /// entry, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub http_request: std::option::Option<logging_type::model::HttpRequest>,

    /// Optional. A map of key, value pairs that provides additional information
    /// about the log entry. The labels can be user-defined or system-defined.
    ///
    /// User-defined labels are arbitrary key, value pairs that you can use to
    /// classify logs.
    ///
    /// System-defined labels are defined by GCP services for platform logs.
    /// They have two components - a service namespace component and the
    /// attribute name. For example: `compute.googleapis.com/resource_name`.
    ///
    /// Cloud Logging truncates label keys that exceed 512 B and label
    /// values that exceed 64 KB upon their associated log entry being
    /// written. The truncation is indicated by an ellipsis at the
    /// end of the character string.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Information about an operation associated with the log entry, if
    /// applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub operation: std::option::Option<crate::model::LogEntryOperation>,

    /// Optional. The REST resource name of the trace being written to
    /// [Cloud Trace](https://cloud.google.com/trace) in
    /// association with this log entry. For example, if your trace data is stored
    /// in the Cloud project "my-trace-project" and if the service that is creating
    /// the log entry receives a trace header that includes the trace ID "12345",
    /// then the service should use "projects/my-tracing-project/traces/12345".
    ///
    /// The `trace` field provides the link between logs and traces. By using
    /// this field, you can navigate from a log entry to a trace.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trace: std::string::String,

    /// Optional. The ID of the [Cloud Trace](https://cloud.google.com/trace) span
    /// associated with the current operation in which the log is being written.
    /// For example, if a span has the REST resource name of
    /// "projects/some-project/traces/some-trace/spans/some-span-id", then the
    /// `span_id` field is "some-span-id".
    ///
    /// A
    /// [Span](https://cloud.google.com/trace/docs/reference/v2/rest/v2/projects.traces/batchWrite#Span)
    /// represents a single operation within a trace. Whereas a trace may involve
    /// multiple different microservices running on multiple different machines,
    /// a span generally corresponds to a single logical operation being performed
    /// in a single instance of a microservice on one specific machine. Spans
    /// are the nodes within the tree that is a trace.
    ///
    /// Applications that are [instrumented for
    /// tracing](https://cloud.google.com/trace/docs/setup) will generally assign a
    /// new, unique span ID on each incoming request. It is also common to create
    /// and record additional spans corresponding to internal processing elements
    /// as well as issuing requests to dependencies.
    ///
    /// The span ID is expected to be a 16-character, hexadecimal encoding of an
    /// 8-byte array and should not be zero. It should be unique within the trace
    /// and should, ideally, be generated in a manner that is uniformly random.
    ///
    /// Example values:
    ///
    /// - `000000000000004a`
    /// - `7a2190356c3fc94b`
    /// - `0000f00300090021`
    /// - `d39223e101960076`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub span_id: std::string::String,

    /// Optional. The sampling decision of the trace associated with the log entry.
    ///
    /// True means that the trace resource name in the `trace` field was sampled
    /// for storage in a trace backend. False means that the trace was not sampled
    /// for storage when this log entry was written, or the sampling decision was
    /// unknown at the time. A non-sampled `trace` value is still useful as a
    /// request correlation identifier. The default is False.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub trace_sampled: bool,

    /// Optional. Source code location information associated with the log entry,
    /// if any.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_location: std::option::Option<crate::model::LogEntrySourceLocation>,

    /// Optional. Information indicating this LogEntry is part of a sequence of
    /// multiple log entries split from a single LogEntry.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub split: std::option::Option<crate::model::LogSplit>,

    /// The log entry payload, which can be one of multiple types.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub payload: std::option::Option<crate::model::log_entry::Payload>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_name][crate::model::LogEntry::log_name].
    pub fn set_log_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_name = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::LogEntry::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::MonitoredResource>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::LogEntry::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::MonitoredResource>,
    {
        self.resource = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timestamp][crate::model::LogEntry::timestamp].
    pub fn set_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timestamp][crate::model::LogEntry::timestamp].
    pub fn set_or_clear_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [receive_timestamp][crate::model::LogEntry::receive_timestamp].
    pub fn set_receive_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.receive_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [receive_timestamp][crate::model::LogEntry::receive_timestamp].
    pub fn set_or_clear_receive_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.receive_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [severity][crate::model::LogEntry::severity].
    pub fn set_severity<T: std::convert::Into<logging_type::model::LogSeverity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [insert_id][crate::model::LogEntry::insert_id].
    pub fn set_insert_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.insert_id = v.into();
        self
    }

    /// Sets the value of [http_request][crate::model::LogEntry::http_request].
    pub fn set_http_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<logging_type::model::HttpRequest>,
    {
        self.http_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [http_request][crate::model::LogEntry::http_request].
    pub fn set_or_clear_http_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<logging_type::model::HttpRequest>,
    {
        self.http_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::LogEntry::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [operation][crate::model::LogEntry::operation].
    pub fn set_operation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogEntryOperation>,
    {
        self.operation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [operation][crate::model::LogEntry::operation].
    pub fn set_or_clear_operation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogEntryOperation>,
    {
        self.operation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [trace][crate::model::LogEntry::trace].
    pub fn set_trace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace = v.into();
        self
    }

    /// Sets the value of [span_id][crate::model::LogEntry::span_id].
    pub fn set_span_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.span_id = v.into();
        self
    }

    /// Sets the value of [trace_sampled][crate::model::LogEntry::trace_sampled].
    pub fn set_trace_sampled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.trace_sampled = v.into();
        self
    }

    /// Sets the value of [source_location][crate::model::LogEntry::source_location].
    pub fn set_source_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogEntrySourceLocation>,
    {
        self.source_location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_location][crate::model::LogEntry::source_location].
    pub fn set_or_clear_source_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogEntrySourceLocation>,
    {
        self.source_location = v.map(|x| x.into());
        self
    }

    /// Sets the value of [split][crate::model::LogEntry::split].
    pub fn set_split<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogSplit>,
    {
        self.split = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [split][crate::model::LogEntry::split].
    pub fn set_or_clear_split<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogSplit>,
    {
        self.split = v.map(|x| x.into());
        self
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload].
    ///
    /// Note that all the setters affecting `payload` are mutually
    /// exclusive.
    pub fn set_payload<
        T: std::convert::Into<std::option::Option<crate::model::log_entry::Payload>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }

    /// The value of [payload][crate::model::LogEntry::payload]
    /// if it holds a `ProtoPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn proto_payload(&self) -> std::option::Option<&std::boxed::Box<wkt::Any>> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::model::log_entry::Payload::ProtoPayload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload]
    /// to hold a `ProtoPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_proto_payload<T: std::convert::Into<std::boxed::Box<wkt::Any>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload =
            std::option::Option::Some(crate::model::log_entry::Payload::ProtoPayload(v.into()));
        self
    }

    /// The value of [payload][crate::model::LogEntry::payload]
    /// if it holds a `TextPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::model::log_entry::Payload::TextPayload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload]
    /// to hold a `TextPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_text_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload =
            std::option::Option::Some(crate::model::log_entry::Payload::TextPayload(v.into()));
        self
    }

    /// The value of [payload][crate::model::LogEntry::payload]
    /// if it holds a `JsonPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json_payload(&self) -> std::option::Option<&std::boxed::Box<wkt::Struct>> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::model::log_entry::Payload::JsonPayload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload]
    /// to hold a `JsonPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_json_payload<T: std::convert::Into<std::boxed::Box<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload =
            std::option::Option::Some(crate::model::log_entry::Payload::JsonPayload(v.into()));
        self
    }
}

impl wkt::message::Message for LogEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogEntry"
    }
}

/// Defines additional types related to [LogEntry].
pub mod log_entry {
    #[allow(unused_imports)]
    use super::*;

    /// The log entry payload, which can be one of multiple types.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Payload {
        /// The log entry payload, represented as a protocol buffer. Some Google
        /// Cloud Platform services use this field for their log entry payloads.
        ///
        /// The following protocol buffer types are supported; user-defined types
        /// are not supported:
        ///
        /// "type.googleapis.com/google.cloud.audit.AuditLog"
        /// "type.googleapis.com/google.appengine.logging.v1.RequestLog"
        ProtoPayload(std::boxed::Box<wkt::Any>),
        /// The log entry payload, represented as a Unicode string (UTF-8).
        TextPayload(std::string::String),
        /// The log entry payload, represented as a structure that is
        /// expressed as a JSON object.
        JsonPayload(std::boxed::Box<wkt::Struct>),
    }
}

/// Additional information about a potentially long-running operation with which
/// a log entry is associated.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogEntryOperation {
    /// Optional. An arbitrary operation identifier. Log entries with the same
    /// identifier are assumed to be part of the same operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Optional. An arbitrary producer identifier. The combination of `id` and
    /// `producer` must be globally unique. Examples for `producer`:
    /// `"MyDivision.MyBigCompany.com"`, `"github.com/MyProject/MyApplication"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub producer: std::string::String,

    /// Optional. Set this to True if this is the first log entry in the operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub first: bool,

    /// Optional. Set this to True if this is the last log entry in the operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub last: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogEntryOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::LogEntryOperation::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [producer][crate::model::LogEntryOperation::producer].
    pub fn set_producer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.producer = v.into();
        self
    }

    /// Sets the value of [first][crate::model::LogEntryOperation::first].
    pub fn set_first<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.first = v.into();
        self
    }

    /// Sets the value of [last][crate::model::LogEntryOperation::last].
    pub fn set_last<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.last = v.into();
        self
    }
}

impl wkt::message::Message for LogEntryOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogEntryOperation"
    }
}

/// Additional information about the source code location that produced the log
/// entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogEntrySourceLocation {
    /// Optional. Source file name. Depending on the runtime environment, this
    /// might be a simple name or a fully-qualified name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file: std::string::String,

    /// Optional. Line within the source file. 1-based; 0 indicates no line number
    /// available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub line: i64,

    /// Optional. Human-readable name of the function or method being invoked, with
    /// optional context such as the class or package name. This information may be
    /// used in contexts such as the logs viewer, where a file and line number are
    /// less meaningful. The format can vary by language. For example:
    /// `qual.if.ied.Class.method` (Java), `dir/package.func` (Go), `function`
    /// (Python).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub function: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogEntrySourceLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file][crate::model::LogEntrySourceLocation::file].
    pub fn set_file<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file = v.into();
        self
    }

    /// Sets the value of [line][crate::model::LogEntrySourceLocation::line].
    pub fn set_line<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.line = v.into();
        self
    }

    /// Sets the value of [function][crate::model::LogEntrySourceLocation::function].
    pub fn set_function<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.function = v.into();
        self
    }
}

impl wkt::message::Message for LogEntrySourceLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogEntrySourceLocation"
    }
}

/// Additional information used to correlate multiple log entries. Used when a
/// single LogEntry would exceed the Google Cloud Logging size limit and is
/// split across multiple log entries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogSplit {
    /// A globally unique identifier for all log entries in a sequence of split log
    /// entries. All log entries with the same |LogSplit.uid| are assumed to be
    /// part of the same sequence of split log entries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// The index of this LogEntry in the sequence of split log entries. Log
    /// entries are given |index| values 0, 1, ..., n-1 for a sequence of n log
    /// entries.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub index: i32,

    /// The total number of log entries that the original LogEntry was split into.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub total_splits: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogSplit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uid][crate::model::LogSplit::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [index][crate::model::LogSplit::index].
    pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [total_splits][crate::model::LogSplit::total_splits].
    pub fn set_total_splits<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_splits = v.into();
        self
    }
}

impl wkt::message::Message for LogSplit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogSplit"
    }
}

/// The parameters to DeleteLog.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteLogRequest {
    /// Required. The resource name of the log to delete:
    ///
    /// * `projects/[PROJECT_ID]/logs/[LOG_ID]`
    /// * `organizations/[ORGANIZATION_ID]/logs/[LOG_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]`
    /// * `folders/[FOLDER_ID]/logs/[LOG_ID]`
    ///
    /// `[LOG_ID]` must be URL-encoded. For example,
    /// `"projects/my-project-id/logs/syslog"`,
    /// `"organizations/123/logs/cloudaudit.googleapis.com%2Factivity"`.
    ///
    /// For more information about log names, see
    /// [LogEntry][google.logging.v2.LogEntry].
    ///
    /// [google.logging.v2.LogEntry]: crate::model::LogEntry
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub log_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteLogRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_name][crate::model::DeleteLogRequest::log_name].
    pub fn set_log_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteLogRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.DeleteLogRequest"
    }
}

/// The parameters to WriteLogEntries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteLogEntriesRequest {
    /// Optional. A default log resource name that is assigned to all log entries
    /// in `entries` that do not specify a value for `log_name`:
    ///
    /// * `projects/[PROJECT_ID]/logs/[LOG_ID]`
    /// * `organizations/[ORGANIZATION_ID]/logs/[LOG_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]`
    /// * `folders/[FOLDER_ID]/logs/[LOG_ID]`
    ///
    /// `[LOG_ID]` must be URL-encoded. For example:
    ///
    /// ```norust
    /// "projects/my-project-id/logs/syslog"
    /// "organizations/123/logs/cloudaudit.googleapis.com%2Factivity"
    /// ```
    ///
    /// The permission `logging.logEntries.create` is needed on each project,
    /// organization, billing account, or folder that is receiving new log
    /// entries, whether the resource is specified in `logName` or in an
    /// individual log entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub log_name: std::string::String,

    /// Optional. A default monitored resource object that is assigned to all log
    /// entries in `entries` that do not specify a value for `resource`. Example:
    ///
    /// ```norust
    /// { "type": "gce_instance",
    ///   "labels": {
    ///     "zone": "us-central1-a", "instance_id": "00000000000000000000" }}
    /// ```
    ///
    /// See [LogEntry][google.logging.v2.LogEntry].
    ///
    /// [google.logging.v2.LogEntry]: crate::model::LogEntry
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource: std::option::Option<api::model::MonitoredResource>,

    /// Optional. Default labels that are added to the `labels` field of all log
    /// entries in `entries`. If a log entry already has a label with the same key
    /// as a label in this parameter, then the log entry's label is not changed.
    /// See [LogEntry][google.logging.v2.LogEntry].
    ///
    /// [google.logging.v2.LogEntry]: crate::model::LogEntry
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The log entries to send to Logging. The order of log
    /// entries in this list does not matter. Values supplied in this method's
    /// `log_name`, `resource`, and `labels` fields are copied into those log
    /// entries in this list that do not include values for their corresponding
    /// fields. For more information, see the
    /// [LogEntry][google.logging.v2.LogEntry] type.
    ///
    /// If the `timestamp` or `insert_id` fields are missing in log entries, then
    /// this method supplies the current time or a unique identifier, respectively.
    /// The supplied values are chosen so that, among the log entries that did not
    /// supply their own values, the entries earlier in the list will sort before
    /// the entries later in the list. See the `entries.list` method.
    ///
    /// Log entries with timestamps that are more than the
    /// [logs retention period](https://cloud.google.com/logging/quotas) in
    /// the past or more than 24 hours in the future will not be available when
    /// calling `entries.list`. However, those log entries can still be [exported
    /// with
    /// LogSinks](https://cloud.google.com/logging/docs/api/tasks/exporting-logs).
    ///
    /// To improve throughput and to avoid exceeding the
    /// [quota limit](https://cloud.google.com/logging/quotas) for calls to
    /// `entries.write`, you should try to include several log entries in this
    /// list, rather than calling this method for each individual log entry.
    ///
    /// [google.logging.v2.LogEntry]: crate::model::LogEntry
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::LogEntry>,

    /// Optional. Whether a batch's valid entries should be written even if some
    /// other entry failed due to a permanent error such as INVALID_ARGUMENT or
    /// PERMISSION_DENIED. If any entry failed, then the response status is the
    /// response status of one of the failed entries. The response will include
    /// error details in `WriteLogEntriesPartialErrors.log_entry_errors` keyed by
    /// the entries' zero-based index in the `entries`. Failed requests for which
    /// no entries are written will not include per-entry errors.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub partial_success: bool,

    /// Optional. If true, the request should expect normal response, but the
    /// entries won't be persisted nor exported. Useful for checking whether the
    /// logging API endpoints are working properly before sending valuable data.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub dry_run: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WriteLogEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_name][crate::model::WriteLogEntriesRequest::log_name].
    pub fn set_log_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_name = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::WriteLogEntriesRequest::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::MonitoredResource>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::WriteLogEntriesRequest::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::MonitoredResource>,
    {
        self.resource = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::WriteLogEntriesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [entries][crate::model::WriteLogEntriesRequest::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogEntry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [partial_success][crate::model::WriteLogEntriesRequest::partial_success].
    pub fn set_partial_success<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.partial_success = v.into();
        self
    }

    /// Sets the value of [dry_run][crate::model::WriteLogEntriesRequest::dry_run].
    pub fn set_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dry_run = v.into();
        self
    }
}

impl wkt::message::Message for WriteLogEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.WriteLogEntriesRequest"
    }
}

/// Result returned from WriteLogEntries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteLogEntriesResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WriteLogEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for WriteLogEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.WriteLogEntriesResponse"
    }
}

/// Error details for WriteLogEntries with partial success.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteLogEntriesPartialErrors {
    /// When `WriteLogEntriesRequest.partial_success` is true, records the error
    /// status for entries that were not written due to a permanent error, keyed
    /// by the entry's zero-based index in `WriteLogEntriesRequest.entries`.
    ///
    /// Failed requests for which no entries are written will not include
    /// per-entry errors.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "std::collections::HashMap<wkt::internal::I32, _>")]
    pub log_entry_errors: std::collections::HashMap<i32, rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WriteLogEntriesPartialErrors {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_entry_errors][crate::model::WriteLogEntriesPartialErrors::log_entry_errors].
    pub fn set_log_entry_errors<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i32>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.log_entry_errors = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for WriteLogEntriesPartialErrors {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.WriteLogEntriesPartialErrors"
    }
}

/// The parameters to `ListLogEntries`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLogEntriesRequest {
    /// Required. Names of one or more parent resources from which to
    /// retrieve log entries:
    ///
    /// * `projects/[PROJECT_ID]`
    /// * `organizations/[ORGANIZATION_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]`
    /// * `folders/[FOLDER_ID]`
    ///
    /// May alternatively be one or more views:
    ///
    /// * `projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    ///
    /// Projects listed in the `project_ids` field are added to this list.
    /// A maximum of 100 resources may be specified in a single request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_names: std::vec::Vec<std::string::String>,

    /// Optional. Only log entries that match the filter are returned.  An empty
    /// filter matches all log entries in the resources listed in `resource_names`.
    /// Referencing a parent resource that is not listed in `resource_names` will
    /// cause the filter to return no results. The maximum length of a filter is
    /// 20,000 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. How the results should be sorted.  Presently, the only permitted
    /// values are `"timestamp asc"` (default) and `"timestamp desc"`. The first
    /// option returns entries in order of increasing values of
    /// `LogEntry.timestamp` (oldest first), and the second option returns entries
    /// in order of decreasing timestamps (newest first).  Entries with equal
    /// timestamps are returned in order of their `insert_id` values.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    /// Default is 50. If the value is negative or exceeds 1000, the request is
    /// rejected. The presence of `next_page_token` in the response indicates that
    /// more results might be available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method.  `page_token` must be the value of
    /// `next_page_token` from the previous response.  The values of other method
    /// parameters should be identical to those in the previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLogEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_names][crate::model::ListLogEntriesRequest::resource_names].
    pub fn set_resource_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filter][crate::model::ListLogEntriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListLogEntriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLogEntriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLogEntriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLogEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLogEntriesRequest"
    }
}

/// Result returned from `ListLogEntries`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLogEntriesResponse {
    /// A list of log entries.  If `entries` is empty, `nextPageToken` may still be
    /// returned, indicating that more entries may exist.  See `nextPageToken` for
    /// more information.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::LogEntry>,

    /// If there might be more results than those appearing in this response, then
    /// `nextPageToken` is included.  To get the next set of results, call this
    /// method again using the value of `nextPageToken` as `pageToken`.
    ///
    /// If a value for `next_page_token` appears and the `entries` field is empty,
    /// it means that the search found no log entries so far but it did not have
    /// time to search all the possible log entries.  Retry the method with this
    /// value for `page_token` to continue the search.  Alternatively, consider
    /// speeding up the search by changing your filter to specify a single log name
    /// or resource type, or to narrow the time range of the search.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLogEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::ListLogEntriesResponse::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogEntry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLogEntriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLogEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLogEntriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLogEntriesResponse {
    type PageItem = crate::model::LogEntry;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entries
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The parameters to ListMonitoredResourceDescriptors
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMonitoredResourceDescriptorsRequest {
    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored.  The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method.  `pageToken` must be the value of
    /// `nextPageToken` from the previous response.  The values of other method
    /// parameters should be identical to those in the previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMonitoredResourceDescriptorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [page_size][crate::model::ListMonitoredResourceDescriptorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMonitoredResourceDescriptorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMonitoredResourceDescriptorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListMonitoredResourceDescriptorsRequest"
    }
}

/// Result returned from ListMonitoredResourceDescriptors.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMonitoredResourceDescriptorsResponse {
    /// A list of resource descriptors.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_descriptors: std::vec::Vec<api::model::MonitoredResourceDescriptor>,

    /// If there might be more results than those appearing in this response, then
    /// `nextPageToken` is included.  To get the next set of results, call this
    /// method again using the value of `nextPageToken` as `pageToken`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMonitoredResourceDescriptorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_descriptors][crate::model::ListMonitoredResourceDescriptorsResponse::resource_descriptors].
    pub fn set_resource_descriptors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::MonitoredResourceDescriptor>,
    {
        use std::iter::Iterator;
        self.resource_descriptors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMonitoredResourceDescriptorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMonitoredResourceDescriptorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListMonitoredResourceDescriptorsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMonitoredResourceDescriptorsResponse {
    type PageItem = api::model::MonitoredResourceDescriptor;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.resource_descriptors
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The parameters to ListLogs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLogsRequest {
    /// Required. The resource name to list logs for:
    ///
    /// * `projects/[PROJECT_ID]`
    /// * `organizations/[ORGANIZATION_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]`
    /// * `folders/[FOLDER_ID]`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. List of resource names to list logs for:
    ///
    /// * `projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    ///
    /// To support legacy queries, it could also be:
    ///
    /// * `projects/[PROJECT_ID]`
    /// * `organizations/[ORGANIZATION_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]`
    /// * `folders/[FOLDER_ID]`
    ///
    /// The resource name in the `parent` field is added to this list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_names: std::vec::Vec<std::string::String>,

    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored.  The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method.  `pageToken` must be the value of
    /// `nextPageToken` from the previous response.  The values of other method
    /// parameters should be identical to those in the previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLogsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLogsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [resource_names][crate::model::ListLogsRequest::resource_names].
    pub fn set_resource_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLogsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLogsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLogsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLogsRequest"
    }
}

/// Result returned from ListLogs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLogsResponse {
    /// A list of log names. For example,
    /// `"projects/my-project/logs/syslog"` or
    /// `"organizations/123/logs/cloudresourcemanager.googleapis.com%2Factivity"`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub log_names: std::vec::Vec<std::string::String>,

    /// If there might be more results than those appearing in this response, then
    /// `nextPageToken` is included.  To get the next set of results, call this
    /// method again using the value of `nextPageToken` as `pageToken`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLogsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_names][crate::model::ListLogsResponse::log_names].
    pub fn set_log_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.log_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLogsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLogsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLogsResponse"
    }
}

/// The parameters to `TailLogEntries`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TailLogEntriesRequest {
    /// Required. Name of a parent resource from which to retrieve log entries:
    ///
    /// * `projects/[PROJECT_ID]`
    /// * `organizations/[ORGANIZATION_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]`
    /// * `folders/[FOLDER_ID]`
    ///
    /// May alternatively be one or more views:
    ///
    /// * `projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    /// * `folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_names: std::vec::Vec<std::string::String>,

    /// Optional. Only log entries that match the filter are returned.  An empty
    /// filter matches all log entries in the resources listed in `resource_names`.
    /// Referencing a parent resource that is not listed in `resource_names` will
    /// cause the filter to return no results. The maximum length of a filter is
    /// 20,000 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The amount of time to buffer log entries at the server before
    /// being returned to prevent out of order results due to late arriving log
    /// entries. Valid values are between 0-60000 milliseconds. Defaults to 2000
    /// milliseconds.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub buffer_window: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TailLogEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_names][crate::model::TailLogEntriesRequest::resource_names].
    pub fn set_resource_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filter][crate::model::TailLogEntriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [buffer_window][crate::model::TailLogEntriesRequest::buffer_window].
    pub fn set_buffer_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.buffer_window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [buffer_window][crate::model::TailLogEntriesRequest::buffer_window].
    pub fn set_or_clear_buffer_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.buffer_window = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TailLogEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.TailLogEntriesRequest"
    }
}

/// Result returned from `TailLogEntries`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TailLogEntriesResponse {
    /// A list of log entries. Each response in the stream will order entries with
    /// increasing values of `LogEntry.timestamp`. Ordering is not guaranteed
    /// between separate responses.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::LogEntry>,

    /// If entries that otherwise would have been included in the session were not
    /// sent back to the client, counts of relevant entries omitted from the
    /// session with the reason that they were not included. There will be at most
    /// one of each reason per response. The counts represent the number of
    /// suppressed entries since the last streamed response.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub suppression_info: std::vec::Vec<crate::model::tail_log_entries_response::SuppressionInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TailLogEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::TailLogEntriesResponse::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogEntry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [suppression_info][crate::model::TailLogEntriesResponse::suppression_info].
    pub fn set_suppression_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::tail_log_entries_response::SuppressionInfo>,
    {
        use std::iter::Iterator;
        self.suppression_info = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TailLogEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.TailLogEntriesResponse"
    }
}

/// Defines additional types related to [TailLogEntriesResponse].
pub mod tail_log_entries_response {
    #[allow(unused_imports)]
    use super::*;

    /// Information about entries that were omitted from the session.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SuppressionInfo {
        /// The reason that entries were omitted from the session.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub reason: crate::model::tail_log_entries_response::suppression_info::Reason,

        /// A lower bound on the count of entries omitted due to `reason`.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I32")]
        pub suppressed_count: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SuppressionInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [reason][crate::model::tail_log_entries_response::SuppressionInfo::reason].
        pub fn set_reason<
            T: std::convert::Into<crate::model::tail_log_entries_response::suppression_info::Reason>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.reason = v.into();
            self
        }

        /// Sets the value of [suppressed_count][crate::model::tail_log_entries_response::SuppressionInfo::suppressed_count].
        pub fn set_suppressed_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.suppressed_count = v.into();
            self
        }
    }

    impl wkt::message::Message for SuppressionInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.logging.v2.TailLogEntriesResponse.SuppressionInfo"
        }
    }

    /// Defines additional types related to [SuppressionInfo].
    pub mod suppression_info {
        #[allow(unused_imports)]
        use super::*;

        /// An indicator of why entries were omitted.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Reason {
            /// Unexpected default.
            Unspecified,
            /// Indicates suppression occurred due to relevant entries being
            /// received in excess of rate limits. For quotas and limits, see
            /// [Logging API quotas and
            /// limits](https://cloud.google.com/logging/quotas#api-limits).
            RateLimit,
            /// Indicates suppression occurred due to the client not consuming
            /// responses quickly enough.
            NotConsumed,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Reason::value] or
            /// [Reason::name].
            UnknownValue(reason::UnknownValue),
        }

        #[doc(hidden)]
        pub mod reason {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Reason {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::RateLimit => std::option::Option::Some(1),
                    Self::NotConsumed => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("REASON_UNSPECIFIED"),
                    Self::RateLimit => std::option::Option::Some("RATE_LIMIT"),
                    Self::NotConsumed => std::option::Option::Some("NOT_CONSUMED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Reason {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Reason {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Reason {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::RateLimit,
                    2 => Self::NotConsumed,
                    _ => Self::UnknownValue(reason::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Reason {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "REASON_UNSPECIFIED" => Self::Unspecified,
                    "RATE_LIMIT" => Self::RateLimit,
                    "NOT_CONSUMED" => Self::NotConsumed,
                    _ => Self::UnknownValue(reason::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Reason {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::RateLimit => serializer.serialize_i32(1),
                    Self::NotConsumed => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Reason {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Reason>::new(
                    ".google.logging.v2.TailLogEntriesResponse.SuppressionInfo.Reason",
                ))
            }
        }
    }
}

/// Configuration for an indexed field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexConfig {
    /// Required. The LogEntry field path to index.
    ///
    /// Note that some paths are automatically indexed, and other paths are not
    /// eligible for indexing. See [indexing documentation](
    /// <https://cloud.google.com/logging/docs/view/advanced-queries#indexed-fields>)
    /// for details.
    ///
    /// For example: `jsonPayload.request.status`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub field_path: std::string::String,

    /// Required. The type of data in this index.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub r#type: crate::model::IndexType,

    /// Output only. The timestamp when the index was last modified.
    ///
    /// This is used to return the timestamp, and will be ignored if supplied
    /// during update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IndexConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [field_path][crate::model::IndexConfig::field_path].
    pub fn set_field_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.field_path = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::IndexConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::IndexType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::IndexConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::IndexConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for IndexConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.IndexConfig"
    }
}

/// Describes a repository in which log entries are stored.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogBucket {
    /// Output only. The resource name of the bucket.
    ///
    /// For example:
    ///
    /// `projects/my-project/locations/global/buckets/my-bucket`
    ///
    /// For a list of supported locations, see [Supported
    /// Regions](https://cloud.google.com/logging/docs/region-support)
    ///
    /// For the location of `global` it is unspecified where log entries are
    /// actually stored.
    ///
    /// After a bucket has been created, the location cannot be changed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Describes this bucket.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The creation timestamp of the bucket. This is not set for any
    /// of the default buckets.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of the bucket.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Logs will be retained by default for this amount of time, after which they
    /// will automatically be deleted. The minimum retention period is 1 day. If
    /// this value is set to zero at bucket creation time, the default time of 30
    /// days will be used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub retention_days: i32,

    /// Whether the bucket is locked.
    ///
    /// The retention period on a locked bucket cannot be changed. Locked buckets
    /// may only be deleted if they are empty.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub locked: bool,

    /// Output only. The bucket lifecycle state.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub lifecycle_state: crate::model::LifecycleState,

    /// Whether log analytics is enabled for this bucket.
    ///
    /// Once enabled, log analytics features cannot be disabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub analytics_enabled: bool,

    /// Log entry field paths that are denied access in this bucket.
    ///
    /// The following fields and their children are eligible: `textPayload`,
    /// `jsonPayload`, `protoPayload`, `httpRequest`, `labels`, `sourceLocation`.
    ///
    /// Restricting a repeated field will restrict all values. Adding a parent will
    /// block all child fields. (e.g. `foo.bar` will block `foo.bar.baz`)
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub restricted_fields: std::vec::Vec<std::string::String>,

    /// A list of indexed fields and related configuration data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub index_configs: std::vec::Vec<crate::model::IndexConfig>,

    /// The CMEK settings of the log bucket. If present, new log entries written to
    /// this log bucket are encrypted using the CMEK key provided in this
    /// configuration. If a log bucket has CMEK settings, the CMEK settings cannot
    /// be disabled later by updating the log bucket. Changing the KMS key is
    /// allowed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cmek_settings: std::option::Option<crate::model::CmekSettings>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogBucket {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LogBucket::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::LogBucket::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::LogBucket::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::LogBucket::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::LogBucket::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::LogBucket::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [retention_days][crate::model::LogBucket::retention_days].
    pub fn set_retention_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retention_days = v.into();
        self
    }

    /// Sets the value of [locked][crate::model::LogBucket::locked].
    pub fn set_locked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.locked = v.into();
        self
    }

    /// Sets the value of [lifecycle_state][crate::model::LogBucket::lifecycle_state].
    pub fn set_lifecycle_state<T: std::convert::Into<crate::model::LifecycleState>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_state = v.into();
        self
    }

    /// Sets the value of [analytics_enabled][crate::model::LogBucket::analytics_enabled].
    pub fn set_analytics_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.analytics_enabled = v.into();
        self
    }

    /// Sets the value of [restricted_fields][crate::model::LogBucket::restricted_fields].
    pub fn set_restricted_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.restricted_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [index_configs][crate::model::LogBucket::index_configs].
    pub fn set_index_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IndexConfig>,
    {
        use std::iter::Iterator;
        self.index_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cmek_settings][crate::model::LogBucket::cmek_settings].
    pub fn set_cmek_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CmekSettings>,
    {
        self.cmek_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cmek_settings][crate::model::LogBucket::cmek_settings].
    pub fn set_or_clear_cmek_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CmekSettings>,
    {
        self.cmek_settings = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LogBucket {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogBucket"
    }
}

/// Describes a view over log entries in a bucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogView {
    /// The resource name of the view.
    ///
    /// For example:
    ///
    /// `projects/my-project/locations/global/buckets/my-bucket/views/my-view`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Describes this view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The creation timestamp of the view.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of the view.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Filter that restricts which log entries in a bucket are visible in this
    /// view.
    ///
    /// Filters are restricted to be a logical AND of ==/!= of any of the
    /// following:
    ///
    /// - originating project/folder/organization/billing account.
    /// - resource type
    /// - log id
    ///
    /// For example:
    ///
    /// SOURCE("projects/myproject") AND resource.type = "gce_instance"
    /// AND LOG_ID("stdout")
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogView {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LogView::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::LogView::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::LogView::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::LogView::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::LogView::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::LogView::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [filter][crate::model::LogView::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for LogView {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogView"
    }
}

/// Describes a sink used to export log entries to one of the following
/// destinations in any project: a Cloud Storage bucket, a BigQuery dataset, a
/// Pub/Sub topic or a Cloud Logging log bucket. A logs filter controls which log
/// entries are exported. The sink must be created within a project,
/// organization, billing account, or folder.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogSink {
    /// Required. The client-assigned sink identifier, unique within the project.
    ///
    /// For example: `"my-syslog-errors-to-pubsub"`. Sink identifiers are limited
    /// to 100 characters and can include only the following characters: upper and
    /// lower-case alphanumeric characters, underscores, hyphens, and periods.
    /// First character has to be alphanumeric.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The export destination:
    ///
    /// ```norust
    /// "storage.googleapis.com/[GCS_BUCKET]"
    /// "bigquery.googleapis.com/projects/[PROJECT_ID]/datasets/[DATASET]"
    /// "pubsub.googleapis.com/projects/[PROJECT_ID]/topics/[TOPIC_ID]"
    /// ```
    ///
    /// The sink's `writer_identity`, set when the sink is created, must have
    /// permission to write to the destination or else the log entries are not
    /// exported. For more information, see
    /// [Exporting Logs with
    /// Sinks](https://cloud.google.com/logging/docs/api/tasks/exporting-logs).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination: std::string::String,

    /// Optional. An [advanced logs
    /// filter](https://cloud.google.com/logging/docs/view/advanced-queries). The
    /// only exported log entries are those that are in the resource owning the
    /// sink and that match the filter.
    ///
    /// For example:
    ///
    /// `logName="projects/[PROJECT_ID]/logs/[LOG_ID]" AND severity>=ERROR`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. A description of this sink.
    ///
    /// The maximum length of the description is 8000 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. If set to true, then this sink is disabled and it does not export
    /// any log entries.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disabled: bool,

    /// Optional. Log entries that match any of these exclusion filters will not be
    /// exported.
    ///
    /// If a log entry is matched by both `filter` and one of `exclusion_filters`
    /// it will not be exported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exclusions: std::vec::Vec<crate::model::LogExclusion>,

    /// Deprecated. This field is unused.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub output_version_format: crate::model::log_sink::VersionFormat,

    /// Output only. An IAM identity&mdash;a service account or group&mdash;under
    /// which Cloud Logging writes the exported log entries to the sink's
    /// destination. This field is either set by specifying
    /// `custom_writer_identity` or set automatically by
    /// [sinks.create][google.logging.v2.ConfigServiceV2.CreateSink] and
    /// [sinks.update][google.logging.v2.ConfigServiceV2.UpdateSink] based on the
    /// value of `unique_writer_identity` in those methods.
    ///
    /// Until you grant this identity write-access to the destination, log entry
    /// exports from this sink will fail. For more information, see [Granting
    /// Access for a
    /// Resource](https://cloud.google.com/iam/docs/granting-roles-to-service-accounts#granting_access_to_a_service_account_for_a_resource).
    /// Consult the destination service's documentation to determine the
    /// appropriate IAM roles to assign to the identity.
    ///
    /// Sinks that have a destination that is a log bucket in the same project as
    /// the sink cannot have a writer_identity and no additional permissions are
    /// required.
    ///
    /// [google.logging.v2.ConfigServiceV2.CreateSink]: crate::client::ConfigServiceV2::create_sink
    /// [google.logging.v2.ConfigServiceV2.UpdateSink]: crate::client::ConfigServiceV2::update_sink
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub writer_identity: std::string::String,

    /// Optional. This field applies only to sinks owned by organizations and
    /// folders. If the field is false, the default, only the logs owned by the
    /// sink's parent resource are available for export. If the field is true, then
    /// log entries from all the projects, folders, and billing accounts contained
    /// in the sink's parent resource are also available for export. Whether a
    /// particular log entry from the children is exported depends on the sink's
    /// filter expression.
    ///
    /// For example, if this field is true, then the filter
    /// `resource.type=gce_instance` would export all Compute Engine VM instance
    /// log entries from all projects in the sink's parent.
    ///
    /// To only export entries from certain child projects, filter on the project
    /// part of the log name:
    ///
    /// logName:("projects/test-project1/" OR "projects/test-project2/") AND
    /// resource.type=gce_instance
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub include_children: bool,

    /// Output only. The creation timestamp of the sink.
    ///
    /// This field may not be present for older sinks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of the sink.
    ///
    /// This field may not be present for older sinks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Destination dependent options.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub options: std::option::Option<crate::model::log_sink::Options>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogSink {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LogSink::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::LogSink::destination].
    pub fn set_destination<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::LogSink::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [description][crate::model::LogSink::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::LogSink::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [exclusions][crate::model::LogSink::exclusions].
    pub fn set_exclusions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogExclusion>,
    {
        use std::iter::Iterator;
        self.exclusions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [output_version_format][crate::model::LogSink::output_version_format].
    #[deprecated]
    pub fn set_output_version_format<
        T: std::convert::Into<crate::model::log_sink::VersionFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_version_format = v.into();
        self
    }

    /// Sets the value of [writer_identity][crate::model::LogSink::writer_identity].
    pub fn set_writer_identity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.writer_identity = v.into();
        self
    }

    /// Sets the value of [include_children][crate::model::LogSink::include_children].
    pub fn set_include_children<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_children = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::LogSink::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::LogSink::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::LogSink::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::LogSink::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [options][crate::model::LogSink::options].
    ///
    /// Note that all the setters affecting `options` are mutually
    /// exclusive.
    pub fn set_options<
        T: std::convert::Into<std::option::Option<crate::model::log_sink::Options>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options = v.into();
        self
    }

    /// The value of [options][crate::model::LogSink::options]
    /// if it holds a `BigqueryOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryOptions>> {
        #[allow(unreachable_patterns)]
        self.options.as_ref().and_then(|v| match v {
            crate::model::log_sink::Options::BigqueryOptions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [options][crate::model::LogSink::options]
    /// to hold a `BigqueryOptions`.
    ///
    /// Note that all the setters affecting `options` are
    /// mutually exclusive.
    pub fn set_bigquery_options<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options =
            std::option::Option::Some(crate::model::log_sink::Options::BigqueryOptions(v.into()));
        self
    }
}

impl wkt::message::Message for LogSink {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogSink"
    }
}

/// Defines additional types related to [LogSink].
pub mod log_sink {
    #[allow(unused_imports)]
    use super::*;

    /// Deprecated. This is unused.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VersionFormat {
        /// An unspecified format version that will default to V2.
        Unspecified,
        /// `LogEntry` version 2 format.
        V2,
        /// `LogEntry` version 1 format.
        V1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VersionFormat::value] or
        /// [VersionFormat::name].
        UnknownValue(version_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod version_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VersionFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::V2 => std::option::Option::Some(1),
                Self::V1 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VERSION_FORMAT_UNSPECIFIED"),
                Self::V2 => std::option::Option::Some("V2"),
                Self::V1 => std::option::Option::Some("V1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VersionFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VersionFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VersionFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::V2,
                2 => Self::V1,
                _ => Self::UnknownValue(version_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VersionFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VERSION_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "V2" => Self::V2,
                "V1" => Self::V1,
                _ => Self::UnknownValue(version_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VersionFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::V2 => serializer.serialize_i32(1),
                Self::V1 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VersionFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VersionFormat>::new(
                ".google.logging.v2.LogSink.VersionFormat",
            ))
        }
    }

    /// Destination dependent options.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Options {
        /// Optional. Options that affect sinks exporting data to BigQuery.
        BigqueryOptions(std::boxed::Box<crate::model::BigQueryOptions>),
    }
}

/// Describes a BigQuery dataset that was created by a link.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryDataset {
    /// Output only. The full resource name of the BigQuery dataset. The DATASET_ID
    /// will match the ID of the link, so the link must match the naming
    /// restrictions of BigQuery datasets (alphanumeric characters and underscores
    /// only).
    ///
    /// The dataset will have a resource path of
    /// "bigquery.googleapis.com/projects/[PROJECT_ID]/datasets/[DATASET_ID]"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryDataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_id][crate::model::BigQueryDataset::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryDataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.BigQueryDataset"
    }
}

/// Describes a link connected to an analytics enabled bucket.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Link {
    /// The resource name of the link. The name can have up to 100 characters.
    /// A valid link id (at the end of the link name) must only have alphanumeric
    /// characters and underscores within it.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `projects/my-project/locations/global/buckets/my-bucket/links/my_link
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Describes this link.
    ///
    /// The maximum length of the description is 8000 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The creation timestamp of the link.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The resource lifecycle state.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub lifecycle_state: crate::model::LifecycleState,

    /// The information of a BigQuery Dataset. When a link is created, a BigQuery
    /// dataset is created along with it, in the same project as the LogBucket it's
    /// linked to. This dataset will also have BigQuery Views corresponding to the
    /// LogViews in the bucket.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bigquery_dataset: std::option::Option<crate::model::BigQueryDataset>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Link {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Link::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Link::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Link::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Link::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lifecycle_state][crate::model::Link::lifecycle_state].
    pub fn set_lifecycle_state<T: std::convert::Into<crate::model::LifecycleState>>(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_state = v.into();
        self
    }

    /// Sets the value of [bigquery_dataset][crate::model::Link::bigquery_dataset].
    pub fn set_bigquery_dataset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryDataset>,
    {
        self.bigquery_dataset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bigquery_dataset][crate::model::Link::bigquery_dataset].
    pub fn set_or_clear_bigquery_dataset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryDataset>,
    {
        self.bigquery_dataset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Link {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.Link"
    }
}

/// Options that change functionality of a sink exporting data to BigQuery.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryOptions {
    /// Optional. Whether to use [BigQuery's partition
    /// tables](https://cloud.google.com/bigquery/docs/partitioned-tables). By
    /// default, Cloud Logging creates dated tables based on the log entries'
    /// timestamps, e.g. syslog_20170523. With partitioned tables the date suffix
    /// is no longer present and [special query
    /// syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
    /// has to be used instead. In both cases, tables are sharded based on UTC
    /// timezone.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_partitioned_tables: bool,

    /// Output only. True if new timestamp column based partitioning is in use,
    /// false if legacy ingestion-time partitioning is in use.
    ///
    /// All new sinks will have this field set true and will use timestamp column
    /// based partitioning. If use_partitioned_tables is false, this value has no
    /// meaning and will be false. Legacy sinks using partitioned tables will have
    /// this field set to false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub uses_timestamp_column_partitioning: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_partitioned_tables][crate::model::BigQueryOptions::use_partitioned_tables].
    pub fn set_use_partitioned_tables<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_partitioned_tables = v.into();
        self
    }

    /// Sets the value of [uses_timestamp_column_partitioning][crate::model::BigQueryOptions::uses_timestamp_column_partitioning].
    pub fn set_uses_timestamp_column_partitioning<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.uses_timestamp_column_partitioning = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.BigQueryOptions"
    }
}

/// The parameters to `ListBuckets`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBucketsRequest {
    /// Required. The parent resource whose buckets are to be listed:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]"
    /// ```
    ///
    /// Note: The locations portion of the resource must be specified, but
    /// supplying the character `-` in place of [LOCATION_ID] will return all
    /// buckets.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method. `pageToken` must be the value of
    /// `nextPageToken` from the previous response. The values of other method
    /// parameters should be identical to those in the previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored. The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBucketsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBucketsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBucketsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBucketsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListBucketsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListBucketsRequest"
    }
}

/// The response from ListBuckets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBucketsResponse {
    /// A list of buckets.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub buckets: std::vec::Vec<crate::model::LogBucket>,

    /// If there might be more results than appear in this response, then
    /// `nextPageToken` is included. To get the next set of results, call the same
    /// method again using the value of `nextPageToken` as `pageToken`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBucketsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [buckets][crate::model::ListBucketsResponse::buckets].
    pub fn set_buckets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogBucket>,
    {
        use std::iter::Iterator;
        self.buckets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBucketsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBucketsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListBucketsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBucketsResponse {
    type PageItem = crate::model::LogBucket;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.buckets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The parameters to `CreateBucket`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBucketRequest {
    /// Required. The resource in which to create the log bucket:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A client-assigned identifier such as `"my-bucket"`. Identifiers
    /// are limited to 100 characters and can include only letters, digits,
    /// underscores, hyphens, and periods.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_id: std::string::String,

    /// Required. The new bucket. The region specified in the new bucket must be
    /// compliant with any Location Restriction Org Policy. The name field in the
    /// bucket is ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bucket: std::option::Option<crate::model::LogBucket>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBucketRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [bucket_id][crate::model::CreateBucketRequest::bucket_id].
    pub fn set_bucket_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_id = v.into();
        self
    }

    /// Sets the value of [bucket][crate::model::CreateBucketRequest::bucket].
    pub fn set_bucket<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogBucket>,
    {
        self.bucket = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bucket][crate::model::CreateBucketRequest::bucket].
    pub fn set_or_clear_bucket<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogBucket>,
    {
        self.bucket = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CreateBucketRequest"
    }
}

/// The parameters to `UpdateBucket`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBucketRequest {
    /// Required. The full resource name of the bucket to update.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The updated bucket.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bucket: std::option::Option<crate::model::LogBucket>,

    /// Required. Field mask that specifies the fields in `bucket` that need an
    /// update. A bucket field will be overwritten if, and only if, it is in the
    /// update mask. `name` and output only fields cannot be updated.
    ///
    /// For a detailed `FieldMask` definition, see:
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask>
    ///
    /// For example: `updateMask=retention_days`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateBucketRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [bucket][crate::model::UpdateBucketRequest::bucket].
    pub fn set_bucket<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogBucket>,
    {
        self.bucket = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bucket][crate::model::UpdateBucketRequest::bucket].
    pub fn set_or_clear_bucket<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogBucket>,
    {
        self.bucket = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBucketRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBucketRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UpdateBucketRequest"
    }
}

/// The parameters to `GetBucket`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBucketRequest {
    /// Required. The resource name of the bucket:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBucketRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetBucketRequest"
    }
}

/// The parameters to `DeleteBucket`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBucketRequest {
    /// Required. The full resource name of the bucket to delete.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBucketRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.DeleteBucketRequest"
    }
}

/// The parameters to `UndeleteBucket`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeleteBucketRequest {
    /// Required. The full resource name of the bucket to undelete.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeleteBucketRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeleteBucketRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UndeleteBucketRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UndeleteBucketRequest"
    }
}

/// The parameters to `ListViews`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListViewsRequest {
    /// Required. The bucket whose views are to be listed:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method. `pageToken` must be the value of
    /// `nextPageToken` from the previous response. The values of other method
    /// parameters should be identical to those in the previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    ///
    /// Non-positive values are ignored. The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListViewsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListViewsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListViewsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListViewsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListViewsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListViewsRequest"
    }
}

/// The response from ListViews.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListViewsResponse {
    /// A list of views.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub views: std::vec::Vec<crate::model::LogView>,

    /// If there might be more results than appear in this response, then
    /// `nextPageToken` is included. To get the next set of results, call the same
    /// method again using the value of `nextPageToken` as `pageToken`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListViewsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [views][crate::model::ListViewsResponse::views].
    pub fn set_views<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogView>,
    {
        use std::iter::Iterator;
        self.views = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListViewsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListViewsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListViewsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListViewsResponse {
    type PageItem = crate::model::LogView;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.views
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The parameters to `CreateView`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateViewRequest {
    /// Required. The bucket in which to create the view
    ///
    /// ```norust
    /// `"projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"`
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A client-assigned identifier such as `"my-view"`. Identifiers are
    /// limited to 100 characters and can include only letters, digits,
    /// underscores, hyphens, and periods.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub view_id: std::string::String,

    /// Required. The new view.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub view: std::option::Option<crate::model::LogView>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateViewRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view_id][crate::model::CreateViewRequest::view_id].
    pub fn set_view_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.view_id = v.into();
        self
    }

    /// Sets the value of [view][crate::model::CreateViewRequest::view].
    pub fn set_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogView>,
    {
        self.view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [view][crate::model::CreateViewRequest::view].
    pub fn set_or_clear_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogView>,
    {
        self.view = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CreateViewRequest"
    }
}

/// The parameters to `UpdateView`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateViewRequest {
    /// Required. The full resource name of the view to update
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket/views/my-view"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The updated view.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub view: std::option::Option<crate::model::LogView>,

    /// Optional. Field mask that specifies the fields in `view` that need
    /// an update. A field will be overwritten if, and only if, it is
    /// in the update mask. `name` and output only fields cannot be updated.
    ///
    /// For a detailed `FieldMask` definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask>
    ///
    /// For example: `updateMask=filter`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::UpdateViewRequest::view].
    pub fn set_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogView>,
    {
        self.view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [view][crate::model::UpdateViewRequest::view].
    pub fn set_or_clear_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogView>,
    {
        self.view = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateViewRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateViewRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UpdateViewRequest"
    }
}

/// The parameters to `GetView`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetViewRequest {
    /// Required. The resource name of the policy:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket/views/my-view"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetViewRequest"
    }
}

/// The parameters to `DeleteView`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteViewRequest {
    /// Required. The full resource name of the view to delete:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-bucket/views/my-view"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.DeleteViewRequest"
    }
}

/// The parameters to `ListSinks`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSinksRequest {
    /// Required. The parent resource whose sinks are to be listed:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]"
    /// "organizations/[ORGANIZATION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]"
    /// "folders/[FOLDER_ID]"
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method. `pageToken` must be the value of
    /// `nextPageToken` from the previous response. The values of other method
    /// parameters should be identical to those in the previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored. The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSinksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSinksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSinksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSinksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListSinksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListSinksRequest"
    }
}

/// Result returned from `ListSinks`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSinksResponse {
    /// A list of sinks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sinks: std::vec::Vec<crate::model::LogSink>,

    /// If there might be more results than appear in this response, then
    /// `nextPageToken` is included. To get the next set of results, call the same
    /// method again using the value of `nextPageToken` as `pageToken`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSinksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sinks][crate::model::ListSinksResponse::sinks].
    pub fn set_sinks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogSink>,
    {
        use std::iter::Iterator;
        self.sinks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSinksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSinksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListSinksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSinksResponse {
    type PageItem = crate::model::LogSink;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sinks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The parameters to `GetSink`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSinkRequest {
    /// Required. The resource name of the sink:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/sinks/[SINK_ID]"
    /// "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
    /// "folders/[FOLDER_ID]/sinks/[SINK_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/sinks/my-sink"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sink_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sink_name][crate::model::GetSinkRequest::sink_name].
    pub fn set_sink_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sink_name = v.into();
        self
    }
}

impl wkt::message::Message for GetSinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetSinkRequest"
    }
}

/// The parameters to `CreateSink`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSinkRequest {
    /// Required. The resource in which to create the sink:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]"
    /// "organizations/[ORGANIZATION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]"
    /// "folders/[FOLDER_ID]"
    /// ```
    ///
    /// For examples:
    ///
    /// `"projects/my-project"`
    /// `"organizations/123456789"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The new sink, whose `name` parameter is a sink identifier that
    /// is not already in use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sink: std::option::Option<crate::model::LogSink>,

    /// Optional. Determines the kind of IAM identity returned as `writer_identity`
    /// in the new sink. If this value is omitted or set to false, and if the
    /// sink's parent is a project, then the value returned as `writer_identity` is
    /// the same group or service account used by Cloud Logging before the addition
    /// of writer identities to this API. The sink's destination must be in the
    /// same project as the sink itself.
    ///
    /// If this field is set to true, or if the sink is owned by a non-project
    /// resource such as an organization, then the value of `writer_identity` will
    /// be a unique service account used only for exports from the new sink. For
    /// more information, see `writer_identity` in
    /// [LogSink][google.logging.v2.LogSink].
    ///
    /// [google.logging.v2.LogSink]: crate::model::LogSink
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub unique_writer_identity: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSinkRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [sink][crate::model::CreateSinkRequest::sink].
    pub fn set_sink<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogSink>,
    {
        self.sink = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sink][crate::model::CreateSinkRequest::sink].
    pub fn set_or_clear_sink<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogSink>,
    {
        self.sink = v.map(|x| x.into());
        self
    }

    /// Sets the value of [unique_writer_identity][crate::model::CreateSinkRequest::unique_writer_identity].
    pub fn set_unique_writer_identity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unique_writer_identity = v.into();
        self
    }
}

impl wkt::message::Message for CreateSinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CreateSinkRequest"
    }
}

/// The parameters to `UpdateSink`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSinkRequest {
    /// Required. The full resource name of the sink to update, including the
    /// parent resource and the sink identifier:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/sinks/[SINK_ID]"
    /// "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
    /// "folders/[FOLDER_ID]/sinks/[SINK_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/sinks/my-sink"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sink_name: std::string::String,

    /// Required. The updated sink, whose name is the same identifier that appears
    /// as part of `sink_name`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sink: std::option::Option<crate::model::LogSink>,

    /// Optional. See [sinks.create][google.logging.v2.ConfigServiceV2.CreateSink]
    /// for a description of this field. When updating a sink, the effect of this
    /// field on the value of `writer_identity` in the updated sink depends on both
    /// the old and new values of this field:
    ///
    /// + If the old and new values of this field are both false or both true,
    ///   then there is no change to the sink's `writer_identity`.
    /// + If the old value is false and the new value is true, then
    ///   `writer_identity` is changed to a unique service account.
    /// + It is an error if the old value is true and the new value is
    ///   set to false or defaulted to false.
    ///
    /// [google.logging.v2.ConfigServiceV2.CreateSink]: crate::client::ConfigServiceV2::create_sink
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub unique_writer_identity: bool,

    /// Optional. Field mask that specifies the fields in `sink` that need
    /// an update. A sink field will be overwritten if, and only if, it is
    /// in the update mask. `name` and output only fields cannot be updated.
    ///
    /// An empty `updateMask` is temporarily treated as using the following mask
    /// for backwards compatibility purposes:
    ///
    /// `destination,filter,includeChildren`
    ///
    /// At some point in the future, behavior will be removed and specifying an
    /// empty `updateMask` will be an error.
    ///
    /// For a detailed `FieldMask` definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask>
    ///
    /// For example: `updateMask=filter`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sink_name][crate::model::UpdateSinkRequest::sink_name].
    pub fn set_sink_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sink_name = v.into();
        self
    }

    /// Sets the value of [sink][crate::model::UpdateSinkRequest::sink].
    pub fn set_sink<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogSink>,
    {
        self.sink = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sink][crate::model::UpdateSinkRequest::sink].
    pub fn set_or_clear_sink<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogSink>,
    {
        self.sink = v.map(|x| x.into());
        self
    }

    /// Sets the value of [unique_writer_identity][crate::model::UpdateSinkRequest::unique_writer_identity].
    pub fn set_unique_writer_identity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unique_writer_identity = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSinkRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSinkRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UpdateSinkRequest"
    }
}

/// The parameters to `DeleteSink`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSinkRequest {
    /// Required. The full resource name of the sink to delete, including the
    /// parent resource and the sink identifier:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/sinks/[SINK_ID]"
    /// "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
    /// "folders/[FOLDER_ID]/sinks/[SINK_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/sinks/my-sink"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sink_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sink_name][crate::model::DeleteSinkRequest::sink_name].
    pub fn set_sink_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sink_name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.DeleteSinkRequest"
    }
}

/// The parameters to CreateLink.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateLinkRequest {
    /// Required. The full resource name of the bucket to create a link for.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The new link.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub link: std::option::Option<crate::model::Link>,

    /// Required. The ID to use for the link. The link_id can have up to 100
    /// characters. A valid link_id must only have alphanumeric characters and
    /// underscores within it.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub link_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateLinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateLinkRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [link][crate::model::CreateLinkRequest::link].
    pub fn set_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Link>,
    {
        self.link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [link][crate::model::CreateLinkRequest::link].
    pub fn set_or_clear_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Link>,
    {
        self.link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [link_id][crate::model::CreateLinkRequest::link_id].
    pub fn set_link_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.link_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateLinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CreateLinkRequest"
    }
}

/// The parameters to DeleteLink.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteLinkRequest {
    /// Required. The full resource name of the link to delete.
    ///
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteLinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteLinkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteLinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.DeleteLinkRequest"
    }
}

/// The parameters to ListLinks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLinksRequest {
    /// Required. The parent resource whose links are to be listed:
    ///
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method. `pageToken` must be the value of
    /// `nextPageToken` from the previous response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLinksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLinksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLinksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLinksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListLinksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLinksRequest"
    }
}

/// The response from ListLinks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLinksResponse {
    /// A list of links.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub links: std::vec::Vec<crate::model::Link>,

    /// If there might be more results than those appearing in this response, then
    /// `nextPageToken` is included. To get the next set of results, call the same
    /// method again using the value of `nextPageToken` as `pageToken`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLinksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [links][crate::model::ListLinksResponse::links].
    pub fn set_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Link>,
    {
        use std::iter::Iterator;
        self.links = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLinksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLinksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLinksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLinksResponse {
    type PageItem = crate::model::Link;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.links
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The parameters to GetLink.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetLinkRequest {
    /// Required. The resource name of the link:
    ///
    /// "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]"
    /// "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/[LINK_ID]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLinkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetLinkRequest"
    }
}

/// Specifies a set of log entries that are filtered out by a sink. If
/// your Google Cloud resource receives a large volume of log entries, you can
/// use exclusions to reduce your chargeable logs. Note that exclusions on
/// organization-level and folder-level sinks don't apply to child resources.
/// Note also that you cannot modify the _Required sink or exclude logs from it.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogExclusion {
    /// Required. A client-assigned identifier, such as
    /// `"load-balancer-exclusion"`. Identifiers are limited to 100 characters and
    /// can include only letters, digits, underscores, hyphens, and periods. First
    /// character has to be alphanumeric.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A description of this exclusion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. An [advanced logs
    /// filter](https://cloud.google.com/logging/docs/view/advanced-queries) that
    /// matches the log entries to be excluded. By using the [sample
    /// function](https://cloud.google.com/logging/docs/view/advanced-queries#sample),
    /// you can exclude less than 100% of the matching log entries.
    ///
    /// For example, the following query matches 99% of low-severity log entries
    /// from Google Cloud Storage buckets:
    ///
    /// `resource.type=gcs_bucket severity<ERROR sample(insertId, 0.99)`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. If set to True, then this exclusion is disabled and it does not
    /// exclude any log entries. You can [update an
    /// exclusion][google.logging.v2.ConfigServiceV2.UpdateExclusion] to change the
    /// value of this field.
    ///
    /// [google.logging.v2.ConfigServiceV2.UpdateExclusion]: crate::client::ConfigServiceV2::update_exclusion
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disabled: bool,

    /// Output only. The creation timestamp of the exclusion.
    ///
    /// This field may not be present for older exclusions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of the exclusion.
    ///
    /// This field may not be present for older exclusions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogExclusion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LogExclusion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::LogExclusion::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::LogExclusion::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::LogExclusion::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::LogExclusion::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::LogExclusion::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::LogExclusion::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::LogExclusion::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LogExclusion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogExclusion"
    }
}

/// The parameters to `ListExclusions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListExclusionsRequest {
    /// Required. The parent resource whose exclusions are to be listed.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]"
    /// "organizations/[ORGANIZATION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]"
    /// "folders/[FOLDER_ID]"
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method. `pageToken` must be the value of
    /// `nextPageToken` from the previous response. The values of other method
    /// parameters should be identical to those in the previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored. The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExclusionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListExclusionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListExclusionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListExclusionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListExclusionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListExclusionsRequest"
    }
}

/// Result returned from `ListExclusions`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListExclusionsResponse {
    /// A list of exclusions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exclusions: std::vec::Vec<crate::model::LogExclusion>,

    /// If there might be more results than appear in this response, then
    /// `nextPageToken` is included. To get the next set of results, call the same
    /// method again using the value of `nextPageToken` as `pageToken`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExclusionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [exclusions][crate::model::ListExclusionsResponse::exclusions].
    pub fn set_exclusions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogExclusion>,
    {
        use std::iter::Iterator;
        self.exclusions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListExclusionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListExclusionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListExclusionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListExclusionsResponse {
    type PageItem = crate::model::LogExclusion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.exclusions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The parameters to `GetExclusion`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetExclusionRequest {
    /// Required. The resource name of an existing exclusion:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
    /// "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
    /// "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/exclusions/my-exclusion"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetExclusionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetExclusionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetExclusionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetExclusionRequest"
    }
}

/// The parameters to `CreateExclusion`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateExclusionRequest {
    /// Required. The parent resource in which to create the exclusion:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]"
    /// "organizations/[ORGANIZATION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]"
    /// "folders/[FOLDER_ID]"
    /// ```
    ///
    /// For examples:
    ///
    /// `"projects/my-logging-project"`
    /// `"organizations/123456789"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The new exclusion, whose `name` parameter is an exclusion name
    /// that is not already used in the parent resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub exclusion: std::option::Option<crate::model::LogExclusion>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateExclusionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateExclusionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [exclusion][crate::model::CreateExclusionRequest::exclusion].
    pub fn set_exclusion<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogExclusion>,
    {
        self.exclusion = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclusion][crate::model::CreateExclusionRequest::exclusion].
    pub fn set_or_clear_exclusion<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogExclusion>,
    {
        self.exclusion = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateExclusionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CreateExclusionRequest"
    }
}

/// The parameters to `UpdateExclusion`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateExclusionRequest {
    /// Required. The resource name of the exclusion to update:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
    /// "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
    /// "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/exclusions/my-exclusion"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. New values for the existing exclusion. Only the fields specified
    /// in `update_mask` are relevant.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub exclusion: std::option::Option<crate::model::LogExclusion>,

    /// Required. A non-empty list of fields to change in the existing exclusion.
    /// New values for the fields are taken from the corresponding fields in the
    /// [LogExclusion][google.logging.v2.LogExclusion] included in this request.
    /// Fields not mentioned in `update_mask` are not changed and are ignored in
    /// the request.
    ///
    /// For example, to change the filter and description of an exclusion,
    /// specify an `update_mask` of `"filter,description"`.
    ///
    /// [google.logging.v2.LogExclusion]: crate::model::LogExclusion
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateExclusionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateExclusionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [exclusion][crate::model::UpdateExclusionRequest::exclusion].
    pub fn set_exclusion<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogExclusion>,
    {
        self.exclusion = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exclusion][crate::model::UpdateExclusionRequest::exclusion].
    pub fn set_or_clear_exclusion<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogExclusion>,
    {
        self.exclusion = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateExclusionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateExclusionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateExclusionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UpdateExclusionRequest"
    }
}

/// The parameters to `DeleteExclusion`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteExclusionRequest {
    /// Required. The resource name of an existing exclusion to delete:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
    /// "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
    /// "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/exclusions/my-exclusion"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteExclusionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteExclusionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteExclusionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.DeleteExclusionRequest"
    }
}

/// The parameters to
/// [GetCmekSettings][google.logging.v2.ConfigServiceV2.GetCmekSettings].
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
///
/// [google.logging.v2.ConfigServiceV2.GetCmekSettings]: crate::client::ConfigServiceV2::get_cmek_settings
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCmekSettingsRequest {
    /// Required. The resource for which to retrieve CMEK settings.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/cmekSettings"
    /// "organizations/[ORGANIZATION_ID]/cmekSettings"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/cmekSettings"
    /// "folders/[FOLDER_ID]/cmekSettings"
    /// ```
    ///
    /// For example:
    ///
    /// `"organizations/12345/cmekSettings"`
    ///
    /// Note: CMEK for the Log Router can be configured for Google Cloud projects,
    /// folders, organizations and billing accounts. Once configured for an
    /// organization, it applies to all projects and folders in the Google Cloud
    /// organization.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCmekSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCmekSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCmekSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetCmekSettingsRequest"
    }
}

/// The parameters to
/// [UpdateCmekSettings][google.logging.v2.ConfigServiceV2.UpdateCmekSettings].
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
///
/// [google.logging.v2.ConfigServiceV2.UpdateCmekSettings]: crate::client::ConfigServiceV2::update_cmek_settings
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCmekSettingsRequest {
    /// Required. The resource name for the CMEK settings to update.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/cmekSettings"
    /// "organizations/[ORGANIZATION_ID]/cmekSettings"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/cmekSettings"
    /// "folders/[FOLDER_ID]/cmekSettings"
    /// ```
    ///
    /// For example:
    ///
    /// `"organizations/12345/cmekSettings"`
    ///
    /// Note: CMEK for the Log Router can currently only be configured for Google
    /// Cloud organizations. Once configured, it applies to all projects and
    /// folders in the Google Cloud organization.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The CMEK settings to update.
    ///
    /// See [Enabling CMEK for Log
    /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
    /// for more information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cmek_settings: std::option::Option<crate::model::CmekSettings>,

    /// Optional. Field mask identifying which fields from `cmek_settings` should
    /// be updated. A field will be overwritten if and only if it is in the update
    /// mask. Output only fields cannot be updated.
    ///
    /// See [FieldMask][google.protobuf.FieldMask] for more information.
    ///
    /// For example: `"updateMask=kmsKeyName"`
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCmekSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateCmekSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cmek_settings][crate::model::UpdateCmekSettingsRequest::cmek_settings].
    pub fn set_cmek_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CmekSettings>,
    {
        self.cmek_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cmek_settings][crate::model::UpdateCmekSettingsRequest::cmek_settings].
    pub fn set_or_clear_cmek_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CmekSettings>,
    {
        self.cmek_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCmekSettingsRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCmekSettingsRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCmekSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UpdateCmekSettingsRequest"
    }
}

/// Describes the customer-managed encryption key (CMEK) settings associated with
/// a project, folder, organization, billing account, or flexible resource.
///
/// Note: CMEK for the Log Router can currently only be configured for Google
/// Cloud organizations. Once configured, it applies to all projects and folders
/// in the Google Cloud organization.
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CmekSettings {
    /// Output only. The resource name of the CMEK settings.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The resource name for the configured Cloud KMS key.
    ///
    /// KMS key name format:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key"`
    ///
    /// To enable CMEK for the Log Router, set this field to a valid
    /// `kms_key_name` for which the associated service account has the required
    /// cloudkms.cryptoKeyEncrypterDecrypter roles assigned for the key.
    ///
    /// The Cloud KMS key used by the Log Router can be updated by changing the
    /// `kms_key_name` to a new valid key name or disabled by setting the key name
    /// to an empty string. Encryption operations that are in progress will be
    /// completed with the key that was in use when they started. Decryption
    /// operations will be completed using the key that was used at the time of
    /// encryption unless access to that key has been revoked.
    ///
    /// To disable CMEK for the Log Router, set this field to an empty string.
    ///
    /// See [Enabling CMEK for Log
    /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
    /// for more information.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// The CryptoKeyVersion resource name for the configured Cloud KMS key.
    ///
    /// KMS key name format:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]/cryptoKeyVersions/[VERSION]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key/cryptoKeyVersions/1"`
    ///
    /// This is a read-only field used to convey the specific configured
    /// CryptoKeyVersion of `kms_key` that has been configured. It will be
    /// populated in cases where the CMEK settings are bound to a single key
    /// version.
    ///
    /// If this field is populated, the `kms_key` is tied to a specific
    /// CryptoKeyVersion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_version_name: std::string::String,

    /// Output only. The service account that will be used by the Log Router to
    /// access your Cloud KMS key.
    ///
    /// Before enabling CMEK for Log Router, you must first assign the
    /// cloudkms.cryptoKeyEncrypterDecrypter role to the service account that
    /// the Log Router will use to access your Cloud KMS key. Use
    /// [GetCmekSettings][google.logging.v2.ConfigServiceV2.GetCmekSettings] to
    /// obtain the service account ID.
    ///
    /// See [Enabling CMEK for Log
    /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
    /// for more information.
    ///
    /// [google.logging.v2.ConfigServiceV2.GetCmekSettings]: crate::client::ConfigServiceV2::get_cmek_settings
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CmekSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CmekSettings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::CmekSettings::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_key_version_name][crate::model::CmekSettings::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }

    /// Sets the value of [service_account_id][crate::model::CmekSettings::service_account_id].
    pub fn set_service_account_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_id = v.into();
        self
    }
}

impl wkt::message::Message for CmekSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CmekSettings"
    }
}

/// The parameters to
/// [GetSettings][google.logging.v2.ConfigServiceV2.GetSettings].
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
///
/// [google.logging.v2.ConfigServiceV2.GetSettings]: crate::client::ConfigServiceV2::get_settings
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSettingsRequest {
    /// Required. The resource for which to retrieve settings.
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/settings"
    /// "organizations/[ORGANIZATION_ID]/settings"
    /// "billingAccounts/[BILLING_ACCOUNT_ID]/settings"
    /// "folders/[FOLDER_ID]/settings"
    /// ```
    ///
    /// For example:
    ///
    /// `"organizations/12345/settings"`
    ///
    /// Note: Settings for the Log Router can be get for Google Cloud projects,
    /// folders, organizations and billing accounts. Currently it can only be
    /// configured for organizations. Once configured for an organization, it
    /// applies to all projects and folders in the Google Cloud organization.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetSettingsRequest"
    }
}

/// The parameters to
/// [UpdateSettings][google.logging.v2.ConfigServiceV2.UpdateSettings].
///
/// See [Enabling CMEK for Log
/// Router](https://cloud.google.com/logging/docs/routing/managed-encryption) for
/// more information.
///
/// [google.logging.v2.ConfigServiceV2.UpdateSettings]: crate::client::ConfigServiceV2::update_settings
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSettingsRequest {
    /// Required. The resource name for the settings to update.
    ///
    /// ```norust
    /// "organizations/[ORGANIZATION_ID]/settings"
    /// ```
    ///
    /// For example:
    ///
    /// `"organizations/12345/settings"`
    ///
    /// Note: Settings for the Log Router can currently only be configured for
    /// Google Cloud organizations. Once configured, it applies to all projects and
    /// folders in the Google Cloud organization.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The settings to update.
    ///
    /// See [Enabling CMEK for Log
    /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
    /// for more information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub settings: std::option::Option<crate::model::Settings>,

    /// Optional. Field mask identifying which fields from `settings` should
    /// be updated. A field will be overwritten if and only if it is in the update
    /// mask. Output only fields cannot be updated.
    ///
    /// See [FieldMask][google.protobuf.FieldMask] for more information.
    ///
    /// For example: `"updateMask=kmsKeyName"`
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [settings][crate::model::UpdateSettingsRequest::settings].
    pub fn set_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Settings>,
    {
        self.settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [settings][crate::model::UpdateSettingsRequest::settings].
    pub fn set_or_clear_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Settings>,
    {
        self.settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSettingsRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSettingsRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UpdateSettingsRequest"
    }
}

/// Describes the settings associated with a project, folder, organization,
/// billing account, or flexible resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Settings {
    /// Output only. The resource name of the settings.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The resource name for the configured Cloud KMS key.
    ///
    /// KMS key name format:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]"
    /// ```
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key"`
    ///
    /// To enable CMEK for the Log Router, set this field to a valid
    /// `kms_key_name` for which the associated service account has the required
    /// `roles/cloudkms.cryptoKeyEncrypterDecrypter` role assigned for the key.
    ///
    /// The Cloud KMS key used by the Log Router can be updated by changing the
    /// `kms_key_name` to a new valid key name. Encryption operations that are in
    /// progress will be completed with the key that was in use when they started.
    /// Decryption operations will be completed using the key that was used at the
    /// time of encryption unless access to that key has been revoked.
    ///
    /// To disable CMEK for the Log Router, set this field to an empty string.
    ///
    /// See [Enabling CMEK for Log
    /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
    /// for more information.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// Output only. The service account that will be used by the Log Router to
    /// access your Cloud KMS key.
    ///
    /// Before enabling CMEK for Log Router, you must first assign the role
    /// `roles/cloudkms.cryptoKeyEncrypterDecrypter` to the service account that
    /// the Log Router will use to access your Cloud KMS key. Use
    /// [GetSettings][google.logging.v2.ConfigServiceV2.GetSettings] to
    /// obtain the service account ID.
    ///
    /// See [Enabling CMEK for Log
    /// Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
    /// for more information.
    ///
    /// [google.logging.v2.ConfigServiceV2.GetSettings]: crate::client::ConfigServiceV2::get_settings
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_service_account_id: std::string::String,

    /// Optional. The Cloud region that will be used for _Default and _Required log
    /// buckets for newly created projects and folders. For example `europe-west1`.
    /// This setting does not affect the location of custom log buckets.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub storage_location: std::string::String,

    /// Optional. If set to true, the _Default sink in newly created projects and
    /// folders will created in a disabled state. This can be used to automatically
    /// disable log ingestion if there is already an aggregated sink configured in
    /// the hierarchy. The _Default sink can be re-enabled manually if needed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disable_default_sink: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Settings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Settings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Settings::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_service_account_id][crate::model::Settings::kms_service_account_id].
    pub fn set_kms_service_account_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_service_account_id = v.into();
        self
    }

    /// Sets the value of [storage_location][crate::model::Settings::storage_location].
    pub fn set_storage_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_location = v.into();
        self
    }

    /// Sets the value of [disable_default_sink][crate::model::Settings::disable_default_sink].
    pub fn set_disable_default_sink<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_default_sink = v.into();
        self
    }
}

impl wkt::message::Message for Settings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.Settings"
    }
}

/// The parameters to CopyLogEntries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CopyLogEntriesRequest {
    /// Required. Log bucket from which to copy log entries.
    ///
    /// For example:
    ///
    /// `"projects/my-project/locations/global/buckets/my-source-bucket"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A filter specifying which log entries to copy. The filter must be
    /// no more than 20k characters. An empty filter matches all log entries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Required. Destination to which to copy log entries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CopyLogEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CopyLogEntriesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::CopyLogEntriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::CopyLogEntriesRequest::destination].
    pub fn set_destination<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = v.into();
        self
    }
}

impl wkt::message::Message for CopyLogEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CopyLogEntriesRequest"
    }
}

/// Metadata for CopyLogEntries long running operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CopyLogEntriesMetadata {
    /// The create time of an operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end time of an operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// State of an operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::OperationState,

    /// Identifies whether the user has requested cancellation of the operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub cancellation_requested: bool,

    /// CopyLogEntries RPC request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::CopyLogEntriesRequest>,

    /// Estimated progress of the operation (0 - 100%).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub progress: i32,

    /// The IAM identity of a service account that must be granted access to the
    /// destination.
    ///
    /// If the service account is not granted permission to the destination within
    /// an hour, the operation will be cancelled.
    ///
    /// For example: `"serviceAccount:foo@bar.com"`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub writer_identity: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CopyLogEntriesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::CopyLogEntriesMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CopyLogEntriesMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CopyLogEntriesMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CopyLogEntriesMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::CopyLogEntriesMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [cancellation_requested][crate::model::CopyLogEntriesMetadata::cancellation_requested].
    pub fn set_cancellation_requested<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cancellation_requested = v.into();
        self
    }

    /// Sets the value of [request][crate::model::CopyLogEntriesMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CopyLogEntriesRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::CopyLogEntriesMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CopyLogEntriesRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress][crate::model::CopyLogEntriesMetadata::progress].
    pub fn set_progress<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress = v.into();
        self
    }

    /// Sets the value of [writer_identity][crate::model::CopyLogEntriesMetadata::writer_identity].
    pub fn set_writer_identity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.writer_identity = v.into();
        self
    }
}

impl wkt::message::Message for CopyLogEntriesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CopyLogEntriesMetadata"
    }
}

/// Response type for CopyLogEntries long running operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CopyLogEntriesResponse {
    /// Number of log entries copied.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub log_entries_copied_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CopyLogEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_entries_copied_count][crate::model::CopyLogEntriesResponse::log_entries_copied_count].
    pub fn set_log_entries_copied_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.log_entries_copied_count = v.into();
        self
    }
}

impl wkt::message::Message for CopyLogEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CopyLogEntriesResponse"
    }
}

/// Metadata for LongRunningUpdateBucket Operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BucketMetadata {
    /// The create time of an operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end time of an operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// State of an operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::OperationState,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::bucket_metadata::Request>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BucketMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::BucketMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::BucketMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BucketMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BucketMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::BucketMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [request][crate::model::BucketMetadata::request].
    ///
    /// Note that all the setters affecting `request` are mutually
    /// exclusive.
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::bucket_metadata::Request>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// The value of [request][crate::model::BucketMetadata::request]
    /// if it holds a `CreateBucketRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_bucket_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateBucketRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::bucket_metadata::Request::CreateBucketRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::BucketMetadata::request]
    /// to hold a `CreateBucketRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_create_bucket_request<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateBucketRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::bucket_metadata::Request::CreateBucketRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::BucketMetadata::request]
    /// if it holds a `UpdateBucketRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn update_bucket_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpdateBucketRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::bucket_metadata::Request::UpdateBucketRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::BucketMetadata::request]
    /// to hold a `UpdateBucketRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_update_bucket_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UpdateBucketRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::bucket_metadata::Request::UpdateBucketRequest(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BucketMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.BucketMetadata"
    }
}

/// Defines additional types related to [BucketMetadata].
pub mod bucket_metadata {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Request {
        /// LongRunningCreateBucket RPC request.
        CreateBucketRequest(std::boxed::Box<crate::model::CreateBucketRequest>),
        /// LongRunningUpdateBucket RPC request.
        UpdateBucketRequest(std::boxed::Box<crate::model::UpdateBucketRequest>),
    }
}

/// Metadata for long running Link operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LinkMetadata {
    /// The start time of an operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end time of an operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// State of an operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::OperationState,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::link_metadata::Request>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LinkMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::LinkMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::LinkMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::LinkMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::LinkMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::LinkMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [request][crate::model::LinkMetadata::request].
    ///
    /// Note that all the setters affecting `request` are mutually
    /// exclusive.
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::link_metadata::Request>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// The value of [request][crate::model::LinkMetadata::request]
    /// if it holds a `CreateLinkRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_link_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateLinkRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::link_metadata::Request::CreateLinkRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::LinkMetadata::request]
    /// to hold a `CreateLinkRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_create_link_request<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateLinkRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::link_metadata::Request::CreateLinkRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::LinkMetadata::request]
    /// if it holds a `DeleteLinkRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delete_link_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeleteLinkRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::link_metadata::Request::DeleteLinkRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::LinkMetadata::request]
    /// to hold a `DeleteLinkRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_delete_link_request<
        T: std::convert::Into<std::boxed::Box<crate::model::DeleteLinkRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::link_metadata::Request::DeleteLinkRequest(v.into()),
        );
        self
    }
}

impl wkt::message::Message for LinkMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LinkMetadata"
    }
}

/// Defines additional types related to [LinkMetadata].
pub mod link_metadata {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Request {
        /// CreateLink RPC request.
        CreateLinkRequest(std::boxed::Box<crate::model::CreateLinkRequest>),
        /// DeleteLink RPC request.
        DeleteLinkRequest(std::boxed::Box<crate::model::DeleteLinkRequest>),
    }
}

/// Cloud Logging specific location metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationMetadata {
    /// Indicates whether or not Log Analytics features are supported in the given
    /// location.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub log_analytics_enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_analytics_enabled][crate::model::LocationMetadata::log_analytics_enabled].
    pub fn set_log_analytics_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.log_analytics_enabled = v.into();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LocationMetadata"
    }
}

/// Describes a logs-based metric. The value of the metric is the number of log
/// entries that match a logs filter in a given time interval.
///
/// Logs-based metrics can also be used to extract values from logs and create a
/// distribution of the values. The distribution records the statistics of the
/// extracted values along with an optional histogram of the values as specified
/// by the bucket options.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogMetric {
    /// Required. The client-assigned metric identifier.
    /// Examples: `"error_count"`, `"nginx/requests"`.
    ///
    /// Metric identifiers are limited to 100 characters and can include only the
    /// following characters: `A-Z`, `a-z`, `0-9`, and the special characters
    /// `_-.,+!*',()%/`. The forward-slash character (`/`) denotes a hierarchy of
    /// name pieces, and it cannot be the first character of the name.
    ///
    /// This field is the `[METRIC_ID]` part of a metric resource name in the
    /// format "projects/[PROJECT_ID]/metrics/[METRIC_ID]". Example: If the
    /// resource name of a metric is
    /// `"projects/my-project/metrics/nginx%2Frequests"`, this field's value is
    /// `"nginx/requests"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A description of this metric, which is used in documentation.
    /// The maximum length of the description is 8000 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Required. An [advanced logs
    /// filter](https://cloud.google.com/logging/docs/view/advanced_filters) which
    /// is used to match log entries. Example:
    ///
    /// ```norust
    /// "resource.type=gae_app AND severity>=ERROR"
    /// ```
    ///
    /// The maximum length of the filter is 20000 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The resource name of the Log Bucket that owns the Log Metric.
    /// Only Log Buckets in projects are supported. The bucket has to be in the
    /// same project as the metric.
    ///
    /// For example:
    ///
    /// `projects/my-project/locations/global/buckets/my-bucket`
    ///
    /// If empty, then the Log Metric is considered a non-Bucket Log Metric.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket_name: std::string::String,

    /// Optional. If set to True, then this metric is disabled and it does not
    /// generate any points.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disabled: bool,

    /// Optional. The metric descriptor associated with the logs-based metric.
    /// If unspecified, it uses a default metric descriptor with a DELTA metric
    /// kind, INT64 value type, with no labels and a unit of "1". Such a metric
    /// counts the number of log entries matching the `filter` expression.
    ///
    /// The `name`, `type`, and `description` fields in the `metric_descriptor`
    /// are output only, and is constructed using the `name` and `description`
    /// field in the LogMetric.
    ///
    /// To create a logs-based metric that records a distribution of log values, a
    /// DELTA metric kind with a DISTRIBUTION value type must be used along with
    /// a `value_extractor` expression in the LogMetric.
    ///
    /// Each label in the metric descriptor must have a matching label
    /// name as the key and an extractor expression as the value in the
    /// `label_extractors` map.
    ///
    /// The `metric_kind` and `value_type` fields in the `metric_descriptor` cannot
    /// be updated once initially configured. New labels can be added in the
    /// `metric_descriptor`, but existing labels cannot be modified except for
    /// their description.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric_descriptor: std::option::Option<api::model::MetricDescriptor>,

    /// Optional. A `value_extractor` is required when using a distribution
    /// logs-based metric to extract the values to record from a log entry.
    /// Two functions are supported for value extraction: `EXTRACT(field)` or
    /// `REGEXP_EXTRACT(field, regex)`. The arguments are:
    ///
    /// . field: The name of the log entry field from which the value is to be
    ///   extracted.
    /// . regex: A regular expression using the Google RE2 syntax
    ///   (<https://github.com/google/re2/wiki/Syntax>) with a single capture
    ///   group to extract data from the specified log entry field. The value
    ///   of the field is converted to a string before applying the regex.
    ///   It is an error to specify a regex that does not include exactly one
    ///   capture group.
    ///
    /// The result of the extraction must be convertible to a double type, as the
    /// distribution always records double values. If either the extraction or
    /// the conversion to double fails, then those values are not recorded in the
    /// distribution.
    ///
    /// Example: `REGEXP_EXTRACT(jsonPayload.request, ".*quantity=(\d+).*")`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value_extractor: std::string::String,

    /// Optional. A map from a label key string to an extractor expression which is
    /// used to extract data from a log entry field and assign as the label value.
    /// Each label key specified in the LabelDescriptor must have an associated
    /// extractor expression in this map. The syntax of the extractor expression
    /// is the same as for the `value_extractor` field.
    ///
    /// The extracted value is converted to the type defined in the label
    /// descriptor. If either the extraction or the type conversion fails,
    /// the label will have a default value. The default value for a string
    /// label is an empty string, for an integer label its 0, and for a boolean
    /// label its `false`.
    ///
    /// Note that there are upper bounds on the maximum number of labels and the
    /// number of active time series that are allowed in a project.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub label_extractors: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The `bucket_options` are required when the logs-based metric is
    /// using a DISTRIBUTION value type and it describes the bucket boundaries
    /// used to create a histogram of the extracted values.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bucket_options: std::option::Option<api::model::distribution::BucketOptions>,

    /// Output only. The creation timestamp of the metric.
    ///
    /// This field may not be present for older metrics.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp of the metric.
    ///
    /// This field may not be present for older metrics.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Deprecated. The API version that created or updated this metric.
    /// The v2 format is used by default and cannot be changed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub version: crate::model::log_metric::ApiVersion,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogMetric {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LogMetric::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::LogMetric::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::LogMetric::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [bucket_name][crate::model::LogMetric::bucket_name].
    pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket_name = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::LogMetric::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [metric_descriptor][crate::model::LogMetric::metric_descriptor].
    pub fn set_metric_descriptor<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::MetricDescriptor>,
    {
        self.metric_descriptor = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metric_descriptor][crate::model::LogMetric::metric_descriptor].
    pub fn set_or_clear_metric_descriptor<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::MetricDescriptor>,
    {
        self.metric_descriptor = v.map(|x| x.into());
        self
    }

    /// Sets the value of [value_extractor][crate::model::LogMetric::value_extractor].
    pub fn set_value_extractor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value_extractor = v.into();
        self
    }

    /// Sets the value of [label_extractors][crate::model::LogMetric::label_extractors].
    pub fn set_label_extractors<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.label_extractors = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [bucket_options][crate::model::LogMetric::bucket_options].
    pub fn set_bucket_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::distribution::BucketOptions>,
    {
        self.bucket_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bucket_options][crate::model::LogMetric::bucket_options].
    pub fn set_or_clear_bucket_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::distribution::BucketOptions>,
    {
        self.bucket_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::LogMetric::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::LogMetric::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::LogMetric::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::LogMetric::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version][crate::model::LogMetric::version].
    #[deprecated]
    pub fn set_version<T: std::convert::Into<crate::model::log_metric::ApiVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for LogMetric {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.LogMetric"
    }
}

/// Defines additional types related to [LogMetric].
pub mod log_metric {
    #[allow(unused_imports)]
    use super::*;

    /// Logging API version.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ApiVersion {
        /// Logging API v2.
        V2,
        /// Logging API v1.
        V1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ApiVersion::value] or
        /// [ApiVersion::name].
        UnknownValue(api_version::UnknownValue),
    }

    #[doc(hidden)]
    pub mod api_version {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ApiVersion {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::V2 => std::option::Option::Some(0),
                Self::V1 => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::V2 => std::option::Option::Some("V2"),
                Self::V1 => std::option::Option::Some("V1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ApiVersion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ApiVersion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ApiVersion {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::V2,
                1 => Self::V1,
                _ => Self::UnknownValue(api_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ApiVersion {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "V2" => Self::V2,
                "V1" => Self::V1,
                _ => Self::UnknownValue(api_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ApiVersion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::V2 => serializer.serialize_i32(0),
                Self::V1 => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ApiVersion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ApiVersion>::new(
                ".google.logging.v2.LogMetric.ApiVersion",
            ))
        }
    }
}

/// The parameters to ListLogMetrics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLogMetricsRequest {
    /// Required. The name of the project containing the metrics:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]"
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method. `pageToken` must be the value of
    /// `nextPageToken` from the previous response. The values of other method
    /// parameters should be identical to those in the previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored. The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLogMetricsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLogMetricsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLogMetricsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLogMetricsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListLogMetricsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLogMetricsRequest"
    }
}

/// Result returned from ListLogMetrics.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLogMetricsResponse {
    /// A list of logs-based metrics.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metrics: std::vec::Vec<crate::model::LogMetric>,

    /// If there might be more results than appear in this response, then
    /// `nextPageToken` is included. To get the next set of results, call this
    /// method again using the value of `nextPageToken` as `pageToken`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLogMetricsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metrics][crate::model::ListLogMetricsResponse::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogMetric>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLogMetricsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLogMetricsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.ListLogMetricsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLogMetricsResponse {
    type PageItem = crate::model::LogMetric;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.metrics
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The parameters to GetLogMetric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetLogMetricRequest {
    /// Required. The resource name of the desired metric:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metric_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLogMetricRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_name][crate::model::GetLogMetricRequest::metric_name].
    pub fn set_metric_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric_name = v.into();
        self
    }
}

impl wkt::message::Message for GetLogMetricRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.GetLogMetricRequest"
    }
}

/// The parameters to CreateLogMetric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateLogMetricRequest {
    /// Required. The resource name of the project in which to create the metric:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]"
    /// ```
    ///
    /// The new metric must be provided in the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The new logs-based metric, which must not have an identifier that
    /// already exists.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric: std::option::Option<crate::model::LogMetric>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateLogMetricRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateLogMetricRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [metric][crate::model::CreateLogMetricRequest::metric].
    pub fn set_metric<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogMetric>,
    {
        self.metric = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metric][crate::model::CreateLogMetricRequest::metric].
    pub fn set_or_clear_metric<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogMetric>,
    {
        self.metric = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateLogMetricRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.CreateLogMetricRequest"
    }
}

/// The parameters to UpdateLogMetric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateLogMetricRequest {
    /// Required. The resource name of the metric to update:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
    /// ```
    ///
    /// The updated metric must be provided in the request and it's
    /// `name` field must be the same as `[METRIC_ID]` If the metric
    /// does not exist in `[PROJECT_ID]`, then a new metric is created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metric_name: std::string::String,

    /// Required. The updated metric.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metric: std::option::Option<crate::model::LogMetric>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateLogMetricRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_name][crate::model::UpdateLogMetricRequest::metric_name].
    pub fn set_metric_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric_name = v.into();
        self
    }

    /// Sets the value of [metric][crate::model::UpdateLogMetricRequest::metric].
    pub fn set_metric<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogMetric>,
    {
        self.metric = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metric][crate::model::UpdateLogMetricRequest::metric].
    pub fn set_or_clear_metric<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogMetric>,
    {
        self.metric = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateLogMetricRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.UpdateLogMetricRequest"
    }
}

/// The parameters to DeleteLogMetric.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteLogMetricRequest {
    /// Required. The resource name of the metric to delete:
    ///
    /// ```norust
    /// "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
    /// ```
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metric_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteLogMetricRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_name][crate::model::DeleteLogMetricRequest::metric_name].
    pub fn set_metric_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric_name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteLogMetricRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.logging.v2.DeleteLogMetricRequest"
    }
}

/// List of different operation states.
/// High level state of the operation. This is used to report the job's
/// current state to the user. Once a long running operation is created,
/// the current state of the operation can be queried even before the
/// operation is finished and the final result is available.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OperationState {
    /// Should not be used.
    Unspecified,
    /// The operation is scheduled.
    Scheduled,
    /// Waiting for necessary permissions.
    WaitingForPermissions,
    /// The operation is running.
    Running,
    /// The operation was completed successfully.
    Succeeded,
    /// The operation failed.
    Failed,
    /// The operation was cancelled by the user.
    Cancelled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OperationState::value] or
    /// [OperationState::name].
    UnknownValue(operation_state::UnknownValue),
}

#[doc(hidden)]
pub mod operation_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OperationState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Scheduled => std::option::Option::Some(1),
            Self::WaitingForPermissions => std::option::Option::Some(2),
            Self::Running => std::option::Option::Some(3),
            Self::Succeeded => std::option::Option::Some(4),
            Self::Failed => std::option::Option::Some(5),
            Self::Cancelled => std::option::Option::Some(6),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("OPERATION_STATE_UNSPECIFIED"),
            Self::Scheduled => std::option::Option::Some("OPERATION_STATE_SCHEDULED"),
            Self::WaitingForPermissions => {
                std::option::Option::Some("OPERATION_STATE_WAITING_FOR_PERMISSIONS")
            }
            Self::Running => std::option::Option::Some("OPERATION_STATE_RUNNING"),
            Self::Succeeded => std::option::Option::Some("OPERATION_STATE_SUCCEEDED"),
            Self::Failed => std::option::Option::Some("OPERATION_STATE_FAILED"),
            Self::Cancelled => std::option::Option::Some("OPERATION_STATE_CANCELLED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OperationState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OperationState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OperationState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Scheduled,
            2 => Self::WaitingForPermissions,
            3 => Self::Running,
            4 => Self::Succeeded,
            5 => Self::Failed,
            6 => Self::Cancelled,
            _ => Self::UnknownValue(operation_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OperationState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OPERATION_STATE_UNSPECIFIED" => Self::Unspecified,
            "OPERATION_STATE_SCHEDULED" => Self::Scheduled,
            "OPERATION_STATE_WAITING_FOR_PERMISSIONS" => Self::WaitingForPermissions,
            "OPERATION_STATE_RUNNING" => Self::Running,
            "OPERATION_STATE_SUCCEEDED" => Self::Succeeded,
            "OPERATION_STATE_FAILED" => Self::Failed,
            "OPERATION_STATE_CANCELLED" => Self::Cancelled,
            _ => Self::UnknownValue(operation_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OperationState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Scheduled => serializer.serialize_i32(1),
            Self::WaitingForPermissions => serializer.serialize_i32(2),
            Self::Running => serializer.serialize_i32(3),
            Self::Succeeded => serializer.serialize_i32(4),
            Self::Failed => serializer.serialize_i32(5),
            Self::Cancelled => serializer.serialize_i32(6),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OperationState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperationState>::new(
            ".google.logging.v2.OperationState",
        ))
    }
}

/// LogBucket lifecycle states.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LifecycleState {
    /// Unspecified state. This is only used/useful for distinguishing unset
    /// values.
    Unspecified,
    /// The normal and active state.
    Active,
    /// The resource has been marked for deletion by the user. For some resources
    /// (e.g. buckets), this can be reversed by an un-delete operation.
    DeleteRequested,
    /// The resource has been marked for an update by the user. It will remain in
    /// this state until the update is complete.
    Updating,
    /// The resource has been marked for creation by the user. It will remain in
    /// this state until the creation is complete.
    Creating,
    /// The resource is in an INTERNAL error state.
    Failed,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LifecycleState::value] or
    /// [LifecycleState::name].
    UnknownValue(lifecycle_state::UnknownValue),
}

#[doc(hidden)]
pub mod lifecycle_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LifecycleState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Active => std::option::Option::Some(1),
            Self::DeleteRequested => std::option::Option::Some(2),
            Self::Updating => std::option::Option::Some(3),
            Self::Creating => std::option::Option::Some(4),
            Self::Failed => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("LIFECYCLE_STATE_UNSPECIFIED"),
            Self::Active => std::option::Option::Some("ACTIVE"),
            Self::DeleteRequested => std::option::Option::Some("DELETE_REQUESTED"),
            Self::Updating => std::option::Option::Some("UPDATING"),
            Self::Creating => std::option::Option::Some("CREATING"),
            Self::Failed => std::option::Option::Some("FAILED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LifecycleState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LifecycleState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LifecycleState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Active,
            2 => Self::DeleteRequested,
            3 => Self::Updating,
            4 => Self::Creating,
            5 => Self::Failed,
            _ => Self::UnknownValue(lifecycle_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LifecycleState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LIFECYCLE_STATE_UNSPECIFIED" => Self::Unspecified,
            "ACTIVE" => Self::Active,
            "DELETE_REQUESTED" => Self::DeleteRequested,
            "UPDATING" => Self::Updating,
            "CREATING" => Self::Creating,
            "FAILED" => Self::Failed,
            _ => Self::UnknownValue(lifecycle_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LifecycleState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Active => serializer.serialize_i32(1),
            Self::DeleteRequested => serializer.serialize_i32(2),
            Self::Updating => serializer.serialize_i32(3),
            Self::Creating => serializer.serialize_i32(4),
            Self::Failed => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LifecycleState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<LifecycleState>::new(
            ".google.logging.v2.LifecycleState",
        ))
    }
}

/// IndexType is used for custom indexing. It describes the type of an indexed
/// field.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum IndexType {
    /// The index's type is unspecified.
    Unspecified,
    /// The index is a string-type index.
    String,
    /// The index is a integer-type index.
    Integer,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [IndexType::value] or
    /// [IndexType::name].
    UnknownValue(index_type::UnknownValue),
}

#[doc(hidden)]
pub mod index_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl IndexType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::String => std::option::Option::Some(1),
            Self::Integer => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INDEX_TYPE_UNSPECIFIED"),
            Self::String => std::option::Option::Some("INDEX_TYPE_STRING"),
            Self::Integer => std::option::Option::Some("INDEX_TYPE_INTEGER"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for IndexType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for IndexType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for IndexType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::String,
            2 => Self::Integer,
            _ => Self::UnknownValue(index_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for IndexType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INDEX_TYPE_UNSPECIFIED" => Self::Unspecified,
            "INDEX_TYPE_STRING" => Self::String,
            "INDEX_TYPE_INTEGER" => Self::Integer,
            _ => Self::UnknownValue(index_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for IndexType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::String => serializer.serialize_i32(1),
            Self::Integer => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for IndexType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<IndexType>::new(
            ".google.logging.v2.IndexType",
        ))
    }
}
