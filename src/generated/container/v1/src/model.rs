// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Parameters that can be configured on Linux nodes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LinuxNodeConfig {
    /// The Linux kernel parameters to be applied to the nodes and all pods running
    /// on the nodes.
    ///
    /// The following parameters are supported.
    ///
    /// net.core.busy_poll
    /// net.core.busy_read
    /// net.core.netdev_max_backlog
    /// net.core.rmem_max
    /// net.core.wmem_default
    /// net.core.wmem_max
    /// net.core.optmem_max
    /// net.core.somaxconn
    /// net.ipv4.tcp_rmem
    /// net.ipv4.tcp_wmem
    /// net.ipv4.tcp_tw_reuse
    /// kernel.shmmni
    /// kernel.shmmax
    /// kernel.shmall
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub sysctls: std::collections::HashMap<std::string::String, std::string::String>,

    /// cgroup_mode specifies the cgroup mode to be used on the node.
    pub cgroup_mode: crate::model::linux_node_config::CgroupMode,

    /// Optional. Amounts for 2M and 1G hugepages
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hugepages: std::option::Option<crate::model::linux_node_config::HugepagesConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LinuxNodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sysctls][crate::model::LinuxNodeConfig::sysctls].
    pub fn set_sysctls<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.sysctls = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [cgroup_mode][crate::model::LinuxNodeConfig::cgroup_mode].
    pub fn set_cgroup_mode<T: std::convert::Into<crate::model::linux_node_config::CgroupMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.cgroup_mode = v.into();
        self
    }

    /// Sets the value of [hugepages][crate::model::LinuxNodeConfig::hugepages].
    pub fn set_hugepages<
        T: std::convert::Into<std::option::Option<crate::model::linux_node_config::HugepagesConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hugepages = v.into();
        self
    }
}

impl wkt::message::Message for LinuxNodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.LinuxNodeConfig"
    }
}

/// Defines additional types related to [LinuxNodeConfig].
pub mod linux_node_config {
    #[allow(unused_imports)]
    use super::*;

    /// Hugepages amount in both 2m and 1g size
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct HugepagesConfig {
        /// Optional. Amount of 2M hugepages
        #[serde(rename = "hugepageSize2m")]
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub hugepage_size2m: std::option::Option<i32>,

        /// Optional. Amount of 1G hugepages
        #[serde(rename = "hugepageSize1g")]
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub hugepage_size1g: std::option::Option<i32>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl HugepagesConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [hugepage_size2m][crate::model::linux_node_config::HugepagesConfig::hugepage_size2m].
        pub fn set_hugepage_size2m<T: std::convert::Into<std::option::Option<i32>>>(
            mut self,
            v: T,
        ) -> Self {
            self.hugepage_size2m = v.into();
            self
        }

        /// Sets the value of [hugepage_size1g][crate::model::linux_node_config::HugepagesConfig::hugepage_size1g].
        pub fn set_hugepage_size1g<T: std::convert::Into<std::option::Option<i32>>>(
            mut self,
            v: T,
        ) -> Self {
            self.hugepage_size1g = v.into();
            self
        }
    }

    impl wkt::message::Message for HugepagesConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.LinuxNodeConfig.HugepagesConfig"
        }
    }

    /// Possible cgroup modes that can be used.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CgroupMode {
        /// CGROUP_MODE_UNSPECIFIED is when unspecified cgroup configuration is used.
        /// The default for the GKE node OS image will be used.
        Unspecified,
        /// CGROUP_MODE_V1 specifies to use cgroupv1 for the cgroup configuration on
        /// the node image.
        V1,
        /// CGROUP_MODE_V2 specifies to use cgroupv2 for the cgroup configuration on
        /// the node image.
        V2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CgroupMode::value] or
        /// [CgroupMode::name].
        UnknownValue(cgroup_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cgroup_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CgroupMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::V1 => std::option::Option::Some(1),
                Self::V2 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CGROUP_MODE_UNSPECIFIED"),
                Self::V1 => std::option::Option::Some("CGROUP_MODE_V1"),
                Self::V2 => std::option::Option::Some("CGROUP_MODE_V2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CgroupMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CgroupMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CgroupMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::V1,
                2 => Self::V2,
                _ => Self::UnknownValue(cgroup_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CgroupMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CGROUP_MODE_UNSPECIFIED" => Self::Unspecified,
                "CGROUP_MODE_V1" => Self::V1,
                "CGROUP_MODE_V2" => Self::V2,
                _ => Self::UnknownValue(cgroup_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CgroupMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::V1 => serializer.serialize_i32(1),
                Self::V2 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CgroupMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CgroupMode>::new(
                ".google.container.v1.LinuxNodeConfig.CgroupMode",
            ))
        }
    }
}

/// Parameters that can be configured on Windows nodes.
/// Windows Node Config that define the parameters that will be used to
/// configure the Windows node pool settings
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WindowsNodeConfig {
    /// OSVersion specifies the Windows node config to be used on the node
    pub os_version: crate::model::windows_node_config::OSVersion,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WindowsNodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_version][crate::model::WindowsNodeConfig::os_version].
    pub fn set_os_version<T: std::convert::Into<crate::model::windows_node_config::OSVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.os_version = v.into();
        self
    }
}

impl wkt::message::Message for WindowsNodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.WindowsNodeConfig"
    }
}

/// Defines additional types related to [WindowsNodeConfig].
pub mod windows_node_config {
    #[allow(unused_imports)]
    use super::*;

    /// Possible OS version that can be used.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OSVersion {
        /// When OSVersion is not specified
        Unspecified,
        /// LTSC2019 specifies to use LTSC2019 as the Windows Servercore Base Image
        Ltsc2019,
        /// LTSC2022 specifies to use LTSC2022 as the Windows Servercore Base Image
        Ltsc2022,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OSVersion::value] or
        /// [OSVersion::name].
        UnknownValue(os_version::UnknownValue),
    }

    #[doc(hidden)]
    pub mod os_version {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OSVersion {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ltsc2019 => std::option::Option::Some(1),
                Self::Ltsc2022 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OS_VERSION_UNSPECIFIED"),
                Self::Ltsc2019 => std::option::Option::Some("OS_VERSION_LTSC2019"),
                Self::Ltsc2022 => std::option::Option::Some("OS_VERSION_LTSC2022"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OSVersion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OSVersion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OSVersion {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ltsc2019,
                2 => Self::Ltsc2022,
                _ => Self::UnknownValue(os_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OSVersion {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OS_VERSION_UNSPECIFIED" => Self::Unspecified,
                "OS_VERSION_LTSC2019" => Self::Ltsc2019,
                "OS_VERSION_LTSC2022" => Self::Ltsc2022,
                _ => Self::UnknownValue(os_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OSVersion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ltsc2019 => serializer.serialize_i32(1),
                Self::Ltsc2022 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OSVersion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OSVersion>::new(
                ".google.container.v1.WindowsNodeConfig.OSVersion",
            ))
        }
    }
}

/// Node kubelet configs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeKubeletConfig {
    /// Control the CPU management policy on the node.
    /// See
    /// <https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/>
    ///
    /// The following values are allowed.
    ///
    /// * "none": the default, which represents the existing scheduling behavior.
    /// * "static": allows pods with certain resource characteristics to be granted
    ///   increased CPU affinity and exclusivity on the node.
    ///   The default value is 'none' if unspecified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cpu_manager_policy: std::string::String,

    /// Enable CPU CFS quota enforcement for containers that specify CPU limits.
    ///
    /// This option is enabled by default which makes kubelet use CFS quota
    /// (<https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt>) to
    /// enforce container CPU limits. Otherwise, CPU limits will not be enforced at
    /// all.
    ///
    /// Disable this option to mitigate CPU throttling problems while still having
    /// your pods to be in Guaranteed QoS class by specifying the CPU limits.
    ///
    /// The default value is 'true' if unspecified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cpu_cfs_quota: std::option::Option<wkt::BoolValue>,

    /// Set the CPU CFS quota period value 'cpu.cfs_period_us'.
    ///
    /// The string must be a sequence of decimal numbers, each with optional
    /// fraction and a unit suffix, such as "300ms".
    /// Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
    /// The value must be a positive duration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cpu_cfs_quota_period: std::string::String,

    /// Set the Pod PID limits. See
    /// <https://kubernetes.io/docs/concepts/policy/pid-limiting/#pod-pid-limits>
    ///
    /// Controls the maximum number of processes allowed to run in a pod. The value
    /// must be greater than or equal to 1024 and less than 4194304.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub pod_pids_limit: i64,

    /// Enable or disable Kubelet read only port.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub insecure_kubelet_readonly_port_enabled: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeKubeletConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu_manager_policy][crate::model::NodeKubeletConfig::cpu_manager_policy].
    pub fn set_cpu_manager_policy<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cpu_manager_policy = v.into();
        self
    }

    /// Sets the value of [cpu_cfs_quota][crate::model::NodeKubeletConfig::cpu_cfs_quota].
    pub fn set_cpu_cfs_quota<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cpu_cfs_quota = v.into();
        self
    }

    /// Sets the value of [cpu_cfs_quota_period][crate::model::NodeKubeletConfig::cpu_cfs_quota_period].
    pub fn set_cpu_cfs_quota_period<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cpu_cfs_quota_period = v.into();
        self
    }

    /// Sets the value of [pod_pids_limit][crate::model::NodeKubeletConfig::pod_pids_limit].
    pub fn set_pod_pids_limit<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pod_pids_limit = v.into();
        self
    }

    /// Sets the value of [insecure_kubelet_readonly_port_enabled][crate::model::NodeKubeletConfig::insecure_kubelet_readonly_port_enabled].
    pub fn set_insecure_kubelet_readonly_port_enabled<
        T: std::convert::Into<std::option::Option<bool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.insecure_kubelet_readonly_port_enabled = v.into();
        self
    }
}

impl wkt::message::Message for NodeKubeletConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeKubeletConfig"
    }
}

/// Parameters that describe the nodes in a cluster.
///
/// GKE Autopilot clusters do not
/// recognize parameters in `NodeConfig`. Use
/// [AutoprovisioningNodePoolDefaults][google.container.v1.AutoprovisioningNodePoolDefaults]
/// instead.
///
/// [google.container.v1.AutoprovisioningNodePoolDefaults]: crate::model::AutoprovisioningNodePoolDefaults
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeConfig {
    /// The name of a Google Compute Engine [machine
    /// type](https://cloud.google.com/compute/docs/machine-types)
    ///
    /// If unspecified, the default machine type is `e2-medium`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type: std::string::String,

    /// Size of the disk attached to each node, specified in GB.
    /// The smallest allowed disk size is 10GB.
    ///
    /// If unspecified, the default disk size is 100GB.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disk_size_gb: i32,

    /// The set of Google API scopes to be made available on all of the
    /// node VMs under the "default" service account.
    ///
    /// The following scopes are recommended, but not required, and by default are
    /// not included:
    ///
    /// * `<https://www.googleapis.com/auth/compute>` is required for mounting
    ///   persistent storage on your nodes.
    /// * `<https://www.googleapis.com/auth/devstorage.read_only>` is required for
    ///   communicating with **gcr.io**
    ///   (the [Google Container
    ///   Registry](https://cloud.google.com/container-registry/)).
    ///
    /// If unspecified, no scopes are added, unless Cloud Logging or Cloud
    /// Monitoring are enabled, in which case their required scopes will be added.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub oauth_scopes: std::vec::Vec<std::string::String>,

    /// The Google Cloud Platform Service Account to be used by the node VMs.
    /// Specify the email address of the Service Account; otherwise, if no Service
    /// Account is specified, the "default" service account is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// The metadata key/value pairs assigned to instances in the cluster.
    ///
    /// Keys must conform to the regexp `[a-zA-Z0-9-_]+` and be less than 128 bytes
    /// in length. These are reflected as part of a URL in the metadata server.
    /// Additionally, to avoid ambiguity, keys must not conflict with any other
    /// metadata keys for the project or be one of the reserved keys:
    ///
    /// - "cluster-location"
    /// - "cluster-name"
    /// - "cluster-uid"
    /// - "configure-sh"
    /// - "containerd-configure-sh"
    /// - "enable-os-login"
    /// - "gci-ensure-gke-docker"
    /// - "gci-metrics-enabled"
    /// - "gci-update-strategy"
    /// - "instance-template"
    /// - "kube-env"
    /// - "startup-script"
    /// - "user-data"
    /// - "disable-address-manager"
    /// - "windows-startup-script-ps1"
    /// - "common-psm1"
    /// - "k8s-node-setup-psm1"
    /// - "install-ssh-psm1"
    /// - "user-profile-psm1"
    ///
    /// Values are free-form strings, and only have meaning as interpreted by
    /// the image running in the instance. The only restriction placed on them is
    /// that each value's size must be less than or equal to 32 KB.
    ///
    /// The total size of all keys and values must be less than 512 KB.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The image type to use for this node. Note that for a given image type,
    /// the latest version of it will be used. Please see
    /// <https://cloud.google.com/kubernetes-engine/docs/concepts/node-images> for
    /// available image types.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_type: std::string::String,

    /// The map of Kubernetes labels (key/value pairs) to be applied to each node.
    /// These will added in addition to any default label(s) that
    /// Kubernetes may apply to the node.
    /// In case of conflict in label keys, the applied set may differ depending on
    /// the Kubernetes version -- it's best to assume the behavior is undefined
    /// and conflicts should be avoided.
    /// For more information, including usage and the valid values, see:
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The number of local SSD disks to be attached to the node.
    ///
    /// The limit for this value is dependent upon the maximum number of
    /// disks available on a machine per zone. See:
    /// <https://cloud.google.com/compute/docs/disks/local-ssd>
    /// for more information.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub local_ssd_count: i32,

    /// The list of instance tags applied to all nodes. Tags are used to identify
    /// valid sources or targets for network firewalls and are specified by
    /// the client during cluster or node pool creation. Each tag within the list
    /// must comply with RFC1035.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<std::string::String>,

    /// Whether the nodes are created as preemptible VM instances. See:
    /// <https://cloud.google.com/compute/docs/instances/preemptible> for more
    /// information about preemptible VM instances.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub preemptible: bool,

    /// A list of hardware accelerators to be attached to each node.
    /// See <https://cloud.google.com/compute/docs/gpus> for more information about
    /// support for GPUs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub accelerators: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd' or
    /// 'pd-balanced')
    ///
    /// If unspecified, the default disk type is 'pd-standard'
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub disk_type: std::string::String,

    /// Minimum CPU platform to be used by this instance. The instance may be
    /// scheduled on the specified or newer CPU platform. Applicable values are the
    /// friendly names of CPU platforms, such as
    /// `minCpuPlatform: "Intel Haswell"` or
    /// `minCpuPlatform: "Intel Sandy Bridge"`. For more
    /// information, read [how to specify min CPU
    /// platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub min_cpu_platform: std::string::String,

    /// The workload metadata configuration for this node.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workload_metadata_config: std::option::Option<crate::model::WorkloadMetadataConfig>,

    /// List of kubernetes taints to be applied to each node.
    ///
    /// For more information, including usage and the valid values, see:
    /// <https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub taints: std::vec::Vec<crate::model::NodeTaint>,

    /// Sandbox configuration for this node.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sandbox_config: std::option::Option<crate::model::SandboxConfig>,

    /// Setting this field will assign instances of this
    /// pool to run on the specified node group. This is useful for running
    /// workloads on [sole tenant
    /// nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_group: std::string::String,

    /// The optional reservation affinity. Setting this field will apply
    /// the specified [Zonal Compute
    /// Reservation](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources)
    /// to this node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reservation_affinity: std::option::Option<crate::model::ReservationAffinity>,

    /// Shielded Instance options.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub shielded_instance_config: std::option::Option<crate::model::ShieldedInstanceConfig>,

    /// Parameters that can be configured on Linux nodes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub linux_node_config: std::option::Option<crate::model::LinuxNodeConfig>,

    /// Node kubelet configs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kubelet_config: std::option::Option<crate::model::NodeKubeletConfig>,

    /// The Customer Managed Encryption Key used to encrypt the boot disk attached
    /// to each node in the node pool. This should be of the form
    /// projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME].
    /// For more information about protecting resources with Cloud KMS Keys please
    /// see:
    /// <https://cloud.google.com/compute/docs/disks/customer-managed-encryption>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub boot_disk_kms_key: std::string::String,

    /// Google Container File System (image streaming) configs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcfs_config: std::option::Option<crate::model::GcfsConfig>,

    /// Advanced features for the Compute Engine VM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub advanced_machine_features: std::option::Option<crate::model::AdvancedMachineFeatures>,

    /// Enable or disable gvnic in the node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gvnic: std::option::Option<crate::model::VirtualNIC>,

    /// Spot flag for enabling Spot VM, which is a rebrand of
    /// the existing preemptible flag.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub spot: bool,

    /// Confidential nodes config.
    /// All the nodes in the node pool will be Confidential VM once enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidential_nodes: std::option::Option<crate::model::ConfidentialNodes>,

    /// Enable or disable NCCL fast socket for the node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fast_socket: std::option::Option<crate::model::FastSocket>,

    /// The resource labels for the node pool to use to annotate any related
    /// Google Compute Engine resources.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub resource_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Logging configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::NodePoolLoggingConfig>,

    /// Parameters that can be configured on Windows nodes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub windows_node_config: std::option::Option<crate::model::WindowsNodeConfig>,

    /// Parameters for using raw-block Local NVMe SSDs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub local_nvme_ssd_block_config: std::option::Option<crate::model::LocalNvmeSsdBlockConfig>,

    /// Parameters for the node ephemeral storage using Local SSDs.
    /// If unspecified, ephemeral storage is backed by the boot disk.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ephemeral_storage_local_ssd_config:
        std::option::Option<crate::model::EphemeralStorageLocalSsdConfig>,

    /// Parameters for node pools to be backed by shared sole tenant node groups.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sole_tenant_config: std::option::Option<crate::model::SoleTenantConfig>,

    /// Parameters for containerd customization.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub containerd_config: std::option::Option<crate::model::ContainerdConfig>,

    /// A map of resource manager tag keys and values to be attached to the nodes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_manager_tags: std::option::Option<crate::model::ResourceManagerTags>,

    /// Optional. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_confidential_storage: bool,

    /// List of secondary boot disks attached to the nodes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub secondary_boot_disks: std::vec::Vec<crate::model::SecondaryBootDisk>,

    /// List of Storage Pools where boot disks are provisioned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub storage_pools: std::vec::Vec<std::string::String>,

    /// Secondary boot disk update strategy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub secondary_boot_disk_update_strategy:
        std::option::Option<crate::model::SecondaryBootDiskUpdateStrategy>,

    /// Specifies which method should be used for encrypting the
    /// Local SSDs attahced to the node.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub local_ssd_encryption_mode:
        std::option::Option<crate::model::node_config::LocalSsdEncryptionMode>,

    /// Output only. effective_cgroup_mode is the cgroup mode actually used by the
    /// node pool. It is determined by the cgroup mode specified in the
    /// LinuxNodeConfig or the default cgroup mode based on the cluster creation
    /// version.
    pub effective_cgroup_mode: crate::model::node_config::EffectiveCgroupMode,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type][crate::model::NodeConfig::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::NodeConfig::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [oauth_scopes][crate::model::NodeConfig::oauth_scopes].
    pub fn set_oauth_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.oauth_scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::NodeConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::NodeConfig::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [image_type][crate::model::NodeConfig::image_type].
    pub fn set_image_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::NodeConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [local_ssd_count][crate::model::NodeConfig::local_ssd_count].
    pub fn set_local_ssd_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.local_ssd_count = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::NodeConfig::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [preemptible][crate::model::NodeConfig::preemptible].
    pub fn set_preemptible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.preemptible = v.into();
        self
    }

    /// Sets the value of [accelerators][crate::model::NodeConfig::accelerators].
    pub fn set_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [disk_type][crate::model::NodeConfig::disk_type].
    pub fn set_disk_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [min_cpu_platform][crate::model::NodeConfig::min_cpu_platform].
    pub fn set_min_cpu_platform<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_cpu_platform = v.into();
        self
    }

    /// Sets the value of [workload_metadata_config][crate::model::NodeConfig::workload_metadata_config].
    pub fn set_workload_metadata_config<
        T: std::convert::Into<std::option::Option<crate::model::WorkloadMetadataConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workload_metadata_config = v.into();
        self
    }

    /// Sets the value of [taints][crate::model::NodeConfig::taints].
    pub fn set_taints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodeTaint>,
    {
        use std::iter::Iterator;
        self.taints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sandbox_config][crate::model::NodeConfig::sandbox_config].
    pub fn set_sandbox_config<
        T: std::convert::Into<std::option::Option<crate::model::SandboxConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sandbox_config = v.into();
        self
    }

    /// Sets the value of [node_group][crate::model::NodeConfig::node_group].
    pub fn set_node_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_group = v.into();
        self
    }

    /// Sets the value of [reservation_affinity][crate::model::NodeConfig::reservation_affinity].
    pub fn set_reservation_affinity<
        T: std::convert::Into<std::option::Option<crate::model::ReservationAffinity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reservation_affinity = v.into();
        self
    }

    /// Sets the value of [shielded_instance_config][crate::model::NodeConfig::shielded_instance_config].
    pub fn set_shielded_instance_config<
        T: std::convert::Into<std::option::Option<crate::model::ShieldedInstanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.shielded_instance_config = v.into();
        self
    }

    /// Sets the value of [linux_node_config][crate::model::NodeConfig::linux_node_config].
    pub fn set_linux_node_config<
        T: std::convert::Into<std::option::Option<crate::model::LinuxNodeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.linux_node_config = v.into();
        self
    }

    /// Sets the value of [kubelet_config][crate::model::NodeConfig::kubelet_config].
    pub fn set_kubelet_config<
        T: std::convert::Into<std::option::Option<crate::model::NodeKubeletConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kubelet_config = v.into();
        self
    }

    /// Sets the value of [boot_disk_kms_key][crate::model::NodeConfig::boot_disk_kms_key].
    pub fn set_boot_disk_kms_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_disk_kms_key = v.into();
        self
    }

    /// Sets the value of [gcfs_config][crate::model::NodeConfig::gcfs_config].
    pub fn set_gcfs_config<T: std::convert::Into<std::option::Option<crate::model::GcfsConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcfs_config = v.into();
        self
    }

    /// Sets the value of [advanced_machine_features][crate::model::NodeConfig::advanced_machine_features].
    pub fn set_advanced_machine_features<
        T: std::convert::Into<std::option::Option<crate::model::AdvancedMachineFeatures>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.advanced_machine_features = v.into();
        self
    }

    /// Sets the value of [gvnic][crate::model::NodeConfig::gvnic].
    pub fn set_gvnic<T: std::convert::Into<std::option::Option<crate::model::VirtualNIC>>>(
        mut self,
        v: T,
    ) -> Self {
        self.gvnic = v.into();
        self
    }

    /// Sets the value of [spot][crate::model::NodeConfig::spot].
    pub fn set_spot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.spot = v.into();
        self
    }

    /// Sets the value of [confidential_nodes][crate::model::NodeConfig::confidential_nodes].
    pub fn set_confidential_nodes<
        T: std::convert::Into<std::option::Option<crate::model::ConfidentialNodes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.confidential_nodes = v.into();
        self
    }

    /// Sets the value of [fast_socket][crate::model::NodeConfig::fast_socket].
    pub fn set_fast_socket<T: std::convert::Into<std::option::Option<crate::model::FastSocket>>>(
        mut self,
        v: T,
    ) -> Self {
        self.fast_socket = v.into();
        self
    }

    /// Sets the value of [resource_labels][crate::model::NodeConfig::resource_labels].
    pub fn set_resource_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::NodeConfig::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::NodePoolLoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [windows_node_config][crate::model::NodeConfig::windows_node_config].
    pub fn set_windows_node_config<
        T: std::convert::Into<std::option::Option<crate::model::WindowsNodeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.windows_node_config = v.into();
        self
    }

    /// Sets the value of [local_nvme_ssd_block_config][crate::model::NodeConfig::local_nvme_ssd_block_config].
    pub fn set_local_nvme_ssd_block_config<
        T: std::convert::Into<std::option::Option<crate::model::LocalNvmeSsdBlockConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.local_nvme_ssd_block_config = v.into();
        self
    }

    /// Sets the value of [ephemeral_storage_local_ssd_config][crate::model::NodeConfig::ephemeral_storage_local_ssd_config].
    pub fn set_ephemeral_storage_local_ssd_config<
        T: std::convert::Into<std::option::Option<crate::model::EphemeralStorageLocalSsdConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ephemeral_storage_local_ssd_config = v.into();
        self
    }

    /// Sets the value of [sole_tenant_config][crate::model::NodeConfig::sole_tenant_config].
    pub fn set_sole_tenant_config<
        T: std::convert::Into<std::option::Option<crate::model::SoleTenantConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sole_tenant_config = v.into();
        self
    }

    /// Sets the value of [containerd_config][crate::model::NodeConfig::containerd_config].
    pub fn set_containerd_config<
        T: std::convert::Into<std::option::Option<crate::model::ContainerdConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.containerd_config = v.into();
        self
    }

    /// Sets the value of [resource_manager_tags][crate::model::NodeConfig::resource_manager_tags].
    pub fn set_resource_manager_tags<
        T: std::convert::Into<std::option::Option<crate::model::ResourceManagerTags>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_manager_tags = v.into();
        self
    }

    /// Sets the value of [enable_confidential_storage][crate::model::NodeConfig::enable_confidential_storage].
    pub fn set_enable_confidential_storage<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_confidential_storage = v.into();
        self
    }

    /// Sets the value of [secondary_boot_disks][crate::model::NodeConfig::secondary_boot_disks].
    pub fn set_secondary_boot_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecondaryBootDisk>,
    {
        use std::iter::Iterator;
        self.secondary_boot_disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [storage_pools][crate::model::NodeConfig::storage_pools].
    pub fn set_storage_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.storage_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [secondary_boot_disk_update_strategy][crate::model::NodeConfig::secondary_boot_disk_update_strategy].
    pub fn set_secondary_boot_disk_update_strategy<
        T: std::convert::Into<std::option::Option<crate::model::SecondaryBootDiskUpdateStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_boot_disk_update_strategy = v.into();
        self
    }

    /// Sets the value of [local_ssd_encryption_mode][crate::model::NodeConfig::local_ssd_encryption_mode].
    pub fn set_local_ssd_encryption_mode<
        T: std::convert::Into<std::option::Option<crate::model::node_config::LocalSsdEncryptionMode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.local_ssd_encryption_mode = v.into();
        self
    }

    /// Sets the value of [effective_cgroup_mode][crate::model::NodeConfig::effective_cgroup_mode].
    pub fn set_effective_cgroup_mode<
        T: std::convert::Into<crate::model::node_config::EffectiveCgroupMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.effective_cgroup_mode = v.into();
        self
    }
}

impl wkt::message::Message for NodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeConfig"
    }
}

/// Defines additional types related to [NodeConfig].
pub mod node_config {
    #[allow(unused_imports)]
    use super::*;

    /// LocalSsdEncryptionMode specifies the method used for encrypting the Local
    /// SSDs attached to the node.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LocalSsdEncryptionMode {
        /// The given node will be encrypted using keys managed by Google
        /// infrastructure and the keys will be deleted when the node is
        /// deleted.
        Unspecified,
        /// The given node will be encrypted using keys managed by Google
        /// infrastructure and the keys will be deleted when the node is
        /// deleted.
        StandardEncryption,
        /// The given node will opt-in for using ephemeral key for
        /// encryption of Local SSDs.
        /// The Local SSDs will not be able to recover data in case of node
        /// crash.
        EphemeralKeyEncryption,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LocalSsdEncryptionMode::value] or
        /// [LocalSsdEncryptionMode::name].
        UnknownValue(local_ssd_encryption_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod local_ssd_encryption_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LocalSsdEncryptionMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::StandardEncryption => std::option::Option::Some(1),
                Self::EphemeralKeyEncryption => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("LOCAL_SSD_ENCRYPTION_MODE_UNSPECIFIED")
                }
                Self::StandardEncryption => std::option::Option::Some("STANDARD_ENCRYPTION"),
                Self::EphemeralKeyEncryption => {
                    std::option::Option::Some("EPHEMERAL_KEY_ENCRYPTION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LocalSsdEncryptionMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LocalSsdEncryptionMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LocalSsdEncryptionMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::StandardEncryption,
                2 => Self::EphemeralKeyEncryption,
                _ => Self::UnknownValue(local_ssd_encryption_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LocalSsdEncryptionMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOCAL_SSD_ENCRYPTION_MODE_UNSPECIFIED" => Self::Unspecified,
                "STANDARD_ENCRYPTION" => Self::StandardEncryption,
                "EPHEMERAL_KEY_ENCRYPTION" => Self::EphemeralKeyEncryption,
                _ => Self::UnknownValue(local_ssd_encryption_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LocalSsdEncryptionMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::StandardEncryption => serializer.serialize_i32(1),
                Self::EphemeralKeyEncryption => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LocalSsdEncryptionMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LocalSsdEncryptionMode>::new(
                ".google.container.v1.NodeConfig.LocalSsdEncryptionMode",
            ))
        }
    }

    /// Possible effective cgroup modes for the node.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EffectiveCgroupMode {
        /// EFFECTIVE_CGROUP_MODE_UNSPECIFIED means the cgroup configuration for the
        /// node pool is unspecified, i.e. the node pool is a Windows node pool.
        Unspecified,
        /// CGROUP_MODE_V1 means the node pool is configured to use cgroupv1 for the
        /// cgroup configuration.
        V1,
        /// CGROUP_MODE_V2 means the node pool is configured to use cgroupv2 for the
        /// cgroup configuration.
        V2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EffectiveCgroupMode::value] or
        /// [EffectiveCgroupMode::name].
        UnknownValue(effective_cgroup_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod effective_cgroup_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EffectiveCgroupMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::V1 => std::option::Option::Some(1),
                Self::V2 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EFFECTIVE_CGROUP_MODE_UNSPECIFIED"),
                Self::V1 => std::option::Option::Some("EFFECTIVE_CGROUP_MODE_V1"),
                Self::V2 => std::option::Option::Some("EFFECTIVE_CGROUP_MODE_V2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EffectiveCgroupMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EffectiveCgroupMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EffectiveCgroupMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::V1,
                2 => Self::V2,
                _ => Self::UnknownValue(effective_cgroup_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EffectiveCgroupMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EFFECTIVE_CGROUP_MODE_UNSPECIFIED" => Self::Unspecified,
                "EFFECTIVE_CGROUP_MODE_V1" => Self::V1,
                "EFFECTIVE_CGROUP_MODE_V2" => Self::V2,
                _ => Self::UnknownValue(effective_cgroup_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EffectiveCgroupMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::V1 => serializer.serialize_i32(1),
                Self::V2 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EffectiveCgroupMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EffectiveCgroupMode>::new(
                ".google.container.v1.NodeConfig.EffectiveCgroupMode",
            ))
        }
    }
}

/// Specifies options for controlling advanced machine features.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdvancedMachineFeatures {
    /// The number of threads per physical core. To disable simultaneous
    /// multithreading (SMT) set this to 1. If unset, the maximum number of threads
    /// supported per core by the underlying processor is assumed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub threads_per_core: std::option::Option<i64>,

    /// Whether or not to enable nested virtualization (defaults to false).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_nested_virtualization: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvancedMachineFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threads_per_core][crate::model::AdvancedMachineFeatures::threads_per_core].
    pub fn set_threads_per_core<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.threads_per_core = v.into();
        self
    }

    /// Sets the value of [enable_nested_virtualization][crate::model::AdvancedMachineFeatures::enable_nested_virtualization].
    pub fn set_enable_nested_virtualization<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_nested_virtualization = v.into();
        self
    }
}

impl wkt::message::Message for AdvancedMachineFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AdvancedMachineFeatures"
    }
}

/// Parameters for node pool-level network config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeNetworkConfig {
    /// Input only. Whether to create a new range for pod IPs in this node pool.
    /// Defaults are provided for `pod_range` and `pod_ipv4_cidr_block` if they
    /// are not specified.
    ///
    /// If neither `create_pod_range` or `pod_range` are specified, the
    /// cluster-level default (`ip_allocation_policy.cluster_ipv4_cidr_block`) is
    /// used.
    ///
    /// Only applicable if `ip_allocation_policy.use_ip_aliases` is true.
    ///
    /// This field cannot be changed after the node pool has been created.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub create_pod_range: bool,

    /// The ID of the secondary range for pod IPs.
    /// If `create_pod_range` is true, this ID is used for the new range.
    /// If `create_pod_range` is false, uses an existing secondary range with this
    /// ID.
    ///
    /// Only applicable if `ip_allocation_policy.use_ip_aliases` is true.
    ///
    /// This field cannot be changed after the node pool has been created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pod_range: std::string::String,

    /// The IP address range for pod IPs in this node pool.
    ///
    /// Only applicable if `create_pod_range` is true.
    ///
    /// Set to blank to have a range chosen with the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `10.96.0.0/14`) to pick a specific range to use.
    ///
    /// Only applicable if `ip_allocation_policy.use_ip_aliases` is true.
    ///
    /// This field cannot be changed after the node pool has been created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pod_ipv4_cidr_block: std::string::String,

    /// Whether nodes have internal IP addresses only.
    /// If enable_private_nodes is not specified, then the value is derived from
    /// [Cluster.NetworkConfig.default_enable_private_nodes][]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_private_nodes: std::option::Option<bool>,

    /// Network bandwidth tier configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_performance_config:
        std::option::Option<crate::model::node_network_config::NetworkPerformanceConfig>,

    /// [PRIVATE FIELD]
    /// Pod CIDR size overprovisioning config for the nodepool.
    ///
    /// Pod CIDR size per node depends on max_pods_per_node. By default, the value
    /// of max_pods_per_node is rounded off to next power of 2 and we then double
    /// that to get the size of pod CIDR block per node.
    /// Example: max_pods_per_node of 30 would result in 64 IPs (/26).
    ///
    /// This config can disable the doubling of IPs (we still round off to next
    /// power of 2)
    /// Example: max_pods_per_node of 30 will result in 32 IPs (/27) when
    /// overprovisioning is disabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pod_cidr_overprovision_config:
        std::option::Option<crate::model::PodCIDROverprovisionConfig>,

    /// We specify the additional node networks for this node pool using this list.
    /// Each node network corresponds to an additional interface
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub additional_node_network_configs: std::vec::Vec<crate::model::AdditionalNodeNetworkConfig>,

    /// We specify the additional pod networks for this node pool using this list.
    /// Each pod network corresponds to an additional alias IP range for the node
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub additional_pod_network_configs: std::vec::Vec<crate::model::AdditionalPodNetworkConfig>,

    /// Output only. The utilization of the IPv4 range for the pod.
    /// The ratio is Usage/[Total number of IPs in the secondary range],
    /// Usage=numNodes*numZones*podIPsPerNode.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub pod_ipv4_range_utilization: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeNetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_pod_range][crate::model::NodeNetworkConfig::create_pod_range].
    pub fn set_create_pod_range<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.create_pod_range = v.into();
        self
    }

    /// Sets the value of [pod_range][crate::model::NodeNetworkConfig::pod_range].
    pub fn set_pod_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod_range = v.into();
        self
    }

    /// Sets the value of [pod_ipv4_cidr_block][crate::model::NodeNetworkConfig::pod_ipv4_cidr_block].
    pub fn set_pod_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.pod_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [enable_private_nodes][crate::model::NodeNetworkConfig::enable_private_nodes].
    pub fn set_enable_private_nodes<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_private_nodes = v.into();
        self
    }

    /// Sets the value of [network_performance_config][crate::model::NodeNetworkConfig::network_performance_config].
    pub fn set_network_performance_config<
        T: std::convert::Into<
                std::option::Option<crate::model::node_network_config::NetworkPerformanceConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_performance_config = v.into();
        self
    }

    /// Sets the value of [pod_cidr_overprovision_config][crate::model::NodeNetworkConfig::pod_cidr_overprovision_config].
    pub fn set_pod_cidr_overprovision_config<
        T: std::convert::Into<std::option::Option<crate::model::PodCIDROverprovisionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pod_cidr_overprovision_config = v.into();
        self
    }

    /// Sets the value of [additional_node_network_configs][crate::model::NodeNetworkConfig::additional_node_network_configs].
    pub fn set_additional_node_network_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdditionalNodeNetworkConfig>,
    {
        use std::iter::Iterator;
        self.additional_node_network_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [additional_pod_network_configs][crate::model::NodeNetworkConfig::additional_pod_network_configs].
    pub fn set_additional_pod_network_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdditionalPodNetworkConfig>,
    {
        use std::iter::Iterator;
        self.additional_pod_network_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pod_ipv4_range_utilization][crate::model::NodeNetworkConfig::pod_ipv4_range_utilization].
    pub fn set_pod_ipv4_range_utilization<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.pod_ipv4_range_utilization = v.into();
        self
    }
}

impl wkt::message::Message for NodeNetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeNetworkConfig"
    }
}

/// Defines additional types related to [NodeNetworkConfig].
pub mod node_network_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of all network bandwidth tiers
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NetworkPerformanceConfig {
        /// Specifies the total network bandwidth tier for the NodePool.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub total_egress_bandwidth_tier: std::option::Option<
            crate::model::node_network_config::network_performance_config::Tier,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NetworkPerformanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [total_egress_bandwidth_tier][crate::model::node_network_config::NetworkPerformanceConfig::total_egress_bandwidth_tier].
        pub fn set_total_egress_bandwidth_tier<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::node_network_config::network_performance_config::Tier,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.total_egress_bandwidth_tier = v.into();
            self
        }
    }

    impl wkt::message::Message for NetworkPerformanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NodeNetworkConfig.NetworkPerformanceConfig"
        }
    }

    /// Defines additional types related to [NetworkPerformanceConfig].
    pub mod network_performance_config {
        #[allow(unused_imports)]
        use super::*;

        /// Node network tier
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Tier {
            /// Default value
            Unspecified,
            /// Higher bandwidth, actual values based on VM size.
            _1,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Tier::value] or
            /// [Tier::name].
            UnknownValue(tier::UnknownValue),
        }

        #[doc(hidden)]
        pub mod tier {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Tier {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::_1 => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TIER_UNSPECIFIED"),
                    Self::_1 => std::option::Option::Some("TIER_1"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Tier {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Tier {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Tier {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::_1,
                    _ => Self::UnknownValue(tier::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Tier {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TIER_UNSPECIFIED" => Self::Unspecified,
                    "TIER_1" => Self::_1,
                    _ => Self::UnknownValue(tier::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Tier {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::_1 => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Tier {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Tier>::new(
                    ".google.container.v1.NodeNetworkConfig.NetworkPerformanceConfig.Tier",
                ))
            }
        }
    }
}

/// AdditionalNodeNetworkConfig is the configuration for additional node networks
/// within the NodeNetworkConfig message
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdditionalNodeNetworkConfig {
    /// Name of the VPC where the additional interface belongs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Name of the subnetwork where the additional interface belongs
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnetwork: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdditionalNodeNetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::AdditionalNodeNetworkConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::AdditionalNodeNetworkConfig::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }
}

impl wkt::message::Message for AdditionalNodeNetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AdditionalNodeNetworkConfig"
    }
}

/// AdditionalPodNetworkConfig is the configuration for additional pod networks
/// within the NodeNetworkConfig message
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdditionalPodNetworkConfig {
    /// Name of the subnetwork where the additional pod network belongs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnetwork: std::string::String,

    /// The name of the secondary range on the subnet which provides IP address for
    /// this pod range.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secondary_pod_range: std::string::String,

    /// The maximum number of pods per node which use this pod network.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_pods_per_node: std::option::Option<crate::model::MaxPodsConstraint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdditionalPodNetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subnetwork][crate::model::AdditionalPodNetworkConfig::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [secondary_pod_range][crate::model::AdditionalPodNetworkConfig::secondary_pod_range].
    pub fn set_secondary_pod_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_pod_range = v.into();
        self
    }

    /// Sets the value of [max_pods_per_node][crate::model::AdditionalPodNetworkConfig::max_pods_per_node].
    pub fn set_max_pods_per_node<
        T: std::convert::Into<std::option::Option<crate::model::MaxPodsConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.max_pods_per_node = v.into();
        self
    }
}

impl wkt::message::Message for AdditionalPodNetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AdditionalPodNetworkConfig"
    }
}

/// A set of Shielded Instance options.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ShieldedInstanceConfig {
    /// Defines whether the instance has Secure Boot enabled.
    ///
    /// Secure Boot helps ensure that the system only runs authentic software by
    /// verifying the digital signature of all boot components, and halting the
    /// boot process if signature verification fails.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_secure_boot: bool,

    /// Defines whether the instance has integrity monitoring enabled.
    ///
    /// Enables monitoring and attestation of the boot integrity of the instance.
    /// The attestation is performed against the integrity policy baseline. This
    /// baseline is initially derived from the implicitly trusted boot image when
    /// the instance is created.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_integrity_monitoring: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShieldedInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_secure_boot][crate::model::ShieldedInstanceConfig::enable_secure_boot].
    pub fn set_enable_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_secure_boot = v.into();
        self
    }

    /// Sets the value of [enable_integrity_monitoring][crate::model::ShieldedInstanceConfig::enable_integrity_monitoring].
    pub fn set_enable_integrity_monitoring<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_integrity_monitoring = v.into();
        self
    }
}

impl wkt::message::Message for ShieldedInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ShieldedInstanceConfig"
    }
}

/// SandboxConfig contains configurations of the sandbox to use for the node.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SandboxConfig {
    /// Type of the sandbox to use for the node.
    #[serde(rename = "type")]
    pub r#type: crate::model::sandbox_config::Type,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SandboxConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::SandboxConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::sandbox_config::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for SandboxConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SandboxConfig"
    }
}

/// Defines additional types related to [SandboxConfig].
pub mod sandbox_config {
    #[allow(unused_imports)]
    use super::*;

    /// Possible types of sandboxes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default value. This should not be used.
        Unspecified,
        /// Run sandbox using gvisor.
        Gvisor,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Gvisor => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Gvisor => std::option::Option::Some("GVISOR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Gvisor,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "GVISOR" => Self::Gvisor,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Gvisor => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.container.v1.SandboxConfig.Type",
            ))
        }
    }
}

/// GcfsConfig contains configurations of Google Container File System
/// (image streaming).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcfsConfig {
    /// Whether to use GCFS.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcfsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::GcfsConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for GcfsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GcfsConfig"
    }
}

/// [ReservationAffinity](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources)
/// is the configuration of desired reservation which instances could take
/// capacity from.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReservationAffinity {
    /// Corresponds to the type of reservation consumption.
    pub consume_reservation_type: crate::model::reservation_affinity::Type,

    /// Corresponds to the label key of a reservation resource. To target a
    /// SPECIFIC_RESERVATION by name, specify
    /// "compute.googleapis.com/reservation-name" as the key and specify the name
    /// of your reservation as its value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    /// Corresponds to the label value(s) of reservation resource(s).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReservationAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consume_reservation_type][crate::model::ReservationAffinity::consume_reservation_type].
    pub fn set_consume_reservation_type<
        T: std::convert::Into<crate::model::reservation_affinity::Type>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.consume_reservation_type = v.into();
        self
    }

    /// Sets the value of [key][crate::model::ReservationAffinity::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [values][crate::model::ReservationAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReservationAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ReservationAffinity"
    }
}

/// Defines additional types related to [ReservationAffinity].
pub mod reservation_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates whether to consume capacity from a reservation or not.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default value. This should not be used.
        Unspecified,
        /// Do not consume from any reserved capacity.
        NoReservation,
        /// Consume any reservation available.
        AnyReservation,
        /// Must consume from a specific reservation. Must specify key value fields
        /// for specifying the reservations.
        SpecificReservation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoReservation => std::option::Option::Some(1),
                Self::AnyReservation => std::option::Option::Some(2),
                Self::SpecificReservation => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::NoReservation => std::option::Option::Some("NO_RESERVATION"),
                Self::AnyReservation => std::option::Option::Some("ANY_RESERVATION"),
                Self::SpecificReservation => std::option::Option::Some("SPECIFIC_RESERVATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoReservation,
                2 => Self::AnyReservation,
                3 => Self::SpecificReservation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "NO_RESERVATION" => Self::NoReservation,
                "ANY_RESERVATION" => Self::AnyReservation,
                "SPECIFIC_RESERVATION" => Self::SpecificReservation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoReservation => serializer.serialize_i32(1),
                Self::AnyReservation => serializer.serialize_i32(2),
                Self::SpecificReservation => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.container.v1.ReservationAffinity.Type",
            ))
        }
    }
}

/// SoleTenantConfig contains the NodeAffinities to specify what shared sole
/// tenant node groups should back the node pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SoleTenantConfig {
    /// NodeAffinities used to match to a shared sole tenant node group.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub node_affinities: std::vec::Vec<crate::model::sole_tenant_config::NodeAffinity>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SoleTenantConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_affinities][crate::model::SoleTenantConfig::node_affinities].
    pub fn set_node_affinities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::sole_tenant_config::NodeAffinity>,
    {
        use std::iter::Iterator;
        self.node_affinities = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SoleTenantConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SoleTenantConfig"
    }
}

/// Defines additional types related to [SoleTenantConfig].
pub mod sole_tenant_config {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the NodeAffinity key, values, and affinity operator according to
    /// [shared sole tenant node group
    /// affinities](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes#node_affinity_and_anti-affinity).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NodeAffinity {
        /// Key for NodeAffinity.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub key: std::string::String,

        /// Operator for NodeAffinity.
        pub operator: crate::model::sole_tenant_config::node_affinity::Operator,

        /// Values for NodeAffinity.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub values: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NodeAffinity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::sole_tenant_config::NodeAffinity::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [operator][crate::model::sole_tenant_config::NodeAffinity::operator].
        pub fn set_operator<
            T: std::convert::Into<crate::model::sole_tenant_config::node_affinity::Operator>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.operator = v.into();
            self
        }

        /// Sets the value of [values][crate::model::sole_tenant_config::NodeAffinity::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for NodeAffinity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.SoleTenantConfig.NodeAffinity"
        }
    }

    /// Defines additional types related to [NodeAffinity].
    pub mod node_affinity {
        #[allow(unused_imports)]
        use super::*;

        /// Operator allows user to specify affinity or anti-affinity for the
        /// given key values.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Operator {
            /// Invalid or unspecified affinity operator.
            Unspecified,
            /// Affinity operator.
            In,
            /// Anti-affinity operator.
            NotIn,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Operator::value] or
            /// [Operator::name].
            UnknownValue(operator::UnknownValue),
        }

        #[doc(hidden)]
        pub mod operator {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Operator {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::In => std::option::Option::Some(1),
                    Self::NotIn => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("OPERATOR_UNSPECIFIED"),
                    Self::In => std::option::Option::Some("IN"),
                    Self::NotIn => std::option::Option::Some("NOT_IN"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Operator {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Operator {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Operator {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::In,
                    2 => Self::NotIn,
                    _ => Self::UnknownValue(operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Operator {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "OPERATOR_UNSPECIFIED" => Self::Unspecified,
                    "IN" => Self::In,
                    "NOT_IN" => Self::NotIn,
                    _ => Self::UnknownValue(operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Operator {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::In => serializer.serialize_i32(1),
                    Self::NotIn => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Operator {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Operator>::new(
                    ".google.container.v1.SoleTenantConfig.NodeAffinity.Operator",
                ))
            }
        }
    }
}

/// ContainerdConfig contains configuration to customize containerd.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContainerdConfig {
    /// PrivateRegistryAccessConfig is used to configure access configuration
    /// for private container registries.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_registry_access_config:
        std::option::Option<crate::model::containerd_config::PrivateRegistryAccessConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContainerdConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_registry_access_config][crate::model::ContainerdConfig::private_registry_access_config].
    pub fn set_private_registry_access_config<
        T: std::convert::Into<
                std::option::Option<crate::model::containerd_config::PrivateRegistryAccessConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_registry_access_config = v.into();
        self
    }
}

impl wkt::message::Message for ContainerdConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ContainerdConfig"
    }
}

/// Defines additional types related to [ContainerdConfig].
pub mod containerd_config {
    #[allow(unused_imports)]
    use super::*;

    /// PrivateRegistryAccessConfig contains access configuration for
    /// private container registries.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PrivateRegistryAccessConfig {

        /// Private registry access is enabled.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enabled: bool,

        /// Private registry access configuration.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub certificate_authority_domain_config: std::vec::Vec<crate::model::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PrivateRegistryAccessConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::containerd_config::PrivateRegistryAccessConfig::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [certificate_authority_domain_config][crate::model::containerd_config::PrivateRegistryAccessConfig::certificate_authority_domain_config].
        pub fn set_certificate_authority_domain_config<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig>
        {
            use std::iter::Iterator;
            self.certificate_authority_domain_config = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PrivateRegistryAccessConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.ContainerdConfig.PrivateRegistryAccessConfig"
        }
    }

    /// Defines additional types related to [PrivateRegistryAccessConfig].
    pub mod private_registry_access_config {
        #[allow(unused_imports)]
        use super::*;

        /// CertificateAuthorityDomainConfig configures one or more fully qualified
        /// domain names (FQDN) to a specific certificate.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CertificateAuthorityDomainConfig {

            /// List of fully qualified domain names (FQDN).
            /// Specifying port is supported.
            /// Wilcards are NOT supported.
            /// Examples:
            ///
            /// - my.customdomain.com
            /// - 10.0.1.2:5000
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub fqdns: std::vec::Vec<std::string::String>,

            /// Certificate access config. The following are supported:
            ///
            /// - GCPSecretManagerCertificateConfig
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub certificate_config: std::option::Option<crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::CertificateConfig>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CertificateAuthorityDomainConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [fqdns][crate::model::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig::fqdns].
            pub fn set_fqdns<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.fqdns = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [certificate_config][crate::model::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig::certificate_config].
            ///
            /// Note that all the setters affecting `certificate_config` are mutually
            /// exclusive.
            pub fn set_certificate_config<T: std::convert::Into<std::option::Option<crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::CertificateConfig>>>(mut self, v: T) -> Self
            {
                self.certificate_config = v.into();
                self
            }

            /// The value of [certificate_config][crate::model::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig::certificate_config]
            /// if it holds a `GcpSecretManagerCertificateConfig`, `None` if the field is not set or
            /// holds a different branch.
            pub fn gcp_secret_manager_certificate_config(&self) -> std::option::Option<&std::boxed::Box<crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::GCPSecretManagerCertificateConfig>>{
                #[allow(unreachable_patterns)]
                self.certificate_config.as_ref().and_then(|v| match v {
                    crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::CertificateConfig::GcpSecretManagerCertificateConfig(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [certificate_config][crate::model::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig::certificate_config]
            /// to hold a `GcpSecretManagerCertificateConfig`.
            ///
            /// Note that all the setters affecting `certificate_config` are
            /// mutually exclusive.
            pub fn set_gcp_secret_manager_certificate_config<T: std::convert::Into<std::boxed::Box<crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::GCPSecretManagerCertificateConfig>>>(mut self, v: T) -> Self{
                self.certificate_config = std::option::Option::Some(
                    crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::CertificateConfig::GcpSecretManagerCertificateConfig(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for CertificateAuthorityDomainConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.container.v1.ContainerdConfig.PrivateRegistryAccessConfig.CertificateAuthorityDomainConfig"
            }
        }

        /// Defines additional types related to [CertificateAuthorityDomainConfig].
        pub mod certificate_authority_domain_config {
            #[allow(unused_imports)]
            use super::*;

            /// GCPSecretManagerCertificateConfig configures a secret from
            /// [Google Secret Manager](https://cloud.google.com/secret-manager).
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct GCPSecretManagerCertificateConfig {
                /// Secret URI, in the form
                /// "projects/$PROJECT_ID/secrets/$SECRET_NAME/versions/$VERSION".
                /// Version can be fixed (e.g. "2") or "latest"
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub secret_uri: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl GCPSecretManagerCertificateConfig {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [secret_uri][crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::GCPSecretManagerCertificateConfig::secret_uri].
                pub fn set_secret_uri<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.secret_uri = v.into();
                    self
                }
            }

            impl wkt::message::Message for GCPSecretManagerCertificateConfig {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.container.v1.ContainerdConfig.PrivateRegistryAccessConfig.CertificateAuthorityDomainConfig.GCPSecretManagerCertificateConfig"
                }
            }

            /// Certificate access config. The following are supported:
            ///
            /// - GCPSecretManagerCertificateConfig
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum CertificateConfig {
                /// Google Secret Manager (GCP) certificate configuration.
                GcpSecretManagerCertificateConfig(std::boxed::Box<crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::GCPSecretManagerCertificateConfig>),
            }
        }
    }
}

/// Kubernetes taint is composed of three fields: key, value, and effect. Effect
/// can only be one of three types:  NoSchedule, PreferNoSchedule or NoExecute.
///
/// See
/// [here](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration)
/// for more information, including usage and the valid values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeTaint {
    /// Key for taint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    /// Value for taint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    /// Effect for taint.
    pub effect: crate::model::node_taint::Effect,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeTaint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::NodeTaint::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [value][crate::model::NodeTaint::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [effect][crate::model::NodeTaint::effect].
    pub fn set_effect<T: std::convert::Into<crate::model::node_taint::Effect>>(
        mut self,
        v: T,
    ) -> Self {
        self.effect = v.into();
        self
    }
}

impl wkt::message::Message for NodeTaint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeTaint"
    }
}

/// Defines additional types related to [NodeTaint].
pub mod node_taint {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values for Effect in taint.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Effect {
        /// Not set
        Unspecified,
        /// NoSchedule
        NoSchedule,
        /// PreferNoSchedule
        PreferNoSchedule,
        /// NoExecute
        NoExecute,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Effect::value] or
        /// [Effect::name].
        UnknownValue(effect::UnknownValue),
    }

    #[doc(hidden)]
    pub mod effect {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Effect {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoSchedule => std::option::Option::Some(1),
                Self::PreferNoSchedule => std::option::Option::Some(2),
                Self::NoExecute => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EFFECT_UNSPECIFIED"),
                Self::NoSchedule => std::option::Option::Some("NO_SCHEDULE"),
                Self::PreferNoSchedule => std::option::Option::Some("PREFER_NO_SCHEDULE"),
                Self::NoExecute => std::option::Option::Some("NO_EXECUTE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Effect {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Effect {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Effect {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoSchedule,
                2 => Self::PreferNoSchedule,
                3 => Self::NoExecute,
                _ => Self::UnknownValue(effect::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Effect {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EFFECT_UNSPECIFIED" => Self::Unspecified,
                "NO_SCHEDULE" => Self::NoSchedule,
                "PREFER_NO_SCHEDULE" => Self::PreferNoSchedule,
                "NO_EXECUTE" => Self::NoExecute,
                _ => Self::UnknownValue(effect::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Effect {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoSchedule => serializer.serialize_i32(1),
                Self::PreferNoSchedule => serializer.serialize_i32(2),
                Self::NoExecute => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Effect {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Effect>::new(
                ".google.container.v1.NodeTaint.Effect",
            ))
        }
    }
}

/// Collection of Kubernetes [node
/// taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeTaints {
    /// List of node taints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub taints: std::vec::Vec<crate::model::NodeTaint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeTaints {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taints][crate::model::NodeTaints::taints].
    pub fn set_taints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodeTaint>,
    {
        use std::iter::Iterator;
        self.taints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NodeTaints {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeTaints"
    }
}

/// Collection of node-level [Kubernetes
/// labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeLabels {
    /// Map of node label keys and node label values.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeLabels {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [labels][crate::model::NodeLabels::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for NodeLabels {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeLabels"
    }
}

/// Collection of [GCP
/// labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceLabels {
    /// Map of node label keys and node label values.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceLabels {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [labels][crate::model::ResourceLabels::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ResourceLabels {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ResourceLabels"
    }
}

/// Collection of Compute Engine network tags that can be applied to a node's
/// underlying VM instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkTags {
    /// List of network tags.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkTags {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tags][crate::model::NetworkTags::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkTags {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NetworkTags"
    }
}

/// The authentication information for accessing the master endpoint.
/// Authentication can be done using HTTP basic auth or using client
/// certificates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MasterAuth {
    /// The username to use for HTTP basic authentication to the master endpoint.
    /// For clusters v1.6.0 and later, basic authentication can be disabled by
    /// leaving username unspecified (or setting it to the empty string).
    ///
    /// Warning: basic authentication is deprecated, and will be removed in GKE
    /// control plane versions 1.19 and newer. For a list of recommended
    /// authentication methods, see:
    /// <https://cloud.google.com/kubernetes-engine/docs/how-to/api-server-authentication>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub username: std::string::String,

    /// The password to use for HTTP basic authentication to the master endpoint.
    /// Because the master endpoint is open to the Internet, you should create a
    /// strong password.  If a password is provided for cluster creation, username
    /// must be non-empty.
    ///
    /// Warning: basic authentication is deprecated, and will be removed in GKE
    /// control plane versions 1.19 and newer. For a list of recommended
    /// authentication methods, see:
    /// <https://cloud.google.com/kubernetes-engine/docs/how-to/api-server-authentication>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub password: std::string::String,

    /// Configuration for client certificate authentication on the cluster. For
    /// clusters before v1.12, if no configuration is specified, a client
    /// certificate is issued.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub client_certificate_config: std::option::Option<crate::model::ClientCertificateConfig>,

    /// Output only. Base64-encoded public certificate that is the root of
    /// trust for the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_ca_certificate: std::string::String,

    /// Output only. Base64-encoded public certificate used by clients to
    /// authenticate to the cluster endpoint. Issued only if
    /// client_certificate_config is set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_certificate: std::string::String,

    /// Output only. Base64-encoded private key used by clients to authenticate
    /// to the cluster endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MasterAuth {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::MasterAuth::username].
    #[deprecated]
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::MasterAuth::password].
    #[deprecated]
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [client_certificate_config][crate::model::MasterAuth::client_certificate_config].
    pub fn set_client_certificate_config<
        T: std::convert::Into<std::option::Option<crate::model::ClientCertificateConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.client_certificate_config = v.into();
        self
    }

    /// Sets the value of [cluster_ca_certificate][crate::model::MasterAuth::cluster_ca_certificate].
    pub fn set_cluster_ca_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ca_certificate = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::MasterAuth::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::MasterAuth::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }
}

impl wkt::message::Message for MasterAuth {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MasterAuth"
    }
}

/// Configuration for client certificates on the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClientCertificateConfig {
    /// Issue a client certificate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub issue_client_certificate: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClientCertificateConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue_client_certificate][crate::model::ClientCertificateConfig::issue_client_certificate].
    pub fn set_issue_client_certificate<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.issue_client_certificate = v.into();
        self
    }
}

impl wkt::message::Message for ClientCertificateConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ClientCertificateConfig"
    }
}

/// Configuration for the addons that can be automatically spun up in the
/// cluster, enabling additional functionality.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddonsConfig {
    /// Configuration for the HTTP (L7) load balancing controller addon, which
    /// makes it easy to set up HTTP load balancers for services in a cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub http_load_balancing: std::option::Option<crate::model::HttpLoadBalancing>,

    /// Configuration for the horizontal pod autoscaling feature, which
    /// increases or decreases the number of replica pods a replication controller
    /// has based on the resource usage of the existing pods.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub horizontal_pod_autoscaling: std::option::Option<crate::model::HorizontalPodAutoscaling>,

    /// Configuration for the Kubernetes Dashboard.
    /// This addon is deprecated, and will be disabled in 1.15. It is recommended
    /// to use the Cloud Console to manage and monitor your Kubernetes clusters,
    /// workloads and applications. For more information, see:
    /// <https://cloud.google.com/kubernetes-engine/docs/concepts/dashboards>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub kubernetes_dashboard: std::option::Option<crate::model::KubernetesDashboard>,

    /// Configuration for NetworkPolicy. This only tracks whether the addon
    /// is enabled or not on the Master, it does not track whether network policy
    /// is enabled for the nodes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_policy_config: std::option::Option<crate::model::NetworkPolicyConfig>,

    /// Configuration for the Cloud Run addon, which allows the user to use a
    /// managed Knative service.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_run_config: std::option::Option<crate::model::CloudRunConfig>,

    /// Configuration for NodeLocalDNS, a dns cache running on cluster nodes
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dns_cache_config: std::option::Option<crate::model::DnsCacheConfig>,

    /// Configuration for the ConfigConnector add-on, a Kubernetes
    /// extension to manage hosted GCP services through the Kubernetes API
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_connector_config: std::option::Option<crate::model::ConfigConnectorConfig>,

    /// Configuration for the Compute Engine Persistent Disk CSI driver.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gce_persistent_disk_csi_driver_config:
        std::option::Option<crate::model::GcePersistentDiskCsiDriverConfig>,

    /// Configuration for the GCP Filestore CSI driver.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcp_filestore_csi_driver_config:
        std::option::Option<crate::model::GcpFilestoreCsiDriverConfig>,

    /// Configuration for the Backup for GKE agent addon.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gke_backup_agent_config: std::option::Option<crate::model::GkeBackupAgentConfig>,

    /// Configuration for the Cloud Storage Fuse CSI driver.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcs_fuse_csi_driver_config: std::option::Option<crate::model::GcsFuseCsiDriverConfig>,

    /// Optional. Configuration for the StatefulHA add-on.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stateful_ha_config: std::option::Option<crate::model::StatefulHAConfig>,

    /// Configuration for the Cloud Storage Parallelstore CSI driver.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub parallelstore_csi_driver_config:
        std::option::Option<crate::model::ParallelstoreCsiDriverConfig>,

    /// Optional. Configuration for Ray Operator addon.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ray_operator_config: std::option::Option<crate::model::RayOperatorConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddonsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [http_load_balancing][crate::model::AddonsConfig::http_load_balancing].
    pub fn set_http_load_balancing<
        T: std::convert::Into<std::option::Option<crate::model::HttpLoadBalancing>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.http_load_balancing = v.into();
        self
    }

    /// Sets the value of [horizontal_pod_autoscaling][crate::model::AddonsConfig::horizontal_pod_autoscaling].
    pub fn set_horizontal_pod_autoscaling<
        T: std::convert::Into<std::option::Option<crate::model::HorizontalPodAutoscaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.horizontal_pod_autoscaling = v.into();
        self
    }

    /// Sets the value of [kubernetes_dashboard][crate::model::AddonsConfig::kubernetes_dashboard].
    #[deprecated]
    pub fn set_kubernetes_dashboard<
        T: std::convert::Into<std::option::Option<crate::model::KubernetesDashboard>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kubernetes_dashboard = v.into();
        self
    }

    /// Sets the value of [network_policy_config][crate::model::AddonsConfig::network_policy_config].
    pub fn set_network_policy_config<
        T: std::convert::Into<std::option::Option<crate::model::NetworkPolicyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_policy_config = v.into();
        self
    }

    /// Sets the value of [cloud_run_config][crate::model::AddonsConfig::cloud_run_config].
    pub fn set_cloud_run_config<
        T: std::convert::Into<std::option::Option<crate::model::CloudRunConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_run_config = v.into();
        self
    }

    /// Sets the value of [dns_cache_config][crate::model::AddonsConfig::dns_cache_config].
    pub fn set_dns_cache_config<
        T: std::convert::Into<std::option::Option<crate::model::DnsCacheConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dns_cache_config = v.into();
        self
    }

    /// Sets the value of [config_connector_config][crate::model::AddonsConfig::config_connector_config].
    pub fn set_config_connector_config<
        T: std::convert::Into<std::option::Option<crate::model::ConfigConnectorConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config_connector_config = v.into();
        self
    }

    /// Sets the value of [gce_persistent_disk_csi_driver_config][crate::model::AddonsConfig::gce_persistent_disk_csi_driver_config].
    pub fn set_gce_persistent_disk_csi_driver_config<
        T: std::convert::Into<std::option::Option<crate::model::GcePersistentDiskCsiDriverConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gce_persistent_disk_csi_driver_config = v.into();
        self
    }

    /// Sets the value of [gcp_filestore_csi_driver_config][crate::model::AddonsConfig::gcp_filestore_csi_driver_config].
    pub fn set_gcp_filestore_csi_driver_config<
        T: std::convert::Into<std::option::Option<crate::model::GcpFilestoreCsiDriverConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gcp_filestore_csi_driver_config = v.into();
        self
    }

    /// Sets the value of [gke_backup_agent_config][crate::model::AddonsConfig::gke_backup_agent_config].
    pub fn set_gke_backup_agent_config<
        T: std::convert::Into<std::option::Option<crate::model::GkeBackupAgentConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gke_backup_agent_config = v.into();
        self
    }

    /// Sets the value of [gcs_fuse_csi_driver_config][crate::model::AddonsConfig::gcs_fuse_csi_driver_config].
    pub fn set_gcs_fuse_csi_driver_config<
        T: std::convert::Into<std::option::Option<crate::model::GcsFuseCsiDriverConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_fuse_csi_driver_config = v.into();
        self
    }

    /// Sets the value of [stateful_ha_config][crate::model::AddonsConfig::stateful_ha_config].
    pub fn set_stateful_ha_config<
        T: std::convert::Into<std::option::Option<crate::model::StatefulHAConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.stateful_ha_config = v.into();
        self
    }

    /// Sets the value of [parallelstore_csi_driver_config][crate::model::AddonsConfig::parallelstore_csi_driver_config].
    pub fn set_parallelstore_csi_driver_config<
        T: std::convert::Into<std::option::Option<crate::model::ParallelstoreCsiDriverConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parallelstore_csi_driver_config = v.into();
        self
    }

    /// Sets the value of [ray_operator_config][crate::model::AddonsConfig::ray_operator_config].
    pub fn set_ray_operator_config<
        T: std::convert::Into<std::option::Option<crate::model::RayOperatorConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ray_operator_config = v.into();
        self
    }
}

impl wkt::message::Message for AddonsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AddonsConfig"
    }
}

/// Configuration options for the HTTP (L7) load balancing controller addon,
/// which makes it easy to set up HTTP load balancers for services in a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HttpLoadBalancing {
    /// Whether the HTTP Load Balancing controller is enabled in the cluster.
    /// When enabled, it runs a small pod in the cluster that manages the load
    /// balancers.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpLoadBalancing {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::HttpLoadBalancing::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

impl wkt::message::Message for HttpLoadBalancing {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.HttpLoadBalancing"
    }
}

/// Configuration options for the horizontal pod autoscaling feature, which
/// increases or decreases the number of replica pods a replication controller
/// has based on the resource usage of the existing pods.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HorizontalPodAutoscaling {
    /// Whether the Horizontal Pod Autoscaling feature is enabled in the cluster.
    /// When enabled, it ensures that metrics are collected into Stackdriver
    /// Monitoring.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HorizontalPodAutoscaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::HorizontalPodAutoscaling::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

impl wkt::message::Message for HorizontalPodAutoscaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.HorizontalPodAutoscaling"
    }
}

/// Configuration for the Kubernetes Dashboard.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KubernetesDashboard {
    /// Whether the Kubernetes Dashboard is enabled for this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KubernetesDashboard {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::KubernetesDashboard::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

impl wkt::message::Message for KubernetesDashboard {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.KubernetesDashboard"
    }
}

/// Configuration for NetworkPolicy. This only tracks whether the addon
/// is enabled or not on the Master, it does not track whether network policy
/// is enabled for the nodes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkPolicyConfig {
    /// Whether NetworkPolicy is enabled for this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkPolicyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::NetworkPolicyConfig::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

impl wkt::message::Message for NetworkPolicyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NetworkPolicyConfig"
    }
}

/// Configuration for NodeLocal DNSCache
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DnsCacheConfig {
    /// Whether NodeLocal DNSCache is enabled for this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DnsCacheConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::DnsCacheConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for DnsCacheConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DnsCacheConfig"
    }
}

/// Configuration for controlling master global access settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateClusterMasterGlobalAccessConfig {
    /// Whenever master is accessible globally or not.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateClusterMasterGlobalAccessConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::PrivateClusterMasterGlobalAccessConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for PrivateClusterMasterGlobalAccessConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.PrivateClusterMasterGlobalAccessConfig"
    }
}

/// Configuration options for private clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateClusterConfig {
    /// Whether nodes have internal IP addresses only. If enabled, all nodes are
    /// given only RFC 1918 private addresses and communicate with the master via
    /// private networking.
    ///
    /// Deprecated: Use
    /// [NetworkConfig.default_enable_private_nodes][google.container.v1.NetworkConfig.default_enable_private_nodes]
    /// instead.
    ///
    /// [google.container.v1.NetworkConfig.default_enable_private_nodes]: crate::model::NetworkConfig::default_enable_private_nodes
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub enable_private_nodes: bool,

    /// Whether the master's internal IP address is used as the cluster endpoint.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.enable_public_endpoint][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.enable_public_endpoint]
    /// instead. Note that the value of enable_public_endpoint is reversed: if
    /// enable_private_endpoint is false, then enable_public_endpoint will be true.
    ///
    /// [google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.enable_public_endpoint]: crate::model::control_plane_endpoints_config::IPEndpointsConfig::enable_public_endpoint
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub enable_private_endpoint: bool,

    /// The IP range in CIDR notation to use for the hosted master network. This
    /// range will be used for assigning internal IP addresses to the master or
    /// set of masters, as well as the ILB VIP. This range must not overlap with
    /// any other ranges in use within the cluster's network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub master_ipv4_cidr_block: std::string::String,

    /// Output only. The internal IP address of this cluster's master endpoint.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint]
    /// instead.
    ///
    /// [google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint]: crate::model::control_plane_endpoints_config::IPEndpointsConfig::private_endpoint
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub private_endpoint: std::string::String,

    /// Output only. The external IP address of this cluster's master endpoint.
    ///
    /// Deprecated:Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.public_endpoint][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.public_endpoint]
    /// instead.
    ///
    /// [google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.public_endpoint]: crate::model::control_plane_endpoints_config::IPEndpointsConfig::public_endpoint
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub public_endpoint: std::string::String,

    /// Output only. The peering name in the customer VPC used by this cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub peering_name: std::string::String,

    /// Controls master global access settings.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.enable_global_access][]
    /// instead.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub master_global_access_config:
        std::option::Option<crate::model::PrivateClusterMasterGlobalAccessConfig>,

    /// Subnet to provision the master's private endpoint during cluster creation.
    /// Specified in projects/*/regions/*/subnetworks/* format.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint_subnetwork][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint_subnetwork]
    /// instead.
    ///
    /// [google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint_subnetwork]: crate::model::control_plane_endpoints_config::IPEndpointsConfig::private_endpoint_subnetwork
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub private_endpoint_subnetwork: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_private_nodes][crate::model::PrivateClusterConfig::enable_private_nodes].
    #[deprecated]
    pub fn set_enable_private_nodes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_nodes = v.into();
        self
    }

    /// Sets the value of [enable_private_endpoint][crate::model::PrivateClusterConfig::enable_private_endpoint].
    #[deprecated]
    pub fn set_enable_private_endpoint<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_endpoint = v.into();
        self
    }

    /// Sets the value of [master_ipv4_cidr_block][crate::model::PrivateClusterConfig::master_ipv4_cidr_block].
    pub fn set_master_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.master_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [private_endpoint][crate::model::PrivateClusterConfig::private_endpoint].
    #[deprecated]
    pub fn set_private_endpoint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint = v.into();
        self
    }

    /// Sets the value of [public_endpoint][crate::model::PrivateClusterConfig::public_endpoint].
    #[deprecated]
    pub fn set_public_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_endpoint = v.into();
        self
    }

    /// Sets the value of [peering_name][crate::model::PrivateClusterConfig::peering_name].
    pub fn set_peering_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peering_name = v.into();
        self
    }

    /// Sets the value of [master_global_access_config][crate::model::PrivateClusterConfig::master_global_access_config].
    #[deprecated]
    pub fn set_master_global_access_config<
        T: std::convert::Into<
                std::option::Option<crate::model::PrivateClusterMasterGlobalAccessConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.master_global_access_config = v.into();
        self
    }

    /// Sets the value of [private_endpoint_subnetwork][crate::model::PrivateClusterConfig::private_endpoint_subnetwork].
    #[deprecated]
    pub fn set_private_endpoint_subnetwork<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint_subnetwork = v.into();
        self
    }
}

impl wkt::message::Message for PrivateClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.PrivateClusterConfig"
    }
}

/// Configuration for returning group information from authenticators.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuthenticatorGroupsConfig {
    /// Whether this cluster should return group membership lookups
    /// during authentication using a group of security groups.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    /// The name of the security group-of-groups to be used. Only relevant
    /// if enabled = true.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub security_group: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthenticatorGroupsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::AuthenticatorGroupsConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [security_group][crate::model::AuthenticatorGroupsConfig::security_group].
    pub fn set_security_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.security_group = v.into();
        self
    }
}

impl wkt::message::Message for AuthenticatorGroupsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AuthenticatorGroupsConfig"
    }
}

/// Configuration options for the Cloud Run feature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudRunConfig {
    /// Whether Cloud Run addon is enabled for this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disabled: bool,

    /// Which load balancer type is installed for Cloud Run.
    pub load_balancer_type: crate::model::cloud_run_config::LoadBalancerType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRunConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::CloudRunConfig::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [load_balancer_type][crate::model::CloudRunConfig::load_balancer_type].
    pub fn set_load_balancer_type<
        T: std::convert::Into<crate::model::cloud_run_config::LoadBalancerType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.load_balancer_type = v.into();
        self
    }
}

impl wkt::message::Message for CloudRunConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CloudRunConfig"
    }
}

/// Defines additional types related to [CloudRunConfig].
pub mod cloud_run_config {
    #[allow(unused_imports)]
    use super::*;

    /// Load balancer type of ingress service of Cloud Run.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LoadBalancerType {
        /// Load balancer type for Cloud Run is unspecified.
        Unspecified,
        /// Install external load balancer for Cloud Run.
        External,
        /// Install internal load balancer for Cloud Run.
        Internal,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LoadBalancerType::value] or
        /// [LoadBalancerType::name].
        UnknownValue(load_balancer_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod load_balancer_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LoadBalancerType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::External => std::option::Option::Some(1),
                Self::Internal => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOAD_BALANCER_TYPE_UNSPECIFIED"),
                Self::External => std::option::Option::Some("LOAD_BALANCER_TYPE_EXTERNAL"),
                Self::Internal => std::option::Option::Some("LOAD_BALANCER_TYPE_INTERNAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LoadBalancerType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LoadBalancerType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LoadBalancerType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::External,
                2 => Self::Internal,
                _ => Self::UnknownValue(load_balancer_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LoadBalancerType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOAD_BALANCER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "LOAD_BALANCER_TYPE_EXTERNAL" => Self::External,
                "LOAD_BALANCER_TYPE_INTERNAL" => Self::Internal,
                _ => Self::UnknownValue(load_balancer_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LoadBalancerType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::External => serializer.serialize_i32(1),
                Self::Internal => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LoadBalancerType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LoadBalancerType>::new(
                ".google.container.v1.CloudRunConfig.LoadBalancerType",
            ))
        }
    }
}

/// Configuration options for the Config Connector add-on.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfigConnectorConfig {
    /// Whether Cloud Connector is enabled for this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigConnectorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ConfigConnectorConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for ConfigConnectorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ConfigConnectorConfig"
    }
}

/// Configuration for the Compute Engine PD CSI driver.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcePersistentDiskCsiDriverConfig {
    /// Whether the Compute Engine PD CSI driver is enabled for this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcePersistentDiskCsiDriverConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::GcePersistentDiskCsiDriverConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for GcePersistentDiskCsiDriverConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GcePersistentDiskCsiDriverConfig"
    }
}

/// Configuration for the GCP Filestore CSI driver.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcpFilestoreCsiDriverConfig {
    /// Whether the GCP Filestore CSI driver is enabled for this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcpFilestoreCsiDriverConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::GcpFilestoreCsiDriverConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for GcpFilestoreCsiDriverConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GcpFilestoreCsiDriverConfig"
    }
}

/// Configuration for the Cloud Storage Fuse CSI driver.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsFuseCsiDriverConfig {
    /// Whether the Cloud Storage Fuse CSI driver is enabled for this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsFuseCsiDriverConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::GcsFuseCsiDriverConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for GcsFuseCsiDriverConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GcsFuseCsiDriverConfig"
    }
}

/// Configuration for the Cloud Storage Parallelstore CSI driver.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ParallelstoreCsiDriverConfig {
    /// Whether the Cloud Storage Parallelstore CSI driver is enabled for this
    /// cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ParallelstoreCsiDriverConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ParallelstoreCsiDriverConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for ParallelstoreCsiDriverConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ParallelstoreCsiDriverConfig"
    }
}

/// Configuration options for the Ray Operator add-on.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RayOperatorConfig {
    /// Whether the Ray Operator addon is enabled for this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    /// Optional. Logging configuration for Ray clusters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ray_cluster_logging_config: std::option::Option<crate::model::RayClusterLoggingConfig>,

    /// Optional. Monitoring configuration for Ray clusters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ray_cluster_monitoring_config:
        std::option::Option<crate::model::RayClusterMonitoringConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RayOperatorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::RayOperatorConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [ray_cluster_logging_config][crate::model::RayOperatorConfig::ray_cluster_logging_config].
    pub fn set_ray_cluster_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::RayClusterLoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ray_cluster_logging_config = v.into();
        self
    }

    /// Sets the value of [ray_cluster_monitoring_config][crate::model::RayOperatorConfig::ray_cluster_monitoring_config].
    pub fn set_ray_cluster_monitoring_config<
        T: std::convert::Into<std::option::Option<crate::model::RayClusterMonitoringConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ray_cluster_monitoring_config = v.into();
        self
    }
}

impl wkt::message::Message for RayOperatorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.RayOperatorConfig"
    }
}

/// Configuration for the Backup for GKE Agent.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GkeBackupAgentConfig {
    /// Whether the Backup for GKE agent is enabled for this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GkeBackupAgentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::GkeBackupAgentConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for GkeBackupAgentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GkeBackupAgentConfig"
    }
}

/// Configuration for the Stateful HA add-on.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StatefulHAConfig {
    /// Whether the Stateful HA add-on is enabled for this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StatefulHAConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::StatefulHAConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for StatefulHAConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.StatefulHAConfig"
    }
}

/// Configuration options for the master authorized networks feature. Enabled
/// master authorized networks will disallow all external traffic to access
/// Kubernetes master through HTTPS except traffic from the given CIDR blocks,
/// Google Compute Engine Public IPs and Google Prod IPs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MasterAuthorizedNetworksConfig {
    /// Whether or not master authorized networks is enabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    /// cidr_blocks define up to 50 external networks that could access
    /// Kubernetes master through HTTPS.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cidr_blocks: std::vec::Vec<crate::model::master_authorized_networks_config::CidrBlock>,

    /// Whether master is accessbile via Google Compute Engine Public IP addresses.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcp_public_cidrs_access_enabled: std::option::Option<bool>,

    /// Whether master authorized networks is enforced on private endpoint or not.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_endpoint_enforcement_enabled: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MasterAuthorizedNetworksConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::MasterAuthorizedNetworksConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [cidr_blocks][crate::model::MasterAuthorizedNetworksConfig::cidr_blocks].
    pub fn set_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::master_authorized_networks_config::CidrBlock>,
    {
        use std::iter::Iterator;
        self.cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [gcp_public_cidrs_access_enabled][crate::model::MasterAuthorizedNetworksConfig::gcp_public_cidrs_access_enabled].
    pub fn set_gcp_public_cidrs_access_enabled<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcp_public_cidrs_access_enabled = v.into();
        self
    }

    /// Sets the value of [private_endpoint_enforcement_enabled][crate::model::MasterAuthorizedNetworksConfig::private_endpoint_enforcement_enabled].
    pub fn set_private_endpoint_enforcement_enabled<
        T: std::convert::Into<std::option::Option<bool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint_enforcement_enabled = v.into();
        self
    }
}

impl wkt::message::Message for MasterAuthorizedNetworksConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MasterAuthorizedNetworksConfig"
    }
}

/// Defines additional types related to [MasterAuthorizedNetworksConfig].
pub mod master_authorized_networks_config {
    #[allow(unused_imports)]
    use super::*;

    /// CidrBlock contains an optional name and one CIDR block.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CidrBlock {
        /// display_name is an optional field for users to identify CIDR blocks.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub display_name: std::string::String,

        /// cidr_block must be specified in CIDR notation.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cidr_block: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CidrBlock {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::master_authorized_networks_config::CidrBlock::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [cidr_block][crate::model::master_authorized_networks_config::CidrBlock::cidr_block].
        pub fn set_cidr_block<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cidr_block = v.into();
            self
        }
    }

    impl wkt::message::Message for CidrBlock {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.MasterAuthorizedNetworksConfig.CidrBlock"
        }
    }
}

/// Configuration for the legacy Attribute Based Access Control authorization
/// mode.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LegacyAbac {
    /// Whether the ABAC authorizer is enabled for this cluster. When enabled,
    /// identities in the system, including service accounts, nodes, and
    /// controllers, will have statically granted permissions beyond those
    /// provided by the RBAC configuration or IAM.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LegacyAbac {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::LegacyAbac::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for LegacyAbac {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.LegacyAbac"
    }
}

/// Configuration options for the NetworkPolicy feature.
/// <https://kubernetes.io/docs/concepts/services-networking/networkpolicies/>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkPolicy {
    /// The selected network policy provider.
    pub provider: crate::model::network_policy::Provider,

    /// Whether network policy is enabled on the cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provider][crate::model::NetworkPolicy::provider].
    pub fn set_provider<T: std::convert::Into<crate::model::network_policy::Provider>>(
        mut self,
        v: T,
    ) -> Self {
        self.provider = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::NetworkPolicy::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for NetworkPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NetworkPolicy"
    }
}

/// Defines additional types related to [NetworkPolicy].
pub mod network_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Allowed Network Policy providers.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Provider {
        /// Not set
        Unspecified,
        /// Tigera (Calico Felix).
        Calico,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Provider::value] or
        /// [Provider::name].
        UnknownValue(provider::UnknownValue),
    }

    #[doc(hidden)]
    pub mod provider {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Provider {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Calico => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROVIDER_UNSPECIFIED"),
                Self::Calico => std::option::Option::Some("CALICO"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Provider {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Provider {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Provider {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Calico,
                _ => Self::UnknownValue(provider::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Provider {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROVIDER_UNSPECIFIED" => Self::Unspecified,
                "CALICO" => Self::Calico,
                _ => Self::UnknownValue(provider::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Provider {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Calico => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Provider {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Provider>::new(
                ".google.container.v1.NetworkPolicy.Provider",
            ))
        }
    }
}

/// Configuration for Binary Authorization.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BinaryAuthorization {
    /// This field is deprecated. Leave this unset and instead configure
    /// BinaryAuthorization using evaluation_mode. If evaluation_mode is set to
    /// anything other than EVALUATION_MODE_UNSPECIFIED, this field is ignored.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub enabled: bool,

    /// Mode of operation for binauthz policy evaluation. If unspecified, defaults
    /// to DISABLED.
    pub evaluation_mode: crate::model::binary_authorization::EvaluationMode,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BinaryAuthorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::BinaryAuthorization::enabled].
    #[deprecated]
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [evaluation_mode][crate::model::BinaryAuthorization::evaluation_mode].
    pub fn set_evaluation_mode<
        T: std::convert::Into<crate::model::binary_authorization::EvaluationMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_mode = v.into();
        self
    }
}

impl wkt::message::Message for BinaryAuthorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.BinaryAuthorization"
    }
}

/// Defines additional types related to [BinaryAuthorization].
pub mod binary_authorization {
    #[allow(unused_imports)]
    use super::*;

    /// Binary Authorization mode of operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EvaluationMode {
        /// Default value
        Unspecified,
        /// Disable BinaryAuthorization
        Disabled,
        /// Enforce Kubernetes admission requests with BinaryAuthorization using the
        /// project's singleton policy. This is equivalent to setting the
        /// enabled boolean to true.
        ProjectSingletonPolicyEnforce,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EvaluationMode::value] or
        /// [EvaluationMode::name].
        UnknownValue(evaluation_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod evaluation_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EvaluationMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::ProjectSingletonPolicyEnforce => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVALUATION_MODE_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::ProjectSingletonPolicyEnforce => {
                    std::option::Option::Some("PROJECT_SINGLETON_POLICY_ENFORCE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EvaluationMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EvaluationMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EvaluationMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::ProjectSingletonPolicyEnforce,
                _ => Self::UnknownValue(evaluation_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EvaluationMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVALUATION_MODE_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "PROJECT_SINGLETON_POLICY_ENFORCE" => Self::ProjectSingletonPolicyEnforce,
                _ => Self::UnknownValue(evaluation_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EvaluationMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::ProjectSingletonPolicyEnforce => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EvaluationMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EvaluationMode>::new(
                ".google.container.v1.BinaryAuthorization.EvaluationMode",
            ))
        }
    }
}

/// [PRIVATE FIELD]
/// Config for pod CIDR size overprovisioning.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PodCIDROverprovisionConfig {
    /// Whether Pod CIDR overprovisioning is disabled.
    /// Note: Pod CIDR overprovisioning is enabled by default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disable: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PodCIDROverprovisionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disable][crate::model::PodCIDROverprovisionConfig::disable].
    pub fn set_disable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable = v.into();
        self
    }
}

impl wkt::message::Message for PodCIDROverprovisionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.PodCIDROverprovisionConfig"
    }
}

/// Configuration for controlling how IPs are allocated in the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IPAllocationPolicy {
    /// Whether alias IPs will be used for pod IPs in the cluster.
    /// This is used in conjunction with use_routes. It cannot
    /// be true if use_routes is true. If both use_ip_aliases and use_routes are
    /// false, then the server picks the default IP allocation mode
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_ip_aliases: bool,

    /// Whether a new subnetwork will be created automatically for the cluster.
    ///
    /// This field is only applicable when `use_ip_aliases` is true.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub create_subnetwork: bool,

    /// A custom subnetwork name to be used if `create_subnetwork` is true.  If
    /// this field is empty, then an automatic name will be chosen for the new
    /// subnetwork.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnetwork_name: std::string::String,

    /// This field is deprecated, use cluster_ipv4_cidr_block.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_ipv4_cidr: std::string::String,

    /// This field is deprecated, use node_ipv4_cidr_block.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub node_ipv4_cidr: std::string::String,

    /// This field is deprecated, use services_ipv4_cidr_block.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub services_ipv4_cidr: std::string::String,

    /// The name of the secondary range to be used for the cluster CIDR
    /// block.  The secondary range will be used for pod IP
    /// addresses. This must be an existing secondary range associated
    /// with the cluster subnetwork.
    ///
    /// This field is only applicable with use_ip_aliases is true and
    /// create_subnetwork is false.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_secondary_range_name: std::string::String,

    /// The name of the secondary range to be used as for the services
    /// CIDR block.  The secondary range will be used for service
    /// ClusterIPs. This must be an existing secondary range associated
    /// with the cluster subnetwork.
    ///
    /// This field is only applicable with use_ip_aliases is true and
    /// create_subnetwork is false.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub services_secondary_range_name: std::string::String,

    /// The IP address range for the cluster pod IPs. If this field is set, then
    /// `cluster.cluster_ipv4_cidr` must be left blank.
    ///
    /// This field is only applicable when `use_ip_aliases` is true.
    ///
    /// Set to blank to have a range chosen with the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
    /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
    /// to use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_ipv4_cidr_block: std::string::String,

    /// The IP address range of the instance IPs in this cluster.
    ///
    /// This is applicable only if `create_subnetwork` is true.
    ///
    /// Set to blank to have a range chosen with the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
    /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
    /// to use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_ipv4_cidr_block: std::string::String,

    /// The IP address range of the services IPs in this cluster. If blank, a range
    /// will be automatically chosen with the default size.
    ///
    /// This field is only applicable when `use_ip_aliases` is true.
    ///
    /// Set to blank to have a range chosen with the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
    /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
    /// to use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub services_ipv4_cidr_block: std::string::String,

    /// The IP address range of the Cloud TPUs in this cluster. If unspecified, a
    /// range will be automatically chosen with the default size.
    ///
    /// This field is only applicable when `use_ip_aliases` is true.
    ///
    /// If unspecified, the range will use the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
    /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
    /// to use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tpu_ipv4_cidr_block: std::string::String,

    /// Whether routes will be used for pod IPs in the cluster.
    /// This is used in conjunction with use_ip_aliases. It cannot be true if
    /// use_ip_aliases is true. If both use_ip_aliases and use_routes are false,
    /// then the server picks the default IP allocation mode
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub use_routes: bool,

    /// The IP stack type of the cluster
    pub stack_type: crate::model::StackType,

    /// The ipv6 access type (internal or external) when create_subnetwork is true
    pub ipv6_access_type: crate::model::IPv6AccessType,

    /// [PRIVATE FIELD]
    /// Pod CIDR size overprovisioning config for the cluster.
    ///
    /// Pod CIDR size per node depends on max_pods_per_node. By default, the value
    /// of max_pods_per_node is doubled and then rounded off to next power of 2 to
    /// get the size of pod CIDR block per node.
    /// Example: max_pods_per_node of 30 would result in 64 IPs (/26).
    ///
    /// This config can disable the doubling of IPs (we still round off to next
    /// power of 2)
    /// Example: max_pods_per_node of 30 will result in 32 IPs (/27) when
    /// overprovisioning is disabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pod_cidr_overprovision_config:
        std::option::Option<crate::model::PodCIDROverprovisionConfig>,

    /// Output only. The subnet's IPv6 CIDR block used by nodes and pods.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet_ipv6_cidr_block: std::string::String,

    /// Output only. The services IPv6 CIDR block for the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub services_ipv6_cidr_block: std::string::String,

    /// Output only. The additional pod ranges that are added to the cluster.
    /// These pod ranges can be used by new node pools to allocate pod IPs
    /// automatically. Once the range is removed it will not show up in
    /// IPAllocationPolicy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub additional_pod_ranges_config: std::option::Option<crate::model::AdditionalPodRangesConfig>,

    /// Output only. The utilization of the cluster default IPv4 range for the
    /// pod. The ratio is Usage/[Total number of IPs in the secondary range],
    /// Usage=numNodes*numZones*podIPsPerNode.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub default_pod_ipv4_range_utilization: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IPAllocationPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_ip_aliases][crate::model::IPAllocationPolicy::use_ip_aliases].
    pub fn set_use_ip_aliases<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_ip_aliases = v.into();
        self
    }

    /// Sets the value of [create_subnetwork][crate::model::IPAllocationPolicy::create_subnetwork].
    pub fn set_create_subnetwork<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.create_subnetwork = v.into();
        self
    }

    /// Sets the value of [subnetwork_name][crate::model::IPAllocationPolicy::subnetwork_name].
    pub fn set_subnetwork_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork_name = v.into();
        self
    }

    /// Sets the value of [cluster_ipv4_cidr][crate::model::IPAllocationPolicy::cluster_ipv4_cidr].
    #[deprecated]
    pub fn set_cluster_ipv4_cidr<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ipv4_cidr = v.into();
        self
    }

    /// Sets the value of [node_ipv4_cidr][crate::model::IPAllocationPolicy::node_ipv4_cidr].
    #[deprecated]
    pub fn set_node_ipv4_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_ipv4_cidr = v.into();
        self
    }

    /// Sets the value of [services_ipv4_cidr][crate::model::IPAllocationPolicy::services_ipv4_cidr].
    #[deprecated]
    pub fn set_services_ipv4_cidr<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_ipv4_cidr = v.into();
        self
    }

    /// Sets the value of [cluster_secondary_range_name][crate::model::IPAllocationPolicy::cluster_secondary_range_name].
    pub fn set_cluster_secondary_range_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_secondary_range_name = v.into();
        self
    }

    /// Sets the value of [services_secondary_range_name][crate::model::IPAllocationPolicy::services_secondary_range_name].
    pub fn set_services_secondary_range_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_secondary_range_name = v.into();
        self
    }

    /// Sets the value of [cluster_ipv4_cidr_block][crate::model::IPAllocationPolicy::cluster_ipv4_cidr_block].
    pub fn set_cluster_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [node_ipv4_cidr_block][crate::model::IPAllocationPolicy::node_ipv4_cidr_block].
    pub fn set_node_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.node_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [services_ipv4_cidr_block][crate::model::IPAllocationPolicy::services_ipv4_cidr_block].
    pub fn set_services_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [tpu_ipv4_cidr_block][crate::model::IPAllocationPolicy::tpu_ipv4_cidr_block].
    pub fn set_tpu_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tpu_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [use_routes][crate::model::IPAllocationPolicy::use_routes].
    pub fn set_use_routes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_routes = v.into();
        self
    }

    /// Sets the value of [stack_type][crate::model::IPAllocationPolicy::stack_type].
    pub fn set_stack_type<T: std::convert::Into<crate::model::StackType>>(mut self, v: T) -> Self {
        self.stack_type = v.into();
        self
    }

    /// Sets the value of [ipv6_access_type][crate::model::IPAllocationPolicy::ipv6_access_type].
    pub fn set_ipv6_access_type<T: std::convert::Into<crate::model::IPv6AccessType>>(
        mut self,
        v: T,
    ) -> Self {
        self.ipv6_access_type = v.into();
        self
    }

    /// Sets the value of [pod_cidr_overprovision_config][crate::model::IPAllocationPolicy::pod_cidr_overprovision_config].
    pub fn set_pod_cidr_overprovision_config<
        T: std::convert::Into<std::option::Option<crate::model::PodCIDROverprovisionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pod_cidr_overprovision_config = v.into();
        self
    }

    /// Sets the value of [subnet_ipv6_cidr_block][crate::model::IPAllocationPolicy::subnet_ipv6_cidr_block].
    pub fn set_subnet_ipv6_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.subnet_ipv6_cidr_block = v.into();
        self
    }

    /// Sets the value of [services_ipv6_cidr_block][crate::model::IPAllocationPolicy::services_ipv6_cidr_block].
    pub fn set_services_ipv6_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_ipv6_cidr_block = v.into();
        self
    }

    /// Sets the value of [additional_pod_ranges_config][crate::model::IPAllocationPolicy::additional_pod_ranges_config].
    pub fn set_additional_pod_ranges_config<
        T: std::convert::Into<std::option::Option<crate::model::AdditionalPodRangesConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.additional_pod_ranges_config = v.into();
        self
    }

    /// Sets the value of [default_pod_ipv4_range_utilization][crate::model::IPAllocationPolicy::default_pod_ipv4_range_utilization].
    pub fn set_default_pod_ipv4_range_utilization<T: std::convert::Into<f64>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_pod_ipv4_range_utilization = v.into();
        self
    }
}

impl wkt::message::Message for IPAllocationPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.IPAllocationPolicy"
    }
}

/// A Google Kubernetes Engine cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Cluster {
    /// The name of this cluster. The name must be unique within this project
    /// and location (e.g. zone or region), and can be up to 40 characters with
    /// the following restrictions:
    ///
    /// * Lowercase letters, numbers, and hyphens only.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// An optional description of this cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The number of nodes to create in this cluster. You must ensure that your
    /// Compute Engine [resource quota](https://cloud.google.com/compute/quotas)
    /// is sufficient for this number of instances. You must also have available
    /// firewall and routes quota.
    /// For requests, this field should only be used in lieu of a
    /// "node_pool" object, since this configuration (along with the
    /// "node_config") will be used to create a "NodePool" object with an
    /// auto-generated name. Do not use this and a node_pool at the same time.
    ///
    /// This field is deprecated, use node_pool.initial_node_count instead.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub initial_node_count: i32,

    /// Parameters used in creating the cluster's nodes.
    /// For requests, this field should only be used in lieu of a
    /// "node_pool" object, since this configuration (along with the
    /// "initial_node_count") will be used to create a "NodePool" object with an
    /// auto-generated name. Do not use this and a node_pool at the same time.
    /// For responses, this field will be populated with the node configuration of
    /// the first node pool. (For configuration of each node pool, see
    /// `node_pool.config`)
    ///
    /// If unspecified, the defaults are used.
    /// This field is deprecated, use node_pool.config instead.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub node_config: std::option::Option<crate::model::NodeConfig>,

    /// The authentication information for accessing the master endpoint.
    /// If unspecified, the defaults are used:
    /// For clusters before v1.12, if master_auth is unspecified, `username` will
    /// be set to "admin", a random password will be generated, and a client
    /// certificate will be issued.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub master_auth: std::option::Option<crate::model::MasterAuth>,

    /// The logging service the cluster should use to write logs.
    /// Currently available options:
    ///
    /// * `logging.googleapis.com/kubernetes` - The Cloud Logging
    ///   service with a Kubernetes-native resource model
    /// * `logging.googleapis.com` - The legacy Cloud Logging service (no longer
    ///   available as of GKE 1.15).
    /// * `none` - no logs will be exported from the cluster.
    ///
    /// If left as an empty string,`logging.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub logging_service: std::string::String,

    /// The monitoring service the cluster should use to write metrics.
    /// Currently available options:
    ///
    /// * "monitoring.googleapis.com/kubernetes" - The Cloud Monitoring
    ///   service with a Kubernetes-native resource model
    /// * `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no
    ///   longer available as of GKE 1.15).
    /// * `none` - No metrics will be exported from the cluster.
    ///
    /// If left as an empty string,`monitoring.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `monitoring.googleapis.com` for earlier versions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub monitoring_service: std::string::String,

    /// The name of the Google Compute Engine
    /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
    /// to which the cluster is connected. If left unspecified, the `default`
    /// network will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// The IP address range of the container pods in this cluster, in
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `10.96.0.0/14`). Leave blank to have
    /// one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_ipv4_cidr: std::string::String,

    /// Configurations for the various addons available to run in the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub addons_config: std::option::Option<crate::model::AddonsConfig>,

    /// The name of the Google Compute Engine
    /// [subnetwork](https://cloud.google.com/compute/docs/subnetworks) to which
    /// the cluster is connected.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnetwork: std::string::String,

    /// The node pools associated with this cluster.
    /// This field should not be set if "node_config" or "initial_node_count" are
    /// specified.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub node_pools: std::vec::Vec<crate::model::NodePool>,

    /// The list of Google Compute Engine
    /// [zones](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster's nodes should be located.
    ///
    /// This field provides a default value if
    /// [NodePool.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.FIELDS.locations)
    /// are not specified during node pool creation.
    ///
    /// Warning: changing cluster locations will update the
    /// [NodePool.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.FIELDS.locations)
    /// of all node pools and will result in nodes being added and/or removed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub locations: std::vec::Vec<std::string::String>,

    /// Kubernetes alpha features are enabled on this cluster. This includes alpha
    /// API groups (e.g. v1alpha1) and features that may not be production ready in
    /// the kubernetes version of the master and nodes.
    /// The cluster has no SLA for uptime and master/node upgrades are disabled.
    /// Alpha enabled clusters are automatically deleted thirty days after
    /// creation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_kubernetes_alpha: bool,

    /// The resource labels for the cluster to use to annotate any related
    /// Google Compute Engine resources.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub resource_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The fingerprint of the set of labels for this cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub label_fingerprint: std::string::String,

    /// Configuration for the legacy ABAC authorization mode.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub legacy_abac: std::option::Option<crate::model::LegacyAbac>,

    /// Configuration options for the NetworkPolicy feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_policy: std::option::Option<crate::model::NetworkPolicy>,

    /// Configuration for cluster IP allocation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ip_allocation_policy: std::option::Option<crate::model::IPAllocationPolicy>,

    /// The configuration options for master authorized networks feature.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.authorized_networks_config][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.authorized_networks_config]
    /// instead.
    ///
    /// [google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.authorized_networks_config]: crate::model::control_plane_endpoints_config::IPEndpointsConfig::authorized_networks_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub master_authorized_networks_config:
        std::option::Option<crate::model::MasterAuthorizedNetworksConfig>,

    /// Configure the maintenance policy for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_policy: std::option::Option<crate::model::MaintenancePolicy>,

    /// Configuration for Binary Authorization.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub binary_authorization: std::option::Option<crate::model::BinaryAuthorization>,

    /// Cluster-level autoscaling configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoscaling: std::option::Option<crate::model::ClusterAutoscaling>,

    /// Configuration for cluster networking.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_config: std::option::Option<crate::model::NetworkConfig>,

    /// The default constraint on the maximum number of pods that can be run
    /// simultaneously on a node in the node pool of this cluster. Only honored
    /// if cluster created with IP Alias support.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_max_pods_constraint: std::option::Option<crate::model::MaxPodsConstraint>,

    /// Configuration for exporting resource usages. Resource usage export is
    /// disabled when this config is unspecified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_usage_export_config: std::option::Option<crate::model::ResourceUsageExportConfig>,

    /// Configuration controlling RBAC group membership information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authenticator_groups_config: std::option::Option<crate::model::AuthenticatorGroupsConfig>,

    /// Configuration for private cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_cluster_config: std::option::Option<crate::model::PrivateClusterConfig>,

    /// Configuration of etcd encryption.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub database_encryption: std::option::Option<crate::model::DatabaseEncryption>,

    /// Cluster-level Vertical Pod Autoscaling configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vertical_pod_autoscaling: std::option::Option<crate::model::VerticalPodAutoscaling>,

    /// Shielded Nodes configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub shielded_nodes: std::option::Option<crate::model::ShieldedNodes>,

    /// Release channel configuration. If left unspecified on cluster creation and
    /// a version is specified, the cluster is enrolled in the most mature release
    /// channel where the version is available (first checking STABLE, then
    /// REGULAR, and finally RAPID). Otherwise, if no release channel
    /// configuration and no version is specified, the cluster is enrolled in the
    /// REGULAR channel with its default version.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub release_channel: std::option::Option<crate::model::ReleaseChannel>,

    /// Configuration for the use of Kubernetes Service Accounts in GCP IAM
    /// policies.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workload_identity_config: std::option::Option<crate::model::WorkloadIdentityConfig>,

    /// Configuration for issuance of mTLS keys and certificates to Kubernetes
    /// pods.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mesh_certificates: std::option::Option<crate::model::MeshCertificates>,

    /// Configuration for the fine-grained cost management feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cost_management_config: std::option::Option<crate::model::CostManagementConfig>,

    /// Notification configuration of the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub notification_config: std::option::Option<crate::model::NotificationConfig>,

    /// Configuration of Confidential Nodes.
    /// All the nodes in the cluster will be Confidential VM once enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidential_nodes: std::option::Option<crate::model::ConfidentialNodes>,

    /// Configuration for Identity Service component.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub identity_service_config: std::option::Option<crate::model::IdentityServiceConfig>,

    /// Output only. Server-defined URL for the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    /// Output only. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field is deprecated, use location instead.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Output only. The IP address of this cluster's master endpoint.
    /// The endpoint can be accessed from the internet at
    /// `https://username:password@endpoint/`.
    ///
    /// See the `masterAuth` property of this resource for username and
    /// password information.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// The initial Kubernetes version for this cluster.  Valid versions are those
    /// found in validMasterVersions returned by getServerConfig.  The version can
    /// be upgraded over time; such upgrades are reflected in
    /// currentMasterVersion and currentNodeVersion.
    ///
    /// Users may specify either explicit versions offered by
    /// Kubernetes Engine or version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "","-": picks the default Kubernetes version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub initial_cluster_version: std::string::String,

    /// Output only. The current software version of the master endpoint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub current_master_version: std::string::String,

    /// Output only. Deprecated, use
    /// [NodePools.version](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools)
    /// instead. The current version of the node software components. If they are
    /// currently at multiple versions because they're in the process of being
    /// upgraded, this reflects the minimum version of all nodes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub current_node_version: std::string::String,

    /// Output only. The time the cluster was created, in
    /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub create_time: std::string::String,

    /// Output only. The current status of this cluster.
    pub status: crate::model::cluster::Status,

    /// Output only. Deprecated. Use conditions instead.
    /// Additional information about the current status of this
    /// cluster, if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub status_message: std::string::String,

    /// Output only. The size of the address space on each node for hosting
    /// containers. This is provisioned from within the `container_ipv4_cidr`
    /// range. This field will only be set when cluster is in route-based network
    /// mode.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub node_ipv4_cidr_size: i32,

    /// Output only. The IP address range of the Kubernetes services in
    /// this cluster, in
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `1.2.3.4/29`). Service addresses are
    /// typically put in the last `/16` from the container CIDR.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub services_ipv4_cidr: std::string::String,

    /// Output only. Deprecated. Use node_pools.instance_group_urls.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[deprecated]
    pub instance_group_urls: std::vec::Vec<std::string::String>,

    /// Output only. The number of nodes currently in the cluster. Deprecated.
    /// Call Kubernetes API directly to retrieve node information.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub current_node_count: i32,

    /// Output only. The time the cluster will be automatically
    /// deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub expire_time: std::string::String,

    /// Output only. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
    /// or
    /// [region](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
    /// in which the cluster resides.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Enable the ability to use Cloud TPUs in this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_tpu: bool,

    /// Output only. The IP address range of the Cloud TPUs in this cluster, in
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `1.2.3.4/29`).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tpu_ipv4_cidr_block: std::string::String,

    /// Which conditions caused the current cluster state.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conditions: std::vec::Vec<crate::model::StatusCondition>,

    /// Autopilot configuration for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autopilot: std::option::Option<crate::model::Autopilot>,

    /// Output only. Unique id for the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Default NodePool settings for the entire cluster. These settings are
    /// overridden if specified on the specific NodePool object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_pool_defaults: std::option::Option<crate::model::NodePoolDefaults>,

    /// Logging configuration for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Monitoring configuration for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub monitoring_config: std::option::Option<crate::model::MonitoringConfig>,

    /// Node pool configs that apply to all auto-provisioned node pools
    /// in autopilot clusters and node auto-provisioning enabled clusters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_pool_auto_config: std::option::Option<crate::model::NodePoolAutoConfig>,

    /// This checksum is computed by the server based on the value of cluster
    /// fields, and may be sent on update requests to ensure the client has an
    /// up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Fleet information for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fleet: std::option::Option<crate::model::Fleet>,

    /// Enable/Disable Security Posture API features for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub security_posture_config: std::option::Option<crate::model::SecurityPostureConfig>,

    /// Configuration for all cluster's control plane endpoints.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub control_plane_endpoints_config:
        std::option::Option<crate::model::ControlPlaneEndpointsConfig>,

    /// Beta APIs Config
    #[serde(rename = "enableK8sBetaApis")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_k8s_beta_apis: std::option::Option<crate::model::K8sBetaAPIConfig>,

    /// GKE Enterprise Configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enterprise_config: std::option::Option<crate::model::EnterpriseConfig>,

    /// Secret CSI driver configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub secret_manager_config: std::option::Option<crate::model::SecretManagerConfig>,

    /// Enable/Disable Compliance Posture features for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub compliance_posture_config: std::option::Option<crate::model::CompliancePostureConfig>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<bool>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzi: std::option::Option<bool>,

    /// The Custom keys configuration for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_managed_keys_config: std::option::Option<crate::model::UserManagedKeysConfig>,

    /// RBACBindingConfig allows user to restrict ClusterRoleBindings an
    /// RoleBindings that can be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rbac_binding_config: std::option::Option<crate::model::RBACBindingConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Cluster::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [initial_node_count][crate::model::Cluster::initial_node_count].
    #[deprecated]
    pub fn set_initial_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.initial_node_count = v.into();
        self
    }

    /// Sets the value of [node_config][crate::model::Cluster::node_config].
    #[deprecated]
    pub fn set_node_config<T: std::convert::Into<std::option::Option<crate::model::NodeConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.node_config = v.into();
        self
    }

    /// Sets the value of [master_auth][crate::model::Cluster::master_auth].
    pub fn set_master_auth<T: std::convert::Into<std::option::Option<crate::model::MasterAuth>>>(
        mut self,
        v: T,
    ) -> Self {
        self.master_auth = v.into();
        self
    }

    /// Sets the value of [logging_service][crate::model::Cluster::logging_service].
    pub fn set_logging_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.logging_service = v.into();
        self
    }

    /// Sets the value of [monitoring_service][crate::model::Cluster::monitoring_service].
    pub fn set_monitoring_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.monitoring_service = v.into();
        self
    }

    /// Sets the value of [network][crate::model::Cluster::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [cluster_ipv4_cidr][crate::model::Cluster::cluster_ipv4_cidr].
    pub fn set_cluster_ipv4_cidr<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ipv4_cidr = v.into();
        self
    }

    /// Sets the value of [addons_config][crate::model::Cluster::addons_config].
    pub fn set_addons_config<
        T: std::convert::Into<std::option::Option<crate::model::AddonsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.addons_config = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::Cluster::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [node_pools][crate::model::Cluster::node_pools].
    pub fn set_node_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodePool>,
    {
        use std::iter::Iterator;
        self.node_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [locations][crate::model::Cluster::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [enable_kubernetes_alpha][crate::model::Cluster::enable_kubernetes_alpha].
    pub fn set_enable_kubernetes_alpha<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_kubernetes_alpha = v.into();
        self
    }

    /// Sets the value of [resource_labels][crate::model::Cluster::resource_labels].
    pub fn set_resource_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [label_fingerprint][crate::model::Cluster::label_fingerprint].
    pub fn set_label_fingerprint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.label_fingerprint = v.into();
        self
    }

    /// Sets the value of [legacy_abac][crate::model::Cluster::legacy_abac].
    pub fn set_legacy_abac<T: std::convert::Into<std::option::Option<crate::model::LegacyAbac>>>(
        mut self,
        v: T,
    ) -> Self {
        self.legacy_abac = v.into();
        self
    }

    /// Sets the value of [network_policy][crate::model::Cluster::network_policy].
    pub fn set_network_policy<
        T: std::convert::Into<std::option::Option<crate::model::NetworkPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_policy = v.into();
        self
    }

    /// Sets the value of [ip_allocation_policy][crate::model::Cluster::ip_allocation_policy].
    pub fn set_ip_allocation_policy<
        T: std::convert::Into<std::option::Option<crate::model::IPAllocationPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ip_allocation_policy = v.into();
        self
    }

    /// Sets the value of [master_authorized_networks_config][crate::model::Cluster::master_authorized_networks_config].
    #[deprecated]
    pub fn set_master_authorized_networks_config<
        T: std::convert::Into<std::option::Option<crate::model::MasterAuthorizedNetworksConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.master_authorized_networks_config = v.into();
        self
    }

    /// Sets the value of [maintenance_policy][crate::model::Cluster::maintenance_policy].
    pub fn set_maintenance_policy<
        T: std::convert::Into<std::option::Option<crate::model::MaintenancePolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_policy = v.into();
        self
    }

    /// Sets the value of [binary_authorization][crate::model::Cluster::binary_authorization].
    pub fn set_binary_authorization<
        T: std::convert::Into<std::option::Option<crate::model::BinaryAuthorization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.binary_authorization = v.into();
        self
    }

    /// Sets the value of [autoscaling][crate::model::Cluster::autoscaling].
    pub fn set_autoscaling<
        T: std::convert::Into<std::option::Option<crate::model::ClusterAutoscaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling = v.into();
        self
    }

    /// Sets the value of [network_config][crate::model::Cluster::network_config].
    pub fn set_network_config<
        T: std::convert::Into<std::option::Option<crate::model::NetworkConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_config = v.into();
        self
    }

    /// Sets the value of [default_max_pods_constraint][crate::model::Cluster::default_max_pods_constraint].
    pub fn set_default_max_pods_constraint<
        T: std::convert::Into<std::option::Option<crate::model::MaxPodsConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_max_pods_constraint = v.into();
        self
    }

    /// Sets the value of [resource_usage_export_config][crate::model::Cluster::resource_usage_export_config].
    pub fn set_resource_usage_export_config<
        T: std::convert::Into<std::option::Option<crate::model::ResourceUsageExportConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_usage_export_config = v.into();
        self
    }

    /// Sets the value of [authenticator_groups_config][crate::model::Cluster::authenticator_groups_config].
    pub fn set_authenticator_groups_config<
        T: std::convert::Into<std::option::Option<crate::model::AuthenticatorGroupsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authenticator_groups_config = v.into();
        self
    }

    /// Sets the value of [private_cluster_config][crate::model::Cluster::private_cluster_config].
    pub fn set_private_cluster_config<
        T: std::convert::Into<std::option::Option<crate::model::PrivateClusterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_cluster_config = v.into();
        self
    }

    /// Sets the value of [database_encryption][crate::model::Cluster::database_encryption].
    pub fn set_database_encryption<
        T: std::convert::Into<std::option::Option<crate::model::DatabaseEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_encryption = v.into();
        self
    }

    /// Sets the value of [vertical_pod_autoscaling][crate::model::Cluster::vertical_pod_autoscaling].
    pub fn set_vertical_pod_autoscaling<
        T: std::convert::Into<std::option::Option<crate::model::VerticalPodAutoscaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vertical_pod_autoscaling = v.into();
        self
    }

    /// Sets the value of [shielded_nodes][crate::model::Cluster::shielded_nodes].
    pub fn set_shielded_nodes<
        T: std::convert::Into<std::option::Option<crate::model::ShieldedNodes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.shielded_nodes = v.into();
        self
    }

    /// Sets the value of [release_channel][crate::model::Cluster::release_channel].
    pub fn set_release_channel<
        T: std::convert::Into<std::option::Option<crate::model::ReleaseChannel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.release_channel = v.into();
        self
    }

    /// Sets the value of [workload_identity_config][crate::model::Cluster::workload_identity_config].
    pub fn set_workload_identity_config<
        T: std::convert::Into<std::option::Option<crate::model::WorkloadIdentityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workload_identity_config = v.into();
        self
    }

    /// Sets the value of [mesh_certificates][crate::model::Cluster::mesh_certificates].
    pub fn set_mesh_certificates<
        T: std::convert::Into<std::option::Option<crate::model::MeshCertificates>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mesh_certificates = v.into();
        self
    }

    /// Sets the value of [cost_management_config][crate::model::Cluster::cost_management_config].
    pub fn set_cost_management_config<
        T: std::convert::Into<std::option::Option<crate::model::CostManagementConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cost_management_config = v.into();
        self
    }

    /// Sets the value of [notification_config][crate::model::Cluster::notification_config].
    pub fn set_notification_config<
        T: std::convert::Into<std::option::Option<crate::model::NotificationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notification_config = v.into();
        self
    }

    /// Sets the value of [confidential_nodes][crate::model::Cluster::confidential_nodes].
    pub fn set_confidential_nodes<
        T: std::convert::Into<std::option::Option<crate::model::ConfidentialNodes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.confidential_nodes = v.into();
        self
    }

    /// Sets the value of [identity_service_config][crate::model::Cluster::identity_service_config].
    pub fn set_identity_service_config<
        T: std::convert::Into<std::option::Option<crate::model::IdentityServiceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identity_service_config = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::Cluster::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::Cluster::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::Cluster::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [initial_cluster_version][crate::model::Cluster::initial_cluster_version].
    pub fn set_initial_cluster_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.initial_cluster_version = v.into();
        self
    }

    /// Sets the value of [current_master_version][crate::model::Cluster::current_master_version].
    pub fn set_current_master_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.current_master_version = v.into();
        self
    }

    /// Sets the value of [current_node_version][crate::model::Cluster::current_node_version].
    #[deprecated]
    pub fn set_current_node_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.current_node_version = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_create_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Cluster::status].
    pub fn set_status<T: std::convert::Into<crate::model::cluster::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::Cluster::status_message].
    #[deprecated]
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [node_ipv4_cidr_size][crate::model::Cluster::node_ipv4_cidr_size].
    pub fn set_node_ipv4_cidr_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_ipv4_cidr_size = v.into();
        self
    }

    /// Sets the value of [services_ipv4_cidr][crate::model::Cluster::services_ipv4_cidr].
    pub fn set_services_ipv4_cidr<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_ipv4_cidr = v.into();
        self
    }

    /// Sets the value of [instance_group_urls][crate::model::Cluster::instance_group_urls].
    #[deprecated]
    pub fn set_instance_group_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_group_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [current_node_count][crate::model::Cluster::current_node_count].
    #[deprecated]
    pub fn set_current_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.current_node_count = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Cluster::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Cluster::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [enable_tpu][crate::model::Cluster::enable_tpu].
    pub fn set_enable_tpu<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_tpu = v.into();
        self
    }

    /// Sets the value of [tpu_ipv4_cidr_block][crate::model::Cluster::tpu_ipv4_cidr_block].
    pub fn set_tpu_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tpu_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::Cluster::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StatusCondition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [autopilot][crate::model::Cluster::autopilot].
    pub fn set_autopilot<T: std::convert::Into<std::option::Option<crate::model::Autopilot>>>(
        mut self,
        v: T,
    ) -> Self {
        self.autopilot = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Cluster::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [node_pool_defaults][crate::model::Cluster::node_pool_defaults].
    pub fn set_node_pool_defaults<
        T: std::convert::Into<std::option::Option<crate::model::NodePoolDefaults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_pool_defaults = v.into();
        self
    }

    /// Sets the value of [logging_config][crate::model::Cluster::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [monitoring_config][crate::model::Cluster::monitoring_config].
    pub fn set_monitoring_config<
        T: std::convert::Into<std::option::Option<crate::model::MonitoringConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.monitoring_config = v.into();
        self
    }

    /// Sets the value of [node_pool_auto_config][crate::model::Cluster::node_pool_auto_config].
    pub fn set_node_pool_auto_config<
        T: std::convert::Into<std::option::Option<crate::model::NodePoolAutoConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_pool_auto_config = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Cluster::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [fleet][crate::model::Cluster::fleet].
    pub fn set_fleet<T: std::convert::Into<std::option::Option<crate::model::Fleet>>>(
        mut self,
        v: T,
    ) -> Self {
        self.fleet = v.into();
        self
    }

    /// Sets the value of [security_posture_config][crate::model::Cluster::security_posture_config].
    pub fn set_security_posture_config<
        T: std::convert::Into<std::option::Option<crate::model::SecurityPostureConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.security_posture_config = v.into();
        self
    }

    /// Sets the value of [control_plane_endpoints_config][crate::model::Cluster::control_plane_endpoints_config].
    pub fn set_control_plane_endpoints_config<
        T: std::convert::Into<std::option::Option<crate::model::ControlPlaneEndpointsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane_endpoints_config = v.into();
        self
    }

    /// Sets the value of [enable_k8s_beta_apis][crate::model::Cluster::enable_k8s_beta_apis].
    pub fn set_enable_k8s_beta_apis<
        T: std::convert::Into<std::option::Option<crate::model::K8sBetaAPIConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enable_k8s_beta_apis = v.into();
        self
    }

    /// Sets the value of [enterprise_config][crate::model::Cluster::enterprise_config].
    pub fn set_enterprise_config<
        T: std::convert::Into<std::option::Option<crate::model::EnterpriseConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enterprise_config = v.into();
        self
    }

    /// Sets the value of [secret_manager_config][crate::model::Cluster::secret_manager_config].
    pub fn set_secret_manager_config<
        T: std::convert::Into<std::option::Option<crate::model::SecretManagerConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secret_manager_config = v.into();
        self
    }

    /// Sets the value of [compliance_posture_config][crate::model::Cluster::compliance_posture_config].
    pub fn set_compliance_posture_config<
        T: std::convert::Into<std::option::Option<crate::model::CompliancePostureConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compliance_posture_config = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Cluster::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Cluster::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [user_managed_keys_config][crate::model::Cluster::user_managed_keys_config].
    pub fn set_user_managed_keys_config<
        T: std::convert::Into<std::option::Option<crate::model::UserManagedKeysConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_managed_keys_config = v.into();
        self
    }

    /// Sets the value of [rbac_binding_config][crate::model::Cluster::rbac_binding_config].
    pub fn set_rbac_binding_config<
        T: std::convert::Into<std::option::Option<crate::model::RBACBindingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rbac_binding_config = v.into();
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.Cluster"
    }
}

/// Defines additional types related to [Cluster].
pub mod cluster {
    #[allow(unused_imports)]
    use super::*;

    /// The current status of the cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Not set.
        Unspecified,
        /// The PROVISIONING state indicates the cluster is being created.
        Provisioning,
        /// The RUNNING state indicates the cluster has been created and is fully
        /// usable.
        Running,
        /// The RECONCILING state indicates that some work is actively being done on
        /// the cluster, such as upgrading the master or node software. Details can
        /// be found in the `statusMessage` field.
        Reconciling,
        /// The STOPPING state indicates the cluster is being deleted.
        Stopping,
        /// The ERROR state indicates the cluster is unusable. It will be
        /// automatically deleted. Details can be found in the `statusMessage` field.
        Error,
        /// The DEGRADED state indicates the cluster requires user action to restore
        /// full functionality. Details can be found in the `statusMessage` field.
        Degraded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Reconciling => std::option::Option::Some(3),
                Self::Stopping => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::Degraded => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Reconciling => std::option::Option::Some("RECONCILING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Degraded => std::option::Option::Some("DEGRADED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Running,
                3 => Self::Reconciling,
                4 => Self::Stopping,
                5 => Self::Error,
                6 => Self::Degraded,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "RUNNING" => Self::Running,
                "RECONCILING" => Self::Reconciling,
                "STOPPING" => Self::Stopping,
                "ERROR" => Self::Error,
                "DEGRADED" => Self::Degraded,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Reconciling => serializer.serialize_i32(3),
                Self::Stopping => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::Degraded => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.container.v1.Cluster.Status",
            ))
        }
    }
}

/// RBACBindingConfig allows user to restrict ClusterRoleBindings an RoleBindings
/// that can be created.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RBACBindingConfig {
    /// Setting this to true will allow any ClusterRoleBinding and RoleBinding
    /// with subjets system:anonymous or system:unauthenticated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_insecure_binding_system_unauthenticated: std::option::Option<bool>,

    /// Setting this to true will allow any ClusterRoleBinding and RoleBinding
    /// with subjects system:authenticated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_insecure_binding_system_authenticated: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RBACBindingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_insecure_binding_system_unauthenticated][crate::model::RBACBindingConfig::enable_insecure_binding_system_unauthenticated].
    pub fn set_enable_insecure_binding_system_unauthenticated<
        T: std::convert::Into<std::option::Option<bool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enable_insecure_binding_system_unauthenticated = v.into();
        self
    }

    /// Sets the value of [enable_insecure_binding_system_authenticated][crate::model::RBACBindingConfig::enable_insecure_binding_system_authenticated].
    pub fn set_enable_insecure_binding_system_authenticated<
        T: std::convert::Into<std::option::Option<bool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enable_insecure_binding_system_authenticated = v.into();
        self
    }
}

impl wkt::message::Message for RBACBindingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.RBACBindingConfig"
    }
}

/// UserManagedKeysConfig holds the resource address to Keys which are used
/// for signing certs and token that are used for communication within cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserManagedKeysConfig {
    /// The Certificate Authority Service caPool to use for the cluster CA in this
    /// cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_ca: std::string::String,

    /// Resource path of the Certificate Authority Service caPool to use for the
    /// etcd API CA in this cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etcd_api_ca: std::string::String,

    /// Resource path of the Certificate Authority Service caPool to use for the
    /// etcd peer CA in this cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etcd_peer_ca: std::string::String,

    /// The Cloud KMS cryptoKeyVersions to use for signing service account JWTs
    /// issued by this cluster.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{cryptoKey}/cryptoKeyVersions/{cryptoKeyVersion}`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub service_account_signing_keys: std::vec::Vec<std::string::String>,

    /// The Cloud KMS cryptoKeyVersions to use for verifying service account JWTs
    /// issued by this cluster.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{cryptoKey}/cryptoKeyVersions/{cryptoKeyVersion}`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub service_account_verification_keys: std::vec::Vec<std::string::String>,

    /// The Certificate Authority Service caPool to use for the aggregation CA in
    /// this cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub aggregation_ca: std::string::String,

    /// The Cloud KMS cryptoKey to use for Confidential Hyperdisk on the control
    /// plane nodes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub control_plane_disk_encryption_key: std::string::String,

    /// Resource path of the Cloud KMS cryptoKey to use for encryption of internal
    /// etcd backups.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gkeops_etcd_backup_encryption_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserManagedKeysConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_ca][crate::model::UserManagedKeysConfig::cluster_ca].
    pub fn set_cluster_ca<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_ca = v.into();
        self
    }

    /// Sets the value of [etcd_api_ca][crate::model::UserManagedKeysConfig::etcd_api_ca].
    pub fn set_etcd_api_ca<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etcd_api_ca = v.into();
        self
    }

    /// Sets the value of [etcd_peer_ca][crate::model::UserManagedKeysConfig::etcd_peer_ca].
    pub fn set_etcd_peer_ca<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etcd_peer_ca = v.into();
        self
    }

    /// Sets the value of [service_account_signing_keys][crate::model::UserManagedKeysConfig::service_account_signing_keys].
    pub fn set_service_account_signing_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_account_signing_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account_verification_keys][crate::model::UserManagedKeysConfig::service_account_verification_keys].
    pub fn set_service_account_verification_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_account_verification_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [aggregation_ca][crate::model::UserManagedKeysConfig::aggregation_ca].
    pub fn set_aggregation_ca<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aggregation_ca = v.into();
        self
    }

    /// Sets the value of [control_plane_disk_encryption_key][crate::model::UserManagedKeysConfig::control_plane_disk_encryption_key].
    pub fn set_control_plane_disk_encryption_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane_disk_encryption_key = v.into();
        self
    }

    /// Sets the value of [gkeops_etcd_backup_encryption_key][crate::model::UserManagedKeysConfig::gkeops_etcd_backup_encryption_key].
    pub fn set_gkeops_etcd_backup_encryption_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gkeops_etcd_backup_encryption_key = v.into();
        self
    }
}

impl wkt::message::Message for UserManagedKeysConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UserManagedKeysConfig"
    }
}

/// CompliancePostureConfig defines the settings needed to enable/disable
/// features for the Compliance Posture.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CompliancePostureConfig {
    /// Defines the enablement mode for Compliance Posture.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mode: std::option::Option<crate::model::compliance_posture_config::Mode>,

    /// List of enabled compliance standards.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub compliance_standards:
        std::vec::Vec<crate::model::compliance_posture_config::ComplianceStandard>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompliancePostureConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::CompliancePostureConfig::mode].
    pub fn set_mode<
        T: std::convert::Into<std::option::Option<crate::model::compliance_posture_config::Mode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [compliance_standards][crate::model::CompliancePostureConfig::compliance_standards].
    pub fn set_compliance_standards<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::compliance_posture_config::ComplianceStandard>,
    {
        use std::iter::Iterator;
        self.compliance_standards = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CompliancePostureConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CompliancePostureConfig"
    }
}

/// Defines additional types related to [CompliancePostureConfig].
pub mod compliance_posture_config {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the details of a compliance standard.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ComplianceStandard {
        /// Name of the compliance standard.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub standard: std::option::Option<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ComplianceStandard {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [standard][crate::model::compliance_posture_config::ComplianceStandard::standard].
        pub fn set_standard<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.standard = v.into();
            self
        }
    }

    impl wkt::message::Message for ComplianceStandard {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.CompliancePostureConfig.ComplianceStandard"
        }
    }

    /// Mode defines enablement mode for Compliance Posture.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Default value not specified.
        Unspecified,
        /// Disables Compliance Posture features on the cluster.
        Disabled,
        /// Enables Compliance Posture features on the cluster.
        Enabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Enabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::Enabled,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "ENABLED" => Self::Enabled,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Enabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.container.v1.CompliancePostureConfig.Mode",
            ))
        }
    }
}

/// K8sBetaAPIConfig , configuration for beta APIs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct K8sBetaAPIConfig {
    /// Enabled k8s beta APIs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub enabled_apis: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl K8sBetaAPIConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled_apis][crate::model::K8sBetaAPIConfig::enabled_apis].
    pub fn set_enabled_apis<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.enabled_apis = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for K8sBetaAPIConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.K8sBetaAPIConfig"
    }
}

/// SecurityPostureConfig defines the flags needed to enable/disable features for
/// the Security Posture API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecurityPostureConfig {
    /// Sets which mode to use for Security Posture features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mode: std::option::Option<crate::model::security_posture_config::Mode>,

    /// Sets which mode to use for vulnerability scanning.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vulnerability_mode:
        std::option::Option<crate::model::security_posture_config::VulnerabilityMode>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecurityPostureConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::SecurityPostureConfig::mode].
    pub fn set_mode<
        T: std::convert::Into<std::option::Option<crate::model::security_posture_config::Mode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [vulnerability_mode][crate::model::SecurityPostureConfig::vulnerability_mode].
    pub fn set_vulnerability_mode<
        T: std::convert::Into<
                std::option::Option<crate::model::security_posture_config::VulnerabilityMode>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vulnerability_mode = v.into();
        self
    }
}

impl wkt::message::Message for SecurityPostureConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SecurityPostureConfig"
    }
}

/// Defines additional types related to [SecurityPostureConfig].
pub mod security_posture_config {
    #[allow(unused_imports)]
    use super::*;

    /// Mode defines enablement mode for GKE Security posture features.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Default value not specified.
        Unspecified,
        /// Disables Security Posture features on the cluster.
        Disabled,
        /// Applies Security Posture features on the cluster.
        Basic,
        /// Applies the Security Posture off cluster Enterprise level features.
        Enterprise,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Basic => std::option::Option::Some(2),
                Self::Enterprise => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Enterprise => std::option::Option::Some("ENTERPRISE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::Basic,
                3 => Self::Enterprise,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "BASIC" => Self::Basic,
                "ENTERPRISE" => Self::Enterprise,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Basic => serializer.serialize_i32(2),
                Self::Enterprise => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.container.v1.SecurityPostureConfig.Mode",
            ))
        }
    }

    /// VulnerabilityMode defines enablement mode for vulnerability scanning.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VulnerabilityMode {
        /// Default value not specified.
        Unspecified,
        /// Disables vulnerability scanning on the cluster.
        VulnerabilityDisabled,
        /// Applies basic vulnerability scanning on the cluster.
        VulnerabilityBasic,
        /// Applies the Security Posture's vulnerability on cluster Enterprise level
        /// features.
        VulnerabilityEnterprise,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VulnerabilityMode::value] or
        /// [VulnerabilityMode::name].
        UnknownValue(vulnerability_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vulnerability_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VulnerabilityMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::VulnerabilityDisabled => std::option::Option::Some(1),
                Self::VulnerabilityBasic => std::option::Option::Some(2),
                Self::VulnerabilityEnterprise => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VULNERABILITY_MODE_UNSPECIFIED"),
                Self::VulnerabilityDisabled => std::option::Option::Some("VULNERABILITY_DISABLED"),
                Self::VulnerabilityBasic => std::option::Option::Some("VULNERABILITY_BASIC"),
                Self::VulnerabilityEnterprise => {
                    std::option::Option::Some("VULNERABILITY_ENTERPRISE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VulnerabilityMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VulnerabilityMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VulnerabilityMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::VulnerabilityDisabled,
                2 => Self::VulnerabilityBasic,
                3 => Self::VulnerabilityEnterprise,
                _ => Self::UnknownValue(vulnerability_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VulnerabilityMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VULNERABILITY_MODE_UNSPECIFIED" => Self::Unspecified,
                "VULNERABILITY_DISABLED" => Self::VulnerabilityDisabled,
                "VULNERABILITY_BASIC" => Self::VulnerabilityBasic,
                "VULNERABILITY_ENTERPRISE" => Self::VulnerabilityEnterprise,
                _ => Self::UnknownValue(vulnerability_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VulnerabilityMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::VulnerabilityDisabled => serializer.serialize_i32(1),
                Self::VulnerabilityBasic => serializer.serialize_i32(2),
                Self::VulnerabilityEnterprise => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VulnerabilityMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VulnerabilityMode>::new(
                ".google.container.v1.SecurityPostureConfig.VulnerabilityMode",
            ))
        }
    }
}

/// Node pool configs that apply to all auto-provisioned node pools
/// in autopilot clusters and node auto-provisioning enabled clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodePoolAutoConfig {
    /// The list of instance tags applied to all nodes. Tags are used to identify
    /// valid sources or targets for network firewalls and are specified by
    /// the client during cluster creation. Each tag within the list
    /// must comply with RFC1035.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_tags: std::option::Option<crate::model::NetworkTags>,

    /// Resource manager tag keys and values to be attached to the nodes
    /// for managing Compute Engine firewalls using Network Firewall Policies.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_manager_tags: std::option::Option<crate::model::ResourceManagerTags>,

    /// NodeKubeletConfig controls the defaults for autoprovisioned node-pools.
    ///
    /// Currently only `insecure_kubelet_readonly_port_enabled` can be set here.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_kubelet_config: std::option::Option<crate::model::NodeKubeletConfig>,

    /// Output only. Configuration options for Linux nodes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub linux_node_config: std::option::Option<crate::model::LinuxNodeConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodePoolAutoConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_tags][crate::model::NodePoolAutoConfig::network_tags].
    pub fn set_network_tags<
        T: std::convert::Into<std::option::Option<crate::model::NetworkTags>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_tags = v.into();
        self
    }

    /// Sets the value of [resource_manager_tags][crate::model::NodePoolAutoConfig::resource_manager_tags].
    pub fn set_resource_manager_tags<
        T: std::convert::Into<std::option::Option<crate::model::ResourceManagerTags>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_manager_tags = v.into();
        self
    }

    /// Sets the value of [node_kubelet_config][crate::model::NodePoolAutoConfig::node_kubelet_config].
    pub fn set_node_kubelet_config<
        T: std::convert::Into<std::option::Option<crate::model::NodeKubeletConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_kubelet_config = v.into();
        self
    }

    /// Sets the value of [linux_node_config][crate::model::NodePoolAutoConfig::linux_node_config].
    pub fn set_linux_node_config<
        T: std::convert::Into<std::option::Option<crate::model::LinuxNodeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.linux_node_config = v.into();
        self
    }
}

impl wkt::message::Message for NodePoolAutoConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodePoolAutoConfig"
    }
}

/// Subset of Nodepool message that has defaults.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodePoolDefaults {
    /// Subset of NodeConfig message that has defaults.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_config_defaults: std::option::Option<crate::model::NodeConfigDefaults>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodePoolDefaults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_config_defaults][crate::model::NodePoolDefaults::node_config_defaults].
    pub fn set_node_config_defaults<
        T: std::convert::Into<std::option::Option<crate::model::NodeConfigDefaults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_config_defaults = v.into();
        self
    }
}

impl wkt::message::Message for NodePoolDefaults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodePoolDefaults"
    }
}

/// Subset of NodeConfig message that has defaults.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeConfigDefaults {
    /// GCFS (Google Container File System, also known as Riptide) options.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcfs_config: std::option::Option<crate::model::GcfsConfig>,

    /// Logging configuration for node pools.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::NodePoolLoggingConfig>,

    /// Parameters for containerd customization.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub containerd_config: std::option::Option<crate::model::ContainerdConfig>,

    /// NodeKubeletConfig controls the defaults for new node-pools.
    ///
    /// Currently only `insecure_kubelet_readonly_port_enabled` can be set here.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_kubelet_config: std::option::Option<crate::model::NodeKubeletConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeConfigDefaults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcfs_config][crate::model::NodeConfigDefaults::gcfs_config].
    pub fn set_gcfs_config<T: std::convert::Into<std::option::Option<crate::model::GcfsConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcfs_config = v.into();
        self
    }

    /// Sets the value of [logging_config][crate::model::NodeConfigDefaults::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::NodePoolLoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [containerd_config][crate::model::NodeConfigDefaults::containerd_config].
    pub fn set_containerd_config<
        T: std::convert::Into<std::option::Option<crate::model::ContainerdConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.containerd_config = v.into();
        self
    }

    /// Sets the value of [node_kubelet_config][crate::model::NodeConfigDefaults::node_kubelet_config].
    pub fn set_node_kubelet_config<
        T: std::convert::Into<std::option::Option<crate::model::NodeKubeletConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_kubelet_config = v.into();
        self
    }
}

impl wkt::message::Message for NodeConfigDefaults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeConfigDefaults"
    }
}

/// ClusterUpdate describes an update to the cluster. Exactly one update can
/// be applied to a cluster with each request, so at most one field can be
/// provided.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterUpdate {
    /// The Kubernetes version to change the nodes to (typically an
    /// upgrade).
    ///
    /// Users may specify either explicit versions offered by
    /// Kubernetes Engine or version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "-": picks the Kubernetes master version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub desired_node_version: std::string::String,

    /// The monitoring service the cluster should use to write metrics.
    /// Currently available options:
    ///
    /// * "monitoring.googleapis.com/kubernetes" - The Cloud Monitoring
    ///   service with a Kubernetes-native resource model
    /// * `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no
    ///   longer available as of GKE 1.15).
    /// * `none` - No metrics will be exported from the cluster.
    ///
    /// If left as an empty string,`monitoring.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `monitoring.googleapis.com` for earlier versions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub desired_monitoring_service: std::string::String,

    /// Configurations for the various addons available to run in the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_addons_config: std::option::Option<crate::model::AddonsConfig>,

    /// The node pool to be upgraded. This field is mandatory if
    /// "desired_node_version", "desired_image_family" or
    /// "desired_node_pool_autoscaling" is specified and there is more than one
    /// node pool on the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub desired_node_pool_id: std::string::String,

    /// The desired image type for the node pool.
    /// NOTE: Set the "desired_node_pool" field as well.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub desired_image_type: std::string::String,

    /// Configuration of etcd encryption.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_database_encryption: std::option::Option<crate::model::DatabaseEncryption>,

    /// Configuration for Workload Identity.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_workload_identity_config: std::option::Option<crate::model::WorkloadIdentityConfig>,

    /// Configuration for issuance of mTLS keys and certificates to Kubernetes
    /// pods.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_mesh_certificates: std::option::Option<crate::model::MeshCertificates>,

    /// Configuration for Shielded Nodes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_shielded_nodes: std::option::Option<crate::model::ShieldedNodes>,

    /// The desired configuration for the fine-grained cost management feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_cost_management_config: std::option::Option<crate::model::CostManagementConfig>,

    /// DNSConfig contains clusterDNS config for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_dns_config: std::option::Option<crate::model::DNSConfig>,

    /// Autoscaler configuration for the node pool specified in
    /// desired_node_pool_id. If there is only one pool in the
    /// cluster and desired_node_pool_id is not provided then
    /// the change applies to that single node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_node_pool_autoscaling: std::option::Option<crate::model::NodePoolAutoscaling>,

    /// The desired list of Google Compute Engine
    /// [zones](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster's nodes should be located.
    ///
    /// This list must always include the cluster's primary zone.
    ///
    /// Warning: changing cluster locations will update the locations of all node
    /// pools and will result in nodes being added and/or removed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub desired_locations: std::vec::Vec<std::string::String>,

    /// The desired configuration options for master authorized networks feature.
    ///
    /// Deprecated: Use
    /// desired_control_plane_endpoints_config.ip_endpoints_config.authorized_networks_config
    /// instead.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub desired_master_authorized_networks_config:
        std::option::Option<crate::model::MasterAuthorizedNetworksConfig>,

    /// Cluster-level autoscaling configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_cluster_autoscaling: std::option::Option<crate::model::ClusterAutoscaling>,

    /// The desired configuration options for the Binary Authorization feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_binary_authorization: std::option::Option<crate::model::BinaryAuthorization>,

    /// The logging service the cluster should use to write logs.
    /// Currently available options:
    ///
    /// * `logging.googleapis.com/kubernetes` - The Cloud Logging
    ///   service with a Kubernetes-native resource model
    /// * `logging.googleapis.com` - The legacy Cloud Logging service (no longer
    ///   available as of GKE 1.15).
    /// * `none` - no logs will be exported from the cluster.
    ///
    /// If left as an empty string,`logging.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub desired_logging_service: std::string::String,

    /// The desired configuration for exporting resource usage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_resource_usage_export_config:
        std::option::Option<crate::model::ResourceUsageExportConfig>,

    /// Cluster-level Vertical Pod Autoscaling configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_vertical_pod_autoscaling: std::option::Option<crate::model::VerticalPodAutoscaling>,

    /// The desired private cluster configuration. master_global_access_config is
    /// the only field that can be changed via this field.
    /// See also
    /// [ClusterUpdate.desired_enable_private_endpoint][google.container.v1.ClusterUpdate.desired_enable_private_endpoint]
    /// for modifying other fields within
    /// [PrivateClusterConfig][google.container.v1.PrivateClusterConfig].
    ///
    /// Deprecated: Use
    /// desired_control_plane_endpoints_config.ip_endpoints_config.global_access
    /// instead.
    ///
    /// [google.container.v1.ClusterUpdate.desired_enable_private_endpoint]: crate::model::ClusterUpdate::desired_enable_private_endpoint
    /// [google.container.v1.PrivateClusterConfig]: crate::model::PrivateClusterConfig
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub desired_private_cluster_config: std::option::Option<crate::model::PrivateClusterConfig>,

    /// The desired config of Intra-node visibility.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_intra_node_visibility_config:
        std::option::Option<crate::model::IntraNodeVisibilityConfig>,

    /// The desired status of whether to disable default sNAT for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_default_snat_status: std::option::Option<crate::model::DefaultSnatStatus>,

    /// The desired release channel configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_release_channel: std::option::Option<crate::model::ReleaseChannel>,

    /// The desired L4 Internal Load Balancer Subsetting configuration.
    #[serde(rename = "desiredL4ilbSubsettingConfig")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_l4ilb_subsetting_config: std::option::Option<crate::model::ILBSubsettingConfig>,

    /// The desired datapath provider for the cluster.
    pub desired_datapath_provider: crate::model::DatapathProvider,

    /// The desired state of IPv6 connectivity to Google Services.
    pub desired_private_ipv6_google_access: crate::model::PrivateIPv6GoogleAccess,

    /// The desired notification configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_notification_config: std::option::Option<crate::model::NotificationConfig>,

    /// The desired authenticator groups config for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_authenticator_groups_config:
        std::option::Option<crate::model::AuthenticatorGroupsConfig>,

    /// The desired logging configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// The desired monitoring configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_monitoring_config: std::option::Option<crate::model::MonitoringConfig>,

    /// The desired Identity Service component configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_identity_service_config: std::option::Option<crate::model::IdentityServiceConfig>,

    /// ServiceExternalIPsConfig specifies the config for the use of Services with
    /// ExternalIPs field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_service_external_ips_config:
        std::option::Option<crate::model::ServiceExternalIPsConfig>,

    /// Enable/Disable private endpoint for the cluster's master.
    ///
    /// Deprecated: Use
    /// desired_control_plane_endpoints_config.ip_endpoints_config.enable_public_endpoint
    /// instead. Note that the value of enable_public_endpoint is reversed: if
    /// enable_private_endpoint is false, then enable_public_endpoint will be true.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub desired_enable_private_endpoint: std::option::Option<bool>,

    /// Override the default setting of whether future created
    /// nodes have private IP addresses only, namely
    /// [NetworkConfig.default_enable_private_nodes][google.container.v1.NetworkConfig.default_enable_private_nodes]
    ///
    /// [google.container.v1.NetworkConfig.default_enable_private_nodes]: crate::model::NetworkConfig::default_enable_private_nodes
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_default_enable_private_nodes: std::option::Option<bool>,

    /// [Control plane
    /// endpoints][google.container.v1.Cluster.control_plane_endpoints_config]
    /// configuration.
    ///
    /// [google.container.v1.Cluster.control_plane_endpoints_config]: crate::model::Cluster::control_plane_endpoints_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_control_plane_endpoints_config:
        std::option::Option<crate::model::ControlPlaneEndpointsConfig>,

    /// The Kubernetes version to change the master to.
    ///
    /// Users may specify either explicit versions offered by
    /// Kubernetes Engine or version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "-": picks the default Kubernetes version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub desired_master_version: std::string::String,

    /// The desired GCFS config for the cluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_gcfs_config: std::option::Option<crate::model::GcfsConfig>,

    /// The desired network tags that apply to all auto-provisioned node pools
    /// in autopilot clusters and node auto-provisioning enabled clusters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_node_pool_auto_config_network_tags: std::option::Option<crate::model::NetworkTags>,

    /// The desired config of Gateway API on this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_gateway_api_config: std::option::Option<crate::model::GatewayAPIConfig>,

    /// The current etag of the cluster.
    /// If an etag is provided and does not match the current etag of the cluster,
    /// update will be blocked and an ABORTED error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The desired node pool logging configuration defaults for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_node_pool_logging_config: std::option::Option<crate::model::NodePoolLoggingConfig>,

    /// The desired fleet configuration for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_fleet: std::option::Option<crate::model::Fleet>,

    /// The desired stack type of the cluster.
    /// If a stack type is provided and does not match the current stack type of
    /// the cluster, update will attempt to change the stack type to the new type.
    pub desired_stack_type: crate::model::StackType,

    /// The additional pod ranges to be added to the cluster. These pod ranges
    /// can be used by node pools to allocate pod IPs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub additional_pod_ranges_config: std::option::Option<crate::model::AdditionalPodRangesConfig>,

    /// The additional pod ranges that are to be removed from the cluster.
    /// The pod ranges specified here must have been specified earlier in the
    /// 'additional_pod_ranges_config' argument.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub removed_additional_pod_ranges_config:
        std::option::Option<crate::model::AdditionalPodRangesConfig>,

    /// Kubernetes open source beta apis enabled on the cluster. Only beta apis
    #[serde(rename = "enableK8sBetaApis")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_k8s_beta_apis: std::option::Option<crate::model::K8sBetaAPIConfig>,

    /// Enable/Disable Security Posture API features for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_security_posture_config: std::option::Option<crate::model::SecurityPostureConfig>,

    /// The desired network performance config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_network_performance_config:
        std::option::Option<crate::model::network_config::ClusterNetworkPerformanceConfig>,

    /// Enable/Disable FQDN Network Policy for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_enable_fqdn_network_policy: std::option::Option<bool>,

    /// The desired workload policy configuration for the autopilot cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_autopilot_workload_policy_config:
        std::option::Option<crate::model::WorkloadPolicyConfig>,

    /// Desired Beta APIs to be enabled for cluster.
    #[serde(rename = "desiredK8sBetaApis")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_k8s_beta_apis: std::option::Option<crate::model::K8sBetaAPIConfig>,

    /// The desired containerd config for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_containerd_config: std::option::Option<crate::model::ContainerdConfig>,

    /// Enable/Disable Multi-Networking for the cluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_enable_multi_networking: std::option::Option<bool>,

    /// The desired resource manager tags that apply to all auto-provisioned node
    /// pools in autopilot clusters and node auto-provisioning enabled clusters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_node_pool_auto_config_resource_manager_tags:
        std::option::Option<crate::model::ResourceManagerTags>,

    /// Specify the details of in-transit encryption.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_in_transit_encryption_config:
        std::option::Option<crate::model::InTransitEncryptionConfig>,

    /// Enable/Disable Cilium Clusterwide Network Policy for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_enable_cilium_clusterwide_network_policy: std::option::Option<bool>,

    /// Enable/Disable Secret Manager Config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_secret_manager_config: std::option::Option<crate::model::SecretManagerConfig>,

    /// Enable/Disable Compliance Posture features for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_compliance_posture_config:
        std::option::Option<crate::model::CompliancePostureConfig>,

    /// The desired node kubelet config for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_node_kubelet_config: std::option::Option<crate::model::NodeKubeletConfig>,

    /// The desired node kubelet config for all auto-provisioned node pools
    /// in autopilot clusters and node auto-provisioning enabled clusters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_node_pool_auto_config_kubelet_config:
        std::option::Option<crate::model::NodeKubeletConfig>,

    /// The Custom keys configuration for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_managed_keys_config: std::option::Option<crate::model::UserManagedKeysConfig>,

    /// RBACBindingConfig allows user to restrict ClusterRoleBindings an
    /// RoleBindings that can be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_rbac_binding_config: std::option::Option<crate::model::RBACBindingConfig>,

    /// The desired enterprise configuration for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_enterprise_config: std::option::Option<crate::model::DesiredEnterpriseConfig>,

    /// The desired Linux node config for all auto-provisioned node pools
    /// in autopilot clusters and node auto-provisioning enabled clusters.
    ///
    /// Currently only `cgroup_mode` can be set here.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub desired_node_pool_auto_config_linux_node_config:
        std::option::Option<crate::model::LinuxNodeConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterUpdate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [desired_node_version][crate::model::ClusterUpdate::desired_node_version].
    pub fn set_desired_node_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_node_version = v.into();
        self
    }

    /// Sets the value of [desired_monitoring_service][crate::model::ClusterUpdate::desired_monitoring_service].
    pub fn set_desired_monitoring_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_monitoring_service = v.into();
        self
    }

    /// Sets the value of [desired_addons_config][crate::model::ClusterUpdate::desired_addons_config].
    pub fn set_desired_addons_config<
        T: std::convert::Into<std::option::Option<crate::model::AddonsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_addons_config = v.into();
        self
    }

    /// Sets the value of [desired_node_pool_id][crate::model::ClusterUpdate::desired_node_pool_id].
    pub fn set_desired_node_pool_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_node_pool_id = v.into();
        self
    }

    /// Sets the value of [desired_image_type][crate::model::ClusterUpdate::desired_image_type].
    pub fn set_desired_image_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_image_type = v.into();
        self
    }

    /// Sets the value of [desired_database_encryption][crate::model::ClusterUpdate::desired_database_encryption].
    pub fn set_desired_database_encryption<
        T: std::convert::Into<std::option::Option<crate::model::DatabaseEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_database_encryption = v.into();
        self
    }

    /// Sets the value of [desired_workload_identity_config][crate::model::ClusterUpdate::desired_workload_identity_config].
    pub fn set_desired_workload_identity_config<
        T: std::convert::Into<std::option::Option<crate::model::WorkloadIdentityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_workload_identity_config = v.into();
        self
    }

    /// Sets the value of [desired_mesh_certificates][crate::model::ClusterUpdate::desired_mesh_certificates].
    pub fn set_desired_mesh_certificates<
        T: std::convert::Into<std::option::Option<crate::model::MeshCertificates>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_mesh_certificates = v.into();
        self
    }

    /// Sets the value of [desired_shielded_nodes][crate::model::ClusterUpdate::desired_shielded_nodes].
    pub fn set_desired_shielded_nodes<
        T: std::convert::Into<std::option::Option<crate::model::ShieldedNodes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_shielded_nodes = v.into();
        self
    }

    /// Sets the value of [desired_cost_management_config][crate::model::ClusterUpdate::desired_cost_management_config].
    pub fn set_desired_cost_management_config<
        T: std::convert::Into<std::option::Option<crate::model::CostManagementConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_cost_management_config = v.into();
        self
    }

    /// Sets the value of [desired_dns_config][crate::model::ClusterUpdate::desired_dns_config].
    pub fn set_desired_dns_config<
        T: std::convert::Into<std::option::Option<crate::model::DNSConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_dns_config = v.into();
        self
    }

    /// Sets the value of [desired_node_pool_autoscaling][crate::model::ClusterUpdate::desired_node_pool_autoscaling].
    pub fn set_desired_node_pool_autoscaling<
        T: std::convert::Into<std::option::Option<crate::model::NodePoolAutoscaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_node_pool_autoscaling = v.into();
        self
    }

    /// Sets the value of [desired_locations][crate::model::ClusterUpdate::desired_locations].
    pub fn set_desired_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.desired_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [desired_master_authorized_networks_config][crate::model::ClusterUpdate::desired_master_authorized_networks_config].
    #[deprecated]
    pub fn set_desired_master_authorized_networks_config<
        T: std::convert::Into<std::option::Option<crate::model::MasterAuthorizedNetworksConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_master_authorized_networks_config = v.into();
        self
    }

    /// Sets the value of [desired_cluster_autoscaling][crate::model::ClusterUpdate::desired_cluster_autoscaling].
    pub fn set_desired_cluster_autoscaling<
        T: std::convert::Into<std::option::Option<crate::model::ClusterAutoscaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_cluster_autoscaling = v.into();
        self
    }

    /// Sets the value of [desired_binary_authorization][crate::model::ClusterUpdate::desired_binary_authorization].
    pub fn set_desired_binary_authorization<
        T: std::convert::Into<std::option::Option<crate::model::BinaryAuthorization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_binary_authorization = v.into();
        self
    }

    /// Sets the value of [desired_logging_service][crate::model::ClusterUpdate::desired_logging_service].
    pub fn set_desired_logging_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_logging_service = v.into();
        self
    }

    /// Sets the value of [desired_resource_usage_export_config][crate::model::ClusterUpdate::desired_resource_usage_export_config].
    pub fn set_desired_resource_usage_export_config<
        T: std::convert::Into<std::option::Option<crate::model::ResourceUsageExportConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_resource_usage_export_config = v.into();
        self
    }

    /// Sets the value of [desired_vertical_pod_autoscaling][crate::model::ClusterUpdate::desired_vertical_pod_autoscaling].
    pub fn set_desired_vertical_pod_autoscaling<
        T: std::convert::Into<std::option::Option<crate::model::VerticalPodAutoscaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_vertical_pod_autoscaling = v.into();
        self
    }

    /// Sets the value of [desired_private_cluster_config][crate::model::ClusterUpdate::desired_private_cluster_config].
    #[deprecated]
    pub fn set_desired_private_cluster_config<
        T: std::convert::Into<std::option::Option<crate::model::PrivateClusterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_private_cluster_config = v.into();
        self
    }

    /// Sets the value of [desired_intra_node_visibility_config][crate::model::ClusterUpdate::desired_intra_node_visibility_config].
    pub fn set_desired_intra_node_visibility_config<
        T: std::convert::Into<std::option::Option<crate::model::IntraNodeVisibilityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_intra_node_visibility_config = v.into();
        self
    }

    /// Sets the value of [desired_default_snat_status][crate::model::ClusterUpdate::desired_default_snat_status].
    pub fn set_desired_default_snat_status<
        T: std::convert::Into<std::option::Option<crate::model::DefaultSnatStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_default_snat_status = v.into();
        self
    }

    /// Sets the value of [desired_release_channel][crate::model::ClusterUpdate::desired_release_channel].
    pub fn set_desired_release_channel<
        T: std::convert::Into<std::option::Option<crate::model::ReleaseChannel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_release_channel = v.into();
        self
    }

    /// Sets the value of [desired_l4ilb_subsetting_config][crate::model::ClusterUpdate::desired_l4ilb_subsetting_config].
    pub fn set_desired_l4ilb_subsetting_config<
        T: std::convert::Into<std::option::Option<crate::model::ILBSubsettingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_l4ilb_subsetting_config = v.into();
        self
    }

    /// Sets the value of [desired_datapath_provider][crate::model::ClusterUpdate::desired_datapath_provider].
    pub fn set_desired_datapath_provider<T: std::convert::Into<crate::model::DatapathProvider>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_datapath_provider = v.into();
        self
    }

    /// Sets the value of [desired_private_ipv6_google_access][crate::model::ClusterUpdate::desired_private_ipv6_google_access].
    pub fn set_desired_private_ipv6_google_access<
        T: std::convert::Into<crate::model::PrivateIPv6GoogleAccess>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_private_ipv6_google_access = v.into();
        self
    }

    /// Sets the value of [desired_notification_config][crate::model::ClusterUpdate::desired_notification_config].
    pub fn set_desired_notification_config<
        T: std::convert::Into<std::option::Option<crate::model::NotificationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_notification_config = v.into();
        self
    }

    /// Sets the value of [desired_authenticator_groups_config][crate::model::ClusterUpdate::desired_authenticator_groups_config].
    pub fn set_desired_authenticator_groups_config<
        T: std::convert::Into<std::option::Option<crate::model::AuthenticatorGroupsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_authenticator_groups_config = v.into();
        self
    }

    /// Sets the value of [desired_logging_config][crate::model::ClusterUpdate::desired_logging_config].
    pub fn set_desired_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_logging_config = v.into();
        self
    }

    /// Sets the value of [desired_monitoring_config][crate::model::ClusterUpdate::desired_monitoring_config].
    pub fn set_desired_monitoring_config<
        T: std::convert::Into<std::option::Option<crate::model::MonitoringConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_monitoring_config = v.into();
        self
    }

    /// Sets the value of [desired_identity_service_config][crate::model::ClusterUpdate::desired_identity_service_config].
    pub fn set_desired_identity_service_config<
        T: std::convert::Into<std::option::Option<crate::model::IdentityServiceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_identity_service_config = v.into();
        self
    }

    /// Sets the value of [desired_service_external_ips_config][crate::model::ClusterUpdate::desired_service_external_ips_config].
    pub fn set_desired_service_external_ips_config<
        T: std::convert::Into<std::option::Option<crate::model::ServiceExternalIPsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_service_external_ips_config = v.into();
        self
    }

    /// Sets the value of [desired_enable_private_endpoint][crate::model::ClusterUpdate::desired_enable_private_endpoint].
    #[deprecated]
    pub fn set_desired_enable_private_endpoint<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_enable_private_endpoint = v.into();
        self
    }

    /// Sets the value of [desired_default_enable_private_nodes][crate::model::ClusterUpdate::desired_default_enable_private_nodes].
    pub fn set_desired_default_enable_private_nodes<
        T: std::convert::Into<std::option::Option<bool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_default_enable_private_nodes = v.into();
        self
    }

    /// Sets the value of [desired_control_plane_endpoints_config][crate::model::ClusterUpdate::desired_control_plane_endpoints_config].
    pub fn set_desired_control_plane_endpoints_config<
        T: std::convert::Into<std::option::Option<crate::model::ControlPlaneEndpointsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_control_plane_endpoints_config = v.into();
        self
    }

    /// Sets the value of [desired_master_version][crate::model::ClusterUpdate::desired_master_version].
    pub fn set_desired_master_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_master_version = v.into();
        self
    }

    /// Sets the value of [desired_gcfs_config][crate::model::ClusterUpdate::desired_gcfs_config].
    pub fn set_desired_gcfs_config<
        T: std::convert::Into<std::option::Option<crate::model::GcfsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_gcfs_config = v.into();
        self
    }

    /// Sets the value of [desired_node_pool_auto_config_network_tags][crate::model::ClusterUpdate::desired_node_pool_auto_config_network_tags].
    pub fn set_desired_node_pool_auto_config_network_tags<
        T: std::convert::Into<std::option::Option<crate::model::NetworkTags>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_node_pool_auto_config_network_tags = v.into();
        self
    }

    /// Sets the value of [desired_gateway_api_config][crate::model::ClusterUpdate::desired_gateway_api_config].
    pub fn set_desired_gateway_api_config<
        T: std::convert::Into<std::option::Option<crate::model::GatewayAPIConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_gateway_api_config = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::ClusterUpdate::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [desired_node_pool_logging_config][crate::model::ClusterUpdate::desired_node_pool_logging_config].
    pub fn set_desired_node_pool_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::NodePoolLoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_node_pool_logging_config = v.into();
        self
    }

    /// Sets the value of [desired_fleet][crate::model::ClusterUpdate::desired_fleet].
    pub fn set_desired_fleet<T: std::convert::Into<std::option::Option<crate::model::Fleet>>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_fleet = v.into();
        self
    }

    /// Sets the value of [desired_stack_type][crate::model::ClusterUpdate::desired_stack_type].
    pub fn set_desired_stack_type<T: std::convert::Into<crate::model::StackType>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_stack_type = v.into();
        self
    }

    /// Sets the value of [additional_pod_ranges_config][crate::model::ClusterUpdate::additional_pod_ranges_config].
    pub fn set_additional_pod_ranges_config<
        T: std::convert::Into<std::option::Option<crate::model::AdditionalPodRangesConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.additional_pod_ranges_config = v.into();
        self
    }

    /// Sets the value of [removed_additional_pod_ranges_config][crate::model::ClusterUpdate::removed_additional_pod_ranges_config].
    pub fn set_removed_additional_pod_ranges_config<
        T: std::convert::Into<std::option::Option<crate::model::AdditionalPodRangesConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.removed_additional_pod_ranges_config = v.into();
        self
    }

    /// Sets the value of [enable_k8s_beta_apis][crate::model::ClusterUpdate::enable_k8s_beta_apis].
    pub fn set_enable_k8s_beta_apis<
        T: std::convert::Into<std::option::Option<crate::model::K8sBetaAPIConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enable_k8s_beta_apis = v.into();
        self
    }

    /// Sets the value of [desired_security_posture_config][crate::model::ClusterUpdate::desired_security_posture_config].
    pub fn set_desired_security_posture_config<
        T: std::convert::Into<std::option::Option<crate::model::SecurityPostureConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_security_posture_config = v.into();
        self
    }

    /// Sets the value of [desired_network_performance_config][crate::model::ClusterUpdate::desired_network_performance_config].
    pub fn set_desired_network_performance_config<
        T: std::convert::Into<
                std::option::Option<crate::model::network_config::ClusterNetworkPerformanceConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_network_performance_config = v.into();
        self
    }

    /// Sets the value of [desired_enable_fqdn_network_policy][crate::model::ClusterUpdate::desired_enable_fqdn_network_policy].
    pub fn set_desired_enable_fqdn_network_policy<
        T: std::convert::Into<std::option::Option<bool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_enable_fqdn_network_policy = v.into();
        self
    }

    /// Sets the value of [desired_autopilot_workload_policy_config][crate::model::ClusterUpdate::desired_autopilot_workload_policy_config].
    pub fn set_desired_autopilot_workload_policy_config<
        T: std::convert::Into<std::option::Option<crate::model::WorkloadPolicyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_autopilot_workload_policy_config = v.into();
        self
    }

    /// Sets the value of [desired_k8s_beta_apis][crate::model::ClusterUpdate::desired_k8s_beta_apis].
    pub fn set_desired_k8s_beta_apis<
        T: std::convert::Into<std::option::Option<crate::model::K8sBetaAPIConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_k8s_beta_apis = v.into();
        self
    }

    /// Sets the value of [desired_containerd_config][crate::model::ClusterUpdate::desired_containerd_config].
    pub fn set_desired_containerd_config<
        T: std::convert::Into<std::option::Option<crate::model::ContainerdConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_containerd_config = v.into();
        self
    }

    /// Sets the value of [desired_enable_multi_networking][crate::model::ClusterUpdate::desired_enable_multi_networking].
    pub fn set_desired_enable_multi_networking<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_enable_multi_networking = v.into();
        self
    }

    /// Sets the value of [desired_node_pool_auto_config_resource_manager_tags][crate::model::ClusterUpdate::desired_node_pool_auto_config_resource_manager_tags].
    pub fn set_desired_node_pool_auto_config_resource_manager_tags<
        T: std::convert::Into<std::option::Option<crate::model::ResourceManagerTags>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_node_pool_auto_config_resource_manager_tags = v.into();
        self
    }

    /// Sets the value of [desired_in_transit_encryption_config][crate::model::ClusterUpdate::desired_in_transit_encryption_config].
    pub fn set_desired_in_transit_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::InTransitEncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_in_transit_encryption_config = v.into();
        self
    }

    /// Sets the value of [desired_enable_cilium_clusterwide_network_policy][crate::model::ClusterUpdate::desired_enable_cilium_clusterwide_network_policy].
    pub fn set_desired_enable_cilium_clusterwide_network_policy<
        T: std::convert::Into<std::option::Option<bool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_enable_cilium_clusterwide_network_policy = v.into();
        self
    }

    /// Sets the value of [desired_secret_manager_config][crate::model::ClusterUpdate::desired_secret_manager_config].
    pub fn set_desired_secret_manager_config<
        T: std::convert::Into<std::option::Option<crate::model::SecretManagerConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_secret_manager_config = v.into();
        self
    }

    /// Sets the value of [desired_compliance_posture_config][crate::model::ClusterUpdate::desired_compliance_posture_config].
    pub fn set_desired_compliance_posture_config<
        T: std::convert::Into<std::option::Option<crate::model::CompliancePostureConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_compliance_posture_config = v.into();
        self
    }

    /// Sets the value of [desired_node_kubelet_config][crate::model::ClusterUpdate::desired_node_kubelet_config].
    pub fn set_desired_node_kubelet_config<
        T: std::convert::Into<std::option::Option<crate::model::NodeKubeletConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_node_kubelet_config = v.into();
        self
    }

    /// Sets the value of [desired_node_pool_auto_config_kubelet_config][crate::model::ClusterUpdate::desired_node_pool_auto_config_kubelet_config].
    pub fn set_desired_node_pool_auto_config_kubelet_config<
        T: std::convert::Into<std::option::Option<crate::model::NodeKubeletConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_node_pool_auto_config_kubelet_config = v.into();
        self
    }

    /// Sets the value of [user_managed_keys_config][crate::model::ClusterUpdate::user_managed_keys_config].
    pub fn set_user_managed_keys_config<
        T: std::convert::Into<std::option::Option<crate::model::UserManagedKeysConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_managed_keys_config = v.into();
        self
    }

    /// Sets the value of [desired_rbac_binding_config][crate::model::ClusterUpdate::desired_rbac_binding_config].
    pub fn set_desired_rbac_binding_config<
        T: std::convert::Into<std::option::Option<crate::model::RBACBindingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_rbac_binding_config = v.into();
        self
    }

    /// Sets the value of [desired_enterprise_config][crate::model::ClusterUpdate::desired_enterprise_config].
    pub fn set_desired_enterprise_config<
        T: std::convert::Into<std::option::Option<crate::model::DesiredEnterpriseConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_enterprise_config = v.into();
        self
    }

    /// Sets the value of [desired_node_pool_auto_config_linux_node_config][crate::model::ClusterUpdate::desired_node_pool_auto_config_linux_node_config].
    pub fn set_desired_node_pool_auto_config_linux_node_config<
        T: std::convert::Into<std::option::Option<crate::model::LinuxNodeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_node_pool_auto_config_linux_node_config = v.into();
        self
    }
}

impl wkt::message::Message for ClusterUpdate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ClusterUpdate"
    }
}

/// AdditionalPodRangesConfig is the configuration for additional pod secondary
/// ranges supporting the ClusterUpdate message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdditionalPodRangesConfig {
    /// Name for pod secondary ipv4 range which has the actual range defined ahead.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pod_range_names: std::vec::Vec<std::string::String>,

    /// Output only. Information for additional pod range.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pod_range_info: std::vec::Vec<crate::model::RangeInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdditionalPodRangesConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pod_range_names][crate::model::AdditionalPodRangesConfig::pod_range_names].
    pub fn set_pod_range_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pod_range_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pod_range_info][crate::model::AdditionalPodRangesConfig::pod_range_info].
    pub fn set_pod_range_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RangeInfo>,
    {
        use std::iter::Iterator;
        self.pod_range_info = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AdditionalPodRangesConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AdditionalPodRangesConfig"
    }
}

/// RangeInfo contains the range name and the range utilization by this cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RangeInfo {
    /// Output only. Name of a range.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub range_name: std::string::String,

    /// Output only. The utilization of the range.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub utilization: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RangeInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [range_name][crate::model::RangeInfo::range_name].
    pub fn set_range_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.range_name = v.into();
        self
    }

    /// Sets the value of [utilization][crate::model::RangeInfo::utilization].
    pub fn set_utilization<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.utilization = v.into();
        self
    }
}

impl wkt::message::Message for RangeInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.RangeInfo"
    }
}

/// DesiredEnterpriseConfig is a wrapper used for updating enterprise_config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DesiredEnterpriseConfig {
    /// desired_tier specifies the desired tier of the cluster.
    pub desired_tier: crate::model::enterprise_config::ClusterTier,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DesiredEnterpriseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [desired_tier][crate::model::DesiredEnterpriseConfig::desired_tier].
    pub fn set_desired_tier<T: std::convert::Into<crate::model::enterprise_config::ClusterTier>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_tier = v.into();
        self
    }
}

impl wkt::message::Message for DesiredEnterpriseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DesiredEnterpriseConfig"
    }
}

/// This operation resource represents operations that may have happened or are
/// happening on the cluster. All fields are output only.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Operation {
    /// Output only. The server-assigned ID for the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// operation is taking place. This field is deprecated, use location instead.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Output only. The operation type.
    pub operation_type: crate::model::operation::Type,

    /// Output only. The current status of the operation.
    pub status: crate::model::operation::Status,

    /// Output only. Detailed operation progress, if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub detail: std::string::String,

    /// Output only. If an error has occurred, a textual description of the error.
    /// Deprecated. Use the field error instead.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub status_message: std::string::String,

    /// Output only. Server-defined URI for the operation. Example:
    /// `<https://container.googleapis.com/v1alpha1/projects/123/locations/us-central1/operations/operation-123>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    /// Output only. Server-defined URI for the target of the operation. The format
    /// of this is a URI to the resource being modified (such as a cluster, node
    /// pool, or node). For node pool repairs, there may be multiple nodes being
    /// repaired, but only one will be the target.
    ///
    /// Examples:
    ///
    ///
    /// ##
    ///
    /// `<https://container.googleapis.com/v1/projects/123/locations/us-central1/clusters/my-cluster>`
    ///
    /// ##
    ///
    /// `<https://container.googleapis.com/v1/projects/123/zones/us-central1-c/clusters/my-cluster/nodePools/my-np>`
    ///
    /// `<https://container.googleapis.com/v1/projects/123/zones/us-central1-c/clusters/my-cluster/nodePools/my-np/node/my-node>`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_link: std::string::String,

    /// Output only. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
    /// or
    /// [region](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
    /// in which the cluster resides.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Output only. The time the operation started, in
    /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub start_time: std::string::String,

    /// Output only. The time the operation completed, in
    /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub end_time: std::string::String,

    /// Output only. Progress information for an operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress: std::option::Option<crate::model::OperationProgress>,

    /// Which conditions caused the current cluster state.
    /// Deprecated. Use field error instead.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[deprecated]
    pub cluster_conditions: std::vec::Vec<crate::model::StatusCondition>,

    /// Which conditions caused the current node pool state.
    /// Deprecated. Use field error instead.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[deprecated]
    pub nodepool_conditions: std::vec::Vec<crate::model::StatusCondition>,

    /// The error result of the operation in case of failure.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Operation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Operation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::Operation::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [operation_type][crate::model::Operation::operation_type].
    pub fn set_operation_type<T: std::convert::Into<crate::model::operation::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Operation::status].
    pub fn set_status<T: std::convert::Into<crate::model::operation::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::Operation::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::Operation::status_message].
    #[deprecated]
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::Operation::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [target_link][crate::model::Operation::target_link].
    pub fn set_target_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_link = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Operation::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Operation::start_time].
    pub fn set_start_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Operation::end_time].
    pub fn set_end_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [progress][crate::model::Operation::progress].
    pub fn set_progress<
        T: std::convert::Into<std::option::Option<crate::model::OperationProgress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress = v.into();
        self
    }

    /// Sets the value of [cluster_conditions][crate::model::Operation::cluster_conditions].
    #[deprecated]
    pub fn set_cluster_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StatusCondition>,
    {
        use std::iter::Iterator;
        self.cluster_conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [nodepool_conditions][crate::model::Operation::nodepool_conditions].
    #[deprecated]
    pub fn set_nodepool_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StatusCondition>,
    {
        use std::iter::Iterator;
        self.nodepool_conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error][crate::model::Operation::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }
}

impl wkt::message::Message for Operation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.Operation"
    }
}

/// Defines additional types related to [Operation].
pub mod operation {
    #[allow(unused_imports)]
    use super::*;

    /// Current status of the operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Not set.
        Unspecified,
        /// The operation has been created.
        Pending,
        /// The operation is currently running.
        Running,
        /// The operation is done, either cancelled or completed.
        Done,
        /// The operation is aborting.
        Aborting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Done => std::option::Option::Some(3),
                Self::Aborting => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::Aborting => std::option::Option::Some("ABORTING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Done,
                4 => Self::Aborting,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                "ABORTING" => Self::Aborting,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Done => serializer.serialize_i32(3),
                Self::Aborting => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.container.v1.Operation.Status",
            ))
        }
    }

    /// Operation type categorizes the operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Not set.
        Unspecified,
        /// The cluster is being created. The cluster should be assumed to be
        /// unusable until the operation finishes.
        ///
        /// In the event of the operation failing, the cluster will enter the [ERROR
        /// state][Cluster.Status.ERROR] and eventually be deleted.
        ///
        /// [Cluster.Status.ERROR]: crate::model::cluster::Status::Error
        CreateCluster,
        /// The cluster is being deleted. The cluster should be assumed to be
        /// unusable as soon as this operation starts.
        ///
        /// In the event of the operation failing, the cluster will enter the [ERROR
        /// state][Cluster.Status.ERROR] and the deletion will be automatically
        /// retried until completed.
        ///
        /// [Cluster.Status.ERROR]: crate::model::cluster::Status::Error
        DeleteCluster,
        /// The [cluster
        /// version][google.container.v1.ClusterUpdate.desired_master_version] is
        /// being updated. Note that this includes "upgrades" to the same version,
        /// which are simply a recreation. This also includes
        /// [auto-upgrades](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-upgrades#upgrading_automatically).
        /// For more details, see [documentation on cluster
        /// upgrades](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-upgrades#cluster_upgrades).
        ///
        /// [google.container.v1.ClusterUpdate.desired_master_version]: crate::model::ClusterUpdate::desired_master_version
        UpgradeMaster,
        /// A node pool is being updated. Despite calling this an "upgrade", this
        /// includes most forms of updates to node pools. This also includes
        /// [auto-upgrades](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-upgrades).
        ///
        /// This operation sets the
        /// [progress][google.container.v1.Operation.progress] field and may be
        /// [canceled][google.container.v1.ClusterManager.CancelOperation].
        ///
        /// The upgrade strategy depends on [node pool
        /// configuration](https://cloud.google.com/kubernetes-engine/docs/concepts/node-pool-upgrade-strategies).
        /// The nodes are generally still usable during this operation.
        ///
        /// [google.container.v1.ClusterManager.CancelOperation]: crate::client::ClusterManager::cancel_operation
        /// [google.container.v1.Operation.progress]: crate::model::Operation::progress
        UpgradeNodes,
        /// A problem has been detected with the control plane and is being repaired.
        /// This operation type is initiated by GKE. For more details, see
        /// [documentation on
        /// repairs](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions#repairs).
        RepairCluster,
        /// The cluster is being updated. This is a broad category of operations and
        /// includes operations that only change metadata as well as those that must
        /// recreate the entire cluster. If the control plane must be recreated, this
        /// will cause temporary downtime for zonal clusters.
        ///
        /// Some features require recreating the nodes as well. Those will be
        /// recreated as separate operations and the update may not be completely
        /// functional until the node pools recreations finish. Node recreations will
        /// generally follow [maintenance
        /// policies](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions).
        ///
        /// Some GKE-initiated operations use this type. This includes certain types
        /// of auto-upgrades and incident mitigations.
        UpdateCluster,
        /// A node pool is being created. The node pool should be assumed to be
        /// unusable until this operation finishes. In the event of an error, the
        /// node pool may be partially created.
        ///
        /// If enabled, [node
        /// autoprovisioning](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning)
        /// may have automatically initiated such operations.
        CreateNodePool,
        /// The node pool is being deleted. The node pool should be assumed to be
        /// unusable as soon as this operation starts.
        DeleteNodePool,
        /// The node pool's [manamagent][google.container.v1.NodePool.management]
        /// field is being updated. These operations only update metadata and may be
        /// concurrent with most other operations.
        ///
        /// [google.container.v1.NodePool.management]: crate::model::NodePool::management
        SetNodePoolManagement,
        /// A problem has been detected with nodes and [they are being
        /// repaired](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-repair).
        /// This operation type is initiated by GKE, typically automatically. This
        /// operation may be concurrent with other operations and there may be
        /// multiple repairs occurring on the same node pool.
        AutoRepairNodes,
        /// Unused. Automatic node upgrade uses
        /// [UPGRADE_NODES][google.container.v1.Operation.Type.UPGRADE_NODES].
        ///
        /// [google.container.v1.Operation.Type.UPGRADE_NODES]: crate::model::operation::Type::UpgradeNodes
        #[deprecated]
        AutoUpgradeNodes,
        /// Unused. Updating labels uses
        /// [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
        ///
        /// [google.container.v1.Operation.Type.UPDATE_CLUSTER]: crate::model::operation::Type::UpdateCluster
        #[deprecated]
        SetLabels,
        /// Unused. Updating master auth uses
        /// [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
        ///
        /// [google.container.v1.Operation.Type.UPDATE_CLUSTER]: crate::model::operation::Type::UpdateCluster
        #[deprecated]
        SetMasterAuth,
        /// The node pool is being resized. With the exception of resizing to or from
        /// size zero, the node pool is generally usable during this operation.
        SetNodePoolSize,
        /// Unused. Updating network policy uses
        /// [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
        ///
        /// [google.container.v1.Operation.Type.UPDATE_CLUSTER]: crate::model::operation::Type::UpdateCluster
        #[deprecated]
        SetNetworkPolicy,
        /// Unused. Updating maintenance policy uses
        /// [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
        ///
        /// [google.container.v1.Operation.Type.UPDATE_CLUSTER]: crate::model::operation::Type::UpdateCluster
        #[deprecated]
        SetMaintenancePolicy,
        /// The control plane is being resized. This operation type is initiated by
        /// GKE. These operations are often performed preemptively to ensure that the
        /// control plane has sufficient resources and is not typically an indication
        /// of issues. For more details, see
        /// [documentation on
        /// resizes](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions#repairs).
        ResizeCluster,
        /// Fleet features of GKE Enterprise are being upgraded. The cluster should
        /// be assumed to be blocked for other upgrades until the operation finishes.
        FleetFeatureUpgrade,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CreateCluster => std::option::Option::Some(1),
                Self::DeleteCluster => std::option::Option::Some(2),
                Self::UpgradeMaster => std::option::Option::Some(3),
                Self::UpgradeNodes => std::option::Option::Some(4),
                Self::RepairCluster => std::option::Option::Some(5),
                Self::UpdateCluster => std::option::Option::Some(6),
                Self::CreateNodePool => std::option::Option::Some(7),
                Self::DeleteNodePool => std::option::Option::Some(8),
                Self::SetNodePoolManagement => std::option::Option::Some(9),
                Self::AutoRepairNodes => std::option::Option::Some(10),
                Self::AutoUpgradeNodes => std::option::Option::Some(11),
                Self::SetLabels => std::option::Option::Some(12),
                Self::SetMasterAuth => std::option::Option::Some(13),
                Self::SetNodePoolSize => std::option::Option::Some(14),
                Self::SetNetworkPolicy => std::option::Option::Some(15),
                Self::SetMaintenancePolicy => std::option::Option::Some(16),
                Self::ResizeCluster => std::option::Option::Some(18),
                Self::FleetFeatureUpgrade => std::option::Option::Some(19),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::CreateCluster => std::option::Option::Some("CREATE_CLUSTER"),
                Self::DeleteCluster => std::option::Option::Some("DELETE_CLUSTER"),
                Self::UpgradeMaster => std::option::Option::Some("UPGRADE_MASTER"),
                Self::UpgradeNodes => std::option::Option::Some("UPGRADE_NODES"),
                Self::RepairCluster => std::option::Option::Some("REPAIR_CLUSTER"),
                Self::UpdateCluster => std::option::Option::Some("UPDATE_CLUSTER"),
                Self::CreateNodePool => std::option::Option::Some("CREATE_NODE_POOL"),
                Self::DeleteNodePool => std::option::Option::Some("DELETE_NODE_POOL"),
                Self::SetNodePoolManagement => {
                    std::option::Option::Some("SET_NODE_POOL_MANAGEMENT")
                }
                Self::AutoRepairNodes => std::option::Option::Some("AUTO_REPAIR_NODES"),
                Self::AutoUpgradeNodes => std::option::Option::Some("AUTO_UPGRADE_NODES"),
                Self::SetLabels => std::option::Option::Some("SET_LABELS"),
                Self::SetMasterAuth => std::option::Option::Some("SET_MASTER_AUTH"),
                Self::SetNodePoolSize => std::option::Option::Some("SET_NODE_POOL_SIZE"),
                Self::SetNetworkPolicy => std::option::Option::Some("SET_NETWORK_POLICY"),
                Self::SetMaintenancePolicy => std::option::Option::Some("SET_MAINTENANCE_POLICY"),
                Self::ResizeCluster => std::option::Option::Some("RESIZE_CLUSTER"),
                Self::FleetFeatureUpgrade => std::option::Option::Some("FLEET_FEATURE_UPGRADE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CreateCluster,
                2 => Self::DeleteCluster,
                3 => Self::UpgradeMaster,
                4 => Self::UpgradeNodes,
                5 => Self::RepairCluster,
                6 => Self::UpdateCluster,
                7 => Self::CreateNodePool,
                8 => Self::DeleteNodePool,
                9 => Self::SetNodePoolManagement,
                10 => Self::AutoRepairNodes,
                11 => Self::AutoUpgradeNodes,
                12 => Self::SetLabels,
                13 => Self::SetMasterAuth,
                14 => Self::SetNodePoolSize,
                15 => Self::SetNetworkPolicy,
                16 => Self::SetMaintenancePolicy,
                18 => Self::ResizeCluster,
                19 => Self::FleetFeatureUpgrade,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "CREATE_CLUSTER" => Self::CreateCluster,
                "DELETE_CLUSTER" => Self::DeleteCluster,
                "UPGRADE_MASTER" => Self::UpgradeMaster,
                "UPGRADE_NODES" => Self::UpgradeNodes,
                "REPAIR_CLUSTER" => Self::RepairCluster,
                "UPDATE_CLUSTER" => Self::UpdateCluster,
                "CREATE_NODE_POOL" => Self::CreateNodePool,
                "DELETE_NODE_POOL" => Self::DeleteNodePool,
                "SET_NODE_POOL_MANAGEMENT" => Self::SetNodePoolManagement,
                "AUTO_REPAIR_NODES" => Self::AutoRepairNodes,
                "AUTO_UPGRADE_NODES" => Self::AutoUpgradeNodes,
                "SET_LABELS" => Self::SetLabels,
                "SET_MASTER_AUTH" => Self::SetMasterAuth,
                "SET_NODE_POOL_SIZE" => Self::SetNodePoolSize,
                "SET_NETWORK_POLICY" => Self::SetNetworkPolicy,
                "SET_MAINTENANCE_POLICY" => Self::SetMaintenancePolicy,
                "RESIZE_CLUSTER" => Self::ResizeCluster,
                "FLEET_FEATURE_UPGRADE" => Self::FleetFeatureUpgrade,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CreateCluster => serializer.serialize_i32(1),
                Self::DeleteCluster => serializer.serialize_i32(2),
                Self::UpgradeMaster => serializer.serialize_i32(3),
                Self::UpgradeNodes => serializer.serialize_i32(4),
                Self::RepairCluster => serializer.serialize_i32(5),
                Self::UpdateCluster => serializer.serialize_i32(6),
                Self::CreateNodePool => serializer.serialize_i32(7),
                Self::DeleteNodePool => serializer.serialize_i32(8),
                Self::SetNodePoolManagement => serializer.serialize_i32(9),
                Self::AutoRepairNodes => serializer.serialize_i32(10),
                Self::AutoUpgradeNodes => serializer.serialize_i32(11),
                Self::SetLabels => serializer.serialize_i32(12),
                Self::SetMasterAuth => serializer.serialize_i32(13),
                Self::SetNodePoolSize => serializer.serialize_i32(14),
                Self::SetNetworkPolicy => serializer.serialize_i32(15),
                Self::SetMaintenancePolicy => serializer.serialize_i32(16),
                Self::ResizeCluster => serializer.serialize_i32(18),
                Self::FleetFeatureUpgrade => serializer.serialize_i32(19),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.container.v1.Operation.Type",
            ))
        }
    }
}

/// Information about operation (or operation stage) progress.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationProgress {
    /// A non-parameterized string describing an operation stage.
    /// Unset for single-stage operations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Status of an operation stage.
    /// Unset for single-stage operations.
    pub status: crate::model::operation::Status,

    /// Progress metric bundle, for example:
    /// metrics: [{name: "nodes done",     int_value: 15},
    /// {name: "nodes total",    int_value: 32}]
    /// or
    /// metrics: [{name: "progress",       double_value: 0.56},
    /// {name: "progress scale", double_value: 1.0}]
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metrics: std::vec::Vec<crate::model::operation_progress::Metric>,

    /// Substages of an operation or a stage.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub stages: std::vec::Vec<crate::model::OperationProgress>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationProgress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OperationProgress::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [status][crate::model::OperationProgress::status].
    pub fn set_status<T: std::convert::Into<crate::model::operation::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::OperationProgress::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::operation_progress::Metric>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [stages][crate::model::OperationProgress::stages].
    pub fn set_stages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OperationProgress>,
    {
        use std::iter::Iterator;
        self.stages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OperationProgress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.OperationProgress"
    }
}

/// Defines additional types related to [OperationProgress].
pub mod operation_progress {
    #[allow(unused_imports)]
    use super::*;

    /// Progress metric is (string, int|float|string) pair.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Metric {
        /// Required. Metric name, e.g., "nodes total", "percent done".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Strictly one of the values is required.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<crate::model::operation_progress::metric::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Metric {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::operation_progress::Metric::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [value][crate::model::operation_progress::Metric::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<
                    std::option::Option<crate::model::operation_progress::metric::Value>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::operation_progress::Metric::value]
        /// if it holds a `IntValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn int_value(&self) -> std::option::Option<&i64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::operation_progress::metric::Value::IntValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::operation_progress::Metric::value]
        /// to hold a `IntValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_int_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::operation_progress::metric::Value::IntValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::operation_progress::Metric::value]
        /// if it holds a `DoubleValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn double_value(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::operation_progress::metric::Value::DoubleValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::operation_progress::Metric::value]
        /// to hold a `DoubleValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::operation_progress::metric::Value::DoubleValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::operation_progress::Metric::value]
        /// if it holds a `StringValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn string_value(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::operation_progress::metric::Value::StringValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::operation_progress::Metric::value]
        /// to hold a `StringValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_string_value<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::operation_progress::metric::Value::StringValue(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Metric {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.OperationProgress.Metric"
        }
    }

    /// Defines additional types related to [Metric].
    pub mod metric {
        #[allow(unused_imports)]
        use super::*;

        /// Strictly one of the values is required.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Value {
            /// For metrics with integer value.
            IntValue(i64),
            /// For metrics with floating point value.
            DoubleValue(f64),
            /// For metrics with custom values (ratios, visual progress, etc.).
            StringValue(std::string::String),
        }
    }
}

/// CreateClusterRequest creates a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the parent field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the parent
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Required. A [cluster
    /// resource](https://cloud.google.com/container-engine/reference/rest/v1/projects.locations.clusters)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// The parent (project and location) where the cluster will be created.
    /// Specified in the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CreateClusterRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::CreateClusterRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CreateClusterRequest"
    }
}

/// GetClusterRequest gets the settings of a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to retrieve.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// The name (project, location, cluster) of the cluster to retrieve.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetClusterRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::GetClusterRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::GetClusterRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::GetClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetClusterRequest"
    }
}

/// UpdateClusterRequest updates the settings of a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateClusterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. A description of the update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update: std::option::Option<crate::model::ClusterUpdate>,

    /// The name (project, location, cluster) of the cluster to update.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateClusterRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::UpdateClusterRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::UpdateClusterRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [update][crate::model::UpdateClusterRequest::update].
    pub fn set_update<T: std::convert::Into<std::option::Option<crate::model::ClusterUpdate>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update = v.into();
        self
    }

    /// Sets the value of [name][crate::model::UpdateClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UpdateClusterRequest"
    }
}

/// UpdateNodePoolRequests update a node pool's image and/or version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateNodePoolRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Deprecated. The name of the node pool to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub node_pool_id: std::string::String,

    /// Required. The Kubernetes version to change the nodes to (typically an
    /// upgrade).
    ///
    /// Users may specify either explicit versions offered by Kubernetes Engine or
    /// version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "-": picks the Kubernetes master version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_version: std::string::String,

    /// Required. The desired image type for the node pool. Please see
    /// <https://cloud.google.com/kubernetes-engine/docs/concepts/node-images> for
    /// available image types.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_type: std::string::String,

    /// The name (project, location, cluster, node pool) of the node pool to
    /// update. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The desired list of Google Compute Engine
    /// [zones](https://cloud.google.com/compute/docs/zones#available) in which the
    /// node pool's nodes should be located. Changing the locations for a node pool
    /// will result in nodes being either created or removed from the node pool,
    /// depending on whether locations are being added or removed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub locations: std::vec::Vec<std::string::String>,

    /// The desired workload metadata config for the node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workload_metadata_config: std::option::Option<crate::model::WorkloadMetadataConfig>,

    /// Upgrade settings control disruption and speed of the upgrade.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upgrade_settings: std::option::Option<crate::model::node_pool::UpgradeSettings>,

    /// The desired network tags to be applied to all nodes in the node pool.
    /// If this field is not present, the tags will not be changed. Otherwise,
    /// the existing network tags will be *replaced* with the provided tags.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tags: std::option::Option<crate::model::NetworkTags>,

    /// The desired node taints to be applied to all nodes in the node pool.
    /// If this field is not present, the taints will not be changed. Otherwise,
    /// the existing node taints will be *replaced* with the provided taints.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub taints: std::option::Option<crate::model::NodeTaints>,

    /// The desired node labels to be applied to all nodes in the node pool.
    /// If this field is not present, the labels will not be changed. Otherwise,
    /// the existing node labels will be *replaced* with the provided labels.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub labels: std::option::Option<crate::model::NodeLabels>,

    /// Parameters that can be configured on Linux nodes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub linux_node_config: std::option::Option<crate::model::LinuxNodeConfig>,

    /// Node kubelet configs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kubelet_config: std::option::Option<crate::model::NodeKubeletConfig>,

    /// Node network config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_network_config: std::option::Option<crate::model::NodeNetworkConfig>,

    /// GCFS config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcfs_config: std::option::Option<crate::model::GcfsConfig>,

    /// Confidential nodes config.
    /// All the nodes in the node pool will be Confidential VM once enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidential_nodes: std::option::Option<crate::model::ConfidentialNodes>,

    /// Enable or disable gvnic on the node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gvnic: std::option::Option<crate::model::VirtualNIC>,

    /// The current etag of the node pool.
    /// If an etag is provided and does not match the current etag of the node
    /// pool, update will be blocked and an ABORTED error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Enable or disable NCCL fast socket for the node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fast_socket: std::option::Option<crate::model::FastSocket>,

    /// Logging configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::NodePoolLoggingConfig>,

    /// The resource labels for the node pool to use to annotate any related
    /// Google Compute Engine resources.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_labels: std::option::Option<crate::model::ResourceLabels>,

    /// Parameters that can be configured on Windows nodes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub windows_node_config: std::option::Option<crate::model::WindowsNodeConfig>,

    /// A list of hardware accelerators to be attached to each node.
    /// See <https://cloud.google.com/compute/docs/gpus> for more information about
    /// support for GPUs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub accelerators: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// Optional. The desired [Google Compute Engine machine
    /// type](https://cloud.google.com/compute/docs/machine-types) for nodes in the
    /// node pool. Initiates an upgrade operation that migrates the nodes in the
    /// node pool to the specified machine type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type: std::string::String,

    /// Optional. The desired disk type (e.g. 'pd-standard', 'pd-ssd' or
    /// 'pd-balanced') for nodes in the node pool.
    /// Initiates an upgrade operation that migrates the nodes in the
    /// node pool to the specified disk type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub disk_type: std::string::String,

    /// Optional. The desired disk size for nodes in the node pool specified in GB.
    /// The smallest allowed disk size is 10GB.
    /// Initiates an upgrade operation that migrates the nodes in the
    /// node pool to the specified disk size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub disk_size_gb: i64,

    /// Desired resource manager tag keys and values to be attached to the nodes
    /// for managing Compute Engine firewalls using Network Firewall Policies.
    /// Existing tags will be replaced with new values.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_manager_tags: std::option::Option<crate::model::ResourceManagerTags>,

    /// The desired containerd config for nodes in the node pool.
    /// Initiates an upgrade operation that recreates the nodes with the new
    /// config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub containerd_config: std::option::Option<crate::model::ContainerdConfig>,

    /// Specifies the configuration of queued provisioning.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub queued_provisioning: std::option::Option<crate::model::node_pool::QueuedProvisioning>,

    /// List of Storage Pools where boot disks are provisioned.
    /// Existing Storage Pools will be replaced with storage-pools.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub storage_pools: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateNodePoolRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::UpdateNodePoolRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::UpdateNodePoolRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::UpdateNodePoolRequest::node_pool_id].
    #[deprecated]
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [node_version][crate::model::UpdateNodePoolRequest::node_version].
    pub fn set_node_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_version = v.into();
        self
    }

    /// Sets the value of [image_type][crate::model::UpdateNodePoolRequest::image_type].
    pub fn set_image_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_type = v.into();
        self
    }

    /// Sets the value of [name][crate::model::UpdateNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [locations][crate::model::UpdateNodePoolRequest::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [workload_metadata_config][crate::model::UpdateNodePoolRequest::workload_metadata_config].
    pub fn set_workload_metadata_config<
        T: std::convert::Into<std::option::Option<crate::model::WorkloadMetadataConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workload_metadata_config = v.into();
        self
    }

    /// Sets the value of [upgrade_settings][crate::model::UpdateNodePoolRequest::upgrade_settings].
    pub fn set_upgrade_settings<
        T: std::convert::Into<std::option::Option<crate::model::node_pool::UpgradeSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.upgrade_settings = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::UpdateNodePoolRequest::tags].
    pub fn set_tags<T: std::convert::Into<std::option::Option<crate::model::NetworkTags>>>(
        mut self,
        v: T,
    ) -> Self {
        self.tags = v.into();
        self
    }

    /// Sets the value of [taints][crate::model::UpdateNodePoolRequest::taints].
    pub fn set_taints<T: std::convert::Into<std::option::Option<crate::model::NodeTaints>>>(
        mut self,
        v: T,
    ) -> Self {
        self.taints = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::UpdateNodePoolRequest::labels].
    pub fn set_labels<T: std::convert::Into<std::option::Option<crate::model::NodeLabels>>>(
        mut self,
        v: T,
    ) -> Self {
        self.labels = v.into();
        self
    }

    /// Sets the value of [linux_node_config][crate::model::UpdateNodePoolRequest::linux_node_config].
    pub fn set_linux_node_config<
        T: std::convert::Into<std::option::Option<crate::model::LinuxNodeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.linux_node_config = v.into();
        self
    }

    /// Sets the value of [kubelet_config][crate::model::UpdateNodePoolRequest::kubelet_config].
    pub fn set_kubelet_config<
        T: std::convert::Into<std::option::Option<crate::model::NodeKubeletConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kubelet_config = v.into();
        self
    }

    /// Sets the value of [node_network_config][crate::model::UpdateNodePoolRequest::node_network_config].
    pub fn set_node_network_config<
        T: std::convert::Into<std::option::Option<crate::model::NodeNetworkConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_network_config = v.into();
        self
    }

    /// Sets the value of [gcfs_config][crate::model::UpdateNodePoolRequest::gcfs_config].
    pub fn set_gcfs_config<T: std::convert::Into<std::option::Option<crate::model::GcfsConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcfs_config = v.into();
        self
    }

    /// Sets the value of [confidential_nodes][crate::model::UpdateNodePoolRequest::confidential_nodes].
    pub fn set_confidential_nodes<
        T: std::convert::Into<std::option::Option<crate::model::ConfidentialNodes>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.confidential_nodes = v.into();
        self
    }

    /// Sets the value of [gvnic][crate::model::UpdateNodePoolRequest::gvnic].
    pub fn set_gvnic<T: std::convert::Into<std::option::Option<crate::model::VirtualNIC>>>(
        mut self,
        v: T,
    ) -> Self {
        self.gvnic = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::UpdateNodePoolRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [fast_socket][crate::model::UpdateNodePoolRequest::fast_socket].
    pub fn set_fast_socket<T: std::convert::Into<std::option::Option<crate::model::FastSocket>>>(
        mut self,
        v: T,
    ) -> Self {
        self.fast_socket = v.into();
        self
    }

    /// Sets the value of [logging_config][crate::model::UpdateNodePoolRequest::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::NodePoolLoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [resource_labels][crate::model::UpdateNodePoolRequest::resource_labels].
    pub fn set_resource_labels<
        T: std::convert::Into<std::option::Option<crate::model::ResourceLabels>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_labels = v.into();
        self
    }

    /// Sets the value of [windows_node_config][crate::model::UpdateNodePoolRequest::windows_node_config].
    pub fn set_windows_node_config<
        T: std::convert::Into<std::option::Option<crate::model::WindowsNodeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.windows_node_config = v.into();
        self
    }

    /// Sets the value of [accelerators][crate::model::UpdateNodePoolRequest::accelerators].
    pub fn set_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [machine_type][crate::model::UpdateNodePoolRequest::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::UpdateNodePoolRequest::disk_type].
    pub fn set_disk_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::UpdateNodePoolRequest::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [resource_manager_tags][crate::model::UpdateNodePoolRequest::resource_manager_tags].
    pub fn set_resource_manager_tags<
        T: std::convert::Into<std::option::Option<crate::model::ResourceManagerTags>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_manager_tags = v.into();
        self
    }

    /// Sets the value of [containerd_config][crate::model::UpdateNodePoolRequest::containerd_config].
    pub fn set_containerd_config<
        T: std::convert::Into<std::option::Option<crate::model::ContainerdConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.containerd_config = v.into();
        self
    }

    /// Sets the value of [queued_provisioning][crate::model::UpdateNodePoolRequest::queued_provisioning].
    pub fn set_queued_provisioning<
        T: std::convert::Into<std::option::Option<crate::model::node_pool::QueuedProvisioning>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.queued_provisioning = v.into();
        self
    }

    /// Sets the value of [storage_pools][crate::model::UpdateNodePoolRequest::storage_pools].
    pub fn set_storage_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.storage_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UpdateNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UpdateNodePoolRequest"
    }
}

/// SetNodePoolAutoscalingRequest sets the autoscaler settings of a node pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetNodePoolAutoscalingRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Deprecated. The name of the node pool to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub node_pool_id: std::string::String,

    /// Required. Autoscaling configuration for the node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoscaling: std::option::Option<crate::model::NodePoolAutoscaling>,

    /// The name (project, location, cluster, node pool) of the node pool to set
    /// autoscaler settings. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetNodePoolAutoscalingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetNodePoolAutoscalingRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetNodePoolAutoscalingRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetNodePoolAutoscalingRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::SetNodePoolAutoscalingRequest::node_pool_id].
    #[deprecated]
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [autoscaling][crate::model::SetNodePoolAutoscalingRequest::autoscaling].
    pub fn set_autoscaling<
        T: std::convert::Into<std::option::Option<crate::model::NodePoolAutoscaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetNodePoolAutoscalingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetNodePoolAutoscalingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetNodePoolAutoscalingRequest"
    }
}

/// SetLoggingServiceRequest sets the logging service of a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetLoggingServiceRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The logging service the cluster should use to write logs.
    /// Currently available options:
    ///
    /// * `logging.googleapis.com/kubernetes` - The Cloud Logging
    ///   service with a Kubernetes-native resource model
    /// * `logging.googleapis.com` - The legacy Cloud Logging service (no longer
    ///   available as of GKE 1.15).
    /// * `none` - no logs will be exported from the cluster.
    ///
    /// If left as an empty string,`logging.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub logging_service: std::string::String,

    /// The name (project, location, cluster) of the cluster to set logging.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetLoggingServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetLoggingServiceRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetLoggingServiceRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetLoggingServiceRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [logging_service][crate::model::SetLoggingServiceRequest::logging_service].
    pub fn set_logging_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.logging_service = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetLoggingServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetLoggingServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetLoggingServiceRequest"
    }
}

/// SetMonitoringServiceRequest sets the monitoring service of a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetMonitoringServiceRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The monitoring service the cluster should use to write metrics.
    /// Currently available options:
    ///
    /// * "monitoring.googleapis.com/kubernetes" - The Cloud Monitoring
    ///   service with a Kubernetes-native resource model
    /// * `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no
    ///   longer available as of GKE 1.15).
    /// * `none` - No metrics will be exported from the cluster.
    ///
    /// If left as an empty string,`monitoring.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `monitoring.googleapis.com` for earlier versions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub monitoring_service: std::string::String,

    /// The name (project, location, cluster) of the cluster to set monitoring.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetMonitoringServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetMonitoringServiceRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetMonitoringServiceRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetMonitoringServiceRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [monitoring_service][crate::model::SetMonitoringServiceRequest::monitoring_service].
    pub fn set_monitoring_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.monitoring_service = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetMonitoringServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetMonitoringServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetMonitoringServiceRequest"
    }
}

/// SetAddonsConfigRequest sets the addons associated with the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetAddonsConfigRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The desired configurations for the various addons available to
    /// run in the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub addons_config: std::option::Option<crate::model::AddonsConfig>,

    /// The name (project, location, cluster) of the cluster to set addons.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetAddonsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetAddonsConfigRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetAddonsConfigRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetAddonsConfigRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [addons_config][crate::model::SetAddonsConfigRequest::addons_config].
    pub fn set_addons_config<
        T: std::convert::Into<std::option::Option<crate::model::AddonsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.addons_config = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetAddonsConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetAddonsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetAddonsConfigRequest"
    }
}

/// SetLocationsRequest sets the locations of the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetLocationsRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The desired list of Google Compute Engine
    /// [zones](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster's nodes should be located. Changing the locations a cluster is in
    /// will result in nodes being either created or removed from the cluster,
    /// depending on whether locations are being added or removed.
    ///
    /// This list must always include the cluster's primary zone.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub locations: std::vec::Vec<std::string::String>,

    /// The name (project, location, cluster) of the cluster to set locations.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetLocationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetLocationsRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetLocationsRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetLocationsRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [locations][crate::model::SetLocationsRequest::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [name][crate::model::SetLocationsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetLocationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetLocationsRequest"
    }
}

/// UpdateMasterRequest updates the master of the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateMasterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The Kubernetes version to change the master to.
    ///
    /// Users may specify either explicit versions offered by Kubernetes Engine or
    /// version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "-": picks the default Kubernetes version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub master_version: std::string::String,

    /// The name (project, location, cluster) of the cluster to update.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateMasterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateMasterRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::UpdateMasterRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::UpdateMasterRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [master_version][crate::model::UpdateMasterRequest::master_version].
    pub fn set_master_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.master_version = v.into();
        self
    }

    /// Sets the value of [name][crate::model::UpdateMasterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UpdateMasterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UpdateMasterRequest"
    }
}

/// SetMasterAuthRequest updates the admin password of a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetMasterAuthRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The exact form of action to be taken on the master auth.
    pub action: crate::model::set_master_auth_request::Action,

    /// Required. A description of the update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update: std::option::Option<crate::model::MasterAuth>,

    /// The name (project, location, cluster) of the cluster to set auth.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetMasterAuthRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetMasterAuthRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetMasterAuthRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetMasterAuthRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [action][crate::model::SetMasterAuthRequest::action].
    pub fn set_action<T: std::convert::Into<crate::model::set_master_auth_request::Action>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [update][crate::model::SetMasterAuthRequest::update].
    pub fn set_update<T: std::convert::Into<std::option::Option<crate::model::MasterAuth>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetMasterAuthRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetMasterAuthRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetMasterAuthRequest"
    }
}

/// Defines additional types related to [SetMasterAuthRequest].
pub mod set_master_auth_request {
    #[allow(unused_imports)]
    use super::*;

    /// Operation type: what type update to perform.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        /// Operation is unknown and will error out.
        Unknown,
        /// Set the password to a user generated value.
        SetPassword,
        /// Generate a new password and set it to that.
        GeneratePassword,
        /// Set the username.  If an empty username is provided, basic authentication
        /// is disabled for the cluster.  If a non-empty username is provided, basic
        /// authentication is enabled, with either a provided password or a generated
        /// one.
        SetUsername,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Action::value] or
        /// [Action::name].
        UnknownValue(action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Action {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::SetPassword => std::option::Option::Some(1),
                Self::GeneratePassword => std::option::Option::Some(2),
                Self::SetUsername => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::SetPassword => std::option::Option::Some("SET_PASSWORD"),
                Self::GeneratePassword => std::option::Option::Some("GENERATE_PASSWORD"),
                Self::SetUsername => std::option::Option::Some("SET_USERNAME"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Action {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Action {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Action {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::SetPassword,
                2 => Self::GeneratePassword,
                3 => Self::SetUsername,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Action {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "SET_PASSWORD" => Self::SetPassword,
                "GENERATE_PASSWORD" => Self::GeneratePassword,
                "SET_USERNAME" => Self::SetUsername,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Action {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::SetPassword => serializer.serialize_i32(1),
                Self::GeneratePassword => serializer.serialize_i32(2),
                Self::SetUsername => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Action {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Action>::new(
                ".google.container.v1.SetMasterAuthRequest.Action",
            ))
        }
    }
}

/// DeleteClusterRequest deletes a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to delete.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// The name (project, location, cluster) of the cluster to delete.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteClusterRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::DeleteClusterRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::DeleteClusterRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DeleteClusterRequest"
    }
}

/// ListClustersRequest lists clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the parent field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides, or "-" for all zones. This field has been deprecated and
    /// replaced by the parent field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// The parent (project and location) where the clusters will be listed.
    /// Specified in the format `projects/*/locations/*`.
    /// Location "-" matches all zones and all regions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListClustersRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ListClustersRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListClustersRequest"
    }
}

/// ListClustersResponse is the result of ListClustersRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// A list of clusters in the project in the specified zone, or
    /// across all ones.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// If any zones are listed here, the list of clusters returned
    /// may be missing those zones.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub missing_zones: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [missing_zones][crate::model::ListClustersResponse::missing_zones].
    pub fn set_missing_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.missing_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListClustersResponse"
    }
}

/// GetOperationRequest gets a single operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetOperationRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The server-assigned `name` of the operation.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub operation_id: std::string::String,

    /// The name (project, location, operation id) of the operation to get.
    /// Specified in the format `projects/*/locations/*/operations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetOperationRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::GetOperationRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [operation_id][crate::model::GetOperationRequest::operation_id].
    #[deprecated]
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::GetOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetOperationRequest"
    }
}

/// ListOperationsRequest lists operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOperationsRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the parent field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) to return
    /// operations for, or `-` for all zones. This field has been deprecated and
    /// replaced by the parent field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// The parent (project and location) where the operations will be listed.
    /// Specified in the format `projects/*/locations/*`.
    /// Location "-" matches all zones and all regions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOperationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListOperationsRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ListOperationsRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::ListOperationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListOperationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListOperationsRequest"
    }
}

/// CancelOperationRequest cancels a single operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelOperationRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// operation resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The server-assigned `name` of the operation.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub operation_id: std::string::String,

    /// The name (project, location, operation id) of the operation to cancel.
    /// Specified in the format `projects/*/locations/*/operations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CancelOperationRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::CancelOperationRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [operation_id][crate::model::CancelOperationRequest::operation_id].
    #[deprecated]
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::CancelOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CancelOperationRequest"
    }
}

/// ListOperationsResponse is the result of ListOperationsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOperationsResponse {
    /// A list of operations in the project in the specified zone.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub operations: std::vec::Vec<crate::model::Operation>,

    /// If any zones are listed here, the list of operations returned
    /// may be missing the operations from those zones.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub missing_zones: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOperationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operations][crate::model::ListOperationsResponse::operations].
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Operation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [missing_zones][crate::model::ListOperationsResponse::missing_zones].
    pub fn set_missing_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.missing_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListOperationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListOperationsResponse"
    }
}

/// Gets the current Kubernetes Engine service configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetServerConfigRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) to return
    /// operations for. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// The name (project and location) of the server config to get,
    /// specified in the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServerConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetServerConfigRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::GetServerConfigRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [name][crate::model::GetServerConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServerConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetServerConfigRequest"
    }
}

/// Kubernetes Engine service configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServerConfig {
    /// Version of Kubernetes the service deploys by default.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_cluster_version: std::string::String,

    /// List of valid node upgrade target versions, in descending order.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub valid_node_versions: std::vec::Vec<std::string::String>,

    /// Default image type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_image_type: std::string::String,

    /// List of valid image types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub valid_image_types: std::vec::Vec<std::string::String>,

    /// List of valid master versions, in descending order.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub valid_master_versions: std::vec::Vec<std::string::String>,

    /// List of release channel configurations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub channels: std::vec::Vec<crate::model::server_config::ReleaseChannelConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [default_cluster_version][crate::model::ServerConfig::default_cluster_version].
    pub fn set_default_cluster_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_cluster_version = v.into();
        self
    }

    /// Sets the value of [valid_node_versions][crate::model::ServerConfig::valid_node_versions].
    pub fn set_valid_node_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.valid_node_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_image_type][crate::model::ServerConfig::default_image_type].
    pub fn set_default_image_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_image_type = v.into();
        self
    }

    /// Sets the value of [valid_image_types][crate::model::ServerConfig::valid_image_types].
    pub fn set_valid_image_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.valid_image_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [valid_master_versions][crate::model::ServerConfig::valid_master_versions].
    pub fn set_valid_master_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.valid_master_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [channels][crate::model::ServerConfig::channels].
    pub fn set_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::server_config::ReleaseChannelConfig>,
    {
        use std::iter::Iterator;
        self.channels = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ServerConfig"
    }
}

/// Defines additional types related to [ServerConfig].
pub mod server_config {
    #[allow(unused_imports)]
    use super::*;

    /// ReleaseChannelConfig exposes configuration for a release channel.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ReleaseChannelConfig {
        /// The release channel this configuration applies to.
        pub channel: crate::model::release_channel::Channel,

        /// The default version for newly created clusters on the channel.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub default_version: std::string::String,

        /// List of valid versions for the channel.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub valid_versions: std::vec::Vec<std::string::String>,

        /// The auto upgrade target version for clusters on the channel.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub upgrade_target_version: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReleaseChannelConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [channel][crate::model::server_config::ReleaseChannelConfig::channel].
        pub fn set_channel<T: std::convert::Into<crate::model::release_channel::Channel>>(
            mut self,
            v: T,
        ) -> Self {
            self.channel = v.into();
            self
        }

        /// Sets the value of [default_version][crate::model::server_config::ReleaseChannelConfig::default_version].
        pub fn set_default_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.default_version = v.into();
            self
        }

        /// Sets the value of [valid_versions][crate::model::server_config::ReleaseChannelConfig::valid_versions].
        pub fn set_valid_versions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.valid_versions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [upgrade_target_version][crate::model::server_config::ReleaseChannelConfig::upgrade_target_version].
        pub fn set_upgrade_target_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.upgrade_target_version = v.into();
            self
        }
    }

    impl wkt::message::Message for ReleaseChannelConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.ServerConfig.ReleaseChannelConfig"
        }
    }
}

/// CreateNodePoolRequest creates a node pool for a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNodePoolRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the parent field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the parent
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the parent field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The node pool to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_pool: std::option::Option<crate::model::NodePool>,

    /// The parent (project, location, cluster name) where the node pool will be
    /// created. Specified in the format
    /// `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CreateNodePoolRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::CreateNodePoolRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateNodePoolRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool][crate::model::CreateNodePoolRequest::node_pool].
    pub fn set_node_pool<T: std::convert::Into<std::option::Option<crate::model::NodePool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.node_pool = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::CreateNodePoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for CreateNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CreateNodePoolRequest"
    }
}

/// DeleteNodePoolRequest deletes a node pool for a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNodePoolRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Deprecated. The name of the node pool to delete.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub node_pool_id: std::string::String,

    /// The name (project, location, cluster, node pool id) of the node pool to
    /// delete. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteNodePoolRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::DeleteNodePoolRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::DeleteNodePoolRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::DeleteNodePoolRequest::node_pool_id].
    #[deprecated]
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::DeleteNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DeleteNodePoolRequest"
    }
}

/// ListNodePoolsRequest lists the node pool(s) for a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNodePoolsRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the parent field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the parent
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the parent field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// The parent (project, location, cluster name) where the node pools will be
    /// listed. Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNodePoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListNodePoolsRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ListNodePoolsRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::ListNodePoolsRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::ListNodePoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListNodePoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListNodePoolsRequest"
    }
}

/// GetNodePoolRequest retrieves a node pool for a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNodePoolRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Deprecated. The name of the node pool.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub node_pool_id: std::string::String,

    /// The name (project, location, cluster, node pool id) of the node pool to
    /// get. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetNodePoolRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::GetNodePoolRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::GetNodePoolRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::GetNodePoolRequest::node_pool_id].
    #[deprecated]
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::GetNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetNodePoolRequest"
    }
}

/// Settings for blue-green upgrade.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BlueGreenSettings {
    /// Time needed after draining entire blue pool. After this period, blue pool
    /// will be cleaned up.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_pool_soak_duration: std::option::Option<wkt::Duration>,

    /// The rollout policy controls the general rollout progress of blue-green.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub rollout_policy: std::option::Option<crate::model::blue_green_settings::RolloutPolicy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BlueGreenSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_pool_soak_duration][crate::model::BlueGreenSettings::node_pool_soak_duration].
    pub fn set_node_pool_soak_duration<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_pool_soak_duration = v.into();
        self
    }

    /// Sets the value of [rollout_policy][crate::model::BlueGreenSettings::rollout_policy].
    ///
    /// Note that all the setters affecting `rollout_policy` are mutually
    /// exclusive.
    pub fn set_rollout_policy<
        T: std::convert::Into<std::option::Option<crate::model::blue_green_settings::RolloutPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_policy = v.into();
        self
    }

    /// The value of [rollout_policy][crate::model::BlueGreenSettings::rollout_policy]
    /// if it holds a `StandardRolloutPolicy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn standard_rollout_policy(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::blue_green_settings::StandardRolloutPolicy>,
    > {
        #[allow(unreachable_patterns)]
        self.rollout_policy.as_ref().and_then(|v| match v {
            crate::model::blue_green_settings::RolloutPolicy::StandardRolloutPolicy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rollout_policy][crate::model::BlueGreenSettings::rollout_policy]
    /// to hold a `StandardRolloutPolicy`.
    ///
    /// Note that all the setters affecting `rollout_policy` are
    /// mutually exclusive.
    pub fn set_standard_rollout_policy<
        T: std::convert::Into<
                std::boxed::Box<crate::model::blue_green_settings::StandardRolloutPolicy>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_policy = std::option::Option::Some(
            crate::model::blue_green_settings::RolloutPolicy::StandardRolloutPolicy(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BlueGreenSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.BlueGreenSettings"
    }
}

/// Defines additional types related to [BlueGreenSettings].
pub mod blue_green_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Standard rollout policy is the default policy for blue-green.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StandardRolloutPolicy {
        /// Soak time after each batch gets drained. Default to zero.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub batch_soak_duration: std::option::Option<wkt::Duration>,

        /// Blue pool size to drain in a batch.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub update_batch_size: std::option::Option<
            crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StandardRolloutPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [batch_soak_duration][crate::model::blue_green_settings::StandardRolloutPolicy::batch_soak_duration].
        pub fn set_batch_soak_duration<
            T: std::convert::Into<std::option::Option<wkt::Duration>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.batch_soak_duration = v.into();
            self
        }

        /// Sets the value of [update_batch_size][crate::model::blue_green_settings::StandardRolloutPolicy::update_batch_size].
        ///
        /// Note that all the setters affecting `update_batch_size` are mutually
        /// exclusive.
        pub fn set_update_batch_size<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.update_batch_size = v.into();
            self
        }

        /// The value of [update_batch_size][crate::model::blue_green_settings::StandardRolloutPolicy::update_batch_size]
        /// if it holds a `BatchPercentage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn batch_percentage(&self) -> std::option::Option<&f32> {
            #[allow(unreachable_patterns)]
            self.update_batch_size.as_ref().and_then(|v| match v {
                crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize::BatchPercentage(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [update_batch_size][crate::model::blue_green_settings::StandardRolloutPolicy::update_batch_size]
        /// to hold a `BatchPercentage`.
        ///
        /// Note that all the setters affecting `update_batch_size` are
        /// mutually exclusive.
        pub fn set_batch_percentage<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.update_batch_size = std::option::Option::Some(
                crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize::BatchPercentage(
                    v.into()
                )
            );
            self
        }

        /// The value of [update_batch_size][crate::model::blue_green_settings::StandardRolloutPolicy::update_batch_size]
        /// if it holds a `BatchNodeCount`, `None` if the field is not set or
        /// holds a different branch.
        pub fn batch_node_count(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.update_batch_size.as_ref().and_then(|v| match v {
                crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize::BatchNodeCount(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [update_batch_size][crate::model::blue_green_settings::StandardRolloutPolicy::update_batch_size]
        /// to hold a `BatchNodeCount`.
        ///
        /// Note that all the setters affecting `update_batch_size` are
        /// mutually exclusive.
        pub fn set_batch_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.update_batch_size = std::option::Option::Some(
                crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize::BatchNodeCount(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for StandardRolloutPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.BlueGreenSettings.StandardRolloutPolicy"
        }
    }

    /// Defines additional types related to [StandardRolloutPolicy].
    pub mod standard_rollout_policy {
        #[allow(unused_imports)]
        use super::*;

        /// Blue pool size to drain in a batch.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum UpdateBatchSize {
            /// Percentage of the blue pool nodes to drain in a batch.
            /// The range of this field should be (0.0, 1.0].
            BatchPercentage(f32),
            /// Number of blue nodes to drain in a batch.
            BatchNodeCount(i32),
        }
    }

    /// The rollout policy controls the general rollout progress of blue-green.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RolloutPolicy {
        /// Standard policy for the blue-green upgrade.
        StandardRolloutPolicy(
            std::boxed::Box<crate::model::blue_green_settings::StandardRolloutPolicy>,
        ),
    }
}

/// NodePool contains the name and configuration for a cluster's node pool.
/// Node pools are a set of nodes (i.e. VM's), with a common configuration and
/// specification, under the control of the cluster master. They may have a set
/// of Kubernetes labels applied to them, which may be used to reference them
/// during pod scheduling. They may also be resized up or down, to accommodate
/// the workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodePool {
    /// The name of the node pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The node configuration of the pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::NodeConfig>,

    /// The initial node count for the pool. You must ensure that your
    /// Compute Engine [resource quota](https://cloud.google.com/compute/quotas)
    /// is sufficient for this number of instances. You must also have available
    /// firewall and routes quota.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub initial_node_count: i32,

    /// The list of Google Compute Engine
    /// [zones](https://cloud.google.com/compute/docs/zones#available) in which the
    /// NodePool's nodes should be located.
    ///
    /// If this value is unspecified during node pool creation, the
    /// [Cluster.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters#Cluster.FIELDS.locations)
    /// value will be used, instead.
    ///
    /// Warning: changing node pool locations will result in nodes being added
    /// and/or removed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub locations: std::vec::Vec<std::string::String>,

    /// Networking configuration for this NodePool. If specified, it overrides the
    /// cluster-level defaults.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_config: std::option::Option<crate::model::NodeNetworkConfig>,

    /// Output only. Server-defined URL for the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    /// The version of Kubernetes running on this NodePool's nodes. If unspecified,
    /// it defaults as described
    /// [here](https://cloud.google.com/kubernetes-engine/versioning#specifying_node_version).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Output only. The resource URLs of the [managed instance
    /// groups](https://cloud.google.com/compute/docs/instance-groups/creating-groups-of-managed-instances)
    /// associated with this node pool.
    /// During the node pool blue-green upgrade operation, the URLs contain both
    /// blue and green resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instance_group_urls: std::vec::Vec<std::string::String>,

    /// Output only. The status of the nodes in this pool instance.
    pub status: crate::model::node_pool::Status,

    /// Output only. Deprecated. Use conditions instead.
    /// Additional information about the current status of this
    /// node pool instance, if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub status_message: std::string::String,

    /// Autoscaler configuration for this NodePool. Autoscaler is enabled
    /// only if a valid configuration is present.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoscaling: std::option::Option<crate::model::NodePoolAutoscaling>,

    /// NodeManagement configuration for this NodePool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub management: std::option::Option<crate::model::NodeManagement>,

    /// The constraint on the maximum number of pods that can be run
    /// simultaneously on a node in the node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_pods_constraint: std::option::Option<crate::model::MaxPodsConstraint>,

    /// Which conditions caused the current node pool state.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conditions: std::vec::Vec<crate::model::StatusCondition>,

    /// Output only. The pod CIDR block size per node in this node pool.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub pod_ipv4_cidr_size: i32,

    /// Upgrade settings control disruption and speed of the upgrade.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upgrade_settings: std::option::Option<crate::model::node_pool::UpgradeSettings>,

    /// Specifies the node placement policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub placement_policy: std::option::Option<crate::model::node_pool::PlacementPolicy>,

    /// Output only. Update info contains relevant information during a node
    /// pool update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_info: std::option::Option<crate::model::node_pool::UpdateInfo>,

    /// This checksum is computed by the server based on the value of node pool
    /// fields, and may be sent on update requests to ensure the client has an
    /// up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Specifies the configuration of queued provisioning.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub queued_provisioning: std::option::Option<crate::model::node_pool::QueuedProvisioning>,

    /// Enable best effort provisioning for nodes
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub best_effort_provisioning: std::option::Option<crate::model::BestEffortProvisioning>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NodePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::NodePool::config].
    pub fn set_config<T: std::convert::Into<std::option::Option<crate::model::NodeConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [initial_node_count][crate::model::NodePool::initial_node_count].
    pub fn set_initial_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.initial_node_count = v.into();
        self
    }

    /// Sets the value of [locations][crate::model::NodePool::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_config][crate::model::NodePool::network_config].
    pub fn set_network_config<
        T: std::convert::Into<std::option::Option<crate::model::NodeNetworkConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_config = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::NodePool::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [version][crate::model::NodePool::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [instance_group_urls][crate::model::NodePool::instance_group_urls].
    pub fn set_instance_group_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_group_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [status][crate::model::NodePool::status].
    pub fn set_status<T: std::convert::Into<crate::model::node_pool::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::NodePool::status_message].
    #[deprecated]
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [autoscaling][crate::model::NodePool::autoscaling].
    pub fn set_autoscaling<
        T: std::convert::Into<std::option::Option<crate::model::NodePoolAutoscaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling = v.into();
        self
    }

    /// Sets the value of [management][crate::model::NodePool::management].
    pub fn set_management<
        T: std::convert::Into<std::option::Option<crate::model::NodeManagement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.management = v.into();
        self
    }

    /// Sets the value of [max_pods_constraint][crate::model::NodePool::max_pods_constraint].
    pub fn set_max_pods_constraint<
        T: std::convert::Into<std::option::Option<crate::model::MaxPodsConstraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.max_pods_constraint = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::NodePool::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StatusCondition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pod_ipv4_cidr_size][crate::model::NodePool::pod_ipv4_cidr_size].
    pub fn set_pod_ipv4_cidr_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.pod_ipv4_cidr_size = v.into();
        self
    }

    /// Sets the value of [upgrade_settings][crate::model::NodePool::upgrade_settings].
    pub fn set_upgrade_settings<
        T: std::convert::Into<std::option::Option<crate::model::node_pool::UpgradeSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.upgrade_settings = v.into();
        self
    }

    /// Sets the value of [placement_policy][crate::model::NodePool::placement_policy].
    pub fn set_placement_policy<
        T: std::convert::Into<std::option::Option<crate::model::node_pool::PlacementPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.placement_policy = v.into();
        self
    }

    /// Sets the value of [update_info][crate::model::NodePool::update_info].
    pub fn set_update_info<
        T: std::convert::Into<std::option::Option<crate::model::node_pool::UpdateInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.update_info = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::NodePool::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [queued_provisioning][crate::model::NodePool::queued_provisioning].
    pub fn set_queued_provisioning<
        T: std::convert::Into<std::option::Option<crate::model::node_pool::QueuedProvisioning>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.queued_provisioning = v.into();
        self
    }

    /// Sets the value of [best_effort_provisioning][crate::model::NodePool::best_effort_provisioning].
    pub fn set_best_effort_provisioning<
        T: std::convert::Into<std::option::Option<crate::model::BestEffortProvisioning>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.best_effort_provisioning = v.into();
        self
    }
}

impl wkt::message::Message for NodePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodePool"
    }
}

/// Defines additional types related to [NodePool].
pub mod node_pool {
    #[allow(unused_imports)]
    use super::*;

    /// These upgrade settings control the level of parallelism and the level of
    /// disruption caused by an upgrade.
    ///
    /// maxUnavailable controls the number of nodes that can be simultaneously
    /// unavailable.
    ///
    /// maxSurge controls the number of additional nodes that can be added to the
    /// node pool temporarily for the time of the upgrade to increase the number of
    /// available nodes.
    ///
    /// (maxUnavailable + maxSurge) determines the level of parallelism (how many
    /// nodes are being upgraded at the same time).
    ///
    /// Note: upgrades inevitably introduce some disruption since workloads need to
    /// be moved from old nodes to new, upgraded ones. Even if maxUnavailable=0,
    /// this holds true. (Disruption stays within the limits of
    /// PodDisruptionBudget, if it is configured.)
    ///
    /// Consider a hypothetical node pool with 5 nodes having maxSurge=2,
    /// maxUnavailable=1. This means the upgrade process upgrades 3 nodes
    /// simultaneously. It creates 2 additional (upgraded) nodes, then it brings
    /// down 3 old (not yet upgraded) nodes at the same time. This ensures that
    /// there are always at least 4 nodes available.
    ///
    /// These upgrade settings configure the upgrade strategy for the node pool.
    /// Use strategy to switch between the strategies applied to the node pool.
    ///
    /// If the strategy is ROLLING, use max_surge and max_unavailable to control
    /// the level of parallelism and the level of disruption caused by upgrade.
    ///
    /// . maxSurge controls the number of additional nodes that can be added to
    ///   the node pool temporarily for the time of the upgrade to increase the
    ///   number of available nodes.
    /// . maxUnavailable controls the number of nodes that can be simultaneously
    ///   unavailable.
    /// . (maxUnavailable + maxSurge) determines the level of parallelism (how
    ///   many nodes are being upgraded at the same time).
    ///
    /// If the strategy is BLUE_GREEN, use blue_green_settings to configure the
    /// blue-green upgrade related settings.
    ///
    /// . standard_rollout_policy is the default policy. The policy is used to
    ///   control the way blue pool gets drained. The draining is executed in the
    ///   batch mode. The batch size could be specified as either percentage of the
    ///   node pool size or the number of nodes. batch_soak_duration is the soak
    ///   time after each batch gets drained.
    /// . node_pool_soak_duration is the soak time after all blue nodes are
    ///   drained. After this period, the blue pool nodes will be deleted.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UpgradeSettings {
        /// The maximum number of nodes that can be created beyond the current size
        /// of the node pool during the upgrade process.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub max_surge: i32,

        /// The maximum number of nodes that can be simultaneously unavailable during
        /// the upgrade process. A node is considered available if its status is
        /// Ready.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub max_unavailable: i32,

        /// Update strategy of the node pool.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub strategy: std::option::Option<crate::model::NodePoolUpdateStrategy>,

        /// Settings for blue-green upgrade strategy.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub blue_green_settings: std::option::Option<crate::model::BlueGreenSettings>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UpgradeSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_surge][crate::model::node_pool::UpgradeSettings::max_surge].
        pub fn set_max_surge<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_surge = v.into();
            self
        }

        /// Sets the value of [max_unavailable][crate::model::node_pool::UpgradeSettings::max_unavailable].
        pub fn set_max_unavailable<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_unavailable = v.into();
            self
        }

        /// Sets the value of [strategy][crate::model::node_pool::UpgradeSettings::strategy].
        pub fn set_strategy<
            T: std::convert::Into<std::option::Option<crate::model::NodePoolUpdateStrategy>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.strategy = v.into();
            self
        }

        /// Sets the value of [blue_green_settings][crate::model::node_pool::UpgradeSettings::blue_green_settings].
        pub fn set_blue_green_settings<
            T: std::convert::Into<std::option::Option<crate::model::BlueGreenSettings>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.blue_green_settings = v.into();
            self
        }
    }

    impl wkt::message::Message for UpgradeSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NodePool.UpgradeSettings"
        }
    }

    /// UpdateInfo contains resource (instance groups, etc), status and other
    /// intermediate information relevant to a node pool upgrade.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UpdateInfo {
        /// Information of a blue-green upgrade.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub blue_green_info:
            std::option::Option<crate::model::node_pool::update_info::BlueGreenInfo>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UpdateInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [blue_green_info][crate::model::node_pool::UpdateInfo::blue_green_info].
        pub fn set_blue_green_info<
            T: std::convert::Into<
                    std::option::Option<crate::model::node_pool::update_info::BlueGreenInfo>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.blue_green_info = v.into();
            self
        }
    }

    impl wkt::message::Message for UpdateInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NodePool.UpdateInfo"
        }
    }

    /// Defines additional types related to [UpdateInfo].
    pub mod update_info {
        #[allow(unused_imports)]
        use super::*;

        /// Information relevant to blue-green upgrade.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct BlueGreenInfo {
            /// Current blue-green upgrade phase.
            pub phase: crate::model::node_pool::update_info::blue_green_info::Phase,

            /// The resource URLs of the [managed instance groups]
            /// (/compute/docs/instance-groups/creating-groups-of-managed-instances)
            /// associated with blue pool.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub blue_instance_group_urls: std::vec::Vec<std::string::String>,

            /// The resource URLs of the [managed instance groups]
            /// (/compute/docs/instance-groups/creating-groups-of-managed-instances)
            /// associated with green pool.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub green_instance_group_urls: std::vec::Vec<std::string::String>,

            /// Time to start deleting blue pool to complete blue-green upgrade,
            /// in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub blue_pool_deletion_start_time: std::string::String,

            /// Version of green pool.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub green_pool_version: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BlueGreenInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [phase][crate::model::node_pool::update_info::BlueGreenInfo::phase].
            pub fn set_phase<
                T: std::convert::Into<crate::model::node_pool::update_info::blue_green_info::Phase>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.phase = v.into();
                self
            }

            /// Sets the value of [blue_instance_group_urls][crate::model::node_pool::update_info::BlueGreenInfo::blue_instance_group_urls].
            pub fn set_blue_instance_group_urls<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.blue_instance_group_urls = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [green_instance_group_urls][crate::model::node_pool::update_info::BlueGreenInfo::green_instance_group_urls].
            pub fn set_green_instance_group_urls<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.green_instance_group_urls = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [blue_pool_deletion_start_time][crate::model::node_pool::update_info::BlueGreenInfo::blue_pool_deletion_start_time].
            pub fn set_blue_pool_deletion_start_time<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.blue_pool_deletion_start_time = v.into();
                self
            }

            /// Sets the value of [green_pool_version][crate::model::node_pool::update_info::BlueGreenInfo::green_pool_version].
            pub fn set_green_pool_version<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.green_pool_version = v.into();
                self
            }
        }

        impl wkt::message::Message for BlueGreenInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.container.v1.NodePool.UpdateInfo.BlueGreenInfo"
            }
        }

        /// Defines additional types related to [BlueGreenInfo].
        pub mod blue_green_info {
            #[allow(unused_imports)]
            use super::*;

            /// Phase represents the different stages blue-green upgrade is running in.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Phase {
                /// Unspecified phase.
                Unspecified,
                /// blue-green upgrade has been initiated.
                UpdateStarted,
                /// Start creating green pool nodes.
                CreatingGreenPool,
                /// Start cordoning blue pool nodes.
                CordoningBluePool,
                /// Start draining blue pool nodes.
                DrainingBluePool,
                /// Start soaking time after draining entire blue pool.
                NodePoolSoaking,
                /// Start deleting blue nodes.
                DeletingBluePool,
                /// Rollback has been initiated.
                RollbackStarted,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [Phase::value] or
                /// [Phase::name].
                UnknownValue(phase::UnknownValue),
            }

            #[doc(hidden)]
            pub mod phase {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl Phase {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::UpdateStarted => std::option::Option::Some(1),
                        Self::CreatingGreenPool => std::option::Option::Some(2),
                        Self::CordoningBluePool => std::option::Option::Some(3),
                        Self::DrainingBluePool => std::option::Option::Some(4),
                        Self::NodePoolSoaking => std::option::Option::Some(5),
                        Self::DeletingBluePool => std::option::Option::Some(6),
                        Self::RollbackStarted => std::option::Option::Some(7),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("PHASE_UNSPECIFIED"),
                        Self::UpdateStarted => std::option::Option::Some("UPDATE_STARTED"),
                        Self::CreatingGreenPool => std::option::Option::Some("CREATING_GREEN_POOL"),
                        Self::CordoningBluePool => std::option::Option::Some("CORDONING_BLUE_POOL"),
                        Self::DrainingBluePool => std::option::Option::Some("DRAINING_BLUE_POOL"),
                        Self::NodePoolSoaking => std::option::Option::Some("NODE_POOL_SOAKING"),
                        Self::DeletingBluePool => std::option::Option::Some("DELETING_BLUE_POOL"),
                        Self::RollbackStarted => std::option::Option::Some("ROLLBACK_STARTED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for Phase {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for Phase {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for Phase {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::UpdateStarted,
                        2 => Self::CreatingGreenPool,
                        3 => Self::CordoningBluePool,
                        4 => Self::DrainingBluePool,
                        5 => Self::NodePoolSoaking,
                        6 => Self::DeletingBluePool,
                        7 => Self::RollbackStarted,
                        _ => Self::UnknownValue(phase::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for Phase {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "PHASE_UNSPECIFIED" => Self::Unspecified,
                        "UPDATE_STARTED" => Self::UpdateStarted,
                        "CREATING_GREEN_POOL" => Self::CreatingGreenPool,
                        "CORDONING_BLUE_POOL" => Self::CordoningBluePool,
                        "DRAINING_BLUE_POOL" => Self::DrainingBluePool,
                        "NODE_POOL_SOAKING" => Self::NodePoolSoaking,
                        "DELETING_BLUE_POOL" => Self::DeletingBluePool,
                        "ROLLBACK_STARTED" => Self::RollbackStarted,
                        _ => Self::UnknownValue(phase::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for Phase {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::UpdateStarted => serializer.serialize_i32(1),
                        Self::CreatingGreenPool => serializer.serialize_i32(2),
                        Self::CordoningBluePool => serializer.serialize_i32(3),
                        Self::DrainingBluePool => serializer.serialize_i32(4),
                        Self::NodePoolSoaking => serializer.serialize_i32(5),
                        Self::DeletingBluePool => serializer.serialize_i32(6),
                        Self::RollbackStarted => serializer.serialize_i32(7),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for Phase {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<Phase>::new(
                        ".google.container.v1.NodePool.UpdateInfo.BlueGreenInfo.Phase",
                    ))
                }
            }
        }
    }

    /// PlacementPolicy defines the placement policy used by the node pool.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PlacementPolicy {
        /// The type of placement.
        #[serde(rename = "type")]
        pub r#type: crate::model::node_pool::placement_policy::Type,

        /// Optional. TPU placement topology for pod slice node pool.
        /// <https://cloud.google.com/tpu/docs/types-topologies#tpu_topologies>
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub tpu_topology: std::string::String,

        /// If set, refers to the name of a custom resource policy supplied by the
        /// user. The resource policy must be in the same project and region as the
        /// node pool. If not found, InvalidArgument error is returned.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub policy_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PlacementPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::node_pool::PlacementPolicy::type].
        pub fn set_type<T: std::convert::Into<crate::model::node_pool::placement_policy::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [tpu_topology][crate::model::node_pool::PlacementPolicy::tpu_topology].
        pub fn set_tpu_topology<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.tpu_topology = v.into();
            self
        }

        /// Sets the value of [policy_name][crate::model::node_pool::PlacementPolicy::policy_name].
        pub fn set_policy_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.policy_name = v.into();
            self
        }
    }

    impl wkt::message::Message for PlacementPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NodePool.PlacementPolicy"
        }
    }

    /// Defines additional types related to [PlacementPolicy].
    pub mod placement_policy {
        #[allow(unused_imports)]
        use super::*;

        /// Type defines the type of placement policy.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// TYPE_UNSPECIFIED specifies no requirements on nodes
            /// placement.
            Unspecified,
            /// COMPACT specifies node placement in the same availability domain to
            /// ensure low communication latency.
            Compact,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Compact => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::Compact => std::option::Option::Some("COMPACT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Compact,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "COMPACT" => Self::Compact,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Compact => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.container.v1.NodePool.PlacementPolicy.Type",
                ))
            }
        }
    }

    /// QueuedProvisioning defines the queued provisioning used by the node pool.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QueuedProvisioning {
        /// Denotes that this nodepool is QRM specific, meaning nodes can be only
        /// obtained through queuing via the Cluster Autoscaler ProvisioningRequest
        /// API.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enabled: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueuedProvisioning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::node_pool::QueuedProvisioning::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for QueuedProvisioning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NodePool.QueuedProvisioning"
        }
    }

    /// The current status of the node pool instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Not set.
        Unspecified,
        /// The PROVISIONING state indicates the node pool is being created.
        Provisioning,
        /// The RUNNING state indicates the node pool has been created
        /// and is fully usable.
        Running,
        /// The RUNNING_WITH_ERROR state indicates the node pool has been created
        /// and is partially usable. Some error state has occurred and some
        /// functionality may be impaired. Customer may need to reissue a request
        /// or trigger a new update.
        RunningWithError,
        /// The RECONCILING state indicates that some work is actively being done on
        /// the node pool, such as upgrading node software. Details can
        /// be found in the `statusMessage` field.
        Reconciling,
        /// The STOPPING state indicates the node pool is being deleted.
        Stopping,
        /// The ERROR state indicates the node pool may be unusable. Details
        /// can be found in the `statusMessage` field.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::RunningWithError => std::option::Option::Some(3),
                Self::Reconciling => std::option::Option::Some(4),
                Self::Stopping => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::RunningWithError => std::option::Option::Some("RUNNING_WITH_ERROR"),
                Self::Reconciling => std::option::Option::Some("RECONCILING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Running,
                3 => Self::RunningWithError,
                4 => Self::Reconciling,
                5 => Self::Stopping,
                6 => Self::Error,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "RUNNING" => Self::Running,
                "RUNNING_WITH_ERROR" => Self::RunningWithError,
                "RECONCILING" => Self::Reconciling,
                "STOPPING" => Self::Stopping,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::RunningWithError => serializer.serialize_i32(3),
                Self::Reconciling => serializer.serialize_i32(4),
                Self::Stopping => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.container.v1.NodePool.Status",
            ))
        }
    }
}

/// NodeManagement defines the set of node management services turned on for the
/// node pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeManagement {
    /// A flag that specifies whether node auto-upgrade is enabled for the node
    /// pool. If enabled, node auto-upgrade helps keep the nodes in your node pool
    /// up to date with the latest release version of Kubernetes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub auto_upgrade: bool,

    /// A flag that specifies whether the node auto-repair is enabled for the node
    /// pool. If enabled, the nodes in this node pool will be monitored and, if
    /// they fail health checks too many times, an automatic repair action will be
    /// triggered.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub auto_repair: bool,

    /// Specifies the Auto Upgrade knobs for the node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upgrade_options: std::option::Option<crate::model::AutoUpgradeOptions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeManagement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auto_upgrade][crate::model::NodeManagement::auto_upgrade].
    pub fn set_auto_upgrade<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_upgrade = v.into();
        self
    }

    /// Sets the value of [auto_repair][crate::model::NodeManagement::auto_repair].
    pub fn set_auto_repair<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_repair = v.into();
        self
    }

    /// Sets the value of [upgrade_options][crate::model::NodeManagement::upgrade_options].
    pub fn set_upgrade_options<
        T: std::convert::Into<std::option::Option<crate::model::AutoUpgradeOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.upgrade_options = v.into();
        self
    }
}

impl wkt::message::Message for NodeManagement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeManagement"
    }
}

/// Best effort provisioning.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BestEffortProvisioning {
    /// When this is enabled, cluster/node pool creations will ignore non-fatal
    /// errors like stockout to best provision as many nodes as possible right now
    /// and eventually bring up all target number of nodes
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    /// Minimum number of nodes to be provisioned to be considered as succeeded,
    /// and the rest of nodes will be provisioned gradually and eventually when
    /// stockout issue has been resolved.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub min_provision_nodes: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BestEffortProvisioning {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::BestEffortProvisioning::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [min_provision_nodes][crate::model::BestEffortProvisioning::min_provision_nodes].
    pub fn set_min_provision_nodes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_provision_nodes = v.into();
        self
    }
}

impl wkt::message::Message for BestEffortProvisioning {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.BestEffortProvisioning"
    }
}

/// AutoUpgradeOptions defines the set of options for the user to control how
/// the Auto Upgrades will proceed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutoUpgradeOptions {
    /// Output only. This field is set when upgrades are about to commence
    /// with the approximate start time for the upgrades, in
    /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub auto_upgrade_start_time: std::string::String,

    /// Output only. This field is set when upgrades are about to commence
    /// with the description of the upgrade.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoUpgradeOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auto_upgrade_start_time][crate::model::AutoUpgradeOptions::auto_upgrade_start_time].
    pub fn set_auto_upgrade_start_time<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.auto_upgrade_start_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AutoUpgradeOptions::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for AutoUpgradeOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AutoUpgradeOptions"
    }
}

/// MaintenancePolicy defines the maintenance policy to be used for the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenancePolicy {
    /// Specifies the maintenance window in which maintenance may be performed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub window: std::option::Option<crate::model::MaintenanceWindow>,

    /// A hash identifying the version of this policy, so that updates to fields of
    /// the policy won't accidentally undo intermediate changes (and so that users
    /// of the API unaware of some fields won't accidentally remove other fields).
    /// Make a `get()` request to the cluster to get the current
    /// resource version and include it with requests to set the policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenancePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window][crate::model::MaintenancePolicy::window].
    pub fn set_window<
        T: std::convert::Into<std::option::Option<crate::model::MaintenanceWindow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.window = v.into();
        self
    }

    /// Sets the value of [resource_version][crate::model::MaintenancePolicy::resource_version].
    pub fn set_resource_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_version = v.into();
        self
    }
}

impl wkt::message::Message for MaintenancePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MaintenancePolicy"
    }
}

/// MaintenanceWindow defines the maintenance window to be used for the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenanceWindow {
    /// Exceptions to maintenance window. Non-emergency maintenance should not
    /// occur in these windows.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub maintenance_exclusions:
        std::collections::HashMap<std::string::String, crate::model::TimeWindow>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub policy: std::option::Option<crate::model::maintenance_window::Policy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [maintenance_exclusions][crate::model::MaintenanceWindow::maintenance_exclusions].
    pub fn set_maintenance_exclusions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TimeWindow>,
    {
        use std::iter::Iterator;
        self.maintenance_exclusions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [policy][crate::model::MaintenanceWindow::policy].
    ///
    /// Note that all the setters affecting `policy` are mutually
    /// exclusive.
    pub fn set_policy<
        T: std::convert::Into<std::option::Option<crate::model::maintenance_window::Policy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy = v.into();
        self
    }

    /// The value of [policy][crate::model::MaintenanceWindow::policy]
    /// if it holds a `DailyMaintenanceWindow`, `None` if the field is not set or
    /// holds a different branch.
    pub fn daily_maintenance_window(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DailyMaintenanceWindow>> {
        #[allow(unreachable_patterns)]
        self.policy.as_ref().and_then(|v| match v {
            crate::model::maintenance_window::Policy::DailyMaintenanceWindow(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [policy][crate::model::MaintenanceWindow::policy]
    /// to hold a `DailyMaintenanceWindow`.
    ///
    /// Note that all the setters affecting `policy` are
    /// mutually exclusive.
    pub fn set_daily_maintenance_window<
        T: std::convert::Into<std::boxed::Box<crate::model::DailyMaintenanceWindow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy = std::option::Option::Some(
            crate::model::maintenance_window::Policy::DailyMaintenanceWindow(v.into()),
        );
        self
    }

    /// The value of [policy][crate::model::MaintenanceWindow::policy]
    /// if it holds a `RecurringWindow`, `None` if the field is not set or
    /// holds a different branch.
    pub fn recurring_window(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RecurringTimeWindow>> {
        #[allow(unreachable_patterns)]
        self.policy.as_ref().and_then(|v| match v {
            crate::model::maintenance_window::Policy::RecurringWindow(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [policy][crate::model::MaintenanceWindow::policy]
    /// to hold a `RecurringWindow`.
    ///
    /// Note that all the setters affecting `policy` are
    /// mutually exclusive.
    pub fn set_recurring_window<
        T: std::convert::Into<std::boxed::Box<crate::model::RecurringTimeWindow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy = std::option::Option::Some(
            crate::model::maintenance_window::Policy::RecurringWindow(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MaintenanceWindow"
    }
}

/// Defines additional types related to [MaintenanceWindow].
pub mod maintenance_window {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Policy {
        /// DailyMaintenanceWindow specifies a daily maintenance operation window.
        DailyMaintenanceWindow(std::boxed::Box<crate::model::DailyMaintenanceWindow>),
        /// RecurringWindow specifies some number of recurring time periods for
        /// maintenance to occur. The time windows may be overlapping. If no
        /// maintenance windows are set, maintenance can occur at any time.
        RecurringWindow(std::boxed::Box<crate::model::RecurringTimeWindow>),
    }
}

/// Represents an arbitrary window of time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeWindow {
    /// The time that the window first starts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time that the window ends. The end time should take place after the
    /// start time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub options: std::option::Option<crate::model::time_window::Options>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::TimeWindow::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::TimeWindow::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [options][crate::model::TimeWindow::options].
    ///
    /// Note that all the setters affecting `options` are mutually
    /// exclusive.
    pub fn set_options<
        T: std::convert::Into<std::option::Option<crate::model::time_window::Options>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options = v.into();
        self
    }

    /// The value of [options][crate::model::TimeWindow::options]
    /// if it holds a `MaintenanceExclusionOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn maintenance_exclusion_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MaintenanceExclusionOptions>> {
        #[allow(unreachable_patterns)]
        self.options.as_ref().and_then(|v| match v {
            crate::model::time_window::Options::MaintenanceExclusionOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [options][crate::model::TimeWindow::options]
    /// to hold a `MaintenanceExclusionOptions`.
    ///
    /// Note that all the setters affecting `options` are
    /// mutually exclusive.
    pub fn set_maintenance_exclusion_options<
        T: std::convert::Into<std::boxed::Box<crate::model::MaintenanceExclusionOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options = std::option::Option::Some(
            crate::model::time_window::Options::MaintenanceExclusionOptions(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TimeWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.TimeWindow"
    }
}

/// Defines additional types related to [TimeWindow].
pub mod time_window {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Options {
        /// MaintenanceExclusionOptions provides maintenance exclusion related
        /// options.
        MaintenanceExclusionOptions(std::boxed::Box<crate::model::MaintenanceExclusionOptions>),
    }
}

/// Represents the Maintenance exclusion option.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenanceExclusionOptions {
    /// Scope specifies the upgrade scope which upgrades are blocked by the
    /// exclusion.
    pub scope: crate::model::maintenance_exclusion_options::Scope,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceExclusionOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scope][crate::model::MaintenanceExclusionOptions::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::maintenance_exclusion_options::Scope>>(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceExclusionOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MaintenanceExclusionOptions"
    }
}

/// Defines additional types related to [MaintenanceExclusionOptions].
pub mod maintenance_exclusion_options {
    #[allow(unused_imports)]
    use super::*;

    /// Scope of exclusion.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// NO_UPGRADES excludes all upgrades, including patch upgrades and minor
        /// upgrades across control planes and nodes. This is the default exclusion
        /// behavior.
        NoUpgrades,
        /// NO_MINOR_UPGRADES excludes all minor upgrades for the cluster, only
        /// patches are allowed.
        NoMinorUpgrades,
        /// NO_MINOR_OR_NODE_UPGRADES excludes all minor upgrades for the cluster,
        /// and also exclude all node pool upgrades. Only control
        /// plane patches are allowed.
        NoMinorOrNodeUpgrades,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::NoUpgrades => std::option::Option::Some(0),
                Self::NoMinorUpgrades => std::option::Option::Some(1),
                Self::NoMinorOrNodeUpgrades => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::NoUpgrades => std::option::Option::Some("NO_UPGRADES"),
                Self::NoMinorUpgrades => std::option::Option::Some("NO_MINOR_UPGRADES"),
                Self::NoMinorOrNodeUpgrades => {
                    std::option::Option::Some("NO_MINOR_OR_NODE_UPGRADES")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::NoUpgrades,
                1 => Self::NoMinorUpgrades,
                2 => Self::NoMinorOrNodeUpgrades,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NO_UPGRADES" => Self::NoUpgrades,
                "NO_MINOR_UPGRADES" => Self::NoMinorUpgrades,
                "NO_MINOR_OR_NODE_UPGRADES" => Self::NoMinorOrNodeUpgrades,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::NoUpgrades => serializer.serialize_i32(0),
                Self::NoMinorUpgrades => serializer.serialize_i32(1),
                Self::NoMinorOrNodeUpgrades => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".google.container.v1.MaintenanceExclusionOptions.Scope",
            ))
        }
    }
}

/// Represents an arbitrary window of time that recurs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecurringTimeWindow {
    /// The window of the first recurrence.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub window: std::option::Option<crate::model::TimeWindow>,

    /// An RRULE (<https://tools.ietf.org/html/rfc5545#section-3.8.5.3>) for how
    /// this window reccurs. They go on for the span of time between the start and
    /// end time.
    ///
    /// For example, to have something repeat every weekday, you'd use:
    /// `FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR`
    ///
    /// To repeat some window daily (equivalent to the DailyMaintenanceWindow):
    /// `FREQ=DAILY`
    ///
    /// For the first weekend of every month:
    /// `FREQ=MONTHLY;BYSETPOS=1;BYDAY=SA,SU`
    ///
    /// This specifies how frequently the window starts. Eg, if you wanted to have
    /// a 9-5 UTC-4 window every weekday, you'd use something like:
    ///
    /// ```norust
    /// start time = 2019-01-01T09:00:00-0400
    /// end time = 2019-01-01T17:00:00-0400
    /// recurrence = FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR
    /// ```
    ///
    /// Windows can span multiple days. Eg, to make the window encompass every
    /// weekend from midnight Saturday till the last minute of Sunday UTC:
    ///
    /// ```norust
    /// start time = 2019-01-05T00:00:00Z
    /// end time = 2019-01-07T23:59:00Z
    /// recurrence = FREQ=WEEKLY;BYDAY=SA
    /// ```
    ///
    /// Note the start and end time's specific dates are largely arbitrary except
    /// to specify duration of the window and when it first starts.
    /// The FREQ values of HOURLY, MINUTELY, and SECONDLY are not supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub recurrence: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecurringTimeWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window][crate::model::RecurringTimeWindow::window].
    pub fn set_window<T: std::convert::Into<std::option::Option<crate::model::TimeWindow>>>(
        mut self,
        v: T,
    ) -> Self {
        self.window = v.into();
        self
    }

    /// Sets the value of [recurrence][crate::model::RecurringTimeWindow::recurrence].
    pub fn set_recurrence<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recurrence = v.into();
        self
    }
}

impl wkt::message::Message for RecurringTimeWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.RecurringTimeWindow"
    }
}

/// Time window specified for daily maintenance operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DailyMaintenanceWindow {
    /// Time within the maintenance window to start the maintenance operations.
    /// Time format should be in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt)
    /// format "HH:MM", where HH : [00-23] and MM : [00-59] GMT.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub start_time: std::string::String,

    /// Output only. Duration of the time window, automatically chosen to be
    /// smallest possible in the given scenario.
    /// Duration will be in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt)
    /// format "PTnHnMnS".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub duration: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DailyMaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::DailyMaintenanceWindow::start_time].
    pub fn set_start_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::DailyMaintenanceWindow::duration].
    pub fn set_duration<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.duration = v.into();
        self
    }
}

impl wkt::message::Message for DailyMaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DailyMaintenanceWindow"
    }
}

/// SetNodePoolManagementRequest sets the node management properties of a node
/// pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetNodePoolManagementRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to update.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Deprecated. The name of the node pool to update.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub node_pool_id: std::string::String,

    /// Required. NodeManagement configuration for the node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub management: std::option::Option<crate::model::NodeManagement>,

    /// The name (project, location, cluster, node pool id) of the node pool to set
    /// management properties. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetNodePoolManagementRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetNodePoolManagementRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetNodePoolManagementRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetNodePoolManagementRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::SetNodePoolManagementRequest::node_pool_id].
    #[deprecated]
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [management][crate::model::SetNodePoolManagementRequest::management].
    pub fn set_management<
        T: std::convert::Into<std::option::Option<crate::model::NodeManagement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.management = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetNodePoolManagementRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetNodePoolManagementRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetNodePoolManagementRequest"
    }
}

/// SetNodePoolSizeRequest sets the size of a node pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetNodePoolSizeRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to update.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Deprecated. The name of the node pool to update.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub node_pool_id: std::string::String,

    /// Required. The desired node count for the pool.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub node_count: i32,

    /// The name (project, location, cluster, node pool id) of the node pool to set
    /// size.
    /// Specified in the format `projects/*/locations/*/clusters/*/nodePools/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetNodePoolSizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetNodePoolSizeRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetNodePoolSizeRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetNodePoolSizeRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::SetNodePoolSizeRequest::node_pool_id].
    #[deprecated]
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [node_count][crate::model::SetNodePoolSizeRequest::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetNodePoolSizeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetNodePoolSizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetNodePoolSizeRequest"
    }
}

/// CompleteNodePoolUpgradeRequest sets the name of target node pool to complete
/// upgrade.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CompleteNodePoolUpgradeRequest {
    /// The name (project, location, cluster, node pool id) of the node pool to
    /// complete upgrade.
    /// Specified in the format `projects/*/locations/*/clusters/*/nodePools/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompleteNodePoolUpgradeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CompleteNodePoolUpgradeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CompleteNodePoolUpgradeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CompleteNodePoolUpgradeRequest"
    }
}

/// RollbackNodePoolUpgradeRequest rollbacks the previously Aborted or Failed
/// NodePool upgrade. This will be an no-op if the last upgrade successfully
/// completed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RollbackNodePoolUpgradeRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to rollback.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Deprecated. The name of the node pool to rollback.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub node_pool_id: std::string::String,

    /// The name (project, location, cluster, node pool id) of the node poll to
    /// rollback upgrade.
    /// Specified in the format `projects/*/locations/*/clusters/*/nodePools/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Option for rollback to ignore the PodDisruptionBudget.
    /// Default value is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub respect_pdb: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackNodePoolUpgradeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::RollbackNodePoolUpgradeRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::RollbackNodePoolUpgradeRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::RollbackNodePoolUpgradeRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::RollbackNodePoolUpgradeRequest::node_pool_id].
    #[deprecated]
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::RollbackNodePoolUpgradeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [respect_pdb][crate::model::RollbackNodePoolUpgradeRequest::respect_pdb].
    pub fn set_respect_pdb<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.respect_pdb = v.into();
        self
    }
}

impl wkt::message::Message for RollbackNodePoolUpgradeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.RollbackNodePoolUpgradeRequest"
    }
}

/// ListNodePoolsResponse is the result of ListNodePoolsRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNodePoolsResponse {
    /// A list of node pools for a cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub node_pools: std::vec::Vec<crate::model::NodePool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNodePoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_pools][crate::model::ListNodePoolsResponse::node_pools].
    pub fn set_node_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodePool>,
    {
        use std::iter::Iterator;
        self.node_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNodePoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListNodePoolsResponse"
    }
}

/// ClusterAutoscaling contains global, per-cluster information
/// required by Cluster Autoscaler to automatically adjust
/// the size of the cluster and create/delete
/// node pools based on the current needs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterAutoscaling {
    /// Enables automatic node pool creation and deletion.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_node_autoprovisioning: bool,

    /// Contains global constraints regarding minimum and maximum
    /// amount of resources in the cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_limits: std::vec::Vec<crate::model::ResourceLimit>,

    /// Defines autoscaling behaviour.
    pub autoscaling_profile: crate::model::cluster_autoscaling::AutoscalingProfile,

    /// AutoprovisioningNodePoolDefaults contains defaults for a node pool
    /// created by NAP.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoprovisioning_node_pool_defaults:
        std::option::Option<crate::model::AutoprovisioningNodePoolDefaults>,

    /// The list of Google Compute Engine
    /// [zones](https://cloud.google.com/compute/docs/zones#available) in which the
    /// NodePool's nodes can be created by NAP.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub autoprovisioning_locations: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterAutoscaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_node_autoprovisioning][crate::model::ClusterAutoscaling::enable_node_autoprovisioning].
    pub fn set_enable_node_autoprovisioning<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_node_autoprovisioning = v.into();
        self
    }

    /// Sets the value of [resource_limits][crate::model::ClusterAutoscaling::resource_limits].
    pub fn set_resource_limits<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceLimit>,
    {
        use std::iter::Iterator;
        self.resource_limits = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [autoscaling_profile][crate::model::ClusterAutoscaling::autoscaling_profile].
    pub fn set_autoscaling_profile<
        T: std::convert::Into<crate::model::cluster_autoscaling::AutoscalingProfile>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling_profile = v.into();
        self
    }

    /// Sets the value of [autoprovisioning_node_pool_defaults][crate::model::ClusterAutoscaling::autoprovisioning_node_pool_defaults].
    pub fn set_autoprovisioning_node_pool_defaults<
        T: std::convert::Into<std::option::Option<crate::model::AutoprovisioningNodePoolDefaults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoprovisioning_node_pool_defaults = v.into();
        self
    }

    /// Sets the value of [autoprovisioning_locations][crate::model::ClusterAutoscaling::autoprovisioning_locations].
    pub fn set_autoprovisioning_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.autoprovisioning_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ClusterAutoscaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ClusterAutoscaling"
    }
}

/// Defines additional types related to [ClusterAutoscaling].
pub mod cluster_autoscaling {
    #[allow(unused_imports)]
    use super::*;

    /// Defines possible options for autoscaling_profile field.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutoscalingProfile {
        /// No change to autoscaling configuration.
        ProfileUnspecified,
        /// Prioritize optimizing utilization of resources.
        OptimizeUtilization,
        /// Use default (balanced) autoscaling configuration.
        Balanced,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutoscalingProfile::value] or
        /// [AutoscalingProfile::name].
        UnknownValue(autoscaling_profile::UnknownValue),
    }

    #[doc(hidden)]
    pub mod autoscaling_profile {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AutoscalingProfile {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::ProfileUnspecified => std::option::Option::Some(0),
                Self::OptimizeUtilization => std::option::Option::Some(1),
                Self::Balanced => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::ProfileUnspecified => std::option::Option::Some("PROFILE_UNSPECIFIED"),
                Self::OptimizeUtilization => std::option::Option::Some("OPTIMIZE_UTILIZATION"),
                Self::Balanced => std::option::Option::Some("BALANCED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AutoscalingProfile {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AutoscalingProfile {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AutoscalingProfile {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::ProfileUnspecified,
                1 => Self::OptimizeUtilization,
                2 => Self::Balanced,
                _ => Self::UnknownValue(autoscaling_profile::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AutoscalingProfile {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROFILE_UNSPECIFIED" => Self::ProfileUnspecified,
                "OPTIMIZE_UTILIZATION" => Self::OptimizeUtilization,
                "BALANCED" => Self::Balanced,
                _ => Self::UnknownValue(autoscaling_profile::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AutoscalingProfile {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::ProfileUnspecified => serializer.serialize_i32(0),
                Self::OptimizeUtilization => serializer.serialize_i32(1),
                Self::Balanced => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AutoscalingProfile {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AutoscalingProfile>::new(
                ".google.container.v1.ClusterAutoscaling.AutoscalingProfile",
            ))
        }
    }
}

/// AutoprovisioningNodePoolDefaults contains defaults for a node pool created
/// by NAP.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutoprovisioningNodePoolDefaults {
    /// Scopes that are used by NAP when creating node pools.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub oauth_scopes: std::vec::Vec<std::string::String>,

    /// The Google Cloud Platform Service Account to be used by the node VMs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Specifies the upgrade settings for NAP created node pools
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upgrade_settings: std::option::Option<crate::model::node_pool::UpgradeSettings>,

    /// Specifies the node management options for NAP created node-pools.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub management: std::option::Option<crate::model::NodeManagement>,

    /// Deprecated. Minimum CPU platform to be used for NAP created node pools.
    /// The instance may be scheduled on the specified or newer CPU platform.
    /// Applicable values are the friendly names of CPU platforms, such as
    /// minCpuPlatform: Intel Haswell or
    /// minCpuPlatform: Intel Sandy Bridge. For more
    /// information, read [how to specify min CPU
    /// platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform).
    /// This field is deprecated, min_cpu_platform should be specified using
    /// `cloud.google.com/requested-min-cpu-platform` label selector on the pod.
    /// To unset the min cpu platform field pass "automatic"
    /// as field value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub min_cpu_platform: std::string::String,

    /// Size of the disk attached to each node, specified in GB.
    /// The smallest allowed disk size is 10GB.
    ///
    /// If unspecified, the default disk size is 100GB.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disk_size_gb: i32,

    /// Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd' or
    /// 'pd-balanced')
    ///
    /// If unspecified, the default disk type is 'pd-standard'
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub disk_type: std::string::String,

    /// Shielded Instance options.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub shielded_instance_config: std::option::Option<crate::model::ShieldedInstanceConfig>,

    /// The Customer Managed Encryption Key used to encrypt the boot disk attached
    /// to each node in the node pool. This should be of the form
    /// projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME].
    /// For more information about protecting resources with Cloud KMS Keys please
    /// see:
    /// <https://cloud.google.com/compute/docs/disks/customer-managed-encryption>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub boot_disk_kms_key: std::string::String,

    /// The image type to use for NAP created node. Please see
    /// <https://cloud.google.com/kubernetes-engine/docs/concepts/node-images> for
    /// available image types.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_type: std::string::String,

    /// Enable or disable Kubelet read only port.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub insecure_kubelet_readonly_port_enabled: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoprovisioningNodePoolDefaults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [oauth_scopes][crate::model::AutoprovisioningNodePoolDefaults::oauth_scopes].
    pub fn set_oauth_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.oauth_scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::AutoprovisioningNodePoolDefaults::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [upgrade_settings][crate::model::AutoprovisioningNodePoolDefaults::upgrade_settings].
    pub fn set_upgrade_settings<
        T: std::convert::Into<std::option::Option<crate::model::node_pool::UpgradeSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.upgrade_settings = v.into();
        self
    }

    /// Sets the value of [management][crate::model::AutoprovisioningNodePoolDefaults::management].
    pub fn set_management<
        T: std::convert::Into<std::option::Option<crate::model::NodeManagement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.management = v.into();
        self
    }

    /// Sets the value of [min_cpu_platform][crate::model::AutoprovisioningNodePoolDefaults::min_cpu_platform].
    #[deprecated]
    pub fn set_min_cpu_platform<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_cpu_platform = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::AutoprovisioningNodePoolDefaults::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::AutoprovisioningNodePoolDefaults::disk_type].
    pub fn set_disk_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [shielded_instance_config][crate::model::AutoprovisioningNodePoolDefaults::shielded_instance_config].
    pub fn set_shielded_instance_config<
        T: std::convert::Into<std::option::Option<crate::model::ShieldedInstanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.shielded_instance_config = v.into();
        self
    }

    /// Sets the value of [boot_disk_kms_key][crate::model::AutoprovisioningNodePoolDefaults::boot_disk_kms_key].
    pub fn set_boot_disk_kms_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_disk_kms_key = v.into();
        self
    }

    /// Sets the value of [image_type][crate::model::AutoprovisioningNodePoolDefaults::image_type].
    pub fn set_image_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_type = v.into();
        self
    }

    /// Sets the value of [insecure_kubelet_readonly_port_enabled][crate::model::AutoprovisioningNodePoolDefaults::insecure_kubelet_readonly_port_enabled].
    pub fn set_insecure_kubelet_readonly_port_enabled<
        T: std::convert::Into<std::option::Option<bool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.insecure_kubelet_readonly_port_enabled = v.into();
        self
    }
}

impl wkt::message::Message for AutoprovisioningNodePoolDefaults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AutoprovisioningNodePoolDefaults"
    }
}

/// Contains information about amount of some resource in the cluster.
/// For memory, value should be in GB.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceLimit {
    /// Resource name "cpu", "memory" or gpu-specific string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_type: std::string::String,

    /// Minimum amount of the resource in the cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub minimum: i64,

    /// Maximum amount of the resource in the cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub maximum: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceLimit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_type][crate::model::ResourceLimit::resource_type].
    pub fn set_resource_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [minimum][crate::model::ResourceLimit::minimum].
    pub fn set_minimum<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.minimum = v.into();
        self
    }

    /// Sets the value of [maximum][crate::model::ResourceLimit::maximum].
    pub fn set_maximum<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.maximum = v.into();
        self
    }
}

impl wkt::message::Message for ResourceLimit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ResourceLimit"
    }
}

/// NodePoolAutoscaling contains information required by cluster autoscaler to
/// adjust the size of the node pool to the current cluster usage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodePoolAutoscaling {
    /// Is autoscaling enabled for this node pool.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    /// Minimum number of nodes for one location in the node pool. Must be greater
    /// than or equal to 0 and less than or equal to max_node_count.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub min_node_count: i32,

    /// Maximum number of nodes for one location in the node pool. Must be >=
    /// min_node_count. There has to be enough quota to scale up the cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_node_count: i32,

    /// Can this node pool be deleted automatically.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub autoprovisioned: bool,

    /// Location policy used when scaling up a nodepool.
    pub location_policy: crate::model::node_pool_autoscaling::LocationPolicy,

    /// Minimum number of nodes in the node pool. Must be greater than or equal
    /// to 0 and less than or equal to total_max_node_count.
    /// The total_*_node_count fields are mutually exclusive with the *_node_count
    /// fields.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub total_min_node_count: i32,

    /// Maximum number of nodes in the node pool. Must be greater than or equal to
    /// total_min_node_count. There has to be enough quota to scale up the cluster.
    /// The total_*_node_count fields are mutually exclusive with the *_node_count
    /// fields.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub total_max_node_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodePoolAutoscaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::NodePoolAutoscaling::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [min_node_count][crate::model::NodePoolAutoscaling::min_node_count].
    pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_count = v.into();
        self
    }

    /// Sets the value of [max_node_count][crate::model::NodePoolAutoscaling::max_node_count].
    pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_node_count = v.into();
        self
    }

    /// Sets the value of [autoprovisioned][crate::model::NodePoolAutoscaling::autoprovisioned].
    pub fn set_autoprovisioned<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.autoprovisioned = v.into();
        self
    }

    /// Sets the value of [location_policy][crate::model::NodePoolAutoscaling::location_policy].
    pub fn set_location_policy<
        T: std::convert::Into<crate::model::node_pool_autoscaling::LocationPolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location_policy = v.into();
        self
    }

    /// Sets the value of [total_min_node_count][crate::model::NodePoolAutoscaling::total_min_node_count].
    pub fn set_total_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_min_node_count = v.into();
        self
    }

    /// Sets the value of [total_max_node_count][crate::model::NodePoolAutoscaling::total_max_node_count].
    pub fn set_total_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_max_node_count = v.into();
        self
    }
}

impl wkt::message::Message for NodePoolAutoscaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodePoolAutoscaling"
    }
}

/// Defines additional types related to [NodePoolAutoscaling].
pub mod node_pool_autoscaling {
    #[allow(unused_imports)]
    use super::*;

    /// Location policy specifies how zones are picked when scaling up the
    /// nodepool.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LocationPolicy {
        /// Not set.
        Unspecified,
        /// BALANCED is a best effort policy that aims to balance the sizes of
        /// different zones.
        Balanced,
        /// ANY policy picks zones that have the highest capacity available.
        Any,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LocationPolicy::value] or
        /// [LocationPolicy::name].
        UnknownValue(location_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod location_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LocationPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Balanced => std::option::Option::Some(1),
                Self::Any => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOCATION_POLICY_UNSPECIFIED"),
                Self::Balanced => std::option::Option::Some("BALANCED"),
                Self::Any => std::option::Option::Some("ANY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LocationPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LocationPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LocationPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Balanced,
                2 => Self::Any,
                _ => Self::UnknownValue(location_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LocationPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOCATION_POLICY_UNSPECIFIED" => Self::Unspecified,
                "BALANCED" => Self::Balanced,
                "ANY" => Self::Any,
                _ => Self::UnknownValue(location_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LocationPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Balanced => serializer.serialize_i32(1),
                Self::Any => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LocationPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LocationPolicy>::new(
                ".google.container.v1.NodePoolAutoscaling.LocationPolicy",
            ))
        }
    }
}

/// SetLabelsRequest sets the Google Cloud Platform labels on a Google Container
/// Engine cluster, which will in turn set them for Google Compute Engine
/// resources used by that cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetLabelsRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The labels to set for that cluster.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub resource_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The fingerprint of the previous set of labels for this resource,
    /// used to detect conflicts. The fingerprint is initially generated by
    /// Kubernetes Engine and changes after every request to modify or update
    /// labels. You must always provide an up-to-date fingerprint hash when
    /// updating or changing labels. Make a `get()` request to the
    /// resource to get the latest fingerprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub label_fingerprint: std::string::String,

    /// The name (project, location, cluster name) of the cluster to set labels.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetLabelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetLabelsRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetLabelsRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetLabelsRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [resource_labels][crate::model::SetLabelsRequest::resource_labels].
    pub fn set_resource_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [label_fingerprint][crate::model::SetLabelsRequest::label_fingerprint].
    pub fn set_label_fingerprint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.label_fingerprint = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetLabelsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetLabelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetLabelsRequest"
    }
}

/// SetLegacyAbacRequest enables or disables the ABAC authorization mechanism for
/// a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetLegacyAbacRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to update.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. Whether ABAC authorization will be enabled in the cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    /// The name (project, location, cluster name) of the cluster to set legacy
    /// abac. Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetLegacyAbacRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetLegacyAbacRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetLegacyAbacRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetLegacyAbacRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::SetLegacyAbacRequest::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetLegacyAbacRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetLegacyAbacRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetLegacyAbacRequest"
    }
}

/// StartIPRotationRequest creates a new IP for the cluster and then performs
/// a node upgrade on each node pool to point to the new IP.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartIPRotationRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// The name (project, location, cluster name) of the cluster to start IP
    /// rotation. Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Whether to rotate credentials during IP rotation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub rotate_credentials: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartIPRotationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::StartIPRotationRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::StartIPRotationRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::StartIPRotationRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::StartIPRotationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [rotate_credentials][crate::model::StartIPRotationRequest::rotate_credentials].
    pub fn set_rotate_credentials<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.rotate_credentials = v.into();
        self
    }
}

impl wkt::message::Message for StartIPRotationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.StartIPRotationRequest"
    }
}

/// CompleteIPRotationRequest moves the cluster master back into single-IP mode.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CompleteIPRotationRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// The name (project, location, cluster name) of the cluster to complete IP
    /// rotation. Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompleteIPRotationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CompleteIPRotationRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::CompleteIPRotationRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CompleteIPRotationRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::CompleteIPRotationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CompleteIPRotationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CompleteIPRotationRequest"
    }
}

/// AcceleratorConfig represents a Hardware Accelerator request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AcceleratorConfig {
    /// The number of the accelerator cards exposed to an instance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub accelerator_count: i64,

    /// The accelerator type resource name. List of supported accelerators
    /// [here](https://cloud.google.com/compute/docs/gpus)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub accelerator_type: std::string::String,

    /// Size of partitions to create on the GPU. Valid values are described in the
    /// NVIDIA [mig user
    /// guide](https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gpu_partition_size: std::string::String,

    /// The configuration for GPU sharing options.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gpu_sharing_config: std::option::Option<crate::model::GPUSharingConfig>,

    /// The configuration for auto installation of GPU driver.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gpu_driver_installation_config:
        std::option::Option<crate::model::GPUDriverInstallationConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AcceleratorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [accelerator_count][crate::model::AcceleratorConfig::accelerator_count].
    pub fn set_accelerator_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.accelerator_count = v.into();
        self
    }

    /// Sets the value of [accelerator_type][crate::model::AcceleratorConfig::accelerator_type].
    pub fn set_accelerator_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.accelerator_type = v.into();
        self
    }

    /// Sets the value of [gpu_partition_size][crate::model::AcceleratorConfig::gpu_partition_size].
    pub fn set_gpu_partition_size<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gpu_partition_size = v.into();
        self
    }

    /// Sets the value of [gpu_sharing_config][crate::model::AcceleratorConfig::gpu_sharing_config].
    pub fn set_gpu_sharing_config<
        T: std::convert::Into<std::option::Option<crate::model::GPUSharingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gpu_sharing_config = v.into();
        self
    }

    /// Sets the value of [gpu_driver_installation_config][crate::model::AcceleratorConfig::gpu_driver_installation_config].
    pub fn set_gpu_driver_installation_config<
        T: std::convert::Into<std::option::Option<crate::model::GPUDriverInstallationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gpu_driver_installation_config = v.into();
        self
    }
}

impl wkt::message::Message for AcceleratorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AcceleratorConfig"
    }
}

/// GPUSharingConfig represents the GPU sharing configuration for Hardware
/// Accelerators.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GPUSharingConfig {
    /// The max number of containers that can share a physical GPU.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_shared_clients_per_gpu: i64,

    /// The type of GPU sharing strategy to enable on the GPU node.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gpu_sharing_strategy:
        std::option::Option<crate::model::gpu_sharing_config::GPUSharingStrategy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GPUSharingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_shared_clients_per_gpu][crate::model::GPUSharingConfig::max_shared_clients_per_gpu].
    pub fn set_max_shared_clients_per_gpu<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_shared_clients_per_gpu = v.into();
        self
    }

    /// Sets the value of [gpu_sharing_strategy][crate::model::GPUSharingConfig::gpu_sharing_strategy].
    pub fn set_gpu_sharing_strategy<
        T: std::convert::Into<
                std::option::Option<crate::model::gpu_sharing_config::GPUSharingStrategy>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gpu_sharing_strategy = v.into();
        self
    }
}

impl wkt::message::Message for GPUSharingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GPUSharingConfig"
    }
}

/// Defines additional types related to [GPUSharingConfig].
pub mod gpu_sharing_config {
    #[allow(unused_imports)]
    use super::*;

    /// The type of GPU sharing strategy currently provided.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum GPUSharingStrategy {
        /// Default value.
        Unspecified,
        /// GPUs are time-shared between containers.
        TimeSharing,
        /// GPUs are shared between containers with NVIDIA MPS.
        Mps,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [GPUSharingStrategy::value] or
        /// [GPUSharingStrategy::name].
        UnknownValue(gpu_sharing_strategy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod gpu_sharing_strategy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl GPUSharingStrategy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TimeSharing => std::option::Option::Some(1),
                Self::Mps => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("GPU_SHARING_STRATEGY_UNSPECIFIED"),
                Self::TimeSharing => std::option::Option::Some("TIME_SHARING"),
                Self::Mps => std::option::Option::Some("MPS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for GPUSharingStrategy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for GPUSharingStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for GPUSharingStrategy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TimeSharing,
                2 => Self::Mps,
                _ => Self::UnknownValue(gpu_sharing_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for GPUSharingStrategy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "GPU_SHARING_STRATEGY_UNSPECIFIED" => Self::Unspecified,
                "TIME_SHARING" => Self::TimeSharing,
                "MPS" => Self::Mps,
                _ => Self::UnknownValue(gpu_sharing_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for GPUSharingStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TimeSharing => serializer.serialize_i32(1),
                Self::Mps => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for GPUSharingStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<GPUSharingStrategy>::new(
                ".google.container.v1.GPUSharingConfig.GPUSharingStrategy",
            ))
        }
    }
}

/// GPUDriverInstallationConfig specifies the version of GPU driver to be auto
/// installed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GPUDriverInstallationConfig {
    /// Mode for how the GPU driver is installed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gpu_driver_version:
        std::option::Option<crate::model::gpu_driver_installation_config::GPUDriverVersion>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GPUDriverInstallationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gpu_driver_version][crate::model::GPUDriverInstallationConfig::gpu_driver_version].
    pub fn set_gpu_driver_version<
        T: std::convert::Into<
                std::option::Option<crate::model::gpu_driver_installation_config::GPUDriverVersion>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gpu_driver_version = v.into();
        self
    }
}

impl wkt::message::Message for GPUDriverInstallationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GPUDriverInstallationConfig"
    }
}

/// Defines additional types related to [GPUDriverInstallationConfig].
pub mod gpu_driver_installation_config {
    #[allow(unused_imports)]
    use super::*;

    /// The GPU driver version to install.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum GPUDriverVersion {
        /// Default value is to not install any GPU driver.
        Unspecified,
        /// Disable GPU driver auto installation and needs manual installation
        InstallationDisabled,
        /// "Default" GPU driver in COS and Ubuntu.
        Default,
        /// "Latest" GPU driver in COS.
        Latest,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [GPUDriverVersion::value] or
        /// [GPUDriverVersion::name].
        UnknownValue(gpu_driver_version::UnknownValue),
    }

    #[doc(hidden)]
    pub mod gpu_driver_version {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl GPUDriverVersion {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InstallationDisabled => std::option::Option::Some(1),
                Self::Default => std::option::Option::Some(2),
                Self::Latest => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("GPU_DRIVER_VERSION_UNSPECIFIED"),
                Self::InstallationDisabled => std::option::Option::Some("INSTALLATION_DISABLED"),
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::Latest => std::option::Option::Some("LATEST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for GPUDriverVersion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for GPUDriverVersion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for GPUDriverVersion {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InstallationDisabled,
                2 => Self::Default,
                3 => Self::Latest,
                _ => Self::UnknownValue(gpu_driver_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for GPUDriverVersion {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "GPU_DRIVER_VERSION_UNSPECIFIED" => Self::Unspecified,
                "INSTALLATION_DISABLED" => Self::InstallationDisabled,
                "DEFAULT" => Self::Default,
                "LATEST" => Self::Latest,
                _ => Self::UnknownValue(gpu_driver_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for GPUDriverVersion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InstallationDisabled => serializer.serialize_i32(1),
                Self::Default => serializer.serialize_i32(2),
                Self::Latest => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for GPUDriverVersion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<GPUDriverVersion>::new(
                ".google.container.v1.GPUDriverInstallationConfig.GPUDriverVersion",
            ))
        }
    }
}

/// WorkloadMetadataConfig defines the metadata configuration to expose to
/// workloads on the node pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkloadMetadataConfig {
    /// Mode is the configuration for how to expose metadata to workloads running
    /// on the node pool.
    pub mode: crate::model::workload_metadata_config::Mode,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkloadMetadataConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::WorkloadMetadataConfig::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::workload_metadata_config::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for WorkloadMetadataConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.WorkloadMetadataConfig"
    }
}

/// Defines additional types related to [WorkloadMetadataConfig].
pub mod workload_metadata_config {
    #[allow(unused_imports)]
    use super::*;

    /// Mode is the configuration for how to expose metadata to workloads running
    /// on the node.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Not set.
        Unspecified,
        /// Expose all Compute Engine metadata to pods.
        GceMetadata,
        /// Run the GKE Metadata Server on this node. The GKE Metadata Server exposes
        /// a metadata API to workloads that is compatible with the V1 Compute
        /// Metadata APIs exposed by the Compute Engine and App Engine Metadata
        /// Servers. This feature can only be enabled if Workload Identity is enabled
        /// at the cluster level.
        GkeMetadata,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GceMetadata => std::option::Option::Some(1),
                Self::GkeMetadata => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::GceMetadata => std::option::Option::Some("GCE_METADATA"),
                Self::GkeMetadata => std::option::Option::Some("GKE_METADATA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GceMetadata,
                2 => Self::GkeMetadata,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "GCE_METADATA" => Self::GceMetadata,
                "GKE_METADATA" => Self::GkeMetadata,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GceMetadata => serializer.serialize_i32(1),
                Self::GkeMetadata => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.container.v1.WorkloadMetadataConfig.Mode",
            ))
        }
    }
}

/// SetNetworkPolicyRequest enables/disables network policy for a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetNetworkPolicyRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. Configuration options for the NetworkPolicy feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_policy: std::option::Option<crate::model::NetworkPolicy>,

    /// The name (project, location, cluster name) of the cluster to set networking
    /// policy. Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetNetworkPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetNetworkPolicyRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetNetworkPolicyRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetNetworkPolicyRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [network_policy][crate::model::SetNetworkPolicyRequest::network_policy].
    pub fn set_network_policy<
        T: std::convert::Into<std::option::Option<crate::model::NetworkPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_policy = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetNetworkPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetNetworkPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetNetworkPolicyRequest"
    }
}

/// SetMaintenancePolicyRequest sets the maintenance policy for a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetMaintenancePolicyRequest {
    /// Required. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
    /// cluster resides.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// Required. The name of the cluster to update.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_id: std::string::String,

    /// Required. The maintenance policy to be set for the cluster. An empty field
    /// clears the existing maintenance policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_policy: std::option::Option<crate::model::MaintenancePolicy>,

    /// The name (project, location, cluster name) of the cluster to set
    /// maintenance policy.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetMaintenancePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetMaintenancePolicyRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetMaintenancePolicyRequest::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetMaintenancePolicyRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [maintenance_policy][crate::model::SetMaintenancePolicyRequest::maintenance_policy].
    pub fn set_maintenance_policy<
        T: std::convert::Into<std::option::Option<crate::model::MaintenancePolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_policy = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetMaintenancePolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetMaintenancePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetMaintenancePolicyRequest"
    }
}

/// StatusCondition describes why a cluster or a node pool has a certain status
/// (e.g., ERROR or DEGRADED).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StatusCondition {
    /// Machine-friendly representation of the condition
    /// Deprecated. Use canonical_code instead.
    #[deprecated]
    pub code: crate::model::status_condition::Code,

    /// Human-friendly representation of the condition
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// Canonical code of the condition.
    pub canonical_code: rpc::model::Code,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StatusCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::StatusCondition::code].
    #[deprecated]
    pub fn set_code<T: std::convert::Into<crate::model::status_condition::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [message][crate::model::StatusCondition::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [canonical_code][crate::model::StatusCondition::canonical_code].
    pub fn set_canonical_code<T: std::convert::Into<rpc::model::Code>>(mut self, v: T) -> Self {
        self.canonical_code = v.into();
        self
    }
}

impl wkt::message::Message for StatusCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.StatusCondition"
    }
}

/// Defines additional types related to [StatusCondition].
pub mod status_condition {
    #[allow(unused_imports)]
    use super::*;

    /// Code for each condition
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Code {
        /// UNKNOWN indicates a generic condition.
        Unknown,
        /// GCE_STOCKOUT indicates that Google Compute Engine resources are
        /// temporarily unavailable.
        GceStockout,
        /// GKE_SERVICE_ACCOUNT_DELETED indicates that the user deleted their robot
        /// service account.
        GkeServiceAccountDeleted,
        /// Google Compute Engine quota was exceeded.
        GceQuotaExceeded,
        /// Cluster state was manually changed by an SRE due to a system logic error.
        SetByOperator,
        /// Unable to perform an encrypt operation against the CloudKMS key used for
        /// etcd level encryption.
        CloudKmsKeyError,
        /// Cluster CA is expiring soon.
        CaExpiring,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Code::value] or
        /// [Code::name].
        UnknownValue(code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Code {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::GceStockout => std::option::Option::Some(1),
                Self::GkeServiceAccountDeleted => std::option::Option::Some(2),
                Self::GceQuotaExceeded => std::option::Option::Some(3),
                Self::SetByOperator => std::option::Option::Some(4),
                Self::CloudKmsKeyError => std::option::Option::Some(7),
                Self::CaExpiring => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::GceStockout => std::option::Option::Some("GCE_STOCKOUT"),
                Self::GkeServiceAccountDeleted => {
                    std::option::Option::Some("GKE_SERVICE_ACCOUNT_DELETED")
                }
                Self::GceQuotaExceeded => std::option::Option::Some("GCE_QUOTA_EXCEEDED"),
                Self::SetByOperator => std::option::Option::Some("SET_BY_OPERATOR"),
                Self::CloudKmsKeyError => std::option::Option::Some("CLOUD_KMS_KEY_ERROR"),
                Self::CaExpiring => std::option::Option::Some("CA_EXPIRING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Code {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::GceStockout,
                2 => Self::GkeServiceAccountDeleted,
                3 => Self::GceQuotaExceeded,
                4 => Self::SetByOperator,
                7 => Self::CloudKmsKeyError,
                9 => Self::CaExpiring,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Code {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "GCE_STOCKOUT" => Self::GceStockout,
                "GKE_SERVICE_ACCOUNT_DELETED" => Self::GkeServiceAccountDeleted,
                "GCE_QUOTA_EXCEEDED" => Self::GceQuotaExceeded,
                "SET_BY_OPERATOR" => Self::SetByOperator,
                "CLOUD_KMS_KEY_ERROR" => Self::CloudKmsKeyError,
                "CA_EXPIRING" => Self::CaExpiring,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Code {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::GceStockout => serializer.serialize_i32(1),
                Self::GkeServiceAccountDeleted => serializer.serialize_i32(2),
                Self::GceQuotaExceeded => serializer.serialize_i32(3),
                Self::SetByOperator => serializer.serialize_i32(4),
                Self::CloudKmsKeyError => serializer.serialize_i32(7),
                Self::CaExpiring => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Code {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                ".google.container.v1.StatusCondition.Code",
            ))
        }
    }
}

/// NetworkConfig reports the relative names of network & subnetwork.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkConfig {
    /// Output only. The relative name of the Google Compute Engine
    /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
    /// to which the cluster is connected. Example:
    /// projects/my-project/global/networks/my-network
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Output only. The relative name of the Google Compute Engine
    /// [subnetwork](https://cloud.google.com/compute/docs/vpc) to which the
    /// cluster is connected. Example:
    /// projects/my-project/regions/us-central1/subnetworks/my-subnet
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnetwork: std::string::String,

    /// Whether Intra-node visibility is enabled for this cluster.
    /// This makes same node pod to pod traffic visible for VPC network.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_intra_node_visibility: bool,

    /// Whether the cluster disables default in-node sNAT rules. In-node sNAT rules
    /// will be disabled when default_snat_status is disabled. When disabled is set
    /// to false, default IP masquerade rules will be applied to the nodes to
    /// prevent sNAT on cluster internal traffic.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_snat_status: std::option::Option<crate::model::DefaultSnatStatus>,

    /// Whether L4ILB Subsetting is enabled for this cluster.
    #[serde(rename = "enableL4ilbSubsetting")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_l4ilb_subsetting: bool,

    /// The desired datapath provider for this cluster. By default, uses the
    /// IPTables-based kube-proxy implementation.
    pub datapath_provider: crate::model::DatapathProvider,

    /// The desired state of IPv6 connectivity to Google Services.
    /// By default, no private IPv6 access to or from Google Services (all access
    /// will be via IPv4)
    pub private_ipv6_google_access: crate::model::PrivateIPv6GoogleAccess,

    /// DNSConfig contains clusterDNS config for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dns_config: std::option::Option<crate::model::DNSConfig>,

    /// ServiceExternalIPsConfig specifies if services with externalIPs field are
    /// blocked or not.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_external_ips_config: std::option::Option<crate::model::ServiceExternalIPsConfig>,

    /// GatewayAPIConfig contains the desired config of Gateway API on this
    /// cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gateway_api_config: std::option::Option<crate::model::GatewayAPIConfig>,

    /// Whether multi-networking is enabled for this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_multi_networking: bool,

    /// Network bandwidth tier configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_performance_config:
        std::option::Option<crate::model::network_config::ClusterNetworkPerformanceConfig>,

    /// Whether FQDN Network Policy is enabled on this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_fqdn_network_policy: std::option::Option<bool>,

    /// Specify the details of in-transit encryption.
    /// Now named inter-node transparent encryption.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub in_transit_encryption_config: std::option::Option<crate::model::InTransitEncryptionConfig>,

    /// Whether CiliumClusterwideNetworkPolicy is enabled on this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_cilium_clusterwide_network_policy: std::option::Option<bool>,

    /// Controls whether by default nodes have private IP addresses only.
    /// It is invalid to specify both [PrivateClusterConfig.enablePrivateNodes][]
    /// and this field at the same time.
    /// To update the default setting, use
    /// [ClusterUpdate.desired_default_enable_private_nodes][google.container.v1.ClusterUpdate.desired_default_enable_private_nodes]
    ///
    /// [google.container.v1.ClusterUpdate.desired_default_enable_private_nodes]: crate::model::ClusterUpdate::desired_default_enable_private_nodes
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_enable_private_nodes: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::NetworkConfig::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [enable_intra_node_visibility][crate::model::NetworkConfig::enable_intra_node_visibility].
    pub fn set_enable_intra_node_visibility<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_intra_node_visibility = v.into();
        self
    }

    /// Sets the value of [default_snat_status][crate::model::NetworkConfig::default_snat_status].
    pub fn set_default_snat_status<
        T: std::convert::Into<std::option::Option<crate::model::DefaultSnatStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_snat_status = v.into();
        self
    }

    /// Sets the value of [enable_l4ilb_subsetting][crate::model::NetworkConfig::enable_l4ilb_subsetting].
    pub fn set_enable_l4ilb_subsetting<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_l4ilb_subsetting = v.into();
        self
    }

    /// Sets the value of [datapath_provider][crate::model::NetworkConfig::datapath_provider].
    pub fn set_datapath_provider<T: std::convert::Into<crate::model::DatapathProvider>>(
        mut self,
        v: T,
    ) -> Self {
        self.datapath_provider = v.into();
        self
    }

    /// Sets the value of [private_ipv6_google_access][crate::model::NetworkConfig::private_ipv6_google_access].
    pub fn set_private_ipv6_google_access<
        T: std::convert::Into<crate::model::PrivateIPv6GoogleAccess>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_ipv6_google_access = v.into();
        self
    }

    /// Sets the value of [dns_config][crate::model::NetworkConfig::dns_config].
    pub fn set_dns_config<T: std::convert::Into<std::option::Option<crate::model::DNSConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dns_config = v.into();
        self
    }

    /// Sets the value of [service_external_ips_config][crate::model::NetworkConfig::service_external_ips_config].
    pub fn set_service_external_ips_config<
        T: std::convert::Into<std::option::Option<crate::model::ServiceExternalIPsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_external_ips_config = v.into();
        self
    }

    /// Sets the value of [gateway_api_config][crate::model::NetworkConfig::gateway_api_config].
    pub fn set_gateway_api_config<
        T: std::convert::Into<std::option::Option<crate::model::GatewayAPIConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gateway_api_config = v.into();
        self
    }

    /// Sets the value of [enable_multi_networking][crate::model::NetworkConfig::enable_multi_networking].
    pub fn set_enable_multi_networking<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_multi_networking = v.into();
        self
    }

    /// Sets the value of [network_performance_config][crate::model::NetworkConfig::network_performance_config].
    pub fn set_network_performance_config<
        T: std::convert::Into<
                std::option::Option<crate::model::network_config::ClusterNetworkPerformanceConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_performance_config = v.into();
        self
    }

    /// Sets the value of [enable_fqdn_network_policy][crate::model::NetworkConfig::enable_fqdn_network_policy].
    pub fn set_enable_fqdn_network_policy<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_fqdn_network_policy = v.into();
        self
    }

    /// Sets the value of [in_transit_encryption_config][crate::model::NetworkConfig::in_transit_encryption_config].
    pub fn set_in_transit_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::InTransitEncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.in_transit_encryption_config = v.into();
        self
    }

    /// Sets the value of [enable_cilium_clusterwide_network_policy][crate::model::NetworkConfig::enable_cilium_clusterwide_network_policy].
    pub fn set_enable_cilium_clusterwide_network_policy<
        T: std::convert::Into<std::option::Option<bool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.enable_cilium_clusterwide_network_policy = v.into();
        self
    }

    /// Sets the value of [default_enable_private_nodes][crate::model::NetworkConfig::default_enable_private_nodes].
    pub fn set_default_enable_private_nodes<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_enable_private_nodes = v.into();
        self
    }
}

impl wkt::message::Message for NetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NetworkConfig"
    }
}

/// Defines additional types related to [NetworkConfig].
pub mod network_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of network bandwidth tiers
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ClusterNetworkPerformanceConfig {
        /// Specifies the total network bandwidth tier for NodePools in the cluster.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub total_egress_bandwidth_tier: std::option::Option<
            crate::model::network_config::cluster_network_performance_config::Tier,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClusterNetworkPerformanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [total_egress_bandwidth_tier][crate::model::network_config::ClusterNetworkPerformanceConfig::total_egress_bandwidth_tier].
        pub fn set_total_egress_bandwidth_tier<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::network_config::cluster_network_performance_config::Tier,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.total_egress_bandwidth_tier = v.into();
            self
        }
    }

    impl wkt::message::Message for ClusterNetworkPerformanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NetworkConfig.ClusterNetworkPerformanceConfig"
        }
    }

    /// Defines additional types related to [ClusterNetworkPerformanceConfig].
    pub mod cluster_network_performance_config {
        #[allow(unused_imports)]
        use super::*;

        /// Node network tier
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Tier {
            /// Default value
            Unspecified,
            /// Higher bandwidth, actual values based on VM size.
            _1,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Tier::value] or
            /// [Tier::name].
            UnknownValue(tier::UnknownValue),
        }

        #[doc(hidden)]
        pub mod tier {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Tier {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::_1 => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TIER_UNSPECIFIED"),
                    Self::_1 => std::option::Option::Some("TIER_1"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Tier {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Tier {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Tier {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::_1,
                    _ => Self::UnknownValue(tier::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Tier {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TIER_UNSPECIFIED" => Self::Unspecified,
                    "TIER_1" => Self::_1,
                    _ => Self::UnknownValue(tier::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Tier {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::_1 => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Tier {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Tier>::new(
                    ".google.container.v1.NetworkConfig.ClusterNetworkPerformanceConfig.Tier",
                ))
            }
        }
    }
}

/// GatewayAPIConfig contains the desired config of Gateway API on this cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GatewayAPIConfig {
    /// The Gateway API release channel to use for Gateway API.
    pub channel: crate::model::gateway_api_config::Channel,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GatewayAPIConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channel][crate::model::GatewayAPIConfig::channel].
    pub fn set_channel<T: std::convert::Into<crate::model::gateway_api_config::Channel>>(
        mut self,
        v: T,
    ) -> Self {
        self.channel = v.into();
        self
    }
}

impl wkt::message::Message for GatewayAPIConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GatewayAPIConfig"
    }
}

/// Defines additional types related to [GatewayAPIConfig].
pub mod gateway_api_config {
    #[allow(unused_imports)]
    use super::*;

    /// Channel describes if/how Gateway API should be installed and implemented in
    /// a cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Channel {
        /// Default value.
        Unspecified,
        /// Gateway API support is disabled
        Disabled,
        /// Deprecated: use CHANNEL_STANDARD instead.
        /// Gateway API support is enabled, experimental CRDs are installed
        #[deprecated]
        Experimental,
        /// Gateway API support is enabled, standard CRDs are installed
        Standard,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Channel::value] or
        /// [Channel::name].
        UnknownValue(channel::UnknownValue),
    }

    #[doc(hidden)]
    pub mod channel {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Channel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Experimental => std::option::Option::Some(3),
                Self::Standard => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CHANNEL_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("CHANNEL_DISABLED"),
                Self::Experimental => std::option::Option::Some("CHANNEL_EXPERIMENTAL"),
                Self::Standard => std::option::Option::Some("CHANNEL_STANDARD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Channel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Channel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Channel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                3 => Self::Experimental,
                4 => Self::Standard,
                _ => Self::UnknownValue(channel::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Channel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CHANNEL_UNSPECIFIED" => Self::Unspecified,
                "CHANNEL_DISABLED" => Self::Disabled,
                "CHANNEL_EXPERIMENTAL" => Self::Experimental,
                "CHANNEL_STANDARD" => Self::Standard,
                _ => Self::UnknownValue(channel::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Channel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Experimental => serializer.serialize_i32(3),
                Self::Standard => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Channel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Channel>::new(
                ".google.container.v1.GatewayAPIConfig.Channel",
            ))
        }
    }
}

/// Config to block services with externalIPs field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceExternalIPsConfig {
    /// Whether Services with ExternalIPs field are allowed or not.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceExternalIPsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ServiceExternalIPsConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for ServiceExternalIPsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ServiceExternalIPsConfig"
    }
}

/// GetOpenIDConfigRequest gets the OIDC discovery document for the
/// cluster. See the OpenID Connect Discovery 1.0 specification for details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetOpenIDConfigRequest {
    /// The cluster (project, location, cluster name) to get the discovery document
    /// for. Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOpenIDConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GetOpenIDConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for GetOpenIDConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetOpenIDConfigRequest"
    }
}

/// GetOpenIDConfigResponse is an OIDC discovery document for the cluster.
/// See the OpenID Connect Discovery 1.0 specification for details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetOpenIDConfigResponse {
    /// OIDC Issuer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub issuer: std::string::String,

    /// JSON Web Key uri.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub jwks_uri: std::string::String,

    /// Supported response types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub response_types_supported: std::vec::Vec<std::string::String>,

    /// Supported subject types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub subject_types_supported: std::vec::Vec<std::string::String>,

    /// supported ID Token signing Algorithms.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub id_token_signing_alg_values_supported: std::vec::Vec<std::string::String>,

    /// Supported claims.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub claims_supported: std::vec::Vec<std::string::String>,

    /// Supported grant types.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grant_types: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOpenIDConfigResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issuer][crate::model::GetOpenIDConfigResponse::issuer].
    pub fn set_issuer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issuer = v.into();
        self
    }

    /// Sets the value of [jwks_uri][crate::model::GetOpenIDConfigResponse::jwks_uri].
    pub fn set_jwks_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.jwks_uri = v.into();
        self
    }

    /// Sets the value of [response_types_supported][crate::model::GetOpenIDConfigResponse::response_types_supported].
    pub fn set_response_types_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.response_types_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [subject_types_supported][crate::model::GetOpenIDConfigResponse::subject_types_supported].
    pub fn set_subject_types_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subject_types_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [id_token_signing_alg_values_supported][crate::model::GetOpenIDConfigResponse::id_token_signing_alg_values_supported].
    pub fn set_id_token_signing_alg_values_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.id_token_signing_alg_values_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [claims_supported][crate::model::GetOpenIDConfigResponse::claims_supported].
    pub fn set_claims_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.claims_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grant_types][crate::model::GetOpenIDConfigResponse::grant_types].
    pub fn set_grant_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.grant_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GetOpenIDConfigResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetOpenIDConfigResponse"
    }
}

/// GetJSONWebKeysRequest gets the public component of the keys used by the
/// cluster to sign token requests. This will be the jwks_uri for the discover
/// document returned by getOpenIDConfig. See the OpenID Connect
/// Discovery 1.0 specification for details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetJSONWebKeysRequest {
    /// The cluster (project, location, cluster name) to get keys for. Specified in
    /// the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJSONWebKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GetJSONWebKeysRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for GetJSONWebKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetJSONWebKeysRequest"
    }
}

/// Jwk is a JSON Web Key as specified in RFC 7517
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Jwk {
    /// Key Type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kty: std::string::String,

    /// Algorithm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub alg: std::string::String,

    /// Permitted uses for the public keys.
    #[serde(rename = "use")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#use: std::string::String,

    /// Key ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kid: std::string::String,

    /// Used for RSA keys.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub n: std::string::String,

    /// Used for RSA keys.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub e: std::string::String,

    /// Used for ECDSA keys.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub x: std::string::String,

    /// Used for ECDSA keys.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub y: std::string::String,

    /// Used for ECDSA keys.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub crv: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Jwk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kty][crate::model::Jwk::kty].
    pub fn set_kty<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kty = v.into();
        self
    }

    /// Sets the value of [alg][crate::model::Jwk::alg].
    pub fn set_alg<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.alg = v.into();
        self
    }

    /// Sets the value of [r#use][crate::model::Jwk::use].
    pub fn set_use<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#use = v.into();
        self
    }

    /// Sets the value of [kid][crate::model::Jwk::kid].
    pub fn set_kid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kid = v.into();
        self
    }

    /// Sets the value of [n][crate::model::Jwk::n].
    pub fn set_n<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.n = v.into();
        self
    }

    /// Sets the value of [e][crate::model::Jwk::e].
    pub fn set_e<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.e = v.into();
        self
    }

    /// Sets the value of [x][crate::model::Jwk::x].
    pub fn set_x<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.x = v.into();
        self
    }

    /// Sets the value of [y][crate::model::Jwk::y].
    pub fn set_y<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.y = v.into();
        self
    }

    /// Sets the value of [crv][crate::model::Jwk::crv].
    pub fn set_crv<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crv = v.into();
        self
    }
}

impl wkt::message::Message for Jwk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.Jwk"
    }
}

/// GetJSONWebKeysResponse is a valid JSON Web Key Set as specififed in rfc 7517
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetJSONWebKeysResponse {
    /// The public component of the keys used by the cluster to sign token
    /// requests.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub keys: std::vec::Vec<crate::model::Jwk>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJSONWebKeysResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [keys][crate::model::GetJSONWebKeysResponse::keys].
    pub fn set_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Jwk>,
    {
        use std::iter::Iterator;
        self.keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GetJSONWebKeysResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetJSONWebKeysResponse"
    }
}

/// CheckAutopilotCompatibilityRequest requests getting the blockers for the
/// given operation in the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckAutopilotCompatibilityRequest {
    /// The name (project, location, cluster) of the cluster to retrieve.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckAutopilotCompatibilityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CheckAutopilotCompatibilityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CheckAutopilotCompatibilityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CheckAutopilotCompatibilityRequest"
    }
}

/// AutopilotCompatibilityIssue contains information about a specific
/// compatibility issue with Autopilot mode.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutopilotCompatibilityIssue {
    /// The last time when this issue was observed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_observation: std::option::Option<wkt::Timestamp>,

    /// The constraint type of the issue.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub constraint_type: std::string::String,

    /// The incompatibility type of this issue.
    pub incompatibility_type: crate::model::autopilot_compatibility_issue::IssueType,

    /// The name of the resources which are subject to this issue.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub subjects: std::vec::Vec<std::string::String>,

    /// A URL to a public documnetation, which addresses resolving this issue.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub documentation_url: std::string::String,

    /// The description of the issue.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutopilotCompatibilityIssue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [last_observation][crate::model::AutopilotCompatibilityIssue::last_observation].
    pub fn set_last_observation<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_observation = v.into();
        self
    }

    /// Sets the value of [constraint_type][crate::model::AutopilotCompatibilityIssue::constraint_type].
    pub fn set_constraint_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.constraint_type = v.into();
        self
    }

    /// Sets the value of [incompatibility_type][crate::model::AutopilotCompatibilityIssue::incompatibility_type].
    pub fn set_incompatibility_type<
        T: std::convert::Into<crate::model::autopilot_compatibility_issue::IssueType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.incompatibility_type = v.into();
        self
    }

    /// Sets the value of [subjects][crate::model::AutopilotCompatibilityIssue::subjects].
    pub fn set_subjects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subjects = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [documentation_url][crate::model::AutopilotCompatibilityIssue::documentation_url].
    pub fn set_documentation_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.documentation_url = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AutopilotCompatibilityIssue::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for AutopilotCompatibilityIssue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AutopilotCompatibilityIssue"
    }
}

/// Defines additional types related to [AutopilotCompatibilityIssue].
pub mod autopilot_compatibility_issue {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the reported issue.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IssueType {
        /// Default value, should not be used.
        Unspecified,
        /// Indicates that the issue is a known incompatibility between the
        /// cluster and Autopilot mode.
        Incompatibility,
        /// Indicates the issue is an incompatibility if customers take no further
        /// action to resolve.
        AdditionalConfigRequired,
        /// Indicates the issue is not an incompatibility, but depending on the
        /// workloads business logic, there is a potential that they won't work on
        /// Autopilot.
        PassedWithOptionalConfig,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IssueType::value] or
        /// [IssueType::name].
        UnknownValue(issue_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod issue_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IssueType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Incompatibility => std::option::Option::Some(1),
                Self::AdditionalConfigRequired => std::option::Option::Some(2),
                Self::PassedWithOptionalConfig => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Incompatibility => std::option::Option::Some("INCOMPATIBILITY"),
                Self::AdditionalConfigRequired => {
                    std::option::Option::Some("ADDITIONAL_CONFIG_REQUIRED")
                }
                Self::PassedWithOptionalConfig => {
                    std::option::Option::Some("PASSED_WITH_OPTIONAL_CONFIG")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IssueType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IssueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IssueType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Incompatibility,
                2 => Self::AdditionalConfigRequired,
                3 => Self::PassedWithOptionalConfig,
                _ => Self::UnknownValue(issue_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IssueType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "INCOMPATIBILITY" => Self::Incompatibility,
                "ADDITIONAL_CONFIG_REQUIRED" => Self::AdditionalConfigRequired,
                "PASSED_WITH_OPTIONAL_CONFIG" => Self::PassedWithOptionalConfig,
                _ => Self::UnknownValue(issue_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IssueType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Incompatibility => serializer.serialize_i32(1),
                Self::AdditionalConfigRequired => serializer.serialize_i32(2),
                Self::PassedWithOptionalConfig => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IssueType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IssueType>::new(
                ".google.container.v1.AutopilotCompatibilityIssue.IssueType",
            ))
        }
    }
}

/// CheckAutopilotCompatibilityResponse has a list of compatibility issues.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckAutopilotCompatibilityResponse {
    /// The list of issues for the given operation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub issues: std::vec::Vec<crate::model::AutopilotCompatibilityIssue>,

    /// The summary of the autopilot compatibility response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub summary: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckAutopilotCompatibilityResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issues][crate::model::CheckAutopilotCompatibilityResponse::issues].
    pub fn set_issues<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutopilotCompatibilityIssue>,
    {
        use std::iter::Iterator;
        self.issues = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [summary][crate::model::CheckAutopilotCompatibilityResponse::summary].
    pub fn set_summary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.summary = v.into();
        self
    }
}

impl wkt::message::Message for CheckAutopilotCompatibilityResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CheckAutopilotCompatibilityResponse"
    }
}

/// ReleaseChannel indicates which release channel a cluster is
/// subscribed to. Release channels are arranged in order of risk.
///
/// When a cluster is subscribed to a release channel, Google maintains
/// both the master version and the node version. Node auto-upgrade
/// defaults to true and cannot be disabled.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReleaseChannel {
    /// channel specifies which release channel the cluster is subscribed to.
    pub channel: crate::model::release_channel::Channel,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReleaseChannel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channel][crate::model::ReleaseChannel::channel].
    pub fn set_channel<T: std::convert::Into<crate::model::release_channel::Channel>>(
        mut self,
        v: T,
    ) -> Self {
        self.channel = v.into();
        self
    }
}

impl wkt::message::Message for ReleaseChannel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ReleaseChannel"
    }
}

/// Defines additional types related to [ReleaseChannel].
pub mod release_channel {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values for 'channel'.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Channel {
        /// No channel specified.
        Unspecified,
        /// RAPID channel is offered on an early access basis for customers who want
        /// to test new releases.
        ///
        /// WARNING: Versions available in the RAPID Channel may be subject to
        /// unresolved issues with no known workaround and are not subject to any
        /// SLAs.
        Rapid,
        /// Clusters subscribed to REGULAR receive versions that are considered GA
        /// quality. REGULAR is intended for production users who want to take
        /// advantage of new features.
        Regular,
        /// Clusters subscribed to STABLE receive versions that are known to be
        /// stable and reliable in production.
        Stable,
        /// Clusters subscribed to EXTENDED receive extended support and availability
        /// for versions which are known to be stable and reliable in production.
        Extended,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Channel::value] or
        /// [Channel::name].
        UnknownValue(channel::UnknownValue),
    }

    #[doc(hidden)]
    pub mod channel {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Channel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Rapid => std::option::Option::Some(1),
                Self::Regular => std::option::Option::Some(2),
                Self::Stable => std::option::Option::Some(3),
                Self::Extended => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Rapid => std::option::Option::Some("RAPID"),
                Self::Regular => std::option::Option::Some("REGULAR"),
                Self::Stable => std::option::Option::Some("STABLE"),
                Self::Extended => std::option::Option::Some("EXTENDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Channel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Channel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Channel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Rapid,
                2 => Self::Regular,
                3 => Self::Stable,
                4 => Self::Extended,
                _ => Self::UnknownValue(channel::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Channel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "RAPID" => Self::Rapid,
                "REGULAR" => Self::Regular,
                "STABLE" => Self::Stable,
                "EXTENDED" => Self::Extended,
                _ => Self::UnknownValue(channel::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Channel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Rapid => serializer.serialize_i32(1),
                Self::Regular => serializer.serialize_i32(2),
                Self::Stable => serializer.serialize_i32(3),
                Self::Extended => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Channel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Channel>::new(
                ".google.container.v1.ReleaseChannel.Channel",
            ))
        }
    }
}

/// Configuration for fine-grained cost management feature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CostManagementConfig {
    /// Whether the feature is enabled or not.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CostManagementConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::CostManagementConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for CostManagementConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CostManagementConfig"
    }
}

/// IntraNodeVisibilityConfig contains the desired config of the intra-node
/// visibility on this cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IntraNodeVisibilityConfig {
    /// Enables intra node visibility for this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IntraNodeVisibilityConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::IntraNodeVisibilityConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for IntraNodeVisibilityConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.IntraNodeVisibilityConfig"
    }
}

/// ILBSubsettingConfig contains the desired config of L4 Internal LoadBalancer
/// subsetting on this cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ILBSubsettingConfig {
    /// Enables l4 ILB subsetting for this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ILBSubsettingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ILBSubsettingConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for ILBSubsettingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ILBSubsettingConfig"
    }
}

/// DNSConfig contains the desired set of options for configuring clusterDNS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DNSConfig {
    /// cluster_dns indicates which in-cluster DNS provider should be used.
    pub cluster_dns: crate::model::dns_config::Provider,

    /// cluster_dns_scope indicates the scope of access to cluster DNS records.
    pub cluster_dns_scope: crate::model::dns_config::DNSScope,

    /// cluster_dns_domain is the suffix used for all cluster service records.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_dns_domain: std::string::String,

    /// Optional. The domain used in Additive VPC scope.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub additive_vpc_scope_dns_domain: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DNSConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_dns][crate::model::DNSConfig::cluster_dns].
    pub fn set_cluster_dns<T: std::convert::Into<crate::model::dns_config::Provider>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_dns = v.into();
        self
    }

    /// Sets the value of [cluster_dns_scope][crate::model::DNSConfig::cluster_dns_scope].
    pub fn set_cluster_dns_scope<T: std::convert::Into<crate::model::dns_config::DNSScope>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_dns_scope = v.into();
        self
    }

    /// Sets the value of [cluster_dns_domain][crate::model::DNSConfig::cluster_dns_domain].
    pub fn set_cluster_dns_domain<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_dns_domain = v.into();
        self
    }

    /// Sets the value of [additive_vpc_scope_dns_domain][crate::model::DNSConfig::additive_vpc_scope_dns_domain].
    pub fn set_additive_vpc_scope_dns_domain<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.additive_vpc_scope_dns_domain = v.into();
        self
    }
}

impl wkt::message::Message for DNSConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DNSConfig"
    }
}

/// Defines additional types related to [DNSConfig].
pub mod dns_config {
    #[allow(unused_imports)]
    use super::*;

    /// Provider lists the various in-cluster DNS providers.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Provider {
        /// Default value
        Unspecified,
        /// Use GKE default DNS provider(kube-dns) for DNS resolution.
        PlatformDefault,
        /// Use CloudDNS for DNS resolution.
        CloudDns,
        /// Use KubeDNS for DNS resolution.
        KubeDns,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Provider::value] or
        /// [Provider::name].
        UnknownValue(provider::UnknownValue),
    }

    #[doc(hidden)]
    pub mod provider {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Provider {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PlatformDefault => std::option::Option::Some(1),
                Self::CloudDns => std::option::Option::Some(2),
                Self::KubeDns => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROVIDER_UNSPECIFIED"),
                Self::PlatformDefault => std::option::Option::Some("PLATFORM_DEFAULT"),
                Self::CloudDns => std::option::Option::Some("CLOUD_DNS"),
                Self::KubeDns => std::option::Option::Some("KUBE_DNS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Provider {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Provider {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Provider {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PlatformDefault,
                2 => Self::CloudDns,
                3 => Self::KubeDns,
                _ => Self::UnknownValue(provider::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Provider {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROVIDER_UNSPECIFIED" => Self::Unspecified,
                "PLATFORM_DEFAULT" => Self::PlatformDefault,
                "CLOUD_DNS" => Self::CloudDns,
                "KUBE_DNS" => Self::KubeDns,
                _ => Self::UnknownValue(provider::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Provider {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PlatformDefault => serializer.serialize_i32(1),
                Self::CloudDns => serializer.serialize_i32(2),
                Self::KubeDns => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Provider {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Provider>::new(
                ".google.container.v1.DNSConfig.Provider",
            ))
        }
    }

    /// DNSScope lists the various scopes of access to cluster DNS records.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DNSScope {
        /// Default value, will be inferred as cluster scope.
        Unspecified,
        /// DNS records are accessible from within the cluster.
        ClusterScope,
        /// DNS records are accessible from within the VPC.
        VpcScope,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DNSScope::value] or
        /// [DNSScope::name].
        UnknownValue(dns_scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod dns_scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DNSScope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ClusterScope => std::option::Option::Some(1),
                Self::VpcScope => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DNS_SCOPE_UNSPECIFIED"),
                Self::ClusterScope => std::option::Option::Some("CLUSTER_SCOPE"),
                Self::VpcScope => std::option::Option::Some("VPC_SCOPE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DNSScope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DNSScope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DNSScope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ClusterScope,
                2 => Self::VpcScope,
                _ => Self::UnknownValue(dns_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DNSScope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DNS_SCOPE_UNSPECIFIED" => Self::Unspecified,
                "CLUSTER_SCOPE" => Self::ClusterScope,
                "VPC_SCOPE" => Self::VpcScope,
                _ => Self::UnknownValue(dns_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DNSScope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ClusterScope => serializer.serialize_i32(1),
                Self::VpcScope => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DNSScope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DNSScope>::new(
                ".google.container.v1.DNSConfig.DNSScope",
            ))
        }
    }
}

/// Constraints applied to pods.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaxPodsConstraint {
    /// Constraint enforced on the max num of pods per node.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub max_pods_per_node: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaxPodsConstraint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_pods_per_node][crate::model::MaxPodsConstraint::max_pods_per_node].
    pub fn set_max_pods_per_node<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_pods_per_node = v.into();
        self
    }
}

impl wkt::message::Message for MaxPodsConstraint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MaxPodsConstraint"
    }
}

/// Configuration for the use of Kubernetes Service Accounts in GCP IAM
/// policies.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkloadIdentityConfig {
    /// The workload pool to attach all Kubernetes service accounts to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub workload_pool: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkloadIdentityConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workload_pool][crate::model::WorkloadIdentityConfig::workload_pool].
    pub fn set_workload_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workload_pool = v.into();
        self
    }
}

impl wkt::message::Message for WorkloadIdentityConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.WorkloadIdentityConfig"
    }
}

/// IdentityServiceConfig is configuration for Identity Service which allows
/// customers to use external identity providers with the K8S API
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IdentityServiceConfig {
    /// Whether to enable the Identity Service component
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IdentityServiceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::IdentityServiceConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for IdentityServiceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.IdentityServiceConfig"
    }
}

/// Configuration for issuance of mTLS keys and certificates to Kubernetes pods.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MeshCertificates {
    /// enable_certificates controls issuance of workload mTLS certificates.
    ///
    /// If set, the GKE Workload Identity Certificates controller and node agent
    /// will be deployed in the cluster, which can then be configured by creating a
    /// WorkloadCertificateConfig Custom Resource.
    ///
    /// Requires Workload Identity
    /// ([workload_pool][google.container.v1.WorkloadIdentityConfig.workload_pool]
    /// must be non-empty).
    ///
    /// [google.container.v1.WorkloadIdentityConfig.workload_pool]: crate::model::WorkloadIdentityConfig::workload_pool
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_certificates: std::option::Option<wkt::BoolValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MeshCertificates {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_certificates][crate::model::MeshCertificates::enable_certificates].
    pub fn set_enable_certificates<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_certificates = v.into();
        self
    }
}

impl wkt::message::Message for MeshCertificates {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MeshCertificates"
    }
}

/// Configuration of etcd encryption.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseEncryption {
    /// Name of CloudKMS key to use for the encryption of secrets in etcd.
    /// Ex. projects/my-project/locations/global/keyRings/my-ring/cryptoKeys/my-key
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_name: std::string::String,

    /// The desired state of etcd encryption.
    pub state: crate::model::database_encryption::State,

    /// Output only. The current state of etcd encryption.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub current_state: std::option::Option<crate::model::database_encryption::CurrentState>,

    /// Output only. Keys in use by the cluster for decrypting
    /// existing objects, in addition to the key in `key_name`.
    ///
    /// Each item is a CloudKMS key resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub decryption_keys: std::vec::Vec<std::string::String>,

    /// Output only. Records errors seen during DatabaseEncryption update
    /// operations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub last_operation_errors: std::vec::Vec<crate::model::database_encryption::OperationError>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseEncryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_name][crate::model::DatabaseEncryption::key_name].
    pub fn set_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DatabaseEncryption::state].
    pub fn set_state<T: std::convert::Into<crate::model::database_encryption::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [current_state][crate::model::DatabaseEncryption::current_state].
    pub fn set_current_state<
        T: std::convert::Into<std::option::Option<crate::model::database_encryption::CurrentState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.current_state = v.into();
        self
    }

    /// Sets the value of [decryption_keys][crate::model::DatabaseEncryption::decryption_keys].
    pub fn set_decryption_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.decryption_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [last_operation_errors][crate::model::DatabaseEncryption::last_operation_errors].
    pub fn set_last_operation_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::database_encryption::OperationError>,
    {
        use std::iter::Iterator;
        self.last_operation_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatabaseEncryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DatabaseEncryption"
    }
}

/// Defines additional types related to [DatabaseEncryption].
pub mod database_encryption {
    #[allow(unused_imports)]
    use super::*;

    /// OperationError records errors seen from CloudKMS keys
    /// encountered during updates to DatabaseEncryption configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OperationError {
        /// CloudKMS key resource that had the error.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub key_name: std::string::String,

        /// Description of the error seen during the operation.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error_message: std::string::String,

        /// Time when the CloudKMS error was seen.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub timestamp: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OperationError {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key_name][crate::model::database_encryption::OperationError::key_name].
        pub fn set_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key_name = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::database_encryption::OperationError::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }

        /// Sets the value of [timestamp][crate::model::database_encryption::OperationError::timestamp].
        pub fn set_timestamp<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.timestamp = v.into();
            self
        }
    }

    impl wkt::message::Message for OperationError {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.DatabaseEncryption.OperationError"
        }
    }

    /// State of etcd encryption.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Should never be set
        Unknown,
        /// Secrets in etcd are encrypted.
        Encrypted,
        /// Secrets in etcd are stored in plain text (at etcd level) - this is
        /// unrelated to Compute Engine level full disk encryption.
        Decrypted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Encrypted => std::option::Option::Some(1),
                Self::Decrypted => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Encrypted => std::option::Option::Some("ENCRYPTED"),
                Self::Decrypted => std::option::Option::Some("DECRYPTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Encrypted,
                2 => Self::Decrypted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "ENCRYPTED" => Self::Encrypted,
                "DECRYPTED" => Self::Decrypted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Encrypted => serializer.serialize_i32(1),
                Self::Decrypted => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.container.v1.DatabaseEncryption.State",
            ))
        }
    }

    /// Current State of etcd encryption.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CurrentState {
        /// Should never be set
        Unspecified,
        /// Secrets in etcd are encrypted.
        Encrypted,
        /// Secrets in etcd are stored in plain text (at etcd level) - this is
        /// unrelated to Compute Engine level full disk encryption.
        Decrypted,
        /// Encryption (or re-encryption with a different CloudKMS key)
        /// of Secrets is in progress.
        EncryptionPending,
        /// Encryption (or re-encryption with a different CloudKMS key) of Secrets in
        /// etcd encountered an error.
        EncryptionError,
        /// De-crypting Secrets to plain text in etcd is in progress.
        DecryptionPending,
        /// De-crypting Secrets to plain text in etcd encountered an error.
        DecryptionError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CurrentState::value] or
        /// [CurrentState::name].
        UnknownValue(current_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod current_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CurrentState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Encrypted => std::option::Option::Some(7),
                Self::Decrypted => std::option::Option::Some(2),
                Self::EncryptionPending => std::option::Option::Some(3),
                Self::EncryptionError => std::option::Option::Some(4),
                Self::DecryptionPending => std::option::Option::Some(5),
                Self::DecryptionError => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CURRENT_STATE_UNSPECIFIED"),
                Self::Encrypted => std::option::Option::Some("CURRENT_STATE_ENCRYPTED"),
                Self::Decrypted => std::option::Option::Some("CURRENT_STATE_DECRYPTED"),
                Self::EncryptionPending => {
                    std::option::Option::Some("CURRENT_STATE_ENCRYPTION_PENDING")
                }
                Self::EncryptionError => {
                    std::option::Option::Some("CURRENT_STATE_ENCRYPTION_ERROR")
                }
                Self::DecryptionPending => {
                    std::option::Option::Some("CURRENT_STATE_DECRYPTION_PENDING")
                }
                Self::DecryptionError => {
                    std::option::Option::Some("CURRENT_STATE_DECRYPTION_ERROR")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CurrentState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CurrentState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CurrentState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Decrypted,
                3 => Self::EncryptionPending,
                4 => Self::EncryptionError,
                5 => Self::DecryptionPending,
                6 => Self::DecryptionError,
                7 => Self::Encrypted,
                _ => Self::UnknownValue(current_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CurrentState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CURRENT_STATE_UNSPECIFIED" => Self::Unspecified,
                "CURRENT_STATE_ENCRYPTED" => Self::Encrypted,
                "CURRENT_STATE_DECRYPTED" => Self::Decrypted,
                "CURRENT_STATE_ENCRYPTION_PENDING" => Self::EncryptionPending,
                "CURRENT_STATE_ENCRYPTION_ERROR" => Self::EncryptionError,
                "CURRENT_STATE_DECRYPTION_PENDING" => Self::DecryptionPending,
                "CURRENT_STATE_DECRYPTION_ERROR" => Self::DecryptionError,
                _ => Self::UnknownValue(current_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CurrentState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Encrypted => serializer.serialize_i32(7),
                Self::Decrypted => serializer.serialize_i32(2),
                Self::EncryptionPending => serializer.serialize_i32(3),
                Self::EncryptionError => serializer.serialize_i32(4),
                Self::DecryptionPending => serializer.serialize_i32(5),
                Self::DecryptionError => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CurrentState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CurrentState>::new(
                ".google.container.v1.DatabaseEncryption.CurrentState",
            ))
        }
    }
}

/// ListUsableSubnetworksRequest requests the list of usable subnetworks
/// available to a user for creating clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUsableSubnetworksRequest {
    /// The parent project where subnetworks are usable.
    /// Specified in the format `projects/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Filtering currently only supports equality on the networkProjectId and must
    /// be in the form: "networkProjectId=[PROJECTID]", where `networkProjectId`
    /// is the project which owns the listed subnetworks. This defaults to the
    /// parent project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The max number of results per page that should be returned. If the number
    /// of available results is larger than `page_size`, a `next_page_token` is
    /// returned which can be used to get the next page of results in subsequent
    /// requests. Acceptable values are 0 to 500, inclusive. (Default: 500)
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Specifies a page token to use. Set this to the nextPageToken returned by
    /// previous list requests to get the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsableSubnetworksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUsableSubnetworksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListUsableSubnetworksRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUsableSubnetworksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUsableSubnetworksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUsableSubnetworksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListUsableSubnetworksRequest"
    }
}

/// ListUsableSubnetworksResponse is the response of
/// ListUsableSubnetworksRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUsableSubnetworksResponse {
    /// A list of usable subnetworks in the specified network project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub subnetworks: std::vec::Vec<crate::model::UsableSubnetwork>,

    /// This token allows you to get the next page of results for list requests.
    /// If the number of results is larger than `page_size`, use the
    /// `next_page_token` as a value for the query parameter `page_token` in the
    /// next request. The value will become empty when there are no more pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsableSubnetworksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subnetworks][crate::model::ListUsableSubnetworksResponse::subnetworks].
    pub fn set_subnetworks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UsableSubnetwork>,
    {
        use std::iter::Iterator;
        self.subnetworks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUsableSubnetworksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUsableSubnetworksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListUsableSubnetworksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUsableSubnetworksResponse {
    type PageItem = crate::model::UsableSubnetwork;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.subnetworks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Secondary IP range of a usable subnetwork.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UsableSubnetworkSecondaryRange {
    /// The name associated with this subnetwork secondary range, used when adding
    /// an alias IP range to a VM instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub range_name: std::string::String,

    /// The range of IP addresses belonging to this subnetwork secondary range.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_cidr_range: std::string::String,

    /// This field is to determine the status of the secondary range programmably.
    pub status: crate::model::usable_subnetwork_secondary_range::Status,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UsableSubnetworkSecondaryRange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [range_name][crate::model::UsableSubnetworkSecondaryRange::range_name].
    pub fn set_range_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.range_name = v.into();
        self
    }

    /// Sets the value of [ip_cidr_range][crate::model::UsableSubnetworkSecondaryRange::ip_cidr_range].
    pub fn set_ip_cidr_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_cidr_range = v.into();
        self
    }

    /// Sets the value of [status][crate::model::UsableSubnetworkSecondaryRange::status].
    pub fn set_status<
        T: std::convert::Into<crate::model::usable_subnetwork_secondary_range::Status>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for UsableSubnetworkSecondaryRange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UsableSubnetworkSecondaryRange"
    }
}

/// Defines additional types related to [UsableSubnetworkSecondaryRange].
pub mod usable_subnetwork_secondary_range {
    #[allow(unused_imports)]
    use super::*;

    /// Status shows the current usage of a secondary IP range.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// UNKNOWN is the zero value of the Status enum. It's not a valid status.
        Unknown,
        /// UNUSED denotes that this range is unclaimed by any cluster.
        Unused,
        /// IN_USE_SERVICE denotes that this range is claimed by cluster(s) for
        /// services. User-managed services range can be shared between clusters
        /// within the same subnetwork.
        InUseService,
        /// IN_USE_SHAREABLE_POD denotes this range was created by the network admin
        /// and is currently claimed by a cluster for pods. It can only be used by
        /// other clusters as a pod range.
        InUseShareablePod,
        /// IN_USE_MANAGED_POD denotes this range was created by GKE and is claimed
        /// for pods. It cannot be used for other clusters.
        InUseManagedPod,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Unused => std::option::Option::Some(1),
                Self::InUseService => std::option::Option::Some(2),
                Self::InUseShareablePod => std::option::Option::Some(3),
                Self::InUseManagedPod => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Unused => std::option::Option::Some("UNUSED"),
                Self::InUseService => std::option::Option::Some("IN_USE_SERVICE"),
                Self::InUseShareablePod => std::option::Option::Some("IN_USE_SHAREABLE_POD"),
                Self::InUseManagedPod => std::option::Option::Some("IN_USE_MANAGED_POD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Unused,
                2 => Self::InUseService,
                3 => Self::InUseShareablePod,
                4 => Self::InUseManagedPod,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "UNUSED" => Self::Unused,
                "IN_USE_SERVICE" => Self::InUseService,
                "IN_USE_SHAREABLE_POD" => Self::InUseShareablePod,
                "IN_USE_MANAGED_POD" => Self::InUseManagedPod,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Unused => serializer.serialize_i32(1),
                Self::InUseService => serializer.serialize_i32(2),
                Self::InUseShareablePod => serializer.serialize_i32(3),
                Self::InUseManagedPod => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.container.v1.UsableSubnetworkSecondaryRange.Status",
            ))
        }
    }
}

/// UsableSubnetwork resource returns the subnetwork name, its associated network
/// and the primary CIDR range.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UsableSubnetwork {
    /// Subnetwork Name.
    /// Example: projects/my-project/regions/us-central1/subnetworks/my-subnet
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnetwork: std::string::String,

    /// Network Name.
    /// Example: projects/my-project/global/networks/my-network
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// The range of internal addresses that are owned by this subnetwork.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_cidr_range: std::string::String,

    /// Secondary IP ranges.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub secondary_ip_ranges: std::vec::Vec<crate::model::UsableSubnetworkSecondaryRange>,

    /// A human readable status message representing the reasons for cases where
    /// the caller cannot use the secondary ranges under the subnet. For example if
    /// the secondary_ip_ranges is empty due to a permission issue, an insufficient
    /// permission message will be given by status_message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UsableSubnetwork {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subnetwork][crate::model::UsableSubnetwork::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [network][crate::model::UsableSubnetwork::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [ip_cidr_range][crate::model::UsableSubnetwork::ip_cidr_range].
    pub fn set_ip_cidr_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_cidr_range = v.into();
        self
    }

    /// Sets the value of [secondary_ip_ranges][crate::model::UsableSubnetwork::secondary_ip_ranges].
    pub fn set_secondary_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UsableSubnetworkSecondaryRange>,
    {
        use std::iter::Iterator;
        self.secondary_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [status_message][crate::model::UsableSubnetwork::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }
}

impl wkt::message::Message for UsableSubnetwork {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UsableSubnetwork"
    }
}

/// Configuration for exporting cluster resource usages.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceUsageExportConfig {
    /// Configuration to use BigQuery as usage export destination.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bigquery_destination:
        std::option::Option<crate::model::resource_usage_export_config::BigQueryDestination>,

    /// Whether to enable network egress metering for this cluster. If enabled, a
    /// daemonset will be created in the cluster to meter network egress traffic.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_network_egress_metering: bool,

    /// Configuration to enable resource consumption metering.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub consumption_metering_config:
        std::option::Option<crate::model::resource_usage_export_config::ConsumptionMeteringConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceUsageExportConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bigquery_destination][crate::model::ResourceUsageExportConfig::bigquery_destination].
    pub fn set_bigquery_destination<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::resource_usage_export_config::BigQueryDestination,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bigquery_destination = v.into();
        self
    }

    /// Sets the value of [enable_network_egress_metering][crate::model::ResourceUsageExportConfig::enable_network_egress_metering].
    pub fn set_enable_network_egress_metering<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_network_egress_metering = v.into();
        self
    }

    /// Sets the value of [consumption_metering_config][crate::model::ResourceUsageExportConfig::consumption_metering_config].
    pub fn set_consumption_metering_config<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::resource_usage_export_config::ConsumptionMeteringConfig,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.consumption_metering_config = v.into();
        self
    }
}

impl wkt::message::Message for ResourceUsageExportConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ResourceUsageExportConfig"
    }
}

/// Defines additional types related to [ResourceUsageExportConfig].
pub mod resource_usage_export_config {
    #[allow(unused_imports)]
    use super::*;

    /// Parameters for using BigQuery as the destination of resource usage export.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BigQueryDestination {
        /// The ID of a BigQuery Dataset.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset_id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BigQueryDestination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset_id][crate::model::resource_usage_export_config::BigQueryDestination::dataset_id].
        pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset_id = v.into();
            self
        }
    }

    impl wkt::message::Message for BigQueryDestination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.ResourceUsageExportConfig.BigQueryDestination"
        }
    }

    /// Parameters for controlling consumption metering.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConsumptionMeteringConfig {
        /// Whether to enable consumption metering for this cluster. If enabled, a
        /// second BigQuery table will be created to hold resource consumption
        /// records.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enabled: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConsumptionMeteringConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::resource_usage_export_config::ConsumptionMeteringConfig::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for ConsumptionMeteringConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.ResourceUsageExportConfig.ConsumptionMeteringConfig"
        }
    }
}

/// VerticalPodAutoscaling contains global, per-cluster information
/// required by Vertical Pod Autoscaler to automatically adjust
/// the resources of pods controlled by it.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerticalPodAutoscaling {
    /// Enables vertical pod autoscaling.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerticalPodAutoscaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::VerticalPodAutoscaling::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for VerticalPodAutoscaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.VerticalPodAutoscaling"
    }
}

/// DefaultSnatStatus contains the desired state of whether default sNAT should
/// be disabled on the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DefaultSnatStatus {
    /// Disables cluster default sNAT rules.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DefaultSnatStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::DefaultSnatStatus::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

impl wkt::message::Message for DefaultSnatStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DefaultSnatStatus"
    }
}

/// Configuration of Shielded Nodes feature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ShieldedNodes {
    /// Whether Shielded Nodes features are enabled on all nodes in this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShieldedNodes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ShieldedNodes::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for ShieldedNodes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ShieldedNodes"
    }
}

/// Configuration of gVNIC feature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VirtualNIC {
    /// Whether gVNIC features are enabled in the node pool.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VirtualNIC {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::VirtualNIC::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for VirtualNIC {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.VirtualNIC"
    }
}

/// Configuration of Fast Socket feature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FastSocket {
    /// Whether Fast Socket features are enabled in the node pool.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FastSocket {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::FastSocket::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for FastSocket {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.FastSocket"
    }
}

/// NotificationConfig is the configuration of notifications.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NotificationConfig {
    /// Notification config for Pub/Sub.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pubsub: std::option::Option<crate::model::notification_config::PubSub>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NotificationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pubsub][crate::model::NotificationConfig::pubsub].
    pub fn set_pubsub<
        T: std::convert::Into<std::option::Option<crate::model::notification_config::PubSub>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pubsub = v.into();
        self
    }
}

impl wkt::message::Message for NotificationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NotificationConfig"
    }
}

/// Defines additional types related to [NotificationConfig].
pub mod notification_config {
    #[allow(unused_imports)]
    use super::*;

    /// Pub/Sub specific notification config.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PubSub {
        /// Enable notifications for Pub/Sub.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enabled: bool,

        /// The desired Pub/Sub topic to which notifications will be
        /// sent by GKE. Format is `projects/{project}/topics/{topic}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub topic: std::string::String,

        /// Allows filtering to one or more specific event types. If no filter is
        /// specified, or if a filter is specified with no event types, all event
        /// types will be sent
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub filter: std::option::Option<crate::model::notification_config::Filter>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PubSub {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::notification_config::PubSub::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [topic][crate::model::notification_config::PubSub::topic].
        pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.topic = v.into();
            self
        }

        /// Sets the value of [filter][crate::model::notification_config::PubSub::filter].
        pub fn set_filter<
            T: std::convert::Into<std::option::Option<crate::model::notification_config::Filter>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.filter = v.into();
            self
        }
    }

    impl wkt::message::Message for PubSub {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NotificationConfig.PubSub"
        }
    }

    /// Allows filtering to one or more specific event types. If event types are
    /// present, those and only those event types will be transmitted to the
    /// cluster. Other types will be skipped. If no filter is specified, or no
    /// event types are present, all event types will be sent
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Filter {
        /// Event types to allowlist.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub event_type: std::vec::Vec<crate::model::notification_config::EventType>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Filter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [event_type][crate::model::notification_config::Filter::event_type].
        pub fn set_event_type<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::notification_config::EventType>,
        {
            use std::iter::Iterator;
            self.event_type = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Filter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NotificationConfig.Filter"
        }
    }

    /// Types of notifications currently supported. Can be used to filter what
    /// notifications are sent.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// Not set, will be ignored.
        Unspecified,
        /// Corresponds with UpgradeAvailableEvent.
        UpgradeAvailableEvent,
        /// Corresponds with UpgradeEvent.
        UpgradeEvent,
        /// Corresponds with SecurityBulletinEvent.
        SecurityBulletinEvent,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UpgradeAvailableEvent => std::option::Option::Some(1),
                Self::UpgradeEvent => std::option::Option::Some(2),
                Self::SecurityBulletinEvent => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::UpgradeAvailableEvent => std::option::Option::Some("UPGRADE_AVAILABLE_EVENT"),
                Self::UpgradeEvent => std::option::Option::Some("UPGRADE_EVENT"),
                Self::SecurityBulletinEvent => std::option::Option::Some("SECURITY_BULLETIN_EVENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UpgradeAvailableEvent,
                2 => Self::UpgradeEvent,
                3 => Self::SecurityBulletinEvent,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "UPGRADE_AVAILABLE_EVENT" => Self::UpgradeAvailableEvent,
                "UPGRADE_EVENT" => Self::UpgradeEvent,
                "SECURITY_BULLETIN_EVENT" => Self::SecurityBulletinEvent,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UpgradeAvailableEvent => serializer.serialize_i32(1),
                Self::UpgradeEvent => serializer.serialize_i32(2),
                Self::SecurityBulletinEvent => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.container.v1.NotificationConfig.EventType",
            ))
        }
    }
}

/// ConfidentialNodes is configuration for the confidential nodes feature, which
/// makes nodes run on confidential VMs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfidentialNodes {
    /// Whether Confidential Nodes feature is enabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfidentialNodes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ConfidentialNodes::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for ConfidentialNodes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ConfidentialNodes"
    }
}

/// UpgradeEvent is a notification sent to customers by the cluster server when
/// a resource is upgrading.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeEvent {
    /// The resource type that is upgrading.
    pub resource_type: crate::model::UpgradeResourceType,

    /// The operation associated with this upgrade.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation: std::string::String,

    /// The time when the operation was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub operation_start_time: std::option::Option<wkt::Timestamp>,

    /// The current version before the upgrade.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub current_version: std::string::String,

    /// The target version for the upgrade.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_version: std::string::String,

    /// Optional relative path to the resource. For example in node pool upgrades,
    /// the relative path of the node pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_type][crate::model::UpgradeEvent::resource_type].
    pub fn set_resource_type<T: std::convert::Into<crate::model::UpgradeResourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::UpgradeEvent::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [operation_start_time][crate::model::UpgradeEvent::operation_start_time].
    pub fn set_operation_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_start_time = v.into();
        self
    }

    /// Sets the value of [current_version][crate::model::UpgradeEvent::current_version].
    pub fn set_current_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.current_version = v.into();
        self
    }

    /// Sets the value of [target_version][crate::model::UpgradeEvent::target_version].
    pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_version = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::UpgradeEvent::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UpgradeEvent"
    }
}

/// UpgradeInfoEvent is a notification sent to customers about the upgrade
/// information of a resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeInfoEvent {
    /// The resource type associated with the upgrade.
    pub resource_type: crate::model::UpgradeResourceType,

    /// The operation associated with this upgrade.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation: std::string::String,

    /// The time when the operation was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time when the operation ended.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The current version before the upgrade.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub current_version: std::string::String,

    /// The target version for the upgrade.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_version: std::string::String,

    /// Optional relative path to the resource. For example in node pool upgrades,
    /// the relative path of the node pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource: std::string::String,

    /// Output only. The state of the upgrade.
    pub state: crate::model::upgrade_info_event::State,

    /// A brief description of the event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeInfoEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_type][crate::model::UpgradeInfoEvent::resource_type].
    pub fn set_resource_type<T: std::convert::Into<crate::model::UpgradeResourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::UpgradeInfoEvent::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::UpgradeInfoEvent::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::UpgradeInfoEvent::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [current_version][crate::model::UpgradeInfoEvent::current_version].
    pub fn set_current_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.current_version = v.into();
        self
    }

    /// Sets the value of [target_version][crate::model::UpgradeInfoEvent::target_version].
    pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_version = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::UpgradeInfoEvent::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [state][crate::model::UpgradeInfoEvent::state].
    pub fn set_state<T: std::convert::Into<crate::model::upgrade_info_event::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [description][crate::model::UpgradeInfoEvent::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeInfoEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UpgradeInfoEvent"
    }
}

/// Defines additional types related to [UpgradeInfoEvent].
pub mod upgrade_info_event {
    #[allow(unused_imports)]
    use super::*;

    /// The state of the upgrade.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// STATE_UNSPECIFIED indicates the state is unspecified.
        Unspecified,
        /// STARTED indicates the upgrade has started.
        Started,
        /// SUCCEEDED indicates the upgrade has completed successfully.
        Succeeded,
        /// FAILED indicates the upgrade has failed.
        Failed,
        /// CANCELED indicates the upgrade has canceled.
        Canceled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Started => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::Canceled => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Started => std::option::Option::Some("STARTED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Canceled => std::option::Option::Some("CANCELED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                3 => Self::Started,
                4 => Self::Succeeded,
                5 => Self::Failed,
                6 => Self::Canceled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "STARTED" => Self::Started,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELED" => Self::Canceled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Started => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::Canceled => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.container.v1.UpgradeInfoEvent.State",
            ))
        }
    }
}

/// UpgradeAvailableEvent is a notification sent to customers when a new
/// available version is released.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeAvailableEvent {
    /// The release version available for upgrade.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// The resource type of the release version.
    pub resource_type: crate::model::UpgradeResourceType,

    /// The release channel of the version. If empty, it means a non-channel
    /// release.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub release_channel: std::option::Option<crate::model::ReleaseChannel>,

    /// Optional relative path to the resource. For example, the relative path of
    /// the node pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeAvailableEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::UpgradeAvailableEvent::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [resource_type][crate::model::UpgradeAvailableEvent::resource_type].
    pub fn set_resource_type<T: std::convert::Into<crate::model::UpgradeResourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [release_channel][crate::model::UpgradeAvailableEvent::release_channel].
    pub fn set_release_channel<
        T: std::convert::Into<std::option::Option<crate::model::ReleaseChannel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.release_channel = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::UpgradeAvailableEvent::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeAvailableEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UpgradeAvailableEvent"
    }
}

/// SecurityBulletinEvent is a notification sent to customers when a security
/// bulletin has been posted that they are vulnerable to.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecurityBulletinEvent {
    /// The resource type (node/control plane) that has the vulnerability. Multiple
    /// notifications (1 notification per resource type) will be sent for a
    /// vulnerability that affects > 1 resource type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_type_affected: std::string::String,

    /// The ID of the bulletin corresponding to the vulnerability.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bulletin_id: std::string::String,

    /// The CVEs associated with this bulletin.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cve_ids: std::vec::Vec<std::string::String>,

    /// The severity of this bulletin as it relates to GKE.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub severity: std::string::String,

    /// The URI link to the bulletin on the website for more information.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bulletin_uri: std::string::String,

    /// A brief description of the bulletin. See the bulletin pointed to by the
    /// bulletin_uri field for an expanded description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub brief_description: std::string::String,

    /// The GKE minor versions affected by this vulnerability.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub affected_supported_minors: std::vec::Vec<std::string::String>,

    /// The GKE versions where this vulnerability is patched.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub patched_versions: std::vec::Vec<std::string::String>,

    /// This represents a version selected from the patched_versions field that
    /// the cluster receiving this notification should most likely want to upgrade
    /// to based on its current version. Note that if this notification is being
    /// received by a given cluster, it means that this version is currently
    /// available as an upgrade target in that cluster's location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub suggested_upgrade_target: std::string::String,

    /// If this field is specified, it means there are manual steps that the user
    /// must take to make their clusters safe.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub manual_steps_required: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecurityBulletinEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_type_affected][crate::model::SecurityBulletinEvent::resource_type_affected].
    pub fn set_resource_type_affected<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_type_affected = v.into();
        self
    }

    /// Sets the value of [bulletin_id][crate::model::SecurityBulletinEvent::bulletin_id].
    pub fn set_bulletin_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bulletin_id = v.into();
        self
    }

    /// Sets the value of [cve_ids][crate::model::SecurityBulletinEvent::cve_ids].
    pub fn set_cve_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.cve_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [severity][crate::model::SecurityBulletinEvent::severity].
    pub fn set_severity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [bulletin_uri][crate::model::SecurityBulletinEvent::bulletin_uri].
    pub fn set_bulletin_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bulletin_uri = v.into();
        self
    }

    /// Sets the value of [brief_description][crate::model::SecurityBulletinEvent::brief_description].
    pub fn set_brief_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.brief_description = v.into();
        self
    }

    /// Sets the value of [affected_supported_minors][crate::model::SecurityBulletinEvent::affected_supported_minors].
    pub fn set_affected_supported_minors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.affected_supported_minors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [patched_versions][crate::model::SecurityBulletinEvent::patched_versions].
    pub fn set_patched_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.patched_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [suggested_upgrade_target][crate::model::SecurityBulletinEvent::suggested_upgrade_target].
    pub fn set_suggested_upgrade_target<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.suggested_upgrade_target = v.into();
        self
    }

    /// Sets the value of [manual_steps_required][crate::model::SecurityBulletinEvent::manual_steps_required].
    pub fn set_manual_steps_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.manual_steps_required = v.into();
        self
    }
}

impl wkt::message::Message for SecurityBulletinEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SecurityBulletinEvent"
    }
}

/// Autopilot is the configuration for Autopilot settings on the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Autopilot {
    /// Enable Autopilot
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    /// Workload policy configuration for Autopilot.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workload_policy_config: std::option::Option<crate::model::WorkloadPolicyConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Autopilot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::Autopilot::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [workload_policy_config][crate::model::Autopilot::workload_policy_config].
    pub fn set_workload_policy_config<
        T: std::convert::Into<std::option::Option<crate::model::WorkloadPolicyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workload_policy_config = v.into();
        self
    }
}

impl wkt::message::Message for Autopilot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.Autopilot"
    }
}

/// WorkloadPolicyConfig is the configuration of workload policy for autopilot
/// clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkloadPolicyConfig {
    /// If true, workloads can use NET_ADMIN capability.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub allow_net_admin: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkloadPolicyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_net_admin][crate::model::WorkloadPolicyConfig::allow_net_admin].
    pub fn set_allow_net_admin<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.allow_net_admin = v.into();
        self
    }
}

impl wkt::message::Message for WorkloadPolicyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.WorkloadPolicyConfig"
    }
}

/// LoggingConfig is cluster logging configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoggingConfig {
    /// Logging components configuration
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub component_config: std::option::Option<crate::model::LoggingComponentConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [component_config][crate::model::LoggingConfig::component_config].
    pub fn set_component_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingComponentConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.component_config = v.into();
        self
    }
}

impl wkt::message::Message for LoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.LoggingConfig"
    }
}

/// LoggingComponentConfig is cluster logging component configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoggingComponentConfig {
    /// Select components to collect logs. An empty set would disable all logging.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub enable_components: std::vec::Vec<crate::model::logging_component_config::Component>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingComponentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_components][crate::model::LoggingComponentConfig::enable_components].
    pub fn set_enable_components<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logging_component_config::Component>,
    {
        use std::iter::Iterator;
        self.enable_components = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LoggingComponentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.LoggingComponentConfig"
    }
}

/// Defines additional types related to [LoggingComponentConfig].
pub mod logging_component_config {
    #[allow(unused_imports)]
    use super::*;

    /// GKE components exposing logs
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Component {
        /// Default value. This shouldn't be used.
        Unspecified,
        /// system components
        SystemComponents,
        /// workloads
        Workloads,
        /// kube-apiserver
        Apiserver,
        /// kube-scheduler
        Scheduler,
        /// kube-controller-manager
        ControllerManager,
        /// kcp-sshd
        KcpSshd,
        /// kcp connection logs
        KcpConnection,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Component::value] or
        /// [Component::name].
        UnknownValue(component::UnknownValue),
    }

    #[doc(hidden)]
    pub mod component {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Component {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SystemComponents => std::option::Option::Some(1),
                Self::Workloads => std::option::Option::Some(2),
                Self::Apiserver => std::option::Option::Some(3),
                Self::Scheduler => std::option::Option::Some(4),
                Self::ControllerManager => std::option::Option::Some(5),
                Self::KcpSshd => std::option::Option::Some(7),
                Self::KcpConnection => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPONENT_UNSPECIFIED"),
                Self::SystemComponents => std::option::Option::Some("SYSTEM_COMPONENTS"),
                Self::Workloads => std::option::Option::Some("WORKLOADS"),
                Self::Apiserver => std::option::Option::Some("APISERVER"),
                Self::Scheduler => std::option::Option::Some("SCHEDULER"),
                Self::ControllerManager => std::option::Option::Some("CONTROLLER_MANAGER"),
                Self::KcpSshd => std::option::Option::Some("KCP_SSHD"),
                Self::KcpConnection => std::option::Option::Some("KCP_CONNECTION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Component {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Component {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Component {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SystemComponents,
                2 => Self::Workloads,
                3 => Self::Apiserver,
                4 => Self::Scheduler,
                5 => Self::ControllerManager,
                7 => Self::KcpSshd,
                8 => Self::KcpConnection,
                _ => Self::UnknownValue(component::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Component {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPONENT_UNSPECIFIED" => Self::Unspecified,
                "SYSTEM_COMPONENTS" => Self::SystemComponents,
                "WORKLOADS" => Self::Workloads,
                "APISERVER" => Self::Apiserver,
                "SCHEDULER" => Self::Scheduler,
                "CONTROLLER_MANAGER" => Self::ControllerManager,
                "KCP_SSHD" => Self::KcpSshd,
                "KCP_CONNECTION" => Self::KcpConnection,
                _ => Self::UnknownValue(component::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Component {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SystemComponents => serializer.serialize_i32(1),
                Self::Workloads => serializer.serialize_i32(2),
                Self::Apiserver => serializer.serialize_i32(3),
                Self::Scheduler => serializer.serialize_i32(4),
                Self::ControllerManager => serializer.serialize_i32(5),
                Self::KcpSshd => serializer.serialize_i32(7),
                Self::KcpConnection => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Component {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Component>::new(
                ".google.container.v1.LoggingComponentConfig.Component",
            ))
        }
    }
}

/// RayClusterLoggingConfig specifies configuration of Ray logging.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RayClusterLoggingConfig {
    /// Enable log collection for Ray clusters.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RayClusterLoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::RayClusterLoggingConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for RayClusterLoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.RayClusterLoggingConfig"
    }
}

/// MonitoringConfig is cluster monitoring configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MonitoringConfig {
    /// Monitoring components configuration
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub component_config: std::option::Option<crate::model::MonitoringComponentConfig>,

    /// Enable Google Cloud Managed Service for Prometheus
    /// in the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub managed_prometheus_config: std::option::Option<crate::model::ManagedPrometheusConfig>,

    /// Configuration of Advanced Datapath Observability features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub advanced_datapath_observability_config:
        std::option::Option<crate::model::AdvancedDatapathObservabilityConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MonitoringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [component_config][crate::model::MonitoringConfig::component_config].
    pub fn set_component_config<
        T: std::convert::Into<std::option::Option<crate::model::MonitoringComponentConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.component_config = v.into();
        self
    }

    /// Sets the value of [managed_prometheus_config][crate::model::MonitoringConfig::managed_prometheus_config].
    pub fn set_managed_prometheus_config<
        T: std::convert::Into<std::option::Option<crate::model::ManagedPrometheusConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.managed_prometheus_config = v.into();
        self
    }

    /// Sets the value of [advanced_datapath_observability_config][crate::model::MonitoringConfig::advanced_datapath_observability_config].
    pub fn set_advanced_datapath_observability_config<
        T: std::convert::Into<std::option::Option<crate::model::AdvancedDatapathObservabilityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.advanced_datapath_observability_config = v.into();
        self
    }
}

impl wkt::message::Message for MonitoringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MonitoringConfig"
    }
}

/// AdvancedDatapathObservabilityConfig specifies configuration of observability
/// features of advanced datapath.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdvancedDatapathObservabilityConfig {
    /// Expose flow metrics on nodes
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_metrics: bool,

    /// Method used to make Relay available
    pub relay_mode: crate::model::advanced_datapath_observability_config::RelayMode,

    /// Enable Relay component
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_relay: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvancedDatapathObservabilityConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_metrics][crate::model::AdvancedDatapathObservabilityConfig::enable_metrics].
    pub fn set_enable_metrics<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_metrics = v.into();
        self
    }

    /// Sets the value of [relay_mode][crate::model::AdvancedDatapathObservabilityConfig::relay_mode].
    pub fn set_relay_mode<
        T: std::convert::Into<crate::model::advanced_datapath_observability_config::RelayMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.relay_mode = v.into();
        self
    }

    /// Sets the value of [enable_relay][crate::model::AdvancedDatapathObservabilityConfig::enable_relay].
    pub fn set_enable_relay<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_relay = v.into();
        self
    }
}

impl wkt::message::Message for AdvancedDatapathObservabilityConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AdvancedDatapathObservabilityConfig"
    }
}

/// Defines additional types related to [AdvancedDatapathObservabilityConfig].
pub mod advanced_datapath_observability_config {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Relay modes
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RelayMode {
        /// Default value. This shouldn't be used.
        Unspecified,
        /// disabled
        Disabled,
        /// exposed via internal load balancer
        InternalVpcLb,
        /// exposed via external load balancer
        ExternalLb,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RelayMode::value] or
        /// [RelayMode::name].
        UnknownValue(relay_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod relay_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RelayMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::InternalVpcLb => std::option::Option::Some(3),
                Self::ExternalLb => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RELAY_MODE_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::InternalVpcLb => std::option::Option::Some("INTERNAL_VPC_LB"),
                Self::ExternalLb => std::option::Option::Some("EXTERNAL_LB"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RelayMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RelayMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RelayMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                3 => Self::InternalVpcLb,
                4 => Self::ExternalLb,
                _ => Self::UnknownValue(relay_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RelayMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RELAY_MODE_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "INTERNAL_VPC_LB" => Self::InternalVpcLb,
                "EXTERNAL_LB" => Self::ExternalLb,
                _ => Self::UnknownValue(relay_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RelayMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::InternalVpcLb => serializer.serialize_i32(3),
                Self::ExternalLb => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RelayMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RelayMode>::new(
                ".google.container.v1.AdvancedDatapathObservabilityConfig.RelayMode",
            ))
        }
    }
}

/// RayClusterMonitoringConfig specifies monitoring configuration for Ray
/// clusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RayClusterMonitoringConfig {
    /// Enable metrics collection for Ray clusters.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RayClusterMonitoringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::RayClusterMonitoringConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for RayClusterMonitoringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.RayClusterMonitoringConfig"
    }
}

/// NodePoolLoggingConfig specifies logging configuration for nodepools.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodePoolLoggingConfig {
    /// Logging variant configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub variant_config: std::option::Option<crate::model::LoggingVariantConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodePoolLoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [variant_config][crate::model::NodePoolLoggingConfig::variant_config].
    pub fn set_variant_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingVariantConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.variant_config = v.into();
        self
    }
}

impl wkt::message::Message for NodePoolLoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodePoolLoggingConfig"
    }
}

/// LoggingVariantConfig specifies the behaviour of the logging component.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoggingVariantConfig {
    /// Logging variant deployed on nodes.
    pub variant: crate::model::logging_variant_config::Variant,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingVariantConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [variant][crate::model::LoggingVariantConfig::variant].
    pub fn set_variant<T: std::convert::Into<crate::model::logging_variant_config::Variant>>(
        mut self,
        v: T,
    ) -> Self {
        self.variant = v.into();
        self
    }
}

impl wkt::message::Message for LoggingVariantConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.LoggingVariantConfig"
    }
}

/// Defines additional types related to [LoggingVariantConfig].
pub mod logging_variant_config {
    #[allow(unused_imports)]
    use super::*;

    /// Logging component variants.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Variant {
        /// Default value. This shouldn't be used.
        Unspecified,
        /// default logging variant.
        Default,
        /// maximum logging throughput variant.
        MaxThroughput,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Variant::value] or
        /// [Variant::name].
        UnknownValue(variant::UnknownValue),
    }

    #[doc(hidden)]
    pub mod variant {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Variant {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(1),
                Self::MaxThroughput => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VARIANT_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::MaxThroughput => std::option::Option::Some("MAX_THROUGHPUT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Variant {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Variant {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Variant {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Default,
                2 => Self::MaxThroughput,
                _ => Self::UnknownValue(variant::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Variant {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VARIANT_UNSPECIFIED" => Self::Unspecified,
                "DEFAULT" => Self::Default,
                "MAX_THROUGHPUT" => Self::MaxThroughput,
                _ => Self::UnknownValue(variant::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Variant {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(1),
                Self::MaxThroughput => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Variant {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Variant>::new(
                ".google.container.v1.LoggingVariantConfig.Variant",
            ))
        }
    }
}

/// MonitoringComponentConfig is cluster monitoring component configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MonitoringComponentConfig {
    /// Select components to collect metrics. An empty set would disable all
    /// monitoring.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub enable_components: std::vec::Vec<crate::model::monitoring_component_config::Component>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MonitoringComponentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_components][crate::model::MonitoringComponentConfig::enable_components].
    pub fn set_enable_components<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::monitoring_component_config::Component>,
    {
        use std::iter::Iterator;
        self.enable_components = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MonitoringComponentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MonitoringComponentConfig"
    }
}

/// Defines additional types related to [MonitoringComponentConfig].
pub mod monitoring_component_config {
    #[allow(unused_imports)]
    use super::*;

    /// GKE components exposing metrics
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Component {
        /// Default value. This shouldn't be used.
        Unspecified,
        /// system components
        SystemComponents,
        /// kube-apiserver
        Apiserver,
        /// kube-scheduler
        Scheduler,
        /// kube-controller-manager
        ControllerManager,
        /// Storage
        Storage,
        /// Horizontal Pod Autoscaling
        Hpa,
        /// Pod
        Pod,
        /// DaemonSet
        Daemonset,
        /// Deployment
        Deployment,
        /// Statefulset
        Statefulset,
        /// CADVISOR
        Cadvisor,
        /// KUBELET
        Kubelet,
        /// NVIDIA Data Center GPU Manager (DCGM)
        Dcgm,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Component::value] or
        /// [Component::name].
        UnknownValue(component::UnknownValue),
    }

    #[doc(hidden)]
    pub mod component {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Component {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SystemComponents => std::option::Option::Some(1),
                Self::Apiserver => std::option::Option::Some(3),
                Self::Scheduler => std::option::Option::Some(4),
                Self::ControllerManager => std::option::Option::Some(5),
                Self::Storage => std::option::Option::Some(7),
                Self::Hpa => std::option::Option::Some(8),
                Self::Pod => std::option::Option::Some(9),
                Self::Daemonset => std::option::Option::Some(10),
                Self::Deployment => std::option::Option::Some(11),
                Self::Statefulset => std::option::Option::Some(12),
                Self::Cadvisor => std::option::Option::Some(13),
                Self::Kubelet => std::option::Option::Some(14),
                Self::Dcgm => std::option::Option::Some(15),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPONENT_UNSPECIFIED"),
                Self::SystemComponents => std::option::Option::Some("SYSTEM_COMPONENTS"),
                Self::Apiserver => std::option::Option::Some("APISERVER"),
                Self::Scheduler => std::option::Option::Some("SCHEDULER"),
                Self::ControllerManager => std::option::Option::Some("CONTROLLER_MANAGER"),
                Self::Storage => std::option::Option::Some("STORAGE"),
                Self::Hpa => std::option::Option::Some("HPA"),
                Self::Pod => std::option::Option::Some("POD"),
                Self::Daemonset => std::option::Option::Some("DAEMONSET"),
                Self::Deployment => std::option::Option::Some("DEPLOYMENT"),
                Self::Statefulset => std::option::Option::Some("STATEFULSET"),
                Self::Cadvisor => std::option::Option::Some("CADVISOR"),
                Self::Kubelet => std::option::Option::Some("KUBELET"),
                Self::Dcgm => std::option::Option::Some("DCGM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Component {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Component {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Component {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SystemComponents,
                3 => Self::Apiserver,
                4 => Self::Scheduler,
                5 => Self::ControllerManager,
                7 => Self::Storage,
                8 => Self::Hpa,
                9 => Self::Pod,
                10 => Self::Daemonset,
                11 => Self::Deployment,
                12 => Self::Statefulset,
                13 => Self::Cadvisor,
                14 => Self::Kubelet,
                15 => Self::Dcgm,
                _ => Self::UnknownValue(component::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Component {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPONENT_UNSPECIFIED" => Self::Unspecified,
                "SYSTEM_COMPONENTS" => Self::SystemComponents,
                "APISERVER" => Self::Apiserver,
                "SCHEDULER" => Self::Scheduler,
                "CONTROLLER_MANAGER" => Self::ControllerManager,
                "STORAGE" => Self::Storage,
                "HPA" => Self::Hpa,
                "POD" => Self::Pod,
                "DAEMONSET" => Self::Daemonset,
                "DEPLOYMENT" => Self::Deployment,
                "STATEFULSET" => Self::Statefulset,
                "CADVISOR" => Self::Cadvisor,
                "KUBELET" => Self::Kubelet,
                "DCGM" => Self::Dcgm,
                _ => Self::UnknownValue(component::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Component {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SystemComponents => serializer.serialize_i32(1),
                Self::Apiserver => serializer.serialize_i32(3),
                Self::Scheduler => serializer.serialize_i32(4),
                Self::ControllerManager => serializer.serialize_i32(5),
                Self::Storage => serializer.serialize_i32(7),
                Self::Hpa => serializer.serialize_i32(8),
                Self::Pod => serializer.serialize_i32(9),
                Self::Daemonset => serializer.serialize_i32(10),
                Self::Deployment => serializer.serialize_i32(11),
                Self::Statefulset => serializer.serialize_i32(12),
                Self::Cadvisor => serializer.serialize_i32(13),
                Self::Kubelet => serializer.serialize_i32(14),
                Self::Dcgm => serializer.serialize_i32(15),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Component {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Component>::new(
                ".google.container.v1.MonitoringComponentConfig.Component",
            ))
        }
    }
}

/// ManagedPrometheusConfig defines the configuration for
/// Google Cloud Managed Service for Prometheus.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManagedPrometheusConfig {
    /// Enable Managed Collection.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagedPrometheusConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ManagedPrometheusConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for ManagedPrometheusConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ManagedPrometheusConfig"
    }
}

/// Fleet is the fleet configuration for the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Fleet {
    /// The Fleet host project(project ID or project number) where this cluster
    /// will be registered to. This field cannot be changed after the cluster has
    /// been registered.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Output only. The full resource name of the registered fleet membership of
    /// the cluster, in the format
    /// `//gkehub.googleapis.com/projects/*/locations/*/memberships/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub membership: std::string::String,

    /// Output only. Whether the cluster has been registered through the fleet
    /// API.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub pre_registered: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Fleet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::Fleet::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [membership][crate::model::Fleet::membership].
    pub fn set_membership<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.membership = v.into();
        self
    }

    /// Sets the value of [pre_registered][crate::model::Fleet::pre_registered].
    pub fn set_pre_registered<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.pre_registered = v.into();
        self
    }
}

impl wkt::message::Message for Fleet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.Fleet"
    }
}

/// Configuration for all of the cluster's control plane endpoints.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ControlPlaneEndpointsConfig {
    /// DNS endpoint configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dns_endpoint_config:
        std::option::Option<crate::model::control_plane_endpoints_config::DNSEndpointConfig>,

    /// IP endpoints configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ip_endpoints_config:
        std::option::Option<crate::model::control_plane_endpoints_config::IPEndpointsConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ControlPlaneEndpointsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dns_endpoint_config][crate::model::ControlPlaneEndpointsConfig::dns_endpoint_config].
    pub fn set_dns_endpoint_config<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::control_plane_endpoints_config::DNSEndpointConfig,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dns_endpoint_config = v.into();
        self
    }

    /// Sets the value of [ip_endpoints_config][crate::model::ControlPlaneEndpointsConfig::ip_endpoints_config].
    pub fn set_ip_endpoints_config<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::control_plane_endpoints_config::IPEndpointsConfig,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ip_endpoints_config = v.into();
        self
    }
}

impl wkt::message::Message for ControlPlaneEndpointsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ControlPlaneEndpointsConfig"
    }
}

/// Defines additional types related to [ControlPlaneEndpointsConfig].
pub mod control_plane_endpoints_config {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the configuration of a DNS endpoint.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DNSEndpointConfig {
        /// Output only. The cluster's DNS endpoint configuration.
        /// A DNS format address. This is accessible from the public internet.
        /// Ex: uid.us-central1.gke.goog.
        /// Always present, but the behavior may change according to the value of
        /// [DNSEndpointConfig.allow_external_traffic][google.container.v1.ControlPlaneEndpointsConfig.DNSEndpointConfig.allow_external_traffic].
        ///
        /// [google.container.v1.ControlPlaneEndpointsConfig.DNSEndpointConfig.allow_external_traffic]: crate::model::control_plane_endpoints_config::DNSEndpointConfig::allow_external_traffic
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub endpoint: std::string::String,

        /// Controls whether user traffic is allowed over this endpoint. Note that
        /// GCP-managed services may still use the endpoint even if this is false.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub allow_external_traffic: std::option::Option<bool>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DNSEndpointConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [endpoint][crate::model::control_plane_endpoints_config::DNSEndpointConfig::endpoint].
        pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.endpoint = v.into();
            self
        }

        /// Sets the value of [allow_external_traffic][crate::model::control_plane_endpoints_config::DNSEndpointConfig::allow_external_traffic].
        pub fn set_allow_external_traffic<T: std::convert::Into<std::option::Option<bool>>>(
            mut self,
            v: T,
        ) -> Self {
            self.allow_external_traffic = v.into();
            self
        }
    }

    impl wkt::message::Message for DNSEndpointConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.ControlPlaneEndpointsConfig.DNSEndpointConfig"
        }
    }

    /// IP endpoints configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IPEndpointsConfig {
        /// Controls whether to allow direct IP access.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub enabled: std::option::Option<bool>,

        /// Controls whether the control plane allows access through a public IP.
        /// It is invalid to specify both
        /// [PrivateClusterConfig.enablePrivateEndpoint][] and this field at the same
        /// time.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub enable_public_endpoint: std::option::Option<bool>,

        /// Controls whether the control plane's private endpoint is accessible from
        /// sources in other regions.
        /// It is invalid to specify both
        /// [PrivateClusterMasterGlobalAccessConfig.enabled][google.container.v1.PrivateClusterMasterGlobalAccessConfig.enabled]
        /// and this field at the same time.
        ///
        /// [google.container.v1.PrivateClusterMasterGlobalAccessConfig.enabled]: crate::model::PrivateClusterMasterGlobalAccessConfig::enabled
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub global_access: std::option::Option<bool>,

        /// Configuration of authorized networks. If enabled, restricts access to the
        /// control plane based on source IP.
        /// It is invalid to specify both
        /// [Cluster.masterAuthorizedNetworksConfig][] and this field at the same
        /// time.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub authorized_networks_config:
            std::option::Option<crate::model::MasterAuthorizedNetworksConfig>,

        /// Output only. The external IP address of this cluster's control plane.
        /// Only populated if enabled.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub public_endpoint: std::string::String,

        /// Output only. The internal IP address of this cluster's control plane.
        /// Only populated if enabled.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub private_endpoint: std::string::String,

        /// Subnet to provision the master's private endpoint during cluster
        /// creation. Specified in projects/*/regions/*/subnetworks/* format. It is
        /// invalid to specify both
        /// [PrivateClusterConfig.privateEndpointSubnetwork][] and this field at the
        /// same time.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub private_endpoint_subnetwork: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IPEndpointsConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::control_plane_endpoints_config::IPEndpointsConfig::enabled].
        pub fn set_enabled<T: std::convert::Into<std::option::Option<bool>>>(
            mut self,
            v: T,
        ) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [enable_public_endpoint][crate::model::control_plane_endpoints_config::IPEndpointsConfig::enable_public_endpoint].
        pub fn set_enable_public_endpoint<T: std::convert::Into<std::option::Option<bool>>>(
            mut self,
            v: T,
        ) -> Self {
            self.enable_public_endpoint = v.into();
            self
        }

        /// Sets the value of [global_access][crate::model::control_plane_endpoints_config::IPEndpointsConfig::global_access].
        pub fn set_global_access<T: std::convert::Into<std::option::Option<bool>>>(
            mut self,
            v: T,
        ) -> Self {
            self.global_access = v.into();
            self
        }

        /// Sets the value of [authorized_networks_config][crate::model::control_plane_endpoints_config::IPEndpointsConfig::authorized_networks_config].
        pub fn set_authorized_networks_config<
            T: std::convert::Into<std::option::Option<crate::model::MasterAuthorizedNetworksConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authorized_networks_config = v.into();
            self
        }

        /// Sets the value of [public_endpoint][crate::model::control_plane_endpoints_config::IPEndpointsConfig::public_endpoint].
        pub fn set_public_endpoint<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.public_endpoint = v.into();
            self
        }

        /// Sets the value of [private_endpoint][crate::model::control_plane_endpoints_config::IPEndpointsConfig::private_endpoint].
        pub fn set_private_endpoint<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.private_endpoint = v.into();
            self
        }

        /// Sets the value of [private_endpoint_subnetwork][crate::model::control_plane_endpoints_config::IPEndpointsConfig::private_endpoint_subnetwork].
        pub fn set_private_endpoint_subnetwork<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.private_endpoint_subnetwork = v.into();
            self
        }
    }

    impl wkt::message::Message for IPEndpointsConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig"
        }
    }
}

/// LocalNvmeSsdBlockConfig contains configuration for using raw-block local
/// NVMe SSDs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocalNvmeSsdBlockConfig {
    /// Number of local NVMe SSDs to use.  The limit for this value is dependent
    /// upon the maximum number of disk available on a machine per zone. See:
    /// <https://cloud.google.com/compute/docs/disks/local-ssd>
    /// for more information.
    ///
    /// A zero (or unset) value has different meanings depending on machine type
    /// being used:
    ///
    /// . For pre-Gen3 machines, which support flexible numbers of local ssds,
    ///   zero (or unset) means to disable using local SSDs as ephemeral storage.
    /// . For Gen3 machines which dictate a specific number of local ssds, zero
    ///   (or unset) means to use the default number of local ssds that goes with
    ///   that machine type. For example, for a c3-standard-8-lssd machine, 2 local
    ///   ssds would be provisioned. For c3-standard-8 (which doesn't support local
    ///   ssds), 0 will be provisioned. See
    ///   <https://cloud.google.com/compute/docs/disks/local-ssd#choose_number_local_ssds>
    ///   for more info.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub local_ssd_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocalNvmeSsdBlockConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [local_ssd_count][crate::model::LocalNvmeSsdBlockConfig::local_ssd_count].
    pub fn set_local_ssd_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.local_ssd_count = v.into();
        self
    }
}

impl wkt::message::Message for LocalNvmeSsdBlockConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.LocalNvmeSsdBlockConfig"
    }
}

/// EphemeralStorageLocalSsdConfig contains configuration for the node ephemeral
/// storage using Local SSDs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EphemeralStorageLocalSsdConfig {
    /// Number of local SSDs to use to back ephemeral storage. Uses NVMe
    /// interfaces.
    ///
    /// A zero (or unset) value has different meanings depending on machine type
    /// being used:
    ///
    /// . For pre-Gen3 machines, which support flexible numbers of local ssds,
    ///   zero (or unset) means to disable using local SSDs as ephemeral storage. The
    ///   limit for this value is dependent upon the maximum number of disk
    ///   available on a machine per zone. See:
    ///   <https://cloud.google.com/compute/docs/disks/local-ssd>
    ///   for more information.
    /// . For Gen3 machines which dictate a specific number of local ssds, zero
    ///   (or unset) means to use the default number of local ssds that goes with
    ///   that machine type. For example, for a c3-standard-8-lssd machine, 2 local
    ///   ssds would be provisioned. For c3-standard-8 (which doesn't support local
    ///   ssds), 0 will be provisioned. See
    ///   <https://cloud.google.com/compute/docs/disks/local-ssd#choose_number_local_ssds>
    ///   for more info.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub local_ssd_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EphemeralStorageLocalSsdConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [local_ssd_count][crate::model::EphemeralStorageLocalSsdConfig::local_ssd_count].
    pub fn set_local_ssd_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.local_ssd_count = v.into();
        self
    }
}

impl wkt::message::Message for EphemeralStorageLocalSsdConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.EphemeralStorageLocalSsdConfig"
    }
}

/// A map of resource manager tag keys and values to be attached to the nodes
/// for managing Compute Engine firewalls using Network Firewall Policies.
/// Tags must be according to specifications in
/// <https://cloud.google.com/vpc/docs/tags-firewalls-overview#specifications>.
/// A maximum of 5 tag key-value pairs can be specified.
/// Existing tags will be replaced with new values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceManagerTags {
    /// TagKeyValue must be in one of the following formats ([KEY]=[VALUE])
    ///
    /// . `tagKeys/{tag_key_id}=tagValues/{tag_value_id}`
    /// . `{org_id}/{tag_key_name}={tag_value_name}`
    /// . `{project_id}/{tag_key_name}={tag_value_name}`
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceManagerTags {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tags][crate::model::ResourceManagerTags::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ResourceManagerTags {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ResourceManagerTags"
    }
}

/// EnterpriseConfig is the cluster enterprise configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnterpriseConfig {
    /// Output only. cluster_tier indicates the effective tier of the cluster.
    pub cluster_tier: crate::model::enterprise_config::ClusterTier,

    /// desired_tier specifies the desired tier of the cluster.
    pub desired_tier: crate::model::enterprise_config::ClusterTier,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnterpriseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_tier][crate::model::EnterpriseConfig::cluster_tier].
    pub fn set_cluster_tier<T: std::convert::Into<crate::model::enterprise_config::ClusterTier>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_tier = v.into();
        self
    }

    /// Sets the value of [desired_tier][crate::model::EnterpriseConfig::desired_tier].
    pub fn set_desired_tier<T: std::convert::Into<crate::model::enterprise_config::ClusterTier>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_tier = v.into();
        self
    }
}

impl wkt::message::Message for EnterpriseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.EnterpriseConfig"
    }
}

/// Defines additional types related to [EnterpriseConfig].
pub mod enterprise_config {
    #[allow(unused_imports)]
    use super::*;

    /// Premium tiers for GKE Cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ClusterTier {
        /// CLUSTER_TIER_UNSPECIFIED is when cluster_tier is not set.
        Unspecified,
        /// STANDARD indicates a standard GKE cluster.
        Standard,
        /// ENTERPRISE indicates a GKE Enterprise cluster.
        Enterprise,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ClusterTier::value] or
        /// [ClusterTier::name].
        UnknownValue(cluster_tier::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cluster_tier {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ClusterTier {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standard => std::option::Option::Some(1),
                Self::Enterprise => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLUSTER_TIER_UNSPECIFIED"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::Enterprise => std::option::Option::Some("ENTERPRISE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ClusterTier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ClusterTier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ClusterTier {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standard,
                2 => Self::Enterprise,
                _ => Self::UnknownValue(cluster_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ClusterTier {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLUSTER_TIER_UNSPECIFIED" => Self::Unspecified,
                "STANDARD" => Self::Standard,
                "ENTERPRISE" => Self::Enterprise,
                _ => Self::UnknownValue(cluster_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ClusterTier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standard => serializer.serialize_i32(1),
                Self::Enterprise => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ClusterTier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ClusterTier>::new(
                ".google.container.v1.EnterpriseConfig.ClusterTier",
            ))
        }
    }
}

/// SecretManagerConfig is config for secret manager enablement.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretManagerConfig {
    /// Enable/Disable Secret Manager Config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enabled: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretManagerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::SecretManagerConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for SecretManagerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SecretManagerConfig"
    }
}

/// SecondaryBootDisk represents a persistent disk attached to a node
/// with special configurations based on its mode.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecondaryBootDisk {
    /// Disk mode (container image cache, etc.)
    pub mode: crate::model::secondary_boot_disk::Mode,

    /// Fully-qualified resource ID for an existing disk image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub disk_image: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecondaryBootDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::SecondaryBootDisk::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::secondary_boot_disk::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [disk_image][crate::model::SecondaryBootDisk::disk_image].
    pub fn set_disk_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_image = v.into();
        self
    }
}

impl wkt::message::Message for SecondaryBootDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SecondaryBootDisk"
    }
}

/// Defines additional types related to [SecondaryBootDisk].
pub mod secondary_boot_disk {
    #[allow(unused_imports)]
    use super::*;

    /// Mode specifies how the secondary boot disk will be used.
    /// This triggers mode-specified logic in the control plane.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// MODE_UNSPECIFIED is when mode is not set.
        Unspecified,
        /// CONTAINER_IMAGE_CACHE is for using the secondary boot disk as
        /// a container image cache.
        ContainerImageCache,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ContainerImageCache => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::ContainerImageCache => std::option::Option::Some("CONTAINER_IMAGE_CACHE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ContainerImageCache,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "CONTAINER_IMAGE_CACHE" => Self::ContainerImageCache,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ContainerImageCache => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.container.v1.SecondaryBootDisk.Mode",
            ))
        }
    }
}

/// SecondaryBootDiskUpdateStrategy is a placeholder which will be extended
/// in the future to define different options for updating secondary boot disks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecondaryBootDiskUpdateStrategy {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecondaryBootDiskUpdateStrategy {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SecondaryBootDiskUpdateStrategy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SecondaryBootDiskUpdateStrategy"
    }
}

/// PrivateIPv6GoogleAccess controls whether and how the pods can communicate
/// with Google Services through gRPC over IPv6.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum PrivateIPv6GoogleAccess {
    /// Default value. Same as DISABLED
    PrivateIpv6GoogleAccessUnspecified,
    /// No private access to or from Google Services
    PrivateIpv6GoogleAccessDisabled,
    /// Enables private IPv6 access to Google Services from GKE
    PrivateIpv6GoogleAccessToGoogle,
    /// Enables private IPv6 access to and from Google Services
    PrivateIpv6GoogleAccessBidirectional,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [PrivateIPv6GoogleAccess::value] or
    /// [PrivateIPv6GoogleAccess::name].
    UnknownValue(private_i_pv_6_google_access::UnknownValue),
}

#[doc(hidden)]
pub mod private_i_pv_6_google_access {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl PrivateIPv6GoogleAccess {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::PrivateIpv6GoogleAccessUnspecified => std::option::Option::Some(0),
            Self::PrivateIpv6GoogleAccessDisabled => std::option::Option::Some(1),
            Self::PrivateIpv6GoogleAccessToGoogle => std::option::Option::Some(2),
            Self::PrivateIpv6GoogleAccessBidirectional => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::PrivateIpv6GoogleAccessUnspecified => {
                std::option::Option::Some("PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED")
            }
            Self::PrivateIpv6GoogleAccessDisabled => {
                std::option::Option::Some("PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED")
            }
            Self::PrivateIpv6GoogleAccessToGoogle => {
                std::option::Option::Some("PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE")
            }
            Self::PrivateIpv6GoogleAccessBidirectional => {
                std::option::Option::Some("PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for PrivateIPv6GoogleAccess {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for PrivateIPv6GoogleAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for PrivateIPv6GoogleAccess {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::PrivateIpv6GoogleAccessUnspecified,
            1 => Self::PrivateIpv6GoogleAccessDisabled,
            2 => Self::PrivateIpv6GoogleAccessToGoogle,
            3 => Self::PrivateIpv6GoogleAccessBidirectional,
            _ => Self::UnknownValue(private_i_pv_6_google_access::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for PrivateIPv6GoogleAccess {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED" => Self::PrivateIpv6GoogleAccessUnspecified,
            "PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED" => Self::PrivateIpv6GoogleAccessDisabled,
            "PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE" => Self::PrivateIpv6GoogleAccessToGoogle,
            "PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL" => {
                Self::PrivateIpv6GoogleAccessBidirectional
            }
            _ => Self::UnknownValue(private_i_pv_6_google_access::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for PrivateIPv6GoogleAccess {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::PrivateIpv6GoogleAccessUnspecified => serializer.serialize_i32(0),
            Self::PrivateIpv6GoogleAccessDisabled => serializer.serialize_i32(1),
            Self::PrivateIpv6GoogleAccessToGoogle => serializer.serialize_i32(2),
            Self::PrivateIpv6GoogleAccessBidirectional => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for PrivateIPv6GoogleAccess {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<PrivateIPv6GoogleAccess>::new(
            ".google.container.v1.PrivateIPv6GoogleAccess",
        ))
    }
}

/// UpgradeResourceType is the resource type that is upgrading. It is used
/// in upgrade notifications.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum UpgradeResourceType {
    /// Default value. This shouldn't be used.
    Unspecified,
    /// Master / control plane
    Master,
    /// Node pool
    NodePool,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [UpgradeResourceType::value] or
    /// [UpgradeResourceType::name].
    UnknownValue(upgrade_resource_type::UnknownValue),
}

#[doc(hidden)]
pub mod upgrade_resource_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl UpgradeResourceType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Master => std::option::Option::Some(1),
            Self::NodePool => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("UPGRADE_RESOURCE_TYPE_UNSPECIFIED"),
            Self::Master => std::option::Option::Some("MASTER"),
            Self::NodePool => std::option::Option::Some("NODE_POOL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for UpgradeResourceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for UpgradeResourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for UpgradeResourceType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Master,
            2 => Self::NodePool,
            _ => Self::UnknownValue(upgrade_resource_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for UpgradeResourceType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UPGRADE_RESOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "MASTER" => Self::Master,
            "NODE_POOL" => Self::NodePool,
            _ => Self::UnknownValue(upgrade_resource_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for UpgradeResourceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Master => serializer.serialize_i32(1),
            Self::NodePool => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for UpgradeResourceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<UpgradeResourceType>::new(
            ".google.container.v1.UpgradeResourceType",
        ))
    }
}

/// The datapath provider selects the implementation of the Kubernetes networking
/// model for service resolution and network policy enforcement.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DatapathProvider {
    /// Default value.
    Unspecified,
    /// Use the IPTables implementation based on kube-proxy.
    LegacyDatapath,
    /// Use the eBPF based GKE Dataplane V2 with additional features. See the [GKE
    /// Dataplane V2
    /// documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2)
    /// for more.
    AdvancedDatapath,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DatapathProvider::value] or
    /// [DatapathProvider::name].
    UnknownValue(datapath_provider::UnknownValue),
}

#[doc(hidden)]
pub mod datapath_provider {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DatapathProvider {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::LegacyDatapath => std::option::Option::Some(1),
            Self::AdvancedDatapath => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATAPATH_PROVIDER_UNSPECIFIED"),
            Self::LegacyDatapath => std::option::Option::Some("LEGACY_DATAPATH"),
            Self::AdvancedDatapath => std::option::Option::Some("ADVANCED_DATAPATH"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DatapathProvider {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DatapathProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DatapathProvider {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::LegacyDatapath,
            2 => Self::AdvancedDatapath,
            _ => Self::UnknownValue(datapath_provider::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DatapathProvider {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATAPATH_PROVIDER_UNSPECIFIED" => Self::Unspecified,
            "LEGACY_DATAPATH" => Self::LegacyDatapath,
            "ADVANCED_DATAPATH" => Self::AdvancedDatapath,
            _ => Self::UnknownValue(datapath_provider::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DatapathProvider {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::LegacyDatapath => serializer.serialize_i32(1),
            Self::AdvancedDatapath => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DatapathProvider {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatapathProvider>::new(
            ".google.container.v1.DatapathProvider",
        ))
    }
}

/// Strategy used for node pool update.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum NodePoolUpdateStrategy {
    /// Default value if unset. GKE internally defaults the update strategy to
    /// SURGE for unspecified strategies.
    Unspecified,
    /// blue-green upgrade.
    BlueGreen,
    /// SURGE is the traditional way of upgrade a node pool.
    /// max_surge and max_unavailable determines the level of upgrade parallelism.
    Surge,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [NodePoolUpdateStrategy::value] or
    /// [NodePoolUpdateStrategy::name].
    UnknownValue(node_pool_update_strategy::UnknownValue),
}

#[doc(hidden)]
pub mod node_pool_update_strategy {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl NodePoolUpdateStrategy {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::BlueGreen => std::option::Option::Some(2),
            Self::Surge => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED"),
            Self::BlueGreen => std::option::Option::Some("BLUE_GREEN"),
            Self::Surge => std::option::Option::Some("SURGE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for NodePoolUpdateStrategy {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for NodePoolUpdateStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for NodePoolUpdateStrategy {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            2 => Self::BlueGreen,
            3 => Self::Surge,
            _ => Self::UnknownValue(node_pool_update_strategy::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for NodePoolUpdateStrategy {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED" => Self::Unspecified,
            "BLUE_GREEN" => Self::BlueGreen,
            "SURGE" => Self::Surge,
            _ => Self::UnknownValue(node_pool_update_strategy::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for NodePoolUpdateStrategy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::BlueGreen => serializer.serialize_i32(2),
            Self::Surge => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for NodePoolUpdateStrategy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<NodePoolUpdateStrategy>::new(
            ".google.container.v1.NodePoolUpdateStrategy",
        ))
    }
}

/// Possible values for IP stack type
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum StackType {
    /// Default value, will be defaulted as IPV4 only
    Unspecified,
    /// Cluster is IPV4 only
    Ipv4,
    /// Cluster can use both IPv4 and IPv6
    Ipv4Ipv6,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [StackType::value] or
    /// [StackType::name].
    UnknownValue(stack_type::UnknownValue),
}

#[doc(hidden)]
pub mod stack_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl StackType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Ipv4 => std::option::Option::Some(1),
            Self::Ipv4Ipv6 => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STACK_TYPE_UNSPECIFIED"),
            Self::Ipv4 => std::option::Option::Some("IPV4"),
            Self::Ipv4Ipv6 => std::option::Option::Some("IPV4_IPV6"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for StackType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for StackType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for StackType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Ipv4,
            2 => Self::Ipv4Ipv6,
            _ => Self::UnknownValue(stack_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for StackType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STACK_TYPE_UNSPECIFIED" => Self::Unspecified,
            "IPV4" => Self::Ipv4,
            "IPV4_IPV6" => Self::Ipv4Ipv6,
            _ => Self::UnknownValue(stack_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for StackType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Ipv4 => serializer.serialize_i32(1),
            Self::Ipv4Ipv6 => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for StackType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<StackType>::new(
            ".google.container.v1.StackType",
        ))
    }
}

/// Possible values for IPv6 access type
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum IPv6AccessType {
    /// Default value, will be defaulted as type external.
    Ipv6AccessTypeUnspecified,
    /// Access type internal (all v6 addresses are internal IPs)
    Internal,
    /// Access type external (all v6 addresses are external IPs)
    External,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [IPv6AccessType::value] or
    /// [IPv6AccessType::name].
    UnknownValue(i_pv_6_access_type::UnknownValue),
}

#[doc(hidden)]
pub mod i_pv_6_access_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl IPv6AccessType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Ipv6AccessTypeUnspecified => std::option::Option::Some(0),
            Self::Internal => std::option::Option::Some(1),
            Self::External => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Ipv6AccessTypeUnspecified => {
                std::option::Option::Some("IPV6_ACCESS_TYPE_UNSPECIFIED")
            }
            Self::Internal => std::option::Option::Some("INTERNAL"),
            Self::External => std::option::Option::Some("EXTERNAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for IPv6AccessType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for IPv6AccessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for IPv6AccessType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Ipv6AccessTypeUnspecified,
            1 => Self::Internal,
            2 => Self::External,
            _ => Self::UnknownValue(i_pv_6_access_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for IPv6AccessType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "IPV6_ACCESS_TYPE_UNSPECIFIED" => Self::Ipv6AccessTypeUnspecified,
            "INTERNAL" => Self::Internal,
            "EXTERNAL" => Self::External,
            _ => Self::UnknownValue(i_pv_6_access_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for IPv6AccessType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Ipv6AccessTypeUnspecified => serializer.serialize_i32(0),
            Self::Internal => serializer.serialize_i32(1),
            Self::External => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for IPv6AccessType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<IPv6AccessType>::new(
            ".google.container.v1.IPv6AccessType",
        ))
    }
}

/// Options for in-transit encryption.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum InTransitEncryptionConfig {
    /// Unspecified, will be inferred as default -
    /// IN_TRANSIT_ENCRYPTION_UNSPECIFIED.
    Unspecified,
    /// In-transit encryption is disabled.
    InTransitEncryptionDisabled,
    /// Data in-transit is encrypted using inter-node transparent encryption.
    InTransitEncryptionInterNodeTransparent,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [InTransitEncryptionConfig::value] or
    /// [InTransitEncryptionConfig::name].
    UnknownValue(in_transit_encryption_config::UnknownValue),
}

#[doc(hidden)]
pub mod in_transit_encryption_config {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl InTransitEncryptionConfig {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::InTransitEncryptionDisabled => std::option::Option::Some(1),
            Self::InTransitEncryptionInterNodeTransparent => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED")
            }
            Self::InTransitEncryptionDisabled => {
                std::option::Option::Some("IN_TRANSIT_ENCRYPTION_DISABLED")
            }
            Self::InTransitEncryptionInterNodeTransparent => {
                std::option::Option::Some("IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for InTransitEncryptionConfig {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for InTransitEncryptionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for InTransitEncryptionConfig {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::InTransitEncryptionDisabled,
            2 => Self::InTransitEncryptionInterNodeTransparent,
            _ => Self::UnknownValue(in_transit_encryption_config::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for InTransitEncryptionConfig {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED" => Self::Unspecified,
            "IN_TRANSIT_ENCRYPTION_DISABLED" => Self::InTransitEncryptionDisabled,
            "IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT" => {
                Self::InTransitEncryptionInterNodeTransparent
            }
            _ => Self::UnknownValue(in_transit_encryption_config::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for InTransitEncryptionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::InTransitEncryptionDisabled => serializer.serialize_i32(1),
            Self::InTransitEncryptionInterNodeTransparent => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for InTransitEncryptionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<InTransitEncryptionConfig>::new(
                ".google.container.v1.InTransitEncryptionConfig",
            ),
        )
    }
}
